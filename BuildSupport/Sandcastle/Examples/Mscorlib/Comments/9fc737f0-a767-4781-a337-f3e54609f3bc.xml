<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:dev="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" fileAssetGuid="9fc737f0-a767-4781-a337-f3e54609f3bc" revisionNumber="11">
  <assembly>
    <name>mscorlib</name>
  </assembly>
  <members>
    <member name="T:System.Object">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</para>
        </summary>
        <threadSafety>
          <para>Public static (<languageKeyword>Shared</languageKeyword> in Visual Basic) members of this type are safe for multithreaded operations. Instance members are not guaranteed to be thread-safe.</para>
        </threadSafety>
        <remarks>
          <content>
            <para>Languages typically do not require a class to declare inheritance from <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> because the inheritance is implicit.</para>
            <para>Because all classes in the .NET Framework are derived from <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>, every method defined in the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class is available in all objects in the system. Derived classes can and do override some of these methods, including: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> - Supports comparisons between objects.</para>
              </listItem>
              <listItem>
                <para>
                  <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> - Performs cleanup operations before an object is automatically reclaimed.</para>
              </listItem>
              <listItem>
                <para>
                  <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> - Generates a number corresponding to the value of the object to support the use of a hash table.</para>
              </listItem>
              <listItem>
                <para>
                  <codeEntityReference autoUpgrade="true">M:System.Object.ToString</codeEntityReference> - Manufactures a human-readable text string that describes an instance of the class.</para>
              </listItem>
            </list>
          </content>
          <sections>
            <section>
              <title>Performance Considerations</title>
              <content>
                <para>If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class. However, the process of boxing and unboxing a type carries a performance cost. If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing. </para>
                <para>One tactic is to create a general method that accepts an <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle. If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked. If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked. This tactic yields methods that are CLS-compliant.</para>
                <para>The other tactic is to design your class and its methods to use generics. The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument. The generic method is type-specific and can be invoked without boxing the calling parameter. This tactic yields methods that are not CLS-compliant in the .NET Framework version 2.0.</para>
              </content>
            </section>
          </sections>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example defines a Point type derived from the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class and overrides many of the virtual methods of the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class. In addition, the example shows how to call many of the static and instance methods of the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class.</para>
                <codeReference>ObjectX#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Object.#ctor">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Initializes a new instance of the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class.</para>
        </summary>
        <remarks>
          <content>
            <para>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="M:System.Object.Equals(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines whether the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> is equal to the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>obj</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> to compare with the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> is equal to the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The default implementation of <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> supports reference equality only, but derived classes can override this method to support value equality.</para>
            <para>For reference types, equality is defined as object equality; that is, whether the references refer to the same object. For value types, equality is defined as bitwise equality. The <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference> class supports value types.</para>
          </content>
        </remarks>
        <notesForImplementers>
          <para>This method can be overridden by a derived class. For example, many of the base data types return <languageKeyword>true</languageKeyword> if both objects represent the same value; otherwise, <languageKeyword>false</languageKeyword>.</para>
          <para>This method only compares primitives and objects. It must be overridden to compare more complex structures, such as arrays of objects.</para>
          <para>The following statements must be true for all implementations of the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method. In the list, x, y, and z represent object references that are not <languageKeyword>null</languageKeyword>.</para>
          <list class="bullet">
            <listItem>
              <para>x.Equals(x) returns <languageKeyword>true</languageKeyword>, except in cases that involve floating-point types. See IEC 60559:1989, Binary Floating-point Arithmetic for Microprocessor Systems.</para>
            </listItem>
            <listItem>
              <para>x.Equals(y) returns the same value as y.Equals(x).</para>
            </listItem>
            <listItem>
              <para>x.Equals(y) returns <languageKeyword>true</languageKeyword> if both x and y are <languageKeyword>NaN</languageKeyword>.</para>
            </listItem>
            <listItem>
              <para>(x.Equals(y) &amp;&amp; y.Equals(z)) returns <languageKeyword>true</languageKeyword> if and only if x.Equals(z) returns <languageKeyword>true</languageKeyword>.</para>
            </listItem>
            <listItem>
              <para>Successive calls to x.Equals(y) return the same value as long as the objects referenced by x and y are not modified.</para>
            </listItem>
            <listItem>
              <para>x.Equals(<languageKeyword>null</languageKeyword>) returns <languageKeyword>false</languageKeyword>.</para>
            </listItem>
          </list>
          <para>See <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> for additional required behaviors pertaining to the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method.</para>
          <para>Implementations of <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> must not throw exceptions.</para>
          <para>For some kinds of objects, it is desirable to have <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> test for value equality instead of referential equality. Such implementations of <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> return <languageKeyword>true</languageKeyword> if the two objects have the same "value", even if they are not the same instance. The type's implementer decides what constitutes an object's "value", but it is typically some or all the data stored in the instance variables of the object. For example, the value of a <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> is based on the characters of the string; the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method of the <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> class returns <languageKeyword>true</languageKeyword> for any two string instances that contain exactly the same characters in the same order.</para>
          <para>Types that implement <codeEntityReference autoUpgrade="true">T:System.IComparable</codeEntityReference> must override <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference>.</para>
          <para>Types that override <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> must also override <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference>; otherwise, <codeEntityReference autoUpgrade="true">T:System.Collections.Hashtable</codeEntityReference> might not work correctly.</para>
          <para>If your programming language supports operator overloading and if you choose to overload the equality operator for a given type, that type must override the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method. Such implementations of the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method must return the same results as the equality operator. Following this guideline will help ensure that class library code using <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> (such as <codeEntityReference autoUpgrade="true">T:System.Collections.ArrayList</codeEntityReference> and <codeEntityReference autoUpgrade="true">T:System.Collections.Hashtable</codeEntityReference>) behaves in a manner that is consistent with the way the equality operator is used by application code.</para>
          <para>The following guidelines are for implementing a value type: </para>
          <list class="bullet">
            <listItem>
              <para>Consider overriding <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> to gain increased performance over that provided by the default implementation of <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> on <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference>.</para>
            </listItem>
            <listItem>
              <para>If you override <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> and the language supports operator overloading, you must overload the equality operator for your value type.</para>
            </listItem>
          </list>
          <para>The following guidelines are for implementing a reference type: </para>
          <list class="bullet">
            <listItem>
              <para>Consider overriding <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> on a reference type if the semantics of the type are based on the fact that the type represents some value(s).</para>
            </listItem>
            <listItem>
              <para>Most reference types must not overload the equality operator, even if they override <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference>. However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</para>
            </listItem>
          </list>
        </notesForImplementers>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example compares the current instance with another object.</para>
                <codeReference>Classic Object.Equals Example#1</codeReference>
                <para>The following example shows a <languageKeyword>Point</languageKeyword> class that overrides the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method to provide value equality and a class <languageKeyword>Point3D</languageKeyword>, which is derived from <languageKeyword>Point</languageKeyword>. Because <languageKeyword>Point</languageKeyword> 's override of <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> is the first in the inheritance chain to introduce value equality, the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method of the base class (which is inherited from <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> and checks for referential equality) is not invoked. However, <languageKeyword>Point3D.Equals</languageKeyword> invokes <languageKeyword>Point.Equals</languageKeyword> because <languageKeyword>Point</languageKeyword> implements <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> in a manner that provides value equality.</para>
                <codeReference>ECMA-System.Object.Equals2#1</codeReference>
                <para>The <languageKeyword>Point.Equals</languageKeyword> method checks that the <parameterReference>obj</parameterReference> argument is not <languageKeyword>null</languageKeyword> and that it references an instance of the same type as this object. If either of those checks fail, the method returns <languageKeyword>false</languageKeyword>.</para>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method uses <codeEntityReference autoUpgrade="true">M:System.Object.GetType</codeEntityReference> to determine whether the run-time types of the two objects are identical. (Note that <languageKeyword>typeof</languageKeyword> is not used here because it returns the static type.) If the method used a check of the form <codeInline>obj is Point</codeInline>, the check would return <languageKeyword>true</languageKeyword> in cases where <parameterReference>obj</parameterReference> is an instance of a derived class of <languageKeyword>Point</languageKeyword>, even though <parameterReference>obj</parameterReference> and the current instance are not of the same runtime type. Having verified that both objects are of the same type, the method casts <parameterReference>obj</parameterReference> to type <languageKeyword>Point</languageKeyword> and returns the result of comparing the instance variables of the two objects.</para>
                <para>In <languageKeyword>Point3D.Equals</languageKeyword>, the inherited <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method is invoked before anything else is done; the inherited <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method checks to see that <parameterReference>obj</parameterReference> is not <languageKeyword>null</languageKeyword>, that <parameterReference>obj</parameterReference> is an instance of the same class as this object and that the inherited instance variables match. Only when the inherited <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> returns <languageKeyword>true</languageKeyword> does the method compare the instance variables introduced in the derived class. Specifically, the cast to <languageKeyword>Point3D</languageKeyword> is not executed unless <parameterReference>obj</parameterReference> has been determined to be of type <languageKeyword>Point3D</languageKeyword> or a derived class of <languageKeyword>Point3D</languageKeyword>.</para>
                <para>In the previous example, <languageKeyword>operator ==</languageKeyword> (the equality operator) is used to compare the individual instance variables. In some cases, it is appropriate to use the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method to compare instance variables in an <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> implementation, as shown in the following code example.</para>
                <codeReference>ECMA-System.Object.Equals3#1</codeReference>
                <para>In some languages, such as C#, operator overloading is supported. When a type overloads <languageKeyword>operator ==</languageKeyword>, it must also override the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method to provide the same functionality. This is typically accomplished by writing the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method in terms of the overloaded <languageKeyword>operator ==</languageKeyword>, as in the following code example.</para>
                <codeReference>ECMA-System.Object.Equals4#1</codeReference>
                <para>Because <languageKeyword>Complex</languageKeyword> is a C# struct (a value type), it cannot be derived from; therefore, the <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> method need not compare the <codeEntityReference autoUpgrade="true">M:System.Object.GetType</codeEntityReference> results for each object, but can instead use the <languageKeyword>is</languageKeyword> operator to check the type of the <parameterReference>obj</parameterReference> parameter.</para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Object.ReferenceEquals(System.Object,System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.IComparable</codeEntityReference>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Collections.ArrayList</codeEntityReference>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Collections.Hashtable</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Determines whether two <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> instances are equal.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Object.Equals">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines whether two <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> instances are equal.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Object.Equals(System.Object,System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines whether the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> instances are considered equal.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>objA</parameterReference>
            <content>
              <para>The first <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> to compare. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>objB</parameterReference>
            <content>
              <para>The second <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> to compare. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if <parameterReference>objA</parameterReference> is the same instance as <parameterReference>objB</parameterReference> or if both are null references or if <codeInline>objA.Equals(objB)</codeInline> returns <languageKeyword>true</languageKeyword>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The default implementation of <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> supports reference equality only, but derived classes can override this method to support value equality.</para>
            <para>For reference types, equality is defined as object equality; that is, whether the references refer to the same object. For value types, equality is defined as bitwise equality. The <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference> class supports value types.</para>
            <para>This method first determines whether both parameters are null references before calling <codeInline>objA.Equals(objB)</codeInline>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example compares different objects.</para>
                <codeReference>ECMA-System.Object.Equals0#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Object.ReferenceEquals(System.Object,System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Object.Finalize">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Allows an <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> to attempt to free resources and perform other cleanup operations before the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> is reclaimed by garbage collection.</para>
        </summary>
        <remarks>
          <content>
            <para>
              <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> is protected and, therefore, is accessible only through this class or a derived class.</para>
            <para>This method is automatically called after an object becomes inaccessible, unless the object has been exempted from finalization by a call to <codeEntityReference autoUpgrade="true">M:System.GC.SuppressFinalize(System.Object)</codeEntityReference>. During shutdown of an application domain, <languageKeyword>Finalize</languageKeyword> is automatically called on objects that are not exempt from finalization, even those that are still accessible. <languageKeyword>Finalize</languageKeyword> is automatically called only once on a given instance, unless the object is re-registered using a mechanism such as <codeEntityReference autoUpgrade="true">M:System.GC.ReRegisterForFinalize(System.Object)</codeEntityReference> and <languageKeyword>GC.SuppressFinalize</languageKeyword> has not been subsequently called.</para>
            <para>Every implementation of <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> in a derived type must call its base type's implementation of <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference>. This is the only case in which application code is allowed to call <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference>.</para>
            <para>
              <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> operations have the following limitations: </para>
            <list class="bullet">
              <listItem>
                <para>The exact time when the finalizer executes during garbage collection is undefined. Resources are not guaranteed to be released at any specific time, unless calling a <languageKeyword>Close</languageKeyword> method or a <languageKeyword>Dispose</languageKeyword> method.</para>
              </listItem>
              <listItem>
                <para>The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other. That is, if Object A has a reference to Object B and both have finalizers, Object B might have already finalized when the finalizer of Object A starts.</para>
              </listItem>
              <listItem>
                <para>The thread on which the finalizer is run is unspecified.</para>
              </listItem>
            </list>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> method might not run to completion or might not run at all in the following exceptional circumstances: </para>
            <list class="bullet">
              <listItem>
                <para>Another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain and so on). Because the runtime attempts to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</para>
              </listItem>
              <listItem>
                <para>The process terminates without giving the runtime a chance to clean up. In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</para>
              </listItem>
            </list>
            <para>The runtime continues to <languageKeyword>Finalize</languageKeyword> objects during shutdown only while the number of finalizable objects continues to decrease.</para>
            <para>If <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> or an override of <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> throws an exception, the runtime ignores the exception, terminates that <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> method, and continues the finalization process.</para>
          </content>
        </remarks>
        <notesForImplementers>
          <para>
            <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> does nothing by default. It must be overridden by a derived class only if necessary, because reclamation during garbage collection tends to take much longer if a <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> operation must be run.</para>
          <para>If an <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> holds references to any resources, <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> must be overridden by a derived class in order to free these resources before the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> is discarded during garbage collection.</para>
          <para>A type must implement <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> when it uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is reclaimed. See the <codeEntityReference autoUpgrade="true">T:System.IDisposable</codeEntityReference> interface for a complementary and more controllable means of disposing resources.</para>
          <para>
            <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> can take any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection. However, the object can only be resurrected once; <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> cannot be called on resurrected objects during garbage collection.</para>
          <conditionalSection>
            <conditions>
              <programmingLanguage>c#</programmingLanguage>
            </conditions>
            <conditionalContent>
              <para>Destructors are the C# mechanism for performing cleanup operations. Destructors provide appropriate safeguards, such as automatically calling the base type's destructor. In C# code, <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> cannot be called or overridden.</para>
            </conditionalContent>
          </conditionalSection>
        </notesForImplementers>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.GC</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.WeakReference</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Object.GetHashCode">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Serves as a hash function for a particular type. <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> is suitable for use in hashing algorithms and data structures like a hash table.</para>
        </summary>
        <returnValue>
          <para>A hash code for the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class. Value classes must override this method to provide a hash function that is appropriate for the class and that ensures a better distribution in the hash table. Classes that might be used as a key in a hash table must also override this method, because objects that are used as keys in a hash table are required to generate their own hash code through this method. However, if the objects that are used as keys do not provide a useful implementation of GetHashCode, you can provide a different hash code provider, that is based on the <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Collections.IHashCodeProvider</codeEntityReference> interface, when the <codeEntityReference autoUpgrade="true">T:System.Collections.Hashtable</codeEntityReference> is constructed.</para>
            <para>The default implementation of <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> does not guarantee uniqueness or consistency; therefore, it must not be used as a unique object identifier for hashing purposes. Derived classes must override <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> with an implementation that returns a unique hash code. For best results, the hash code must be based on the value of an instance field or property, instead of a static field or property.</para>
          </content>
        </remarks>
        <notesForImplementers>
          <para>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> and must use at least one of the instance fields as input.</para>
          <para>A hash function must have the following properties: </para>
          <list class="bullet">
            <listItem>
              <para>If two objects of the same type represent the same value, the hash function must return the same constant value for either object.</para>
            </listItem>
            <listItem>
              <para>For the best performance, a hash function must generate a random distribution for all input.</para>
            </listItem>
            <listItem>
              <para>The hash function must return exactly the same value regardless of any changes that are made to the object.</para>
            </listItem>
          </list>
          <para>For example, the implementation of <codeEntityReference autoUpgrade="true">M:System.String.GetHashCode</codeEntityReference> provided by the <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> class returns unique hash codes for unique string values. Therefore, two <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</para>
          <para>
            <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> must always return the same value for a given instance of the object. For derived classes of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> can delegate to the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> implementation, if and only if that derived class defines value equality to be reference equality and the type is not a value type.</para>
          <para>Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<parameterReference>n</parameterReference>) operation, where <parameterReference>n</parameterReference> is the number of items in the hash table). Hash functions must also be inexpensive to compute.</para>
          <para>Implementations of <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> must not result in circular references. For example, if <languageKeyword>ClassA.GetHashCode</languageKeyword> calls <languageKeyword>ClassB.GetHashCode</languageKeyword>, <languageKeyword>ClassB.GetHashCode</languageKeyword> must not call <languageKeyword>ClassA.GetHashCode</languageKeyword> either directly or indirectly.</para>
          <para>Implementations of <languageKeyword>GetHashCode</languageKeyword> must not throw exceptions.</para>
          <para>Derived classes that override <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> must also override <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference> to guarantee that two objects considered equal have the same hash code; otherwise, <codeEntityReference autoUpgrade="true">T:System.Collections.Hashtable</codeEntityReference> might not work correctly.</para>
        </notesForImplementers>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>In some cases, <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> is implemented to simply return an integer value. The following code example illustrates an implementation of <codeEntityReference autoUpgrade="true">M:System.Int32.GetHashCode</codeEntityReference>, which returns an integer value.</para>
                <codeReference>ECMA-System.Object.GetHashCode1#1</codeReference>
                <para>Frequently, a type has multiple data fields that can participate in generating the hash code. One way to generate a hash code is to combine these fields using an <languageKeyword>XOR (eXclusive OR)</languageKeyword> operation, as shown in the following code example.</para>
                <codeReference>ECMA-System.Object.GetHashCode2#1</codeReference>
                <para>The following code example illustrates another case where the type's fields are combined using <languageKeyword>XOR (eXclusive OR)</languageKeyword> to generate the hash code. Notice that in this code example, the fields represent user-defined types, each of which implements <codeEntityReference autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference>.</para>
                <codeReference>ECMA-System.Object.GetHashCode3#1</codeReference>
                <para>If the data member of the derived class is bigger than an <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>, you can combine the high order bits of the value with the low order bits using an <languageKeyword>XOR (eXclusive OR)</languageKeyword> operation, as shown in the following code example.</para>
                <codeReference>ECMA-System.Object.GetHashCode4#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="BFC20837-3D02-4FC7-8A8F-C5215B6B7913">[&lt;topic://cpconhashtable&gt;]</link>
          <codeEntityReference autoUpgrade="true">T:System.Collections.Hashtable</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Object.GetType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> of the current instance.</para>
        </summary>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> instance that represents the exact runtime type of the current instance.</para>
        </returnValue>
        <remarks>
          <content>
            <para>For two objects <parameterReference>x</parameterReference> and <parameterReference>y</parameterReference> that have identical runtime types, <codeInline>Object.ReferenceEquals(x.GetType(),y.GetType())</codeInline> returns <languageKeyword>true</languageKeyword>.</para>
            <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object exposes the metadata associated with the class of the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example demonstrates that <codeEntityReference autoUpgrade="true">M:System.Object.GetType</codeEntityReference> returns the runtime type of the current instance.</para>
                <codeReference>ECMA-System.Object.GetType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Object.MemberwiseClone">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a shallow copy of the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>A shallow copy of the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Object.MemberwiseClone</codeEntityReference> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a value type, a bit-by-bit copy of the field is performed. If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</para>
            <para>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy C. Use a class that implements the <codeEntityReference autoUpgrade="true">T:System.ICloneable</codeEntityReference> interface to perform a deep or shallow copy of an object. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example shows how to copy an instance of a class using <codeEntityReference autoUpgrade="true">M:System.Object.MemberwiseClone</codeEntityReference>.</para>
                <codeReference>ECMA-System.Object.MemberwiseClone#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.ICloneable</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Object.ReferenceEquals(System.Object,System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines whether the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> instances are the same instance.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>objA</parameterReference>
            <content>
              <para>The first <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> to compare. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>objB</parameterReference>
            <content>
              <para>The second <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> to compare. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if <parameterReference>objA</parameterReference> is the same instance as <parameterReference>objB</parameterReference> or if both are null references; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example uses <codeEntityReference autoUpgrade="true">M:System.Object.ReferenceEquals(System.Object,System.Object)</codeEntityReference> to determine if two objects are the same instance.</para>
                <codeReference>ECMA-System.Object.ReferenceEquals#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Object.ToString">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> that represents the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> that represents the current <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method returns a human-readable string that is culture-sensitive. For example, for an instance of the <codeEntityReference autoUpgrade="true">T:System.Double</codeEntityReference> class whose value is zero, the implementation of <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Double.ToString</codeEntityReference> might return "0.00" or "0,00" depending on the current UI culture.</para>
            <para>The default implementation returns the fully qualified name of the type of the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
          </content>
        </remarks>
        <notesForImplementers>
          <para>This method can be overridden in a derived class to return values that are meaningful for that type. For example, the base data types, such as <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>, implement <codeEntityReference autoUpgrade="true">M:System.Object.ToString</codeEntityReference> so that it returns the string form of the value that the object represents. Derived classes that require more control over the formatting of strings than <codeEntityReference autoUpgrade="true">M:System.Object.ToString</codeEntityReference> provides must implement <codeEntityReference autoUpgrade="true">T:System.IFormattable</codeEntityReference>, whose <codeEntityReference autoUpgrade="true">M:System.IFormattable.ToString(System.String,System.IFormatProvider)</codeEntityReference> method uses the current thread's <codeEntityReference autoUpgrade="true">P:System.Threading.Thread.CurrentCulture</codeEntityReference> property.</para>
        </notesForImplementers>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example demonstrates what <codeEntityReference autoUpgrade="true">M:System.Object.ToString</codeEntityReference> returns.</para>
                <codeReference>Classic Object.ToString Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
  </members>
</doc>