<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:dev="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" fileAssetGuid="b5b802fa-17cd-414d-b552-80afe25aa341" revisionNumber="5">
  <assembly>
    <name>mscorlib</name>
  </assembly>
  <members>
    <member name="T:System.IDisposable">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a method to release allocated unmanaged resources.</para>
        </summary>
        <remarks>
          <content>
            <para>The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used, however, it is not possible to predict when garbage collection will occur. Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.</para>
            <para>Use the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector. The consumer of an object can call this method when the object is no longer needed.</para>
            <alert class="important">
              <para>C++ programmers should read <link xlink:href="0d09d3f1-13a0-4041-8178-402aad667edd">Destructors and Finalizers in Visual C++</link>. In the .NET Framework version 2.0, the C++ compiler provides support for implementing deterministic disposal of resources and does not allow direct implementation of the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method. </para>
            </alert>
            <para>It is a version breaking change to add the <codeEntityReference autoUpgrade="true">T:System.IDisposable</codeEntityReference> interface to an existing class, as it changes the semantics of the class.</para>
            <para>For a detailed discussion about how this interface and the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> method are used, see the <link xlink:href="22B6CB97-0C80-4EEB-A2CF-5ED7655E37F9">Garbage Collection</link> and <link xlink:href="EB4E1AF0-3B48-4FBC-AD4E-FC2F64138BF9">[&lt;topic://cpconimplementingdisposemethod&gt;]</link> topics.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.IDisposable.Dispose Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.IDisposable.Dispose">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</para>
        </summary>
        <remarks>
          <content>
            <para>Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. This method is, by convention, used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.</para>
            <alert class="important">
              <para>C++ programmers should read <link xlink:href="0d09d3f1-13a0-4041-8178-402aad667edd">Destructors and Finalizers in Visual C++</link>. In the .NET Framework version 2.0, the C++ compiler provides support for implementing deterministic disposal of resources and does not allow direct implementation of the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method. </para>
            </alert>
            <para>When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A's <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> implementation must call <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> on B, which must in turn call <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> on C. An object must also call the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method of its base class if the base class implements <codeEntityReference autoUpgrade="true">T:System.IDisposable</codeEntityReference>.</para>
            <para>If an object's <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method is called multiple times. Instance methods other than <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> can throw an <codeEntityReference autoUpgrade="true">T:System.ObjectDisposedException</codeEntityReference> when resources are already disposed.</para>
            <para>Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state. An example of this is stream classes, which are traditionally thought of as open or closed. The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as Close, that calls the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method.</para>
            <para>Because the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method must be called explicitly, objects that implement <codeEntityReference autoUpgrade="true">T:System.IDisposable</codeEntityReference> must also implement a finalizer to handle freeing resources when <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> is not called. By default, the garbage collector automatically calls an object's finalizer prior to reclaiming its memory. However, once the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer. To prevent automatic finalization, <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> implementations can call the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.GC.SuppressFinalize(System.Object)</codeEntityReference> method.</para>
            <para>For more information on implementing finalizers and the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method, see the <codeEntityReference autoUpgrade="true">T:System.GC</codeEntityReference> class, the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> method, and <link xlink:href="31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Implementing Finalize and Dispose to Clean Up Unmanaged Resources</link>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.IDisposable.Dispose Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
  </members>
</doc>