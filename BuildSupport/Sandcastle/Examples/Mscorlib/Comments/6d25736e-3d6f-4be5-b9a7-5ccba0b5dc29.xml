<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:dev="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" fileAssetGuid="6d25736e-3d6f-4be5-b9a7-5ccba0b5dc29" revisionNumber="14">
  <assembly>
    <name>mscorlib</name>
  </assembly>
  <members>
    <member name="T:System.GC">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Controls the system garbage collector, a service that automatically reclaims unused memory.</para>
        </summary>
        <remarks>
          <content>
            <para>The methods in this class influence when garbage collection is performed on an object, and when resources allocated by an object are released. Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</para>
            <para>The garbage collector tracks and reclaims objects allocated in managed memory. Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references. Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory. Alternatively, an application can force garbage collection using the <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> method.</para>
            <para>Garbage collection consists of the following steps: </para>
            <list class="ordered">
              <listItem>
                <para>The garbage collector searches for managed objects that are referenced in managed code.</para>
              </listItem>
              <listItem>
                <para>The garbage collector attempts to finalize objects that are not referenced.</para>
              </listItem>
              <listItem>
                <para>The garbage collector frees objects that are not referenced and reclaims their memory.</para>
              </listItem>
            </list>
            <para>During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code. However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so. The <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</para>
            <para>Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections. When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</para>
            <para>In most cases, finalizers are implemented by overriding the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Finalize</codeEntityReference>. In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object. However, the garbage collector is not required to call finalizers in all situations; for example, the <codeEntityReference autoUpgrade="true">M:System.GC.SuppressFinalize(System.Object)</codeEntityReference> method explicitly prevents a finalizer from being called. Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</para>
            <para>In scenarios where resources must be released at a specific time, classes can implement the <codeEntityReference autoUpgrade="true">T:System.IDisposable</codeEntityReference> interface, which contains the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method that performs resource management and cleanup tasks. Classes that implement <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> must specify, as part of their class contract, if and when class consumers call the method to clean up the object. The garbage collector does not, by default, call the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method; however, implementations of the <codeEntityReference autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method can call methods in the <codeEntityReference autoUpgrade="true">T:System.GC</codeEntityReference> class to customize the finalization behavior of the garbage collector.</para>
            <para>It is recommended, but not required, that garbage collectors support object aging using generations. A generation is a unit of measure of the relative age of objects in memory. The generation number, or age, of an object indicates the generation to which an object belongs. Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. Objects in the most recent generation are in generation zero.</para>
          </content>
        </remarks>
        <notesForImplementers>
          <para>This implementation of the garbage collector supports three generations of objects.</para>
          <para>
            <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference> is used to determine the maximum generation number supported by the system. Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</para>
        </notesForImplementers>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.Collect Int Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.GC.AddMemoryPressure(System.Int64)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bytesAllocated</parameterReference>
            <content>
              <para>The incremental amount of unmanaged memory that has been allocated. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentOutOfRangeException</codeEntityReference>
            <content>
              <para>
                <parameterReference>bytesAllocated</parameterReference> is less than or equal to 0.</para>
              <para>-or-</para>
              <para>On a 32-bit computer, <parameterReference>bytesAllocated</parameterReference> is larger than <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Int32.MaxValue</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>The total amount of memory pressure exceeds <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.UInt64.MaxValue</codeEntityReference>.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <codeEntityReference autoUpgrade="true">M:System.GC.AddMemoryPressure(System.Int64)</codeEntityReference> method informs the runtime of this additional pressure on system memory.</para>
            <para>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <languageKeyword>Dispose</languageKeyword> or <languageKeyword>Finalize</languageKeyword> method. Call the <codeEntityReference autoUpgrade="true">M:System.GC.AddMemoryPressure(System.Int64)</codeEntityReference> method after allocating the unmanaged memory, and call the <codeEntityReference autoUpgrade="true">M:System.GC.RemoveMemoryPressure(System.Int64)</codeEntityReference> method after releasing it.</para>
            <para>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <codeEntityReference autoUpgrade="true">M:System.GC.AddMemoryPressure(System.Int64)</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.GC.RemoveMemoryPressure(System.Int64)</codeEntityReference> methods to communicate these incremental changes to the runtime.</para>
            <alert class="caution">
              <para>You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</para>
            </alert>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to call unmanaged code when manipulating garbage-collection priority. Associated enumeration: <codeEntityReference autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.GC.Collect">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Forces garbage collection of all generations. </para>
        </summary>
        <remarks>
          <content>
            <para>Use this method to attempt to reclaim all memory that is inaccessible. However, the <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> method does not guarantee that all inaccessible memory is reclaimed.</para>
            <para>All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected. Use this method to force the system to attempt to reclaim the maximum amount of available memory.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.Collect Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      <overload>
        <summary>
          <para>Forces garbage collection.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.GC.Collect(System.Int32)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Forces garbage collection from generation zero through a specified generation.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>generation</parameterReference>
            <content>
              <para>The number of the oldest generation on which garbage collection can be performed. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentOutOfRangeException</codeEntityReference>
            <content>
              <para>
                <parameterReference>generation</parameterReference> is less than 0. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Use this method to attempt to reclaim memory that is inaccessible. However, use of this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</para>
            <para>If object aging is implemented, the garbage collector does not collect objects with a generation number higher than the specified generation. If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</para>
            <para>Use the <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference> property to determine the maximum valid value of <parameterReference>generation</parameterReference>.</para>
            <para>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no arguments.</para>
          </content>
          <sections>
            <section>
              <title>Performance Considerations</title>
              <content>
                <para>A garbage collection operation for generations 0 and 1 is relatively fast and requires few system resources. In contrast, a garbage collection operation for generation 2 is a lengthy activity that pauses the application process while the garbage collector examines every object on the heap. The garbage collection mechanism is very efficient because it observes the way memory is being allocated in the system, and tunes its behavior accordingly. Attempting to force a garbage collection operation by calling the <codeEntityReference autoUpgrade="true">Overload:System.GC.Collect</codeEntityReference> or <codeEntityReference autoUpgrade="true">M:System.GC.WaitForPendingFinalizers</codeEntityReference> method interferes with the garbage collection algorithm and usually worsens your application's memory usage. </para>
                <para>Call the <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> method only when you know your application is finished using a significant amount of memory that is allocated only once. For example, call the <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> method when your application has finished using a large cache, or when a large dialog is closed and you know, or it is unlikely, that the dialog will be reopened.</para>
              </content>
            </section>
          </sections>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.Collect Int Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="Overload:System.GC.Collect">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Forces garbage collection.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.GC.CollectionCount(System.Int32)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the number of times garbage collection has occurred for the specified generation of objects.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>generation</parameterReference>
            <content>
              <para>The generation of objects for which the garbage collection count is to be determined. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The number of times garbage collection has occurred for the specified generation, since the process was started.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentOutOfRangeException</codeEntityReference>
            <content>
              <para>
                <parameterReference>generation</parameterReference> is less than 0. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If you implement your own resource management, you might need to force garbage collection periodically by calling the <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> method. Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently. Save the value returned by <codeEntityReference autoUpgrade="true">M:System.GC.CollectionCount(System.Int32)</codeEntityReference> immediately after calling <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference>. The next time you need to call <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference>, compare the current value returned by <codeEntityReference autoUpgrade="true">M:System.GC.CollectionCount(System.Int32)</codeEntityReference> to the saved value. If the two values are equal, no collection has occurred in the interim, and it is reasonable to call <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> again.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="M:System.GC.GetGeneration(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the current generation number of the specified object.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>obj</parameterReference>
            <content>
              <para>The object for which generation information is retrieved. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The current generation number of <parameterReference>obj</parameterReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Use this method to determine the age of an object, then use that information with the <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> method to force the garbage collector to collect objects in the same generation. For example, use this method when you have a set of objects that are created as a group and become inaccessible at the same time.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.Collect Int Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Returns the current generation number of an object.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.GC.GetGeneration">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the current generation number of an object.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.GC.GetGeneration(System.WeakReference)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the current generation number of the target of a specified weak reference.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>wo</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.WeakReference</codeEntityReference> that refers to the target object whose generation number is to be determined. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The current generation number of the target of <parameterReference>wo</parameterReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>Garbage collection has already been performed on <parameterReference>wo</parameterReference>. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.GetGenerationWeak Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.GC.GetTotalMemory(System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>forceFullCollection</parameterReference>
            <content>
              <para>A Boolean value which, if <languageKeyword>true</languageKeyword>, indicates that this method can wait for garbage collection to occur before returning. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If <parameterReference>forceFullCollection</parameterReference> is <languageKeyword>true</languageKeyword>, this method waits a short interval before returning while the system collects garbage and finalizes objects. The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles. The garbage collector does not guarantee that all inaccessible memory is collected.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.Collect Int Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.GC.KeepAlive(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>References the specified object, making it ineligible for garbage collection from the start of the current routine to the point where this method is called.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>obj</parameterReference>
            <content>
              <para>The object to reference. </para>
            </content>
          </parameter>
        </parameters>
        <remarks>
          <content>
            <para>The purpose of the <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector. A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</para>
            <para>Another case of premature garbage collection occurs when an object is created and used within a method. The object might be reclaimed while a call to one of its members is still executing, as shown in the first code example. </para>
            <para>This method references <parameterReference>obj</parameterReference>, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called. Code this method at the end, not the beginning, of the range of instructions where <parameterReference>obj</parameterReference> must be available.</para>
            <para>The <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This section contains two code examples. The first example demonstrates the use of the <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method to prevent aggressive garbage collection, and the second example demonstrates the use of the <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method in a long-running method.</para>
                <para>
                  <embeddedLabel>Example 1</embeddedLabel>
                </para>
                <para>The following code example shows how the <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method prevents aggressive garbage collection from occurring while a method of the collected object is still executing.</para>
                <alert class="note">
                  <para>This example requires a computer with multiple processors.</para>
                </alert>
                <para>The example starts a thread that repeatedly calls a test method. The thread executes until you press the ENTER key. By default, the code example runs the <codeInline>DoWork</codeInline> method, which creates an <codeInline>Example</codeInline> object and reads its <codeInline>Hash</codeInline> property. Because the <codeInline>DoWork</codeInline> method does not use the <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method, the finalizer for the <codeInline>Example</codeInline> object sometimes runs before the property has been read. The <codeInline>DoWork</codeInline> method detects this and displays a console message.</para>
                <para>When executed with the argument <system>KeepAlive</system>, the example runs the <codeInline>SafeDoWork</codeInline> method. The <codeInline>SafeDoWork</codeInline> method is identical to the <codeInline>DoWork</codeInline> method except for the last line, which calls the <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method. This prevents the <codeInline>Example</codeInline> object from being reclaimed until the end of the <codeInline>SafeDoWork</codeInline> method.</para>
                <para>When executed with the argument <system>Trivial</system>, the example runs the <codeInline>Trivial</codeInline> method, which accesses an integer property that is much faster than the <codeInline>Hash</codeInline> property. Because access is so fast, the finalizer almost never runs first.</para>
                <codeReference>AggressiveGarbargeCollection#1</codeReference>
                <para>
                  <embeddedLabel>Example 2</embeddedLabel>
                </para>
                <para>The following code example creates an object at the beginning of its <codeInline>Main</codeInline> method and does not refer to the object again until the end, when the <codeEntityReference autoUpgrade="true">M:System.GC.KeepAlive(System.Object)</codeEntityReference> method is called. The object persists for the 30-second duration of the <codeInline>Main</codeInline> method, despite calls to the <codeEntityReference autoUpgrade="true">M:System.GC.Collect</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.GC.WaitForPendingFinalizers</codeEntityReference> methods.</para>
                <codeReference>System.GC.KeepAlive Example2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="P:System.GC.MaxGeneration">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the maximum number of generations the system currently supports.</para>
        </summary>
        <returnValue>
          <para>A value ranging from zero to the maximum number of supported generations.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan. The most recently created objects are in generation zero and the oldest objects are in a generation less than or equal to the generation returned by the <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference> property.</para>
            <para>The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory. Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference> property value can grow over time.</para>
            <para>If object aging is implemented, the <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference> property returns the maximum generation number used by the system; otherwise, this property returns zero.</para>
          </content>
        </remarks>
        <notesForImplementers>
          <para>For this implementation, the value returned by the <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference> property is guaranteed to remain constant for the lifetime of an executing application.</para>
          <para>Use the <codeEntityReference autoUpgrade="true">P:System.GC.MaxGeneration</codeEntityReference> property to determine the maximum value you can specify when calling the <codeEntityReference autoUpgrade="true">M:System.GC.Collect(System.Int32)</codeEntityReference> method that takes a generation parameter.</para>
        </notesForImplementers>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.Collect Int Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.GC.GetGeneration(System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.GC.RemoveMemoryPressure(System.Int64)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bytesAllocated</parameterReference>
            <content>
              <para>The amount of unmanaged memory that has been released. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentOutOfRangeException</codeEntityReference>
            <content>
              <para>
                <parameterReference>bytesAllocated</parameterReference> is less than or equal to 0. </para>
              <para>-or- </para>
              <para>On a 32-bit computer, <parameterReference>bytesAllocated</parameterReference> is larger than <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Int32.MaxValue</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>The total amount of memory pressure is less than zero.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <codeEntityReference autoUpgrade="true">M:System.GC.AddMemoryPressure(System.Int64)</codeEntityReference> method informs the runtime of this additional pressure on system memory, and the <codeEntityReference autoUpgrade="true">M:System.GC.RemoveMemoryPressure(System.Int64)</codeEntityReference> method informs the runtime that the additional pressure has been released.</para>
            <para>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <languageKeyword>Dispose</languageKeyword> or <languageKeyword>Finalize</languageKeyword> method. Call the <codeEntityReference autoUpgrade="true">M:System.GC.AddMemoryPressure(System.Int64)</codeEntityReference> method after allocating the unmanaged memory, and call the <codeEntityReference autoUpgrade="true">M:System.GC.RemoveMemoryPressure(System.Int64)</codeEntityReference> method after releasing it.</para>
            <para>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <codeEntityReference autoUpgrade="true">M:System.GC.AddMemoryPressure(System.Int64)</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.GC.RemoveMemoryPressure(System.Int64)</codeEntityReference> methods to communicate these incremental changes to the runtime.</para>
            <alert class="caution">
              <para>You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</para>
            </alert>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to call unmanaged code when manipulating garbage-collection priority. Associated enumeration: <codeEntityReference autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.GC.ReRegisterForFinalize(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Requests that the system call the finalizer for the specified object, for which <codeEntityReference autoUpgrade="true">M:System.GC.SuppressFinalize(System.Object)</codeEntityReference> has previously been called.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>obj</parameterReference>
            <content>
              <para>The object for which a finalizer must be called. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>obj</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.GC.ReRegisterForFinalize(System.Object)</codeEntityReference> method adds <parameterReference>obj</parameterReference> to the list of objects that request finalization before the garbage collector frees the object. The <parameterReference>obj</parameterReference> parameter must be the caller of this method.</para>
            <para>Calling the <codeEntityReference autoUpgrade="true">M:System.GC.ReRegisterForFinalize(System.Object)</codeEntityReference> method does not guarantee that the garbage collector will call an object's finalizer.</para>
            <para>By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized, or might have disabled finalization by calling the <codeEntityReference autoUpgrade="true">M:System.GC.SuppressFinalize(System.Object)</codeEntityReference> method.</para>
            <para>A finalizer can use this method to resurrect itself or an object it references.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.ReregisterForFinalize Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.GC.SuppressFinalize(System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.GC.SuppressFinalize(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Requests that the system not call the finalizer for the specified object.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>obj</parameterReference>
            <content>
              <para>The object for which a finalizer must not be called. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>obj</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The method sets a bit in the object header, which the system checks when calling finalizers. The <parameterReference>obj</parameterReference> parameter is required to be the caller of this method.</para>
            <para>Objects that implement the <codeEntityReference autoUpgrade="true">T:System.IDisposable</codeEntityReference> interface can call this method from the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.IDisposable.Dispose</codeEntityReference> method to prevent the garbage collector from calling <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> on an object that does not require it.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.SuppressFinalize2 Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.GC.ReRegisterForFinalize(System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.GC.WaitForPendingFinalizers">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Suspends the current thread until the thread processing the queue of finalizers has emptied that queue.</para>
        </summary>
        <remarks>
          <content>
            <para>When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements. If an object implements a finalizer and has not disabled finalization by calling <codeEntityReference autoUpgrade="true">M:System.GC.SuppressFinalize(System.Object)</codeEntityReference>, the object is placed in a list of objects marked as ready for finalization. The garbage collector calls the <codeEntityReference autoUpgrade="true">M:System.Object.Finalize</codeEntityReference> methods for the objects in this list and removes the entries from the list. This method blocks until all finalizers have run to completion.</para>
            <para>The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate. However, this thread can be interrupted by another thread while the <codeEntityReference autoUpgrade="true">M:System.GC.WaitForPendingFinalizers</codeEntityReference> method is in progress. For example, you can start another thread that waits for a period of time then interrupts this thread if this thread is still suspended.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>System.GC.WaitForPendingFinalizers Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
  </members>
</doc>