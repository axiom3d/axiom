<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:dev="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" fileAssetGuid="d575d6d9-6c27-4620-a93a-7ab967598dec" revisionNumber="69">
  <assembly>
    <name>mscorlib</name>
  </assembly>
  <members>
    <member name="T:System.Type">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</para>
        </summary>
        <threadSafety>
          <para>This type is thread safe.</para>
        </threadSafety>
        <remarks>
          <content>
            <para>
              <languageKeyword>Type</languageKeyword> is the root of the <codeEntityReference autoUpgrade="true">N:System.Reflection</codeEntityReference> functionality and is the primary way to access metadata. Use the members of <languageKeyword>Type</languageKeyword> to get information about a type declaration, such as the constructors, methods, fields, properties, and events of a class, as well as the module and the assembly in which the class is deployed.</para>
            <para>A <languageKeyword>Type</languageKeyword> object that represents a type is unique; that is, two <languageKeyword>Type</languageKeyword> object references refer to the same object if and only if they represent the same type. This allows for comparison of <languageKeyword>Type</languageKeyword> objects using reference equality.</para>
            <para>Without <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>, code can access only the public members of loaded assemblies. This includes, but is not limited to, unrestricted access to <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.GetType</codeEntityReference>, access to public exported types through <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Type.GetType</codeEntityReference>, and access to <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)</codeEntityReference>. Some properties of <languageKeyword>Type</languageKeyword>, such as <codeEntityReference autoUpgrade="true">P:System.Type.FullName</codeEntityReference> and <codeEntityReference autoUpgrade="true">P:System.Type.Attributes</codeEntityReference>, are accessible without <languageKeyword>ReflectionPermission</languageKeyword>.</para>
            <para>
              <languageKeyword>Type</languageKeyword> is an abstract base class that allows multiple implementations. The system will always provide the derived class RuntimeType. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</para>
            <alert class="note">
              <para>In multithreading scenarios, do not lock <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects in order to synchronize access to <languageKeyword>static</languageKeyword> data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private <languageKeyword>static</languageKeyword> object.</para>
            </alert>
            <para>This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of <languageKeyword>Type</languageKeyword> can represent any of the following types: </para>
            <list class="bullet">
              <listItem>
                <para>Classes </para>
              </listItem>
              <listItem>
                <para>Value types </para>
              </listItem>
              <listItem>
                <para>Arrays </para>
              </listItem>
              <listItem>
                <para>Interfaces </para>
              </listItem>
              <listItem>
                <para>Pointers </para>
              </listItem>
              <listItem>
                <para>Enumerations </para>
              </listItem>
              <listItem>
                <para>Constructed generic types and generic type definitions</para>
              </listItem>
              <listItem>
                <para>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</para>
              </listItem>
            </list>
            <para>A reference to the <languageKeyword>Type</languageKeyword> object associated with a type can be obtained in the following ways:</para>
            <list class="bullet">
              <listItem>
                <para>The <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.GetType</codeEntityReference> method returns a <languageKeyword>Type</languageKeyword> object that represents the type of an instance.</para>
              </listItem>
              <listItem>
                <para>The static <languageKeyword>GetType</languageKeyword> methods return a <languageKeyword>Type</languageKeyword> object that represents a type specified by its fully qualified name.</para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Module.GetTypes</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Module.GetType(System.String,System.Boolean)</codeEntityReference>, and <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)</codeEntityReference> methods return <languageKeyword>Type</languageKeyword> objects that represent the types defined in a module. The first method can be used to obtain an array of <languageKeyword>Type</languageKeyword> objects for all of the public and private types defined in a module. (You can obtain an instance of <languageKeyword>Module</languageKeyword> through the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Assembly.GetModule(System.String)</codeEntityReference> or <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Assembly.GetModules</codeEntityReference> methods, or through the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.Module</codeEntityReference> property.) </para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference> method returns a filtered list of interface types supported by a type.</para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Type.GetElementType</codeEntityReference> method returns a <languageKeyword>Type</languageKeyword> object that represents the element.</para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Type.GetInterfaces</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.Type.GetInterface(System.String)</codeEntityReference> methods return <languageKeyword>Type</languageKeyword> objects representing the interface types supported by a type.</para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeArray(System.Object[])</codeEntityReference> method returns an array of <languageKeyword>Type</languageKeyword> objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <languageKeyword>Object</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeFromProgID(System.String)</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeFromCLSID(System.Guid)</codeEntityReference> methods are provided for COM interoperability. They return a <languageKeyword>Type</languageKeyword> object that represents the type specified by a <languageKeyword>ProgID</languageKeyword> or <languageKeyword>CLSID</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)</codeEntityReference> method is provided for interoperability. It returns a <languageKeyword>Type</languageKeyword> object that represents the type specified by a class handle.</para>
              </listItem>
              <listItem>
                <para>The C# <languageKeyword>typeof</languageKeyword> operator, the C++ <languageKeyword>typeid</languageKeyword> operator, and the Visual Basic <languageKeyword>GetType</languageKeyword> operator obtain the <languageKeyword>Type</languageKeyword> object for a type.</para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a constructed generic type, which is an open constructed type if its <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property returns <languageKeyword>true</languageKeyword>, and a closed constructed type otherwise. A generic type can be instantiated only if it is closed. </para>
              </listItem>
              <listItem>
                <para>The <codeEntityReference autoUpgrade="true">Overload:System.Type.MakeArrayType</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.MakePointerType</codeEntityReference>, and <codeEntityReference autoUpgrade="true">M:System.Type.MakeByRefType</codeEntityReference> methods return <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<languageKeyword>ref</languageKeyword> in C#, <languageKeyword>ByRef</languageKeyword> in Visual Basic). </para>
              </listItem>
            </list>
            <alert class="note">
              <para>A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</para>
            </alert>
            <alert class="note">
              <para>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</para>
            </alert>
          </content>
        </remarks>
        <notesForInheritors>
          <para>When you inherit from <languageKeyword>Type</languageKeyword>, you must override the following members: <codeEntityReference autoUpgrade="true">P:System.Type.GUID</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</codeEntityReference>, <codeEntityReference autoUpgrade="false">P:System.Type.Module</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.Assembly</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.TypeHandle</codeEntityReference>, <codeEntityReference autoUpgrade="false">P:System.Type.FullName</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.Namespace</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.BaseType</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetConstructors(System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetMethods(System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetField(System.String,System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetFields(System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetInterface(System.String,System.Boolean)</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetInterfaces</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetEvents(System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.GetAttributeFlagsImpl</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.IsArrayImpl</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.IsByRefImpl</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.IsPointerImpl</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.IsPrimitiveImpl</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.IsCOMObjectImpl</codeEntityReference>, <codeEntityReference autoUpgrade="false">M:System.Type.GetElementType</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.HasElementTypeImpl</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.UnderlyingSystemType</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.MemberInfo.Name</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="false">M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)</codeEntityReference>, and <codeEntityReference autoUpgrade="true">M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)</codeEntityReference>.</para>
        </notesForInheritors>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>
          <codeEntityReference autoUpgrade="true">N:System.Reflection</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.#ctor">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Initializes a new instance of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> class.</para>
        </summary>
        <remarks>
          <content>
            <para>This constructor is invoked by derived classes during the construction of type objects.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="P:System.Type.IsGenericType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the current type is a generic type.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the current type is a generic type; otherwise,<languageKeyword> false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Use the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property to determine whether a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a generic type. Use the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property to determine whether a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents an open constructed type or a closed constructed type.</para>
            <alert class="note">
              <para>The <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property returns <languageKeyword>false</languageKeyword> if the immediate type is not generic. For example, an array whose elements are of type <codeInline>A&lt;int&gt;</codeInline> (<codeInline>A(Of Integer)</codeInline> in Visual Basic) is not itself a generic type.</para>
            </alert>
            <para>The following table summarizes the invariant conditions for common terms used in generic reflection.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Term</para>
                  </entry>
                  <entry>
                    <para>Invariant</para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>generic type definition</para>
                </entry>
                <entry>
                  <para>The <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> property is <languageKeyword>true</languageKeyword>.</para>
                  <para>Defines a generic type. A constructed type is created by calling the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method on a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents a generic type definition and specifying an array of type arguments.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> can be called only on generic type definitions. </para>
                  <para>Any generic type definition is a generic type (the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property is <languageKeyword>true</languageKeyword>), but the converse is not true.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>generic type</para>
                </entry>
                <entry>
                  <para>The <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property is <languageKeyword>true</languageKeyword>.</para>
                  <para>Can be a generic type definition, an open constructed type, or a closed constructed type. </para>
                  <para>Note that an array type whose element type is generic is not itself a generic type. The same is true of a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a pointer to a generic type.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>open constructed type</para>
                </entry>
                <entry>
                  <para>The <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property is <languageKeyword>true</languageKeyword>.</para>
                  <para>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property is <languageKeyword>true</languageKeyword>.</para>
                  <para>It is not possible to create an instance of an open constructed type.</para>
                  <para>Note that not all open constructed types are generic. For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>closed constructed type</para>
                </entry>
                <entry>
                  <para>The <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property is <languageKeyword>false</languageKeyword>.</para>
                  <para>When examined recursively, the type has no unassigned generic parameters. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>generic type parameter</para>
                </entry>
                <entry>
                  <para>The <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property is <languageKeyword>true</languageKeyword>.</para>
                  <para>In a generic type definition, a placeholder for a type that will be assigned later. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>generic type argument</para>
                </entry>
                <entry>
                  <para>Can be any type, including a generic type parameter.</para>
                  <para>Type arguments are specified as an array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects passed to the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method when creating a constructed generic type. If instances of the resulting type are to be created, the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property must be <languageKeyword>false</languageKeyword> for all the type arguments.</para>
                </entry>
              </row>
            </table>
            <para>The following code example and table illustrate some of these terms and invariants. The <codeInline>Derived</codeInline> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.  </para>
            <code language="vb#">Public Class Base(Of T, U)
End Class
Public Class Derived(Of V) 
    Inherits Base(Of String, V)
    Public F As G(Of Derived(Of V))
    Public Class Nested
    End Class
End Class
Public Class G(Of T)
End Class </code>
            <code language="c#">public class Base&lt;T,U&gt; {}
public class Derived&lt;V&gt; : Base&lt;String,V&gt; 
{
    public G&lt;Derived&lt;V&gt;&gt; F;
    public class Nested {}
}
public class G&lt;T&gt; {}</code>
            <code language="cpp#">generic &lt;typename T&gt; public ref class G {};
generic &lt;typename T, typename U&gt; public ref class Base {};
generic &lt;typename V&gt; public ref class Derived : Base&lt;String^,V&gt; {
public:
    G&lt;Derived&lt;V&gt;^&gt;^ F;
    ref class Nested {};
};</code>
            <para>The following table shows examples that use and build on the classes <codeInline>Base</codeInline>, <codeInline>Derived</codeInline>, and <codeInline>G</codeInline>. When the C++ and C# code is the same, only one entry is shown.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Example</para>
                  </entry>
                  <entry>
                    <para>Invariants</para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>
                    <codeInline>Derived(Of V)</codeInline>
                  </para>
                  <para>
                    <codeInline>Derived&lt;V&gt;</codeInline>
                  </para>
                </entry>
                <entry>
                  <para>For this type:</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> is <languageKeyword>true</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> is <languageKeyword>true</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> is <languageKeyword>true</languageKeyword>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <codeInline>Base(Of String, V)</codeInline>
                  </para>
                  <para>
                    <codeInline>Base&lt;String,V&gt;</codeInline>
                  </para>
                  <para>
                    <codeInline>Base&lt;String^,V&gt;</codeInline>
                  </para>
                </entry>
                <entry>
                  <para>For this type:</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> is <languageKeyword>true</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> is <languageKeyword>false</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> is <languageKeyword>true</languageKeyword>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <codeInline>Dim d() As Derived(Of Integer)</codeInline>
                  </para>
                  <para>
                    <codeInline>Derived&lt;int&gt;[] d;</codeInline>
                  </para>
                  <para>
                    <codeInline>array&lt;Derived&lt;int&gt;^&gt;^ d;</codeInline>
                  </para>
                </entry>
                <entry>
                  <para>For the type of variable <codeInline>d</codeInline>:</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> is <languageKeyword>false</languageKeyword> because <codeInline>d</codeInline> is an array.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> is <languageKeyword>false</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> is <languageKeyword>false</languageKeyword>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>
                    <codeInline>T</codeInline>, <codeInline>U</codeInline>, and <codeInline>V</codeInline> (everywhere they appear)</para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> is <languageKeyword>true</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> is <languageKeyword>false</languageKeyword> because there is no way to constrain a type parameter to generic types.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> is <languageKeyword>false</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> is <languageKeyword>false</languageKeyword>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>The type of field<codeInline> F</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> is <languageKeyword>true</languageKeyword>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> is <languageKeyword>false</languageKeyword> because a type has been assigned to to the type parameter of <codeInline>G</codeInline>. Note that this is equivalent to having called the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> is <languageKeyword>true</languageKeyword> because the type of field<codeInline> F</codeInline> has a type argument that is an open constructed type. The constructed type is open because its type argument (that is, <codeInline>Base</codeInline>) is a generic type definition. This illustrates the recursive nature of the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>The nested class <codeInline>Nested</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> is <languageKeyword>true</languageKeyword>, even though the <codeInline>Nested</codeInline> class has no generic type parameters of its own, because it is nested in a generic type.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> is <languageKeyword>true</languageKeyword>. That is, you can call the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method and supply the type parameter of the enclosing type, <codeInline>Derived</codeInline>.</para>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> is <languageKeyword>true</languageKeyword> because the enclosing type, <codeInline>Derived</codeInline>, has generic type parameters. This illustrates the recursive nature of the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property. </para>
                </entry>
              </row>
            </table>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example displays the value of the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference>, and <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> properties for the types described in the Remarks section. For explanations of the property values, see the accompanying table in Remarks.</para>
                <codeReference>System.Type.IsGenericType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsGenericParameter">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or method.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of a generic type definition or generic method definition; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>
              <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects that represent generic type parameters can be obtained by calling the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericArguments</codeEntityReference> method of a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents a generic type definition, or the <codeEntityReference autoUpgrade="true">M:System.Reflection.MethodInfo.GetGenericArguments</codeEntityReference> method of a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object that represents a generic method definition.</para>
            <list class="bullet">
              <listItem>
                <para>For a generic type or method definition, the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property returns <languageKeyword>true</languageKeyword> for every element of the resulting array.</para>
              </listItem>
              <listItem>
                <para>For a closed constructed type or method, the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property returns <languageKeyword>false</languageKeyword> for every element of the array returned by the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericArguments</codeEntityReference> method.</para>
              </listItem>
              <listItem>
                <para>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters. <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> returns <languageKeyword>false</languageKeyword> for the types and <languageKeyword>true</languageKeyword> for the type parameters. The code example for the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property demonstrates a generic class with a mixture of types and type parameters.</para>
              </listItem>
            </list>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example uses the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property to test for generic type parameters in a generic type.</para>
                <codeReference>System.Type.IsGenericParameter#2</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericArguments</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericParameterConstraints</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsGenericTypeDefinition">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type definition, from which other generic types can be constructed.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a generic type definition; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>A generic type definition is a template from which other types can be constructed. For example, from the generic type definition <codeInline>G&lt;T&gt;</codeInline> (expressed in C# syntax; <codeInline>G(Of T)</codeInline> in Visual Basic or <codeInline>generic &lt;typename T&gt; ref class G</codeInline> in C++) you can construct and instantiate the type <codeInline>G&lt;int&gt;</codeInline> (<codeInline>G(Of Integer)</codeInline> in Visual Basic), by calling the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method with a generic argument list containing the <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference> type. Given a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing this constructed type, the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference> method gets the generic type definition back again.</para>
            <para>Use the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> property to determine whether you can create new types from the current type. If the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> property returns <languageKeyword>true</languageKeyword>, you can call the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method to create new generic types.</para>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays information about a type, including whether or not it is a generic type definition. Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</para>
                <codeReference>System.Type.IsGenericTypeDefinition#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.MakeGenericType(System.Type[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing the resulting constructed type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>typeArguments</parameterReference>
            <content>
              <para>An array of types to be substituted for the type parameters of the current generic type.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> representing the constructed type formed by substituting the elements of <parameterReference>typeArguments</parameterReference> for the type parameters of the current generic type.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>The current type does not represent a generic type definition. That is, <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> returns <languageKeyword>false</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeArguments</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>Any element of <parameterReference>typeArguments</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The number of elements in <parameterReference>typeArguments</parameterReference> is not the same as the number of type parameters in the current generic type definition.</para>
              <para>-or- </para>
              <para>Any element of <parameterReference>typeArguments</parameterReference> does not satisfy the constraints specified for the corresponding type parameter of the current generic type. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents a particular constructed type. You can use this <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object to create run-time instances of the constructed type.</para>
            <para>Types constructed with <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types. You might use such open constructed types when you emit dynamic assemblies. For example, consider the classes <codeInline>Base</codeInline> and <codeInline>Derived</codeInline> in the following code.</para>
            <code language="vb#">Public Class Base(Of T, U)
End Class
Public Class Derived(Of V)
    Inherits Base(Of Integer, V)
End Class</code>
            <code language="c#">public class Base&lt;T, U&gt; { }
public class Derived&lt;V&gt; : Base&lt;int, V&gt; { }</code>
            <code language="cpp#">generic&lt;typename T, typename U&gt; 
    public ref class Base { };
generic&lt;typename V&gt; 
    public ref class Derived : Base&lt;int, V&gt; { };</code>
            <para>To generate <codeInline>Derived</codeInline> in a dynamic assembly, it is necessary to construct its base type. To do this, call the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method on a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing the class <codeInline>Base</codeInline>, using the generic type arguments <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference> and the type parameter <codeInline>V</codeInline> from <codeInline>Derived</codeInline>. Because types and generic type parameters are both represented by <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects, an array containing both can be passed to the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method.</para>
            <alert class="note">
              <para>A constructed type such as <codeInline>Base&lt;int, V&gt;</codeInline> is useful when emitting code, but you cannot call the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method on this type because it is not a generic type definition. To create a closed constructed type that can be instantiated, first call the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference> method to get a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing the generic type definition and then call <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> with the desired type arguments.</para>
            </alert>
            <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object returned by <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> is the same as the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> obtained by calling the <codeEntityReference autoUpgrade="true">M:System.Object.GetType</codeEntityReference> method of the resulting constructed type, or the <codeEntityReference autoUpgrade="true">M:System.Object.GetType</codeEntityReference> method of any constructed type that was created from the same generic type definition using the same type arguments.</para>
            <alert class="note">
              <para>An array of generic types is not itself a generic type. You cannot call <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> on an array type such as <codeInline>C&lt;T&gt;[]</codeInline> (<codeInline>Dim ac() As C(Of T)</codeInline> in Visual Basic). To construct a closed generic type from <codeInline>C&lt;T&gt;[]</codeInline>, call <codeEntityReference autoUpgrade="true">M:System.Type.GetElementType</codeEntityReference> to obtain the generic type definition <codeInline>C&lt;T&gt;</codeInline>; call <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> on the generic type definition to create the constructed type; and finally call the <codeEntityReference autoUpgrade="true">Overload:System.Type.MakeArrayType</codeEntityReference> method on the constructed type to create the array type. The same is true of pointer types and <languageKeyword>ref</languageKeyword> types (<languageKeyword>ByRef</languageKeyword> in Visual Basic).</para>
            </alert>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
          <sections>
            <section>
              <title>Nested Types</title>
              <content>
                <para>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic. This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types. Consider the following classes:</para>
                <code language="vb#">Public Class Outermost(Of T)
    Public Class Inner(Of U)
        Public Class Innermost1(Of V)
        End Class
        Public Class Innermost2
        End Class
    End Class
End Class</code>
                <code language="c#">public class Outermost&lt;T&gt;
{
    public class Inner&lt;U&gt;
    {
        public class Innermost1&lt;V&gt; {}
        public class Innermost2 {}
    }
}</code>
                <code language="cpp#">generic&lt;typename T&gt; public ref class Outermost
{
public:
    generic&lt;typename U&gt; ref class Inner
    {
    public:
        generic&lt;typename V&gt; ref class Innermost1 {};
        ref class Innermost2 {};
    };
};</code>
                <para>The type parameter list of the nested class <codeInline>Inner</codeInline> has two type parameters, <parameterReference>T</parameterReference> and <parameterReference>U</parameterReference>, the first of which is the type parameter of its enclosing class. Similarly, the type parameter list of the nested class <codeInline>Innermost1</codeInline> has three type parameters, <parameterReference>T</parameterReference>, <parameterReference>U</parameterReference>, and <parameterReference>V</parameterReference>, with <parameterReference>T</parameterReference> and <parameterReference>U</parameterReference> coming from its enclosing classes. The nested class <codeInline>Innermost2</codeInline> has two type parameters, <parameterReference>T</parameterReference> and <parameterReference>U</parameterReference>, which come from its enclosing classes. </para>
                <para>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</para>
                <para>To construct a generic type from the generic type definition for a nested type, call the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own. To create an instance of <codeInline>Innermost1</codeInline>, call the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <codeInline>Innermost2</codeInline>, call the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method with an array containing two types, to be assigned to T and U. </para>
                <para>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types. Otherwise, the type parameters would not be in scope within the bodies of the nested types. It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <link xlink:href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</link>. Consider the following code for the MSIL assembler:</para>
                <code>.class public Outer&lt;T&gt; {
    .class nested public Inner&lt;U&gt; {
        .class nested public Innermost {
        }
    }
}</code>
                <para>In this example, it is not possible to define a field of type <parameterReference>T</parameterReference> or <parameterReference>U</parameterReference> in class <codeInline>Innermost</codeInline>, because those type parameters are not in scope. The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</para>
                <code>.class public Outer&lt;T&gt; {
    .class nested public Inner&lt;T, U&gt; {
        .class nested public Innermost&lt;T, U, V&gt; {
        }
    }
}</code>
                <para>You can use the <link xlink:href="db27f6b2-f1ec-499e-be3a-7eecf95ca42b">MSIL Disassembler (Ildasm.exe)</link> to examine nested classes defined in the high-level languages and observe this naming scheme.</para>
              </content>
            </section>
          </sections>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example uses the <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference> method to create a constructed type from the generic type definition for the <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> type. The constructed type represents a <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>Test</codeInline> objects with string keys.</para>
                <codeReference>System.Type.BindGenericParameters#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.ContainsGenericParameters">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object has type parameters that have not been replaced by specific types.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object has type parameters for which specific types have not been supplied; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type. Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</para>
            <para>Since types can be arbitrarily complex, making this determination is difficult. For convenience and to reduce the chance of error, the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot. If the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property returns <languageKeyword>true</languageKeyword>, the type cannot be instantiated.</para>
            <para>The <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property searches recursively for type parameters. For example, it returns <languageKeyword>true</languageKeyword> for an array whose elements are type <codeInline>A&lt;T&gt;</codeInline> (<codeInline>A(Of T)</codeInline> in Visual Basic), even though the array is not itself generic. Contrast this with the behavior of the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property, which returns <languageKeyword>false</languageKeyword> for arrays.</para>
            <para>For a set of example classes and a table showing the values of the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property, see <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference>. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class. The derived class's base class has two type arguments: the first is <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference> and the second is a type parameter of the derived type. The example displays information about these generic classes, including the positions reported by the <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference> property.</para>
                <codeReference>System.Type.HasUnboundGenericParameters#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="A0C3C0C5-8178-4673-8107-9FDDE780A669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.DeclaringMethod">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodBase</codeEntityReference> that represents the declaring method, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic method.</para>
        </summary>
        <returnValue>
          <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic method, a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodBase</codeEntityReference> that represents declaring method; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The declaring method is a generic method definition. That is, if <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> does not return <languageKeyword>null</languageKeyword>, then <codeInline>DeclaringMethod.IsGenericMethodDefinition</codeInline> returns <languageKeyword>true</languageKeyword>.</para>
            <para>The <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference> and <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</para>
            <list class="bullet">
              <listItem>
                <para>If the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property returns a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>, that <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> represents a generic method definition, and the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of that generic method definition.</para>
              </listItem>
              <listItem>
                <para>If the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property returns <languageKeyword>null</languageKeyword>, then the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference> property always returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a generic type definition, and the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of that generic type definition.</para>
              </listItem>
            </list>
            <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodBase</codeEntityReference> that is returned by the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property is either a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> in the case of a generic method, or a <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> in the case of a generic constructor.</para>
            <alert class="note">
              <para>In the .NET Framework version 2.0, generic constructors are not supported.</para>
            </alert>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method. It also displays information about the generic method definition and the constructed method. When displaying information about the type parameters of the generic method definition, in the <codeInline>DisplayGenericMethodInfo</codeInline> method, the example code shows the value of the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property for the method's generic type parameter.</para>
                <codeReference>MethodInfo.Generics#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.GenericParameterAttributes">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a combination of <codeEntityReference autoUpgrade="true">T:System.Reflection.GenericParameterAttributes</codeEntityReference> flags that describe the covariance and special constraints of the current generic type parameter. </para>
        </summary>
        <returnValue>
          <para>A bitwise combination of <codeEntityReference autoUpgrade="true">T:System.Reflection.GenericParameterAttributes</codeEntityReference> values that describes the covariance and special constraints of the current generic type parameter.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object is not a generic type parameter. That is, the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property returns <languageKeyword>false</languageKeyword>.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints. Use the <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.GenericParameterAttributes.VarianceMask</codeEntityReference> value to select the covariance flags, and use the <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.GenericParameterAttributes.SpecialConstraintMask</codeEntityReference> value to select the constraint flags.</para>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example defines a generic type <codeInline>Test</codeInline> with two type parameters that have different constraints. When the program executes, the constraints are examined using the <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterAttributes</codeEntityReference> property and the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericParameterConstraints</codeEntityReference> method.</para>
                <codeReference>System.Type.GetGenericParameterConstraints#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericParameterConstraints</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.GenericParameterPosition">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of a generic type or a generic method.</para>
        </summary>
        <returnValue>
          <para>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter. Position numbers begin at 0.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>The current type does not represent a type parameter. That is, <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> returns <languageKeyword>false</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference> and <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> properties identify the generic type or method definition:</para>
            <list class="bullet">
              <listItem>
                <para>If the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property returns a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>, that <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> represents a generic method definition, and the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of that generic method definition.</para>
              </listItem>
              <listItem>
                <para>If the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property returns <languageKeyword>null</languageKeyword>, then the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference> property always returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a generic type definition, and the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of that generic type definition.</para>
              </listItem>
            </list>
            <para>To provide the correct context for the value of the <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference> property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method <codeInline>GetSomething</codeInline> in the following code: </para>
            <code language="vb#">Public Class B(Of T, U)
End Class
Public Class A(Of V)
    Public Function GetSomething(Of X)() As B(Of V, X)
        Return New B(Of V, X)()
    End Function
End Class</code>
            <code language="c#">public class B&lt;T, U&gt; { }
public class A&lt;V&gt;
{
    public B&lt;V, X&gt; GetSomething&lt;X&gt;()
    {
        return new B&lt;V, X&gt;();
    }
}</code>
            <code language="cpp#">generic&lt;typename T, typename U&gt; public ref class B { };
generic&lt;typename V&gt; public ref class A
{
public:
    generic&lt;typename X&gt; B&lt;V, X&gt;^ GetSomething()
    {
        return gcnew Base&lt;V, X&gt;();
    }
};</code>
            <para>The type returned by <codeInline>GetSomething</codeInline> depends on the type arguments supplied to class <codeInline>A</codeInline> and to <codeInline>GetSomething</codeInline> itself. You can obtain a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> for <codeInline>GetSomething</codeInline>, and from that you can obtain the return type. When you examine the type parameters of the return type, <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference> returns 0 for both. The position of <codeInline>V</codeInline> is 0 because <codeInline>V</codeInline> is the first type parameter in the type parameter list for class <codeInline>A</codeInline>. The position of <codeInline>X</codeInline> is 0 because <codeInline>X</codeInline> is the first type parameter in the type parameter list for <codeInline>GetSomething</codeInline>.</para>
            <alert class="note">
              <para>Calling the <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference> property causes an exception if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property to tell which are type parameters and which are types. The <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property returns <languageKeyword>true</languageKeyword> for a type parameter; you can then use the <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference> method to obtain its position and use the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> and <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference> properties to determine the generic method or type definition that defines it.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class. The derived class's base class has two type arguments: the first is <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>, and the second is a type parameter of the derived type. The example displays information about these generic classes, including the positions reported by the <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterPosition</codeEntityReference> property.</para>
                <codeReference>System.Type.HasUnboundGenericParameters#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetGenericArguments">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns an array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects that represent the type arguments of a generic type or the type parameters of a generic type definition.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</para>
            <list class="bullet">
              <listItem>
                <para>If the current type is a closed constructed type (that is, the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property returns <languageKeyword>false</languageKeyword>), the array returned by the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericArguments</codeEntityReference> method contains the types that have been assigned to the generic type parameters of the generic type definition. </para>
              </listItem>
              <listItem>
                <para>If the current type is a generic type definition, the array contains the type parameters. </para>
              </listItem>
              <listItem>
                <para>If the current type is an open constructed type (that is, the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property returns <languageKeyword>true</languageKeyword>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters. Use the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property to tell them apart. For a demonstration of this scenario, see the code example for the <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> property.</para>
              </listItem>
            </list>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example uses the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericArguments</codeEntityReference> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</para>
                <para>This code example is part of a larger example provided for the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference> property.</para>
                <codeReference>System.Type.IsGenericTypeDefinition#2</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetGenericTypeDefinition">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents a generic type definition from which the current generic type can be constructed.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a generic type from which the current type can be constructed.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>The current type is not a generic type.  That is, <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> returns <languageKeyword>false</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>A generic type definition is a template from which other types can be constructed. For example, from the generic type definition <codeInline>G&lt;T&gt;</codeInline> (expressed in C# syntax; <codeInline>G(Of T)</codeInline> in Visual Basic or <codeInline>generic &lt;typename T&gt; ref class G</codeInline> in C++) you can construct and instantiate the type <codeInline>G&lt;int&gt;</codeInline> (<codeInline>G(Of Integer)</codeInline> in Visual Basic). Given a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing this constructed type, the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference> method returns the generic type definition.</para>
            <para>If two constructed types are created from the same generic type definition, using the same type arguments, the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference> method returns the same <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object for both types.</para>
            <para>If you call the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference> method on a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that already represents a generic type definition, it returns the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
            <alert class="important">
              <para>An array of generic types is not itself generic. In the C# code <codeInline>A&lt;int&gt;[] v;</codeInline> or the Visual Basic code <codeInline>Dim v() As A(Of Integer)</codeInline>, the type of variable <codeInline>v</codeInline> is not generic. Use <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> to determine whether a type is generic before calling <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference>.</para>
            </alert>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericTypeDefinition</codeEntityReference> methods to retrieve the constructed type and the generic type definition. This example uses the generic <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> type; the constructed type represents a <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>Test</codeInline> objects with string keys.</para>
                <codeReference>System.Type.GetGenericTypeDefinition#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="a0c3c0c5-8178-4673-8107-9fdde780a669">Reflection and Generic Types</link>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericTypeDefinition</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetGenericParameterConstraints">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns an array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects that represent the constraints on the current generic type parameter. </para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects that represent the constraints on the current generic type parameter.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object is not a generic type parameter. That is, the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property returns <languageKeyword>false</languageKeyword>.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Each constraint on a generic type parameter is expressed as a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object. Use the <codeEntityReference autoUpgrade="true">P:System.Type.IsClass</codeEntityReference> property to determine whether a constraint is the base class constraint; if the property returns <languageKeyword>false</languageKeyword>, the constraint is an interface constraint. If a type parameter has no class constraint and no interface constraints, an empty array is returned. </para>
            <para>For a list of the invariant conditions for terms used in generic reflection, see the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericType</codeEntityReference> property remarks. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example defines a generic type <codeInline>Test</codeInline> with two type parameters that have different constraints. When the program executes, the constraints are examined using the <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterAttributes</codeEntityReference> property and the <codeEntityReference autoUpgrade="true">M:System.Type.GetGenericParameterConstraints</codeEntityReference> method.</para>
                <codeReference>System.Type.GetGenericParameterConstraints#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="f93b03b0-1778-43fc-bc6d-35983d210e74">How to: Examine and Instantiate Generic Types with Reflection</link>
          <codeEntityReference autoUpgrade="true">P:System.Type.GenericParameterAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.Assembly">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> in which the type is declared. For generic types, gets the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> in which the generic type is defined.</para>
        </summary>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> instance that describes the assembly containing the current type. For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a constructed generic type, this property returns the assembly that contains the generic type definition. For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <codeInline>MyGenericStack&lt;T&gt;</codeInline> (<codeInline>MyGenericStack(Of T)</codeInline> in Visual Basic, <codeInline>generic&lt;T&gt; ref class MyGenericStack</codeInline> in C++). If you create an instance of <codeInline>MyGenericStack&lt;int&gt;</codeInline> (<codeInline>MyGenericStack(Of Integer)</codeInline> in Visual Basic) in another assembly, the <codeEntityReference autoUpgrade="true">P:System.Type.Assembly</codeEntityReference> property for the constructed type returns an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> object that represents MyGenerics.dll.</para>
            <para>Similarly, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents an unassigned generic parameter <parameterReference>T</parameterReference>, this property returns the assembly that contains the generic type that defines <parameterReference>T</parameterReference>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays the assembly name associated with the class and the fully qualified name of the type.</para>
                <codeReference>Type_Assembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="P:System.Type.AssemblyQualifiedName">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the assembly-qualified name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, which includes the name of the assembly from which the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> was loaded.</para>
        </summary>
        <returnValue>
          <para>The assembly-qualified name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, which includes the name of the assembly from which the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> was loaded, or <languageKeyword>null</languageKeyword> if the current instance represents a generic type parameter.</para>
        </returnValue>
        <remarks>
          <content>
            <para>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Delimiter </para>
                  </entry>
                  <entry>
                    <para>Meaning </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Backslash (\) </para>
                </entry>
                <entry>
                  <para>Escape character. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Comma (,) </para>
                </entry>
                <entry>
                  <para>Precedes the Assembly name. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Plus sign (+) </para>
                </entry>
                <entry>
                  <para>Precedes a nested class. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Period (.) </para>
                </entry>
                <entry>
                  <para>Denotes namespace identifiers. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Brackets ([]) </para>
                </entry>
                <entry>
                  <para>After a type name, denotes an array of that type.</para>
                  <para>-or-</para>
                  <para>For a generic type, encloses the generic type argument list.</para>
                  <para>-or-</para>
                  <para>Within a type argument list, encloses an assembly-qualified type. </para>
                </entry>
              </row>
            </table>
            <para>For example, the assembly-qualified name for a class might look like this: </para>
            <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089</code>
            <para>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection would emit this string as follows: </para>
            <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089 </code>
            <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
            <para>This qualified name can be persisted and later used to load the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. To search for and load a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, use <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> either with the type name only or with the assembly qualified type name. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the type name only will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in the caller's assembly and then in the System assembly. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the assembly qualified type name will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in any assembly.</para>
            <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <codeInline>t.GetElementType().ToString()</codeInline>, where <parameterReference>t</parameterReference> is the type.</para>
            <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
            <para>Generic arguments of generic types are themselves qualified by assembly name. For example, in the assembly-qualified type name for <codeInline>MyGenericClass&lt;int&gt;</codeInline> (<codeInline>MyGenericClass(Of Integer)</codeInline> in Visual Basic), <languageKeyword>int</languageKeyword> is expanded to the assembly-qualified type name for <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a generic parameter, this property returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays the assembly name associated with the class and the fully qualified name of the type.</para>
                <codeReference>type_assembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.FullName</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.Namespace</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.Attributes">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the attributes associated with the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference> object representing the attribute set of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, unless the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type parameter, in which case the value is unspecified. </para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property returns the attributes of the generic type definition. For example, the attributes returned for <codeInline>MyGenericClass&lt;int&gt;</codeInline> (<codeInline>MyGenericClass(Of Integer)</codeInline> in Visual Basic) are the attributes of <codeInline>MyGenericClass&lt;T&gt;</codeInline> (<codeInline>MyGenericClass(Of T)</codeInline> in Visual Basic).</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type parameter — that is, if the <codeEntityReference autoUpgrade="true">P:System.Type.IsGenericParameter</codeEntityReference> property returns <languageKeyword>true</languageKeyword> — the <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference> value returned by this property is unspecified.  </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example shows the use of the <languageKeyword>Type.Attributes</languageKeyword> property.</para>
                <codeReference>Classic Type.Attributes Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetAttributeFlagsImpl</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.BaseType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type from which the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> directly inherits.</para>
        </summary>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> from which the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> directly inherits, or <languageKeyword>null</languageKeyword> if the current <languageKeyword>Type</languageKeyword> represents the <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> class.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The base type is the type from which the current type directly inherits. <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> is the only type that does not have a base type, therefore <languageKeyword>null</languageKeyword> is returned as the base type of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
            <para>Interfaces inherit from <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> and from zero or more base interfaces; therefore, the base type of an interface is considered to be <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>. The base interfaces can be determined with <codeEntityReference autoUpgrade="true">M:System.Type.GetInterfaces</codeEntityReference> or <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, the base type reflects the generic arguments. For example, consider the following declarations: </para>
            <code language="c#">class B&lt;U&gt; { }
class C&lt;T&gt; : B&lt;T&gt; { }</code>
            <code language="vb#">Class B(Of U)
End Class
Class C(Of T)
    Inherits B(Of T)
End Class</code>
            <code language="cpp#">generic&lt;typename U&gt; ref class B { };
generic&lt;typename T&gt; class C : B&lt;T&gt; { };</code>
            <para>For the constructed type <codeInline>C&lt;int&gt;</codeInline> (<codeInline>C(Of Integer)</codeInline> in Visual Basic), the <codeEntityReference autoUpgrade="true">P:System.Type.BaseType</codeEntityReference> property returns <codeInline>B&lt;int&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type definition, <codeEntityReference autoUpgrade="true">P:System.Type.BaseType</codeEntityReference> returns the class constraint, that is, the class the type parameter must inherit. If there is no class constraint, <codeEntityReference autoUpgrade="true">P:System.Type.BaseType</codeEntityReference> returns <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates using the <languageKeyword>BaseType</languageKeyword> property.</para>
                <codeReference>TestBaseType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <link xlink:href="A0C3C0C5-8178-4673-8107-9FDDE780A669">[&lt;topic://conReflectionGenericTypes&gt;]</link>
          <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetInterfaces</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.UnderlyingSystemType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsSubclassOf(System.Type)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.DeclaringType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the class that declares this member.</para>
        </summary>
        <returnValue>
          <para>The <languageKeyword>Type</languageKeyword> object for the class that declares this member. If the type is a nested type, this property returns the enclosing type.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This property implements the abstract property inherited from <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference> and <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</para>
            <list class="bullet">
              <listItem>
                <para>If the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property returns a <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>, that <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> represents a generic method definition, and the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of that generic method definition.</para>
              </listItem>
              <listItem>
                <para>If the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringMethod</codeEntityReference> property returns <languageKeyword>null</languageKeyword>, then the <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference> property always returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a generic type definition, and the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type parameter of that generic type definition.</para>
              </listItem>
            </list>
            <para>For a type parameter of a generic method, this property returns the type that contains the generic method definition.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This example displays the declaring type of a method in a derived class.</para>
                <codeReference>Classic Type.DeclaringType Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.ReflectedType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.DefaultBinder">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <codeEntityReference autoUpgrade="true">M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>A reference to the default binder used by the system.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances. If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class and pass an instance of that type using the <parameterReference>binder</parameterReference> parameter of one of the <codeEntityReference autoUpgrade="true">M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</codeEntityReference> overloads.</para>
            <para>Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>. This is consistent with lookup of members that are protected, private, and so on.</para>
            <para>The general principle is that <codeEntityReference autoUpgrade="true">M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)</codeEntityReference> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</para>
            <para>The following table lists the conversions supported by the default binder.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Source Type </para>
                  </entry>
                  <entry>
                    <para>Target Type </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Any type </para>
                </entry>
                <entry>
                  <para>Its base type. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Any type </para>
                </entry>
                <entry>
                  <para>The interface it implements. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Char </para>
                </entry>
                <entry>
                  <para>Unt16, UInt32, Int32, UInt64, Int64, Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Byte </para>
                </entry>
                <entry>
                  <para>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SByte </para>
                </entry>
                <entry>
                  <para>Int16, Int32, Int64, Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>UInt16 </para>
                </entry>
                <entry>
                  <para>UInt32, Int32, UInt64, Int64, Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Int16 </para>
                </entry>
                <entry>
                  <para>Int32, Int64, Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>UInt32 </para>
                </entry>
                <entry>
                  <para>UInt64, Int64, Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Int32 </para>
                </entry>
                <entry>
                  <para>Int64, Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>UInt64 </para>
                </entry>
                <entry>
                  <para>Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Int64 </para>
                </entry>
                <entry>
                  <para>Single, Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Single </para>
                </entry>
                <entry>
                  <para>Double </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Non-reference </para>
                </entry>
                <entry>
                  <para>By-reference. </para>
                </entry>
              </row>
            </table>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the default binder from the <languageKeyword>DefaultBinder</languageKeyword> property, and invokes a member of MyClass by passing the <languageKeyword>DefaultBinder</languageKeyword> value as a parameter to <codeEntityReference autoUpgrade="true">M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</codeEntityReference>.</para>
                <codeReference>Type_DefaultBinder#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="F:System.Type.Delimiter">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Separates names in the namespace of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. This field is read-only.</para>
        </summary>
      </dduexml>
    </member>
    <member name="F:System.Type.EmptyTypes">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Represents an empty array of type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. This field is read-only.</para>
        </summary>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example shows the <languageKeyword>EmptyTypes</languageKeyword> field used in one of the <languageKeyword>GetConstructor</languageKeyword> methods to get a constructor that takes no parameters.</para>
                <codeReference>Classic Type.EmptyTypes Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.Equals(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines if the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is the same as the underlying system type of the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>o</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> whose underlying system type is to be compared with the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the underlying system type of <parameterReference>o</parameterReference> is the same as the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>. This method also returns <languageKeyword>false</languageKeyword> if the object specified by the <parameterReference>o</parameterReference> parameter is not a <languageKeyword>Type</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method overrides <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.Equals(System.Object)</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example uses <languageKeyword>Equals</languageKeyword> to compare two <languageKeyword>Object</languageKeyword> instances.</para>
                <codeReference>Classic Type.Equals Example#1</codeReference>
                <para>This code produces the following output: </para>
                <para>False </para>
                <para>True </para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.UnderlyingSystemType</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Determines if the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is the same as the underlying system type of the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> or <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.Equals">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines if the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is the same as the underlying system type of the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> or <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.Equals(System.Type)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines if the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is the same as the underlying system type of the specified <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>o</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> whose underlying system type is to be compared with the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the underlying system type of <parameterReference>o</parameterReference> is the same as the underlying system type of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example uses <languageKeyword>Equals</languageKeyword> to compare two types.</para>
                <codeReference>Classic Type.Equals1 Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.UnderlyingSystemType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="F:System.Type.FilterAttribute">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Represents the member filter used on attributes. This field is read-only.</para>
        </summary>
        <remarks>
          <content>
            <para>This field holds a reference to the delegate used by the <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference> method. The method encapsulated by this delegate takes two parameters: the first is a <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> object and the second is an <languageKeyword>Object</languageKeyword>. The method determines whether the <languageKeyword>MemberInfo</languageKeyword> object matches the criteria specified by the <languageKeyword>Object</languageKeyword>. The <languageKeyword>Object</languageKeyword> may be assigned the value of any one of the fields on the classes <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldAttributes</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodAttributes</codeEntityReference>, or <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodImplAttributes</codeEntityReference>.</para>
            <para>For example, the <languageKeyword>Object</languageKeyword> can be assigned the value of a field from <languageKeyword>FieldAttributes</languageKeyword> such as Public. In that case, when the <languageKeyword>FilterAttribute</languageKeyword> delegate is invoked, it will return <languageKeyword>true</languageKeyword> only if the method represented by the <languageKeyword>MemberInfo</languageKeyword> object is decorated with the public field attribute in metadata.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the <languageKeyword>FilterAttribute</languageKeyword> delegate, passes it as a parameter to the <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference> method, and displays the specified members and their attributes.</para>
                <codeReference>Type_FilterAttribute#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberFilter</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="F:System.Type.FilterName">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Represents the case-sensitive member filter used on names. This field is read-only.</para>
        </summary>
        <remarks>
          <content>
            <para>This field holds a reference to the delegate used by the <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference> method. The method encapsulated by this delegate takes two parameters: the first is a <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> object and the second is an <languageKeyword>Object</languageKeyword>. The method determines whether the <languageKeyword>MemberInfo</languageKeyword> object matches the criteria specified by the <languageKeyword>Object</languageKeyword>. The <languageKeyword>Object</languageKeyword> is assigned a string value, which may include a trailing "*" wildcard character. Only wildcard end string matching is supported.</para>
            <para>For example, the <languageKeyword>Object</languageKeyword> may be assigned the value "Byte*". In that case, when the <languageKeyword>FilterName</languageKeyword> delegate is invoked, it will return <languageKeyword>true</languageKeyword> only if the method represented by the <languageKeyword>MemberInfo</languageKeyword> object has a name that begins with "Byte".</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example gets the methods associated with the user-defined <languageKeyword>Application</languageKeyword> type.</para>
                <codeReference>Classic Type.FilterName Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberFilter</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="F:System.Type.FilterNameIgnoreCase">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Represents the case-insensitive member filter used on names. This field is read-only.</para>
        </summary>
        <remarks>
          <content>
            <para>This field holds a reference to the delegate used by the <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference> method. The method encapsulated by this delegate takes two parameters: the first is a <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> object and the second is an <languageKeyword>Object</languageKeyword>. The method determines whether the <languageKeyword>MemberInfo</languageKeyword> object matches the criteria specified by the <languageKeyword>Object</languageKeyword>. The <languageKeyword>Object</languageKeyword> is assigned a string value, which may include a trailing "*" wildcard character. Only wildcard end string matching is supported.</para>
            <para>For example, the <languageKeyword>Object</languageKeyword> may be assigned the value "ByTe*". In that case, when the <languageKeyword>FilterName</languageKeyword> delegate is invoked, it will return true only if the method represented by the <languageKeyword>MemberInfo</languageKeyword> object has a name that begins with "byte", ignoring case.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the <languageKeyword>MemberFilter</languageKeyword> delegate, passes it as a parameter to the <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference> method, and displays the methods and their attributes of the <languageKeyword>String</languageKeyword> class that begin with the letter "c", disregarding the case.</para>
                <codeReference>Type_FilterNameIgnoreCase#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberFilter</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns an array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing a filtered list of interfaces implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>filter</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeFilter</codeEntityReference> delegate that compares the interfaces against <parameterReference>filterCriteria</parameterReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>filterCriteria</parameterReference>
            <content>
              <para>The search criteria that determines whether an interface should be included in the returned array. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing a filtered list of the interfaces implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, or an empty array of type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> if no interfaces matching the filter are implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>filter</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A static initializer is invoked and throws an exception. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <para>The <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.Module.FilterTypeName</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.Module.FilterTypeNameIgnoreCase</codeEntityReference> delegates supplied by the <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Module</codeEntityReference> class may also be used, in lieu of the <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.TypeFilter</codeEntityReference> delegate.</para>
            <para>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</para>
            <para>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints. If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type argument of a generic type, <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference> searches all the interfaces implemented by the type, whether or not they match constraints.</para>
            <alert class="note">
              <para>
                <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference> can return generic interfaces, even on types that are not generic. For example, a nongeneric type might implement <codeInline>IEnumerable&lt;int&gt;</codeInline> (<codeInline>IEnumerable(Of Integer)</codeInline> in Visual Basic).</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</para>
                <codeReference>Type_FindInterfaces#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Module</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeFilter</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetInterface(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetInterfaces</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a filtered array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects of the specified member type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>memberType</parameterReference>
            <content>
              <para>A <languageKeyword>MemberTypes</languageKeyword> object indicating the type of member to search for. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>filter</parameterReference>
            <content>
              <para>The delegate that does the comparisons, returning <languageKeyword>true</languageKeyword> if the member currently being inspected matches the <parameterReference>filterCriteria</parameterReference> and <languageKeyword>false</languageKeyword> otherwise. You can use the <languageKeyword>FilterAttribute</languageKeyword>, <languageKeyword>FilterName</languageKeyword>, and <languageKeyword>FilterNameIgnoreCase</languageKeyword> delegates supplied by this class. The first uses the fields of <languageKeyword>FieldAttributes</languageKeyword>, <languageKeyword>MethodAttributes</languageKeyword>, and <languageKeyword>MethodImplAttributes</languageKeyword> as search criteria, and the other two delegates use <languageKeyword>String</languageKeyword> objects as the search criteria. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>filterCriteria</parameterReference>
            <content>
              <para>The search criteria that determines whether a member is returned in the array of <languageKeyword>MemberInfo</languageKeyword> objects.</para>
              <para>The fields of <languageKeyword>FieldAttributes</languageKeyword>, <languageKeyword>MethodAttributes</languageKeyword>, and <languageKeyword>MethodImplAttributes</languageKeyword> can be used in conjunction with the <languageKeyword>FilterAttribute</languageKeyword> delegate supplied by this class. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A filtered array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects of the specified member type.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not have members of type <parameterReference>memberType</parameterReference> that match the filter criteria.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>filter</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <para>Members include properties, methods, fields, events, and so on. If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which members to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <parameterReference>Instance</parameterReference> to include instance members in the search.</para>
              </listItem>
              <listItem>
                <para>
                  <parameterReference>Static</parameterReference> to include static members in the search.</para>
              </listItem>
              <listItem>
                <para>
                  <parameterReference>Public</parameterReference> to include public members in the search.</para>
              </listItem>
              <listItem>
                <para>
                  <parameterReference>NonPublic</parameterReference> to include non-public members (that is, private and protected members) in the search.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <parameterReference>DeclaredOnly</parameterReference> to search only the members declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not members that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>Valid values for <codeEntityReference autoUpgrade="true">P:System.Type.MemberType</codeEntityReference> are defined in <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>. If no such members are found, an empty array is returned.</para>
            <para>To get the class initializer (.cctor) using this method, you must specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type or generic method, <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference> processes any members declared by the class constraint and the interface constraints of the type parameter.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</para>
                <codeReference>Type_FindMembers#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMember(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetDefaultMembers</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.FullName">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the fully qualified name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, including the namespace of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> but not the assembly.</para>
        </summary>
        <returnValue>
          <para>A string containing the fully qualified name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, including the namespace of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> but not the assembly, or <languageKeyword>null</languageKeyword> if the current instance represents a generic type parameter.</para>
        </returnValue>
        <remarks>
          <content>
            <para>For example, the fully qualified name of the C# string type is <codeInline>System.String</codeInline>. Contrast this with the assembly-qualified name, which is the full name plus the assembly, provided by the <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference> property.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, the type arguments in the string returned by <codeEntityReference autoUpgrade="true">P:System.Type.FullName</codeEntityReference> are qualified by their assembly, version, and so on, even though the string representation of the generic type itself is not qualified by assembly. Thus, concatenating <codeInline>t.FullName + ", " + t.Assembly.FullName</codeInline> produces a result that is equivalent to <codeInline>t.AssemblyQualifiedName</codeInline>, as is the case with types that are not generic. </para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property returns <languageKeyword>null</languageKeyword>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays the full name of the specified type.</para>
                <codeReference>TestFullName#1</codeReference>
                <para>This code produces the following output: </para>
                <code>The full name of the Array type is System.Array</code>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.Namespace</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetArrayRank">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the number of dimensions in an <codeEntityReference autoUpgrade="true">T:System.Array</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference> containing the number of dimensions in the current <languageKeyword>Type</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The current <languageKeyword>Type</languageKeyword> is not an array. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays the number of dimensions in an array.</para>
                <codeReference>Type_GetArrayRank#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Array</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Array.Rank</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetAttributeFlagsImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, implements the <codeEntityReference autoUpgrade="true">P:System.Type.Attributes</codeEntityReference> property and gets a bitmask indicating the attributes associated with the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference> object representing the attribute set of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.Attributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>callConvention</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the constructor to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> object representing the constructor that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>If an exact match does not exist, the <parameterReference>binder</parameterReference> will attempt to coerce the parameter types specified in the <parameterReference>types</parameterReference> array in order to select a match. If the <parameterReference>binder</parameterReference> is unable to select a match, then <languageKeyword>null</languageKeyword> is returned.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which constructors to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public constructors in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public constructors (that is, private and protected constructors) in the search.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>To get the class initializer (.cctor) using this method, you must specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the requested constructor is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public methods outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments. If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method always returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example obtains the type of <languageKeyword>MyClass1</languageKeyword>, gets the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> object that matches the specified binding flags, and displays the constructor signature.</para>
                <codeReference>Type_GetConstructor3#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public methods. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a specific constructor of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetConstructor">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a specific constructor of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the constructor to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</para>
              <para>-or- </para>
              <para>
                <codeEntityReference autoUpgrade="true">F:System.Type.EmptyTypes</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> object representing the constructor that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>If an exact match does not exist, the <parameterReference>binder</parameterReference> will attempt to coerce the parameter types specified in the <parameterReference>types</parameterReference> array in order to select a match. If the <parameterReference>binder</parameterReference> is unable to select a match, then <languageKeyword>null</languageKeyword> is returned.</para>
            <para>If the requested constructor is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public methods outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which constructors to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public constructors in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public constructors (that is, private and protected constructors) in the search.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>To get the class initializer (.cctor) using this method overload, you must specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments. If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method always returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following program obtains the type of <languageKeyword>MyClass1</languageKeyword> class, gets the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> object matching the specified binding flags, and displays the signature of the constructor.</para>
                <codeReference>Type_GetConstructor2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public methods. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetConstructor(System.Type[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for a public instance constructor whose parameters match the types in the specified array.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the desired constructor.</para>
              <para>-or- </para>
              <para>An empty array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects, to get a constructor that takes no parameters. Such an empty array is provided by the <languageKeyword>static</languageKeyword> field <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Type.EmptyTypes</codeEntityReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor). To get a class initializer, use an overload that takes <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>, and specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the requested constructor is non-public, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments. If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method always returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example obtains the type of <languageKeyword>MyClass</languageKeyword>, gets the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> object, and displays the constructor signature.</para>
                <codeReference>Type_GetConstructor#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>callConvention</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the constructor to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> object representing the constructor that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</para>
            <para>If an exact match does not exist, the <parameterReference>binder</parameterReference> will attempt to coerce the parameter types specified in the <parameterReference>types</parameterReference> array in order to select a match. If the <parameterReference>binder</parameterReference> is unable to select a match, then <languageKeyword>null</languageKeyword> is returned.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which constructors to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public constructors in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public constructors (that is, private and protected constructors) in the search.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>This method implements <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>
              <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference> cannot be used to obtain a class initializer. Class initializers are available only through <codeEntityReference autoUpgrade="true">M:System.Type.GetMember(System.String)</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.GetMembers</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>, and <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetConstructors">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns all the public constructors defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> objects representing all the public instance constructors defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, or if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, an empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> is returned.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>This method overload calls the <codeEntityReference autoUpgrade="false">M:System.Type.GetConstructors(System.Reflection.BindingFlags)</codeEntityReference> method overload, with <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>, and specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments. For example, if class <codeInline>C&lt;T&gt;</codeInline> has a constructor <codeInline>C(T t1)</codeInline> (<codeInline>Sub New(ByVal t1 As T)</codeInline> in Visual Basic), calling <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference> on <codeInline>C&lt;int&gt; </codeInline>returns a <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> that represents <codeInline>C(int t1)</codeInline> in C# (<codeInline>Sub New(ByVal t1 As Integer)</codeInline> in Visual Basic).</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type parameter, the <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference> method returns an empty array.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This example shows the output of the <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference> overload from a class that has two instance constructors and one static constructor.</para>
                <codeReference>Classic Type.GetConstructors Example#1</codeReference>
                <para>The output of this code is: </para>
                <para>2 </para>
                <para>False </para>
                <para>False </para>
                <para>Because the <codeEntityReference autoUpgrade="false">M:System.Type.GetConstructors</codeEntityReference> overload uses only <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference>, the static constructor is neither counted by the <languageKeyword>for</languageKeyword> expression nor evaluated by <languageKeyword>IsStatic</languageKeyword>.</para>
                <para>To find static constructors, use the <codeEntityReference autoUpgrade="false">M:System.Type.GetConstructors(System.Reflection.BindingFlags)</codeEntityReference> overload, and pass the combination (logical <languageKeyword>OR</languageKeyword>) of <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference>, as shown in the following code example: </para>
                <codeReference>Classic Type.GetConstructors Example#2</codeReference>
                <para>Now the output is: </para>
                <para>3 </para>
                <para>False </para>
                <para>True </para>
                <para>False </para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the constructors of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetConstructors">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the constructors of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the constructors defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, using the specified <languageKeyword>BindingFlags</languageKeyword>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> objects representing all constructors defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> if no constructors are defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if none of the defined constructors match the binding constraints, or if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method.</para>
        </returnValue>
        <remarks>
          <content>
            <para>
              <parameterReference>bindingAttr</parameterReference> can be used to specify whether to return only public constructors or both public and non-public constructors.</para>
            <para>If an exact match does not exist, the <parameterReference>binder</parameterReference> will attempt to coerce the parameter types specified in the <parameterReference>types</parameterReference> array in order to select a match. If the <parameterReference>binder</parameterReference> is unable to select a match, then <languageKeyword>null</languageKeyword> is returned.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which constructors to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public constructors in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public constructors (that is, private and protected constructors) in the search.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>To get the class initializer (.cctor) using this method overload, you must specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments. For example, if class <codeInline>C&lt;T&gt; </codeInline>has a constructor <codeInline>C(T t1)</codeInline> (<codeInline>Sub New(ByVal t1 As T)</codeInline> in Visual Basic), calling <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference> on <codeInline>C&lt;int&gt;</codeInline> returns a <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> that represents <codeInline>C(int t1)</codeInline> in C# (<codeInline>Sub New(ByVal t1 As Integer)</codeInline> in Visual Basic).</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type parameter, the <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference> method returns an empty array.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This example shows the output of the <codeEntityReference autoUpgrade="false">M:System.Type.GetConstructors</codeEntityReference> overload from a class that has two instance constructors and one static constructor.</para>
                <codeReference>Classic Type.GetConstructors Example#1</codeReference>
                <para>The output of this code is: </para>
                <para>2 </para>
                <para>False </para>
                <para>False </para>
                <para>Because the <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors</codeEntityReference> overload uses only <codeEntityReference autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference> and <codeEntityReference autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference>, the static constructor is neither counted by the <languageKeyword>for</languageKeyword> expression nor evaluated by <languageKeyword>IsStatic</languageKeyword>.</para>
                <para>To find static constructors, use the <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructors(System.Reflection.BindingFlags)</codeEntityReference> overload, and pass it the combination (logical OR) of <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference>, as shown in the following code example:</para>
                <codeReference>Classic Type.GetConstructors Example#2</codeReference>
                <para>Now the output is: </para>
                <para>3 </para>
                <para>False </para>
                <para>True </para>
                <para>False </para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting nonpublic objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetDefaultMembers">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the members defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> whose <codeEntityReference autoUpgrade="true">T:System.Reflection.DefaultMemberAttribute</codeEntityReference> is set.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects representing all default members of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not have default members.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <para>Members include properties, methods, fields, events, and so on.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments. For example, if class<codeInline> C&lt;T&gt;</codeInline> has a property <codeInline>P</codeInline> that returns <codeInline>T</codeInline>, calling <codeEntityReference autoUpgrade="true">M:System.Type.GetDefaultMembers</codeEntityReference> on <codeInline>C&lt;int&gt;</codeInline> returns <codeInline>int P</codeInline> in C# (<codeInline>Property P As Integer</codeInline> in Visual Basic).</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example obtains the default member information of <languageKeyword>MyClass</languageKeyword> and displays the default members.</para>
                <codeReference>Type_GetDefaultMembers#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.DefaultMemberAttribute</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMember(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetElementType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, returns the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> of the object encompassed or referred to by the current array, pointer or reference type.</para>
        </summary>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> of the object encompassed or referred to by the current array, pointer, or reference type, or <languageKeyword>null</languageKeyword> if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method returns <languageKeyword>null</languageKeyword> for the <codeEntityReference autoUpgrade="true">T:System.Array</codeEntityReference> class.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates using the <languageKeyword>GetElementType</languageKeyword> method.</para>
                <codeReference>TestGetElementType#1</codeReference>
                <para>This code produces the following output: </para>
                <code>System.Int32[] element type is System.Int32
    TestGetElementType element type is null</code>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.HasElementType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetEvent(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> object representing the specified public event.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of an event which is declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> object representing the specified public event which is declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance events.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> object and gets the event for a button class for the specified event.</para>
                <codeReference>Type_GetEvent#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetEvents</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a specific event declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetEvent">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a specific event declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> object representing the specified event, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of an event which is declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> object representing the specified event which is declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which events to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public events in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public events (that is, private and protected events) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the events declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not events that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetEvent1#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetEvents</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetEvents">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns all the public events that are declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> objects representing all the public events which are declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference>, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not have public events.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example obtains an array of <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> objects, gets all the events for a <languageKeyword>Button</languageKeyword> class, and displays the event names. To compile the Visual Basic example, use the following command line: </para>
                <para>
                  <languageKeyword>vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll</languageKeyword>
                </para>
                <codeReference>Type_GetEvents1#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetEvent(System.String)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the events that are declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetEvents">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the events that are declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for events that are declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> objects representing all events which are declared or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference>, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not have events, or if none of the events match the binding constraints.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which events to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public events in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public events (that is, private and protected events) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the events declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not events that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example obtains an array of <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference> objects that match the specified binding flags, gets all the events for a <languageKeyword>Button</languageKeyword> class, and displays the event names. To compile the Visual Basic example, use the following command line: </para>
                <para>
                  <languageKeyword>vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll</languageKeyword>
                </para>
                <codeReference>Type_GetEvents2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.EventInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetEvent(System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetField(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the public field with the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the data field to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> object representing the public field with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance fields.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the <languageKeyword>Type</languageKeyword> object for the specified class, obtains the <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> object for the field, and displays the value of the field.</para>
                <codeReference>Type_GetField#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetFields</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a specific field of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified field, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the data field to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> object representing the field that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which fields to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public fields in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public fields (that is, private and protected fields) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the fields declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not fields that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the <languageKeyword>Type</languageKeyword> object for the specified class, obtains the <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> object for the field that matches the specified binding flags, and displays the value of the field.</para>
                <codeReference>Type_GetField#2</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetFields</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.Type.GetField">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a specific field of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetFields">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns all the public fields of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> objects representing all the public fields defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference>, if no public fields are defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.GetFields</codeEntityReference> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order can vary.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example shows a use of the <languageKeyword>GetFields()</languageKeyword> method.</para>
                <codeReference>FieldInfo_IsSpecialName#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetField(System.String,System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the fields of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetFields">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the fields of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetFields(System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the fields defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> objects representing all fields defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference>, if no fields are defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, or if none of the defined fields match the binding constraints.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.GetFields</codeEntityReference> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order can vary.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which fields to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public fields in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public fields (that is, private and protected fields) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the fields declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not fields that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example shows a use of the <languageKeyword>GetFields(BindingFlags)</languageKeyword> method.</para>
                <codeReference>Classic MethodBase.Attributes Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.FieldInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetField(System.String,System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetHashCode">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the hash code for this instance.</para>
        </summary>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference> containing the hash code for this instance.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method overrides <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Object.GetHashCode</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays the hash code of the <languageKeyword>System.Windows.Forms.Button</languageKeyword> class.</para>
                <codeReference>Type_GetHashCode_GetFields#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.GetInterface(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the interface with the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the interface to get. For generic interfaces, this is the mangled name.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing the interface with the specified name, implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type that implements the same generic interface with different type arguments. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
            <alert class="note">
              <para>For generic interfaces, the <parameterReference>name</parameterReference> parameter is the mangled name, ending with a grave accent (`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find <codeInline>IExample&lt;T&gt;</codeInline> (<codeInline>IExample(Of T)</codeInline> in Visual Basic) or <codeInline>IExample&lt;string&gt;</codeInline> (<codeInline>IExample(Of String)</codeInline> in Visual Basic), search for <codeInline>"IExample`1"</codeInline>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetInterface#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetInterfaces</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a specific interface implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetInterface">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a specific interface implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetInterface(System.String,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-sensitive search.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the interface to get. For generic interfaces, this is the mangled name.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ignoreCase</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to perform a case-insensitive search for <parameterReference>name</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>false</languageKeyword> to perform a case-sensitive search for <parameterReference>name</parameterReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing the interface with the specified name, implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type that implements the same generic interface with different type arguments. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
            <alert class="note">
              <para>For generic interfaces, the <parameterReference>name</parameterReference> parameter is the mangled name, ending with a grave accent (`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find <codeInline>IExample&lt;T&gt;</codeInline> (<codeInline>IExample(Of T)</codeInline> in Visual Basic) or <codeInline>IExample&lt;string&gt;</codeInline> (<codeInline>IExample(Of String)</codeInline> in Visual Basic), search for <codeInline>"IExample`1"</codeInline>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetInterface#2</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetInterfaces</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetInterfaceMap(System.Type)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns an interface mapping for the specified interface type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>interfaceType</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> of the interface of which to retrieve a mapping. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Reflection.InterfaceMapping</codeEntityReference> object representing the interface mapping for <parameterReference>interfaceType</parameterReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <parameterReference>interfaceType</parameterReference> parameter does not refer to an interface. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>interfaceType</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <codeEntityReference autoUpgrade="true">T:System.Reflection.InterfaceMapping</codeEntityReference> returned by this method.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.InterfaceMapping</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetInterfaces">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing all the interfaces implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if no interfaces are implemented or inherited by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A static initializer is invoked and throws an exception. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits. To compile the Visual Basic example, use the following compiler commands: </para>
                <para>
                  <languageKeyword>vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll</languageKeyword>
                </para>
                <codeReference>Type_GetInterfaces1#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetInterface(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMember(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the public members with the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public members to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects representing the public members with the specified name, if found; otherwise, an empty array.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance members.</para>
            <para>Members include properties, methods, fields, events, and so on.</para>
            <para>This method searches the current type and its base types. Only public methods can be found using this method. If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>This method overload will not find class initializers (.cctor). To find class initializers, use an overload that takes <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>, and specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays all the members of the <languageKeyword>String</languageKeyword> class that start with the letter C.</para>
                <codeReference>Type_GetMember#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetDefaultMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the specified members of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetMember">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the specified members of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified members, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the members to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return an empty array. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects representing the public members with the specified name, if found; otherwise, an empty array.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <para>Members include properties, methods, fields, events, and so on.</para>
            <para>This method searches the current classes and its base classes. If the requested member is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns an empty array.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which members to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public members in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public members (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the members declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not members that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <parameterReference>name</parameterReference>, and <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic) for <parameterReference>bindingAttr</parameterReference>. You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays all the public static members of the <languageKeyword>myString</languageKeyword> class that start with the letter C.</para>
                <codeReference>Type_GetMember#2</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetDefaultMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified members of the specified member type, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the members to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>type</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberTypes</codeEntityReference> value to search for. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return an empty array. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects representing the public members with the specified name, if found; otherwise, an empty array.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>A derived class must provide an implementation. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Members include properties, methods, fields, events, and so on. </para>
            <para>This method searches the current classes and its base classes. If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns an empty array.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which members to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public members in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public members (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the members declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not members that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <parameterReference>name</parameterReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.MemberTypes.Constructor</codeEntityReference> for <parameterReference>type</parameterReference>, and  <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic) for <parameterReference>bindingAttr</parameterReference>. You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays all the methods of the <languageKeyword>myString</languageKeyword> class that start with the letter C.</para>
                <codeReference>Type_GetMember#3</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetDefaultMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMembers">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns all the public members of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects representing all the public members of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not have public members.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Members include properties, methods, fields, events, and so on.</para>
            <para>This method overload calls the <codeEntityReference autoUpgrade="false">M:System.Type.GetMembers(System.Reflection.BindingFlags)</codeEntityReference> method overload, with <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference>  | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Instance</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>, and specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetMembers1#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMember(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetDefaultMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the members (properties, methods, fields, events, and so on) of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetMembers">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the members (properties, methods, fields, events, and so on) of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the members defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects representing all members defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>, if no members are defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, or if none of the defined members match the binding constraints.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Members include properties, methods, fields, events, and so on.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which members to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public members in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public members (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the members declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not members that were simply inherited.</para>
              </listItem>
            </list>
            <para>Calling this method with only the <languageKeyword>Public</languageKeyword> flag or only the <languageKeyword>NonPublic</languageKeyword> flag will return the specified members and does not require any other flags.</para>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>To get the class initializer (.cctor) using this method overload, you must specify <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference> | <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> (<codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Static</codeEntityReference><languageKeyword>Or</languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> in Visual Basic). You can also get the class initializer using the <codeEntityReference autoUpgrade="true">P:System.Type.TypeInitializer</codeEntityReference> property.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetMembers2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMember(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetDefaultMembers</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethod(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the public method with the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public method to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object representing the public method with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method is found with the specified name. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance methods.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the parameters of <languageKeyword>MyFunction</languageKeyword> in <languageKeyword>MyClass</languageKeyword> and displays their position and data type.</para>
                <codeReference>Type_GetMethod1#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethods</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a specific method of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified method, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the method to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object representing the method that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method is found with the specified name and matching the specified binding constraints. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which methods to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public methods in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public methods (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the methods declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not methods that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the method that matches the specified binding flags and displays its signature.</para>
                <codeReference>Type_GetMethod2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethods</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the method to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>callConvention</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the method to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a method that takes no parameters. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object representing the method that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method is found with the specified name and matching the specified binding constraints. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>GetXXX</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which methods to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public methods in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include nonpublic methods (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the methods declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not methods that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is nonpublic and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect nonpublic objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example displays information about a method named <languageKeyword>MyFunc</languageKeyword> in the class <languageKeyword>MyClass</languageKeyword>.</para>
                <codeReference>Type_GetMethod3#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethods</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.Type.GetMethod">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a specific method of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the method to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the method to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a method that takes no parameters. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object representing the method that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method is found with the specified name and matching the specified binding constraints. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which methods to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public methods in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include nonpublic methods (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the methods declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not methods that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets method information and displays the signature and declaring type.</para>
                <codeReference>Type_GetMethod#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethods</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethod(System.String,System.Type[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified public method whose parameters match the specified argument types.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public method to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the method to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a method that takes no parameters. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object representing the public method whose parameters match the specified argument types, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method is found with the specified name and specified parameters. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance methods.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>The <parameterReference>name</parameterReference> parameter cannot include type arguments. For example, the C# code <codeInline>GetMethod("MyGenericMethod&lt;int&gt;")</codeInline> searches for a method with the text name "<codeInline>MyGenericMethod&lt;int&gt;"</codeInline>, rather than for a method named <codeInline>MyGenericMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example contains a class with an overloaded method. It obtains a <languageKeyword>Type</languageKeyword> object corresponding to <languageKeyword>MyClass1</languageKeyword> and calls <languageKeyword>GetMethod</languageKeyword>. The method whose parameters match the arguments specified in the type array is returned by the method call.</para>
                <codeReference>Type_GetMethod4#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethods</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified public method whose parameters match the specified argument types and modifiers.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public method to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the method to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a method that takes no parameters. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object representing the public method that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method is found with the specified name and specified parameters. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</para>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance methods.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
            <alert class="note">
              <para>For generic methods, do not include the type arguments in <parameterReference>name</parameterReference>. For example, the C# code <codeInline>GetMember("MyMethod&lt;int&gt;")</codeInline> searches for a member with the text name "<codeInline>MyMethod&lt;int&gt;</codeInline>", rather than for a method named <codeInline>MyMethod</codeInline> that has one generic argument of type <languageKeyword>int</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethods</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the method to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>callConvention</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the method to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>. If <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>, arguments are not matched. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> object representing the method that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method is found with the specified name and matching the specified binding constraints. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>If <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>, arguments are not matched.</para>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which methods to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public methods in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public methods (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the methods declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not methods that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.CallingConventions</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethods</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethods">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns all the public methods of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> objects representing all the public methods defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>, if no public methods are defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Constructors are not included in the array of methods returned by this call. Make a separate call to <languageKeyword>GetConstructors()</languageKeyword> to get the constructor methods.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the methods of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetMethods">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the methods of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the methods defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> objects representing all methods defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>, if no methods are defined for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, or if none of the defined methods match the binding constraints.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which methods to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public methods in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public methods (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the methods declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not methods that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <alert class="note">
              <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
            </alert>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> if there is no class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates a class with two public methods and one protected method, creates a <languageKeyword>Type</languageKeyword> object corresponding to <languageKeyword>MyTypeClass</languageKeyword>, gets all public and non-public methods, and displays their names.</para>
                <codeReference>Type_GetMethods2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MethodInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.Type.GetNestedType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a specific type nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetNestedType(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the public nested type with the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The string containing the name of the nested type to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing the public nested type with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive.</para>
            <para>Use the simple name of the nested class for <parameterReference>name</parameterReference>. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments. For example, use the string "Inner`1" to get the generic nested class <codeInline>Inner&lt;T&gt;</codeInline> (<codeInline>Inner(Of T)</codeInline> in Visual Basic). Do not include language-specific syntax for type parameters.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
            <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
            <alert class="note">
              <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <link xlink:href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</link>. </para>
            </alert>
            <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting methods that are not public. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetNestedTypes</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a specific type nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The string containing the name of the nested type to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing the nested type that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Use the simple name of the nested class for <parameterReference>name</parameterReference>. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters. For example, use the string "Inner`1" to get the generic nested class <codeInline>Inner&lt;T&gt;</codeInline> (<codeInline>Inner(Of T)</codeInline> in Visual Basic). Do not include language-specific syntax for type parameters.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which nested types to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Public</languageKeyword> or <languageKeyword>BindingFlags.NonPublic</languageKeyword> to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public nested types in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public nested types (that is, private and protected members) in the search.</para>
              </listItem>
            </list>
            <para>This method returns only the nested types of the current type. It does not search the hierarchy of inherited types. To find types that are nested in inherited types, you must walk the inheritance hierarchy.</para>
            <para>
              <languageKeyword>BindingFlags.Instance</languageKeyword> and <languageKeyword>BindingFlags.Static</languageKeyword> are ignored. </para>
            <para>Calling this method with only the <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference> flag or only the <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> flag will return the specified nested types and does not require any other flags.</para>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
            <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
            <alert class="note">
              <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <link xlink:href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</link>. </para>
            </alert>
            <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting methods that are not public. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetNestedTypes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetNestedTypes">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns all the public types nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing all the public types nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if no public types are nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
            <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
            <alert class="note">
              <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <link xlink:href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</link>. </para>
            </alert>
            <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example defines a nested class and a <codeInline>struct</codeInline> in <languageKeyword>MyClass</languageKeyword>, and then obtains objects of the nested types using the type of <languageKeyword>MyClass</languageKeyword>.</para>
                <codeReference>Type_GetNestedTypes#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetNestedType(System.String)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the types nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetNestedTypes">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the types nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the types nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing all the types nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, if no types are nested within the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, or if none of the nested types match the binding constraints.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which nested types to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Public</languageKeyword> or <languageKeyword>BindingFlags.NonPublic</languageKeyword> to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public nested types in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public nested types (that is, private and protected members) in the search.</para>
              </listItem>
            </list>
            <para>This method returns only the nested types of the current type. It does not search the hierarchy of inherited types. To find types that are nested in inherited types, you must walk the inheritance hierarchy.</para>
            <para>
              <languageKeyword>BindingFlags.Instance</languageKeyword> and <languageKeyword>BindingFlags.Static</languageKeyword> are ignored. </para>
            <para>Calling this method with only the <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.Public</codeEntityReference> flag or only the <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.NonPublic</codeEntityReference> flag will return the specified nested types and does not require any other flags.</para>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
            <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
            <alert class="note">
              <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <link xlink:href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</link>. </para>
            </alert>
            <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <codeEntityReference autoUpgrade="true">M:System.Type.MakeGenericType(System.Type[])</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</para>
                <codeReference>Type_GetNestedClassesAbs#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting methods that are not public. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetNestedType(System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetProperties">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns all the public properties of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> objects representing all public properties of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not have public properties.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates the use of the <languageKeyword>GetProperties</languageKeyword> method.</para>
                <codeReference>Type_GetTypeCode#2</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the properties of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the properties of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> objects representing all properties of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> does not have properties, or if none of the properties match the binding constraints.</para>
        </returnValue>
        <remarks>
          <content>
            <para>A property is considered public to reflection if it has at least one accessor that is public. That is, you can call type.GetProperty("propertyname", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static) to get it.</para>
            <para>Otherwise, the property is private and you must use type.GetProperty("propertyname", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static) to get it.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which nested types to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public properties in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public properties (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the properties declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not properties that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> objects with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates two public properties and one protected property and displays information for the properties that match the specified binding constraints.</para>
                <codeReference>Type_GetProperties2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.Type.GetProperties">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the properties of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetProperty(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the public property with the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public property to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the public property with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance properties.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the <languageKeyword>Type</languageKeyword> object of a user-defined class, retrieves a property of that class, and displays the property name.</para>
                <codeReference>Type_GetProperty1#1</codeReference>
                <para>Internally, this property is referred to in the metadata by the name "Item." Any attempt to get <languageKeyword>PropertyInfo</languageKeyword> using reflection must specify this internal name in order to correctly return the <languageKeyword>PropertyInfo</languageKeyword> property.</para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a specific property of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified property, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the property to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the property that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name and matching the specified binding constraints. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which properties to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public properties in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public properties (that is, private and protected properties) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the properties declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not properties that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</para>
                <codeReference>Type_GetProperty2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the property to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>returnType</parameterReference>
            <content>
              <para>The return type of the property. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the property that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name and matching the specified binding constraints. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which properties to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public properties in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public properties (that is, private and protected properties) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the properties declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not properties that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.Type.GetProperty">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a specific property of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetProperty(System.String,System.Type)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the public property with the specified name and return type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public property to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>returnType</parameterReference>
            <content>
              <para>The return type of the property. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the public property with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance properties.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example defines a class with one property and retrieves the name and type of the property.</para>
                <codeReference>Type_GetProperty_Types#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified public property whose parameters match the specified argument types.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public property to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>returnType</parameterReference>
            <content>
              <para>The return type of the property. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the public property whose parameters match the specified argument types, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name and matching the specified argument types. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance properties.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified public property whose parameters match the specified argument types and modifiers.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public property to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>returnType</parameterReference>
            <content>
              <para>The return type of the property. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the public property that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name and matching the specified argument types and modifiers. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance properties.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example obtains a <languageKeyword>Type</languageKeyword> object corresponding to <languageKeyword>MyPropertyClass</languageKeyword>, and the indexed property of this class is retrieved using the arguments passed to the <languageKeyword>GetProperty</languageKeyword> method.</para>
                <codeReference>Type_GetProperty5#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetProperty(System.String,System.Type[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Searches for the specified public property whose parameters match the specified argument types.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the public property to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the public property whose parameters match the specified argument types, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name and matching the specified argument types. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The search for <parameterReference>name</parameterReference> is case-sensitive. The search includes public static and public instance properties.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>If the current T:System.Type represents a constructed generic type, this method returns the <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> with the type parameters replaced by the appropriate type arguments.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the <languageKeyword>Type</languageKeyword> object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to <languageKeyword>GetProperty</languageKeyword>.</para>
                <codeReference>Type_GetProperty3#1</codeReference>
                <para>Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <languageKeyword>PropertyInfo</languageKeyword> using reflection must specify this internal name in order for the <languageKeyword>PropertyInfo</languageKeyword> to be returned correctly.</para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the property to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted.</para>
              <para>-or- </para>
              <para>Zero, to return <languageKeyword>null</languageKeyword>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>returnType</parameterReference>
            <content>
              <para>The return type of the property. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>types</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
              <para>-or- </para>
              <para>An empty array of the type <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>types</parameterReference> array. The default binder does not process this parameter. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference> object representing the property that matches the specified requirements, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one property is found with the specified name and matching the specified binding constraints. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the elements in <parameterReference>types</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>types</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>types</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> (the <parameterReference>modifiers</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The <parameterReference>types</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>types</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and are used for interoperability.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which properties to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public properties in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public properties (that is, private and protected properties) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include <languageKeyword>public</languageKeyword> and <languageKeyword>protected</languageKeyword> static members up the hierarchy; <languageKeyword>private</languageKeyword> static members in inherited classes are not included.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the properties declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not properties that were simply inherited.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.PropertyInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetProperties(System.Reflection.BindingFlags)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A class initializer is invoked and throws an exception. </para>
            </content>
          </exception>
        </exceptions>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents the specified type.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents the specified type.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetType(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, performing a case-sensitive search.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The name of the <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference> to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A class initializer is invoked and throws an exception. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is invalid, for example if it contains invalid characters, or if it is a zero-length string. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> represents an array of <codeEntityReference autoUpgrade="true">T:System.TypedReference</codeEntityReference>. This is a change from the behavior in the .NET Framework versions 1.0 and 1.1, which was to return a null reference.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>
              <languageKeyword>GetType</languageKeyword> only works on assemblies loaded from disk. If you call <languageKeyword>GetType</languageKeyword> to look up a type defined in a dynamic assembly defined using the <codeEntityReference autoUpgrade="true">N:System.Reflection.Emit</codeEntityReference> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <languageKeyword>RunAndSave</languageKeyword> or <languageKeyword>Save</languageKeyword> access modes of the <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Emit.AssemblyBuilderAccess</codeEntityReference> enumeration. If the dynamic assembly is persistent and has been written to disk before <languageKeyword>GetType</languageKeyword> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <languageKeyword>GetType</languageKeyword> is called, the method returns <languageKeyword>null</languageKeyword>. <languageKeyword>GetType</languageKeyword> does not understand transient dynamic assemblies; therefore, calling <languageKeyword>GetType</languageKeyword> to retrieve a type in a transient dynamic assembly returns <languageKeyword>null</languageKeyword>.</para>
            <para>To use <languageKeyword>GetType</languageKeyword> on a dynamic module, subscribe to the <codeEntityReference qualifyHint="true" autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event and call <languageKeyword>GetType</languageKeyword> before saving. Otherwise, you will get two copies of the assembly in memory.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</para>
            <para>
              <parameterReference>typeName</parameterReference> can be a simple type name, a type name that includes a namespace, or a complex name that includes an assembly name specification.</para>
            <para>If <parameterReference>typeName</parameterReference> includes only the name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, this method searches in the calling object's assembly, then in the mscorlib.dll assembly. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</para>
            <para>
              <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference> can return a fully qualified type name including nested types, the assembly name, and generic type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Delimiter </para>
                  </entry>
                  <entry>
                    <para>Meaning </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Backslash (\) </para>
                </entry>
                <entry>
                  <para>Escape character. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Comma (,) </para>
                </entry>
                <entry>
                  <para>Precedes the Assembly name. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Plus sign (+) </para>
                </entry>
                <entry>
                  <para>Precedes a nested class. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Period (.) </para>
                </entry>
                <entry>
                  <para>Denotes namespace identifiers. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Brackets ([]) </para>
                </entry>
                <entry>
                  <para>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type. </para>
                </entry>
              </row>
            </table>
            <para>For example, the fully qualified name for a class might look like this: </para>
            <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</code>
            <para>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </para>
            <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</code>
            <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
            <para>This qualified name can be persisted and later used to load the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. To search for and load a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, use <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> either with the type name only or with the assembly qualified type name. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the type name only will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in the caller's assembly and then in the System assembly. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the assembly qualified type name will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in any assembly.</para>
            <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <codeInline>t.GetElementType().ToString()</codeInline>, where <parameterReference>t</parameterReference> is the type.</para>
            <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
            <para>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> has two type parameters. A <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>MyType</codeInline> with keys of type <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> might be represented as follows: </para>
            <code>System.Collections.Generic.Dictionary`2[System.String,MyType]</code>
            <para>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>MyType</codeInline> from<codeInline></codeInline>MyAssembly.dll, with keys of type <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>, might be specified as follows: </para>
            <code>Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")</code>
            <alert class="note">
              <para>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</para>
            </alert>
            <para>The following table shows the syntax you use with <languageKeyword>GetType</languageKeyword> for various types.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>To Get </para>
                  </entry>
                  <entry>
                    <para>Use </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>An unmanaged pointer to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType*")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An unmanaged pointer to a pointer to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType**")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A managed pointer or reference to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType&amp;")</codeInline>. Note that unlike pointers, references are limited to one level. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A parent class and a nested class </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyParentClass+MyNestedClass")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A one-dimensional array with a lower bound of 0 </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType[]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A one-dimensional array with an unknown lower bound </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType[*]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An n-dimensional array </para>
                </entry>
                <entry>
                  <para>A comma (,) inside the brackets a total of n-1 times. For example, <codeInline>System.Object[,,]</codeInline> represents a three-dimensional <languageKeyword>Object</languageKeyword> array. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An array of one-dimensional arrays </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType[][]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A rectangular two-dimensional array with unknown lower bounds </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType[*,*]")</codeInline> or <codeInline>Type.GetType("MyType[,]")</codeInline></para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with one type argument </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[MyType]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with two type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`2[MyType,AnotherType]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with two assembly-qualified type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An assembly-qualified generic type with an assembly-qualified type argument </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type whose type argument is a generic type with two type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")</codeInline>
                  </para>
                </entry>
              </row>
            </table>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the type of <languageKeyword>System.Int32</languageKeyword> and uses that type object to display the <codeEntityReference autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property of <languageKeyword>System.Int32</languageKeyword>.</para>
                <codeReference>Type_GetType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetAssembly(System.Type)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetType(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetType(System.String,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The name of the <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference> to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>throwOnError</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to throw an exception if the type cannot be found; <languageKeyword>false</languageKeyword> to return <languageKeyword>null</languageKeyword>.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A class initializer is invoked and throws an exception. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>throwOnError</parameterReference> is <languageKeyword>true</languageKeyword> and the type is not found. </para>
              <para>-or-</para>
              <para>
                <parameterReference>typeName</parameterReference> represents an array of <codeEntityReference autoUpgrade="true">T:System.TypedReference</codeEntityReference>. This is a change from the behavior in the .NET Framework versions 1.0 and 1.1, which was to return a null reference.</para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is invalid, for example if it contains invalid characters, or if it is a zero-length string. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>
              <languageKeyword>GetType</languageKeyword> only works on assemblies loaded from disk. If you call <languageKeyword>GetType</languageKeyword> to look up a type defined in a dynamic assembly defined using the <codeEntityReference autoUpgrade="true">N:System.Reflection.Emit</codeEntityReference> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <languageKeyword>RunAndSave</languageKeyword> or <languageKeyword>Save</languageKeyword> access modes of the <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Emit.AssemblyBuilderAccess</codeEntityReference> enumeration. If the dynamic assembly is persistent and has been written to disk before <languageKeyword>GetType</languageKeyword> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <languageKeyword>GetType</languageKeyword> is called, the method returns <languageKeyword>null</languageKeyword>. <languageKeyword>GetType</languageKeyword> does not understand transient dynamic assemblies; therefore, calling <languageKeyword>GetType</languageKeyword> to retrieve a type in a transient dynamic assembly returns <languageKeyword>null</languageKeyword>.</para>
            <para>To use <languageKeyword>GetType</languageKeyword> on a dynamic module, subscribe to the <codeEntityReference qualifyHint="true" autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event and call <languageKeyword>GetType</languageKeyword> before saving. Otherwise, you will get two copies of the assembly in memory.</para>
            <para>The <parameterReference>throwOnError</parameterReference> parameter only affects what happens when the type is not found. It does not affect any other exceptions that might be thrown. In particular, if the type is found but cannot be loaded, a <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference> can be thrown even if <parameterReference>throwOnError</parameterReference> is <languageKeyword>false</languageKeyword>.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</para>
            <para>
              <parameterReference>typeName</parameterReference> can be a simple type name, a type name that includes a namespace, or a complex name that includes an assembly name specification.</para>
            <para>If <parameterReference>typeName</parameterReference> includes only the name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, this method searches in the calling object's assembly, then in the mscorlib.dll assembly. If <parameterReference>typeName</parameterReference> is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</para>
            <para>
              <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference> can return a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Delimiter </para>
                  </entry>
                  <entry>
                    <para>Meaning </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Backslash (\) </para>
                </entry>
                <entry>
                  <para>Escape character. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Comma (,) </para>
                </entry>
                <entry>
                  <para>Precedes the Assembly name. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Plus sign (+) </para>
                </entry>
                <entry>
                  <para>Precedes a nested class. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Period (.) </para>
                </entry>
                <entry>
                  <para>Denotes namespace identifiers. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Brackets ([]) </para>
                </entry>
                <entry>
                  <para>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type. </para>
                </entry>
              </row>
            </table>
            <para>For example, the fully qualified name for a class might look like this: </para>
            <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</code>
            <para>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </para>
            <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</code>
            <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
            <para>This qualified name can be persisted and later used to load the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. To search for and load a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, use <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> either with the type name only or with the assembly qualified type name. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the type name only will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in the caller's assembly and then in the System assembly. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the assembly qualified type name will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in any assembly.</para>
            <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <codeInline>t.GetElementType().ToString()</codeInline>, where <parameterReference>t</parameterReference> is the type.</para>
            <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
            <para>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> has two type parameters. A <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>MyType</codeInline> with keys of type <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> might be represented as follows: </para>
            <code>System.Collections.Generic.Dictionary`2[System.String,MyType]</code>
            <para>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>MyType</codeInline> from MyAssembly.dll, with keys of type <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>, might be specified as follows: </para>
            <code>Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")</code>
            <alert class="note">
              <para>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</para>
            </alert>
            <para>The following table shows the syntax you use with <languageKeyword>GetType</languageKeyword> for various types.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>To Get </para>
                  </entry>
                  <entry>
                    <para>Use </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>An unmanaged pointer to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType*")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An unmanaged pointer to a pointer to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType**")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A managed pointer or reference to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType&amp;")</codeInline>. Note that unlike pointers, references are limited to one level. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A parent class and a nested class </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyParentClass+MyNestedClass")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A one-dimensional array with a lower bound of 0 </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A one-dimensional array with an unknown lower bound </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[*]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An n-dimensional array </para>
                </entry>
                <entry>
                  <para>A comma (,) inside the brackets a total of n-1 times. For example, <codeInline>System.Object[,,]</codeInline> represents a three-dimensional <languageKeyword>Object</languageKeyword> array. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A two-dimensional array's array </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[][]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A rectangular two-dimensional array with unknown lower bounds </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[*,*]")</codeInline> or <codeInline>Type.GetType("MyArray[,]")</codeInline></para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with one type argument </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[MyType]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with two type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`2[MyType,AnotherType]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with two assembly-qualified type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An assembly-qualified generic type with an assembly-qualified type argument </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type whose type argument is a generic type with two type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")</codeInline>
                  </para>
                </entry>
              </row>
            </table>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the type of <languageKeyword>System.Int32</languageKeyword> and uses that type object to display the <codeEntityReference autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property of <languageKeyword>System.Int32</languageKeyword>. If a type object refers to an assembly that does not exist, this example throws an exception.</para>
                <codeReference>Type_GetType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetAssembly(System.Type)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetType(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The name of the <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference> to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>throwOnError</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to throw an exception if the type cannot be found; <languageKeyword>false</languageKeyword> to return <languageKeyword>null</languageKeyword>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ignoreCase</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to perform a case-insensitive search for <parameterReference>typeName</parameterReference>, <languageKeyword>false</languageKeyword> to perform a case-sensitive search for <parameterReference>typeName</parameterReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A class initializer is invoked and throws an exception. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>throwOnError</parameterReference> is <languageKeyword>true</languageKeyword> and the type is not found. </para>
              <para>-or-</para>
              <para>
                <parameterReference>typeName</parameterReference> represents an array of <codeEntityReference autoUpgrade="true">T:System.TypedReference</codeEntityReference>. This is a change from the behavior in the .NET Framework versions 1.0 and 1.1, which was to return a null reference.</para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is invalid, for example if it contains invalid characters, or if it is a zero-length string. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>
              <languageKeyword>GetType</languageKeyword> only works on assemblies loaded from disk. If you call <languageKeyword>GetType</languageKeyword> to look up a type defined in a dynamic assembly defined using the <codeEntityReference autoUpgrade="true">N:System.Reflection.Emit</codeEntityReference> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <languageKeyword>RunAndSave</languageKeyword> or <languageKeyword>Save</languageKeyword> access modes of the <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Emit.AssemblyBuilderAccess</codeEntityReference> enumeration. If the dynamic assembly is persistent and has been written to disk before <languageKeyword>GetType</languageKeyword> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <languageKeyword>GetType</languageKeyword> is called, the method returns <languageKeyword>null</languageKeyword>. <languageKeyword>GetType</languageKeyword> does not understand transient dynamic assemblies; therefore, calling <languageKeyword>GetType</languageKeyword> to retrieve a type in a transient dynamic assembly returns <languageKeyword>null</languageKeyword>.</para>
            <para>To use <languageKeyword>GetType</languageKeyword> on a dynamic module, subscribe to the <codeEntityReference qualifyHint="true" autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event and call <languageKeyword>GetType</languageKeyword> before saving. Otherwise, you will get two copies of the assembly in memory.</para>
            <para>The <parameterReference>throwOnError</parameterReference> parameter only affects what happens when the type is not found. It does not affect any other exceptions that might be thrown. In particular, if the type is found but cannot be loaded, a <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference> can be thrown even if <parameterReference>throwOnError</parameterReference> is <languageKeyword>false</languageKeyword>.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
            <para>The following table shows what members of a base class are returned by the <languageKeyword>Get</languageKeyword> methods when reflecting on a type.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Member Type </para>
                  </entry>
                  <entry>
                    <para>Static </para>
                  </entry>
                  <entry>
                    <para>Non-Static </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Constructor </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Field </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A field is always hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Event </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Method </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Nested Type </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
                <entry>
                  <para>No </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Property </para>
                </entry>
                <entry>
                  <para>Not applicable </para>
                </entry>
                <entry>
                  <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
                </entry>
              </row>
            </table>
            <list class="ordered">
              <listItem>
                <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
              </listItem>
              <listItem>
                <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
              </listItem>
              <listItem>
                <para>Custom attributes are not part of the common type system.</para>
              </listItem>
            </list>
            <para>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</para>
            <para>
              <parameterReference>typeName</parameterReference> can be a simple type name, a type name that includes a namespace, or a complex name that includes an assembly name specification.</para>
            <para>If <parameterReference>typeName</parameterReference> includes only the name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, this method searches in the calling object's assembly, then in the mscorlib.dll assembly. If <parameterReference>typeName</parameterReference> is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</para>
            <para>
              <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference> can return a fully qualified type name including nested types, the assembly name, and type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Delimiter </para>
                  </entry>
                  <entry>
                    <para>Meaning </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>Backslash (\) </para>
                </entry>
                <entry>
                  <para>Escape character. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Comma (,) </para>
                </entry>
                <entry>
                  <para>Precedes the Assembly name. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Plus sign (+) </para>
                </entry>
                <entry>
                  <para>Precedes a nested class. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Period (.) </para>
                </entry>
                <entry>
                  <para>Denotes namespace identifiers. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Brackets ([]) </para>
                </entry>
                <entry>
                  <para>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type. </para>
                </entry>
              </row>
            </table>
            <para>For example, the fully qualified name for a class might look like this: </para>
            <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</code>
            <para>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </para>
            <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</code>
            <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
            <para>This qualified name can be persisted and later used to load the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>. To search for and load a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, use <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> either with the type name only or with the assembly qualified type name. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the type name only will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in the caller's assembly and then in the System assembly. <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference> with the assembly qualified type name will look for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> in any assembly.</para>
            <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <codeInline>t.GetElementType().ToString()</codeInline>, where <parameterReference>t</parameterReference> is the type.</para>
            <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
            <para>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> has two type parameters. A <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>MyType</codeInline> with keys of type <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> might be represented as follows: </para>
            <code>System.Collections.Generic.Dictionary`2[System.String,MyType]</code>
            <para>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <codeEntityReference autoUpgrade="true">T:System.Collections.Generic.Dictionary`2</codeEntityReference> of <codeInline>MyType</codeInline> from MyAssembly.dll, with keys of type <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>, might be specified as follows: </para>
            <code>Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")</code>
            <alert class="note">
              <para>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</para>
            </alert>
            <para>The following table shows the syntax you use with <languageKeyword>GetType</languageKeyword> for various types.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>To Get </para>
                  </entry>
                  <entry>
                    <para>Use </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>An unmanaged pointer to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType*")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An unmanaged pointer to a pointer to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType**")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A managed pointer or reference to <codeInline>MyType</codeInline></para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyType&amp;")</codeInline>. Note that unlike pointers, references are limited to one level. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A parent class and a nested class </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyParentClass+MyNestedClass")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A one-dimensional array with a lower bound of 0 </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A one-dimensional array with an unknown lower bound </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[*]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An n-dimensional array </para>
                </entry>
                <entry>
                  <para>A comma (,) inside the brackets a total of n-1 times. For example, <codeInline>System.Object[,,]</codeInline> represents a three-dimensional <languageKeyword>Object</languageKeyword> array. </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A two-dimensional array's array </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[][]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A rectangular two-dimensional array with unknown lower bounds </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyArray[*,*]")</codeInline> or <codeInline>Type.GetType("MyArray[,]")</codeInline></para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with one type argument </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[MyType]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with two type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`2[MyType,AnotherType]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type with two assembly-qualified type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>An assembly-qualified generic type with an assembly-qualified type argument </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")</codeInline>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>A generic type whose type argument is a generic type with two type arguments </para>
                </entry>
                <entry>
                  <para>
                    <codeInline>Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")</codeInline>
                  </para>
                </entry>
              </row>
            </table>
          </content>
        </remarks>
        <platformNotes>
          <platformNote>
            <platforms>
              <platform>NETCF</platform>
            </platforms>
            <content>
              <para>The <parameterReference>ignoreCase</parameterReference> parameter is not supported and should be set to <languageKeyword>false</languageKeyword>.</para>
            </content>
          </platformNote>
        </platformNotes>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetAssembly(System.Type)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetType(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeArray(System.Object[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the types of the objects in the specified array.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>An array of objects whose types to determine. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> objects representing the types of the corresponding elements in <parameterReference>args</parameterReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>args</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>The class initializers are invoked and at least one throws an exception. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If a requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword> for the corresponding element in the result array.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetTypeCode#3</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeCode(System.Type)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the underlying type code of the specified <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>type</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> whose underlying type code to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.TypeCode</codeEntityReference> value of the underlying type.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetTypeCode#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.TypeCode</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromCLSID(System.Guid)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified class identifier (CLSID).</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>clsid</parameterReference>
            <content>
              <para>The CLSID of the type to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>System.__ComObject</languageKeyword> regardless of whether the CLSID is valid.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves a GUID by passing the <parameterReference>clsid</parameterReference> parameter to the constructor of the <codeEntityReference autoUpgrade="true">T:System.Guid</codeEntityReference> structure, and then retrieves the type associated with the specified class identifier (CLSID).</para>
                <codeReference>Type_GetTypeCLSID1#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      <overload>
        <summary>
          <para>Gets the type associated with the specified class identifier (CLSID).</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetTypeFromCLSID">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified class identifier (CLSID).</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>clsid</parameterReference>
            <content>
              <para>The CLSID of the type to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>throwOnError</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to throw any exception that occurs.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>false</languageKeyword> to ignore any exception that occurs. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>System.__ComObject</languageKeyword> regardless of whether the CLSID is valid.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Exceptions such as <codeEntityReference autoUpgrade="true">T:System.OutOfMemoryException</codeEntityReference> will be thrown when specifying <languageKeyword>true</languageKeyword> for <parameterReference>throwOnError</parameterReference>, but it will not fail for unregistered CLSIDs.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the type associated with the CLSID from the local host, specifying whether to throw an exception if an error occurs while loading the type.</para>
                <codeReference>Type_GetTypeCLSID2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified class identifier (CLSID) from the specified server.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>clsid</parameterReference>
            <content>
              <para>The CLSID of the type to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>server</parameterReference>
            <content>
              <para>The server from which to load the type. If the server name is <languageKeyword>null</languageKeyword>, this method automatically reverts to the local machine. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>System.__ComObject</languageKeyword> regardless of whether the CLSID is valid.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the type associated with the CLSID from the local host.</para>
                <codeReference>Type_GetTypeCLSID2#2</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>clsid</parameterReference>
            <content>
              <para>The CLSID of the type to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>server</parameterReference>
            <content>
              <para>The server from which to load the type. If the server name is <languageKeyword>null</languageKeyword>, this method automatically reverts to the local machine. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>throwOnError</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to throw any exception that occurs.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>false</languageKeyword> to ignore any exception that occurs. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>System.__ComObject</languageKeyword> regardless of whether the CLSID is valid.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Exceptions such as <codeEntityReference autoUpgrade="true">T:System.OutOfMemoryException</codeEntityReference> will be thrown when specifying <languageKeyword>true</languageKeyword> for <parameterReference>throwOnError</parameterReference>, but it will not fail for unregistered CLSIDs.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves the type associated with the CLSID from the local host, specifying whether to throw an exception if an error occurs while loading the type.</para>
                <codeReference>Type_GetTypeCLSID2#3</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type referenced by the specified type handle.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>handle</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.RuntimeTypeHandle</codeEntityReference> object that refers to the type. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The type referenced by the specified <codeEntityReference autoUpgrade="true">T:System.RuntimeTypeHandle</codeEntityReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>handle</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A class initializer is invoked and throws an exception. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The handles are valid only in the application domain in which they were obtained.</para>
            <para>If the requested type is non-public and the caller does not have <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference> to reflect non-public objects outside the current assembly, this method returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_GetTypeFromHandle#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting non-public objects. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.RuntimeTypeHandle</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.TypeHandle</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeHandle(System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromProgID(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>progID</parameterReference>
            <content>
              <para>The ProgID of the type to get. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The type associated with the specified ProgID, if <parameterReference>progID</parameterReference> is a valid entry in the registry and a type is associated with it; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>progID</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for executing unmanaged code. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Gets the type associated with the specified program identifier (ProgID).</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.Type.GetTypeFromProgID">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified program identifier (ProgID).</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>progID</parameterReference>
            <content>
              <para>The ProgID of the type to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>throwOnError</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to throw any exception that occurs.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>false</languageKeyword> to ignore any exception that occurs. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The type associated with the specified program identifier (ProgID), if <parameterReference>progID</parameterReference> is a valid entry in the registry and a type is associated with it; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>progID</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.COMException</codeEntityReference>
            <content>
              <para>The specified ProgID is not registered. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid. The example then displays the ClassID related to the ProgID, along with any applicable exception message.</para>
                <codeReference>Type_GetTypeFromProgID2#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for executing unmanaged code. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromProgID(System.String,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>progID</parameterReference>
            <content>
              <para>The progID of the type to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>server</parameterReference>
            <content>
              <para>The server from which to load the type. If the server name is <languageKeyword>null</languageKeyword>, this method automatically reverts to the local machine. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The type associated with the specified program identifier (progID), if <parameterReference>progID</parameterReference> is a valid entry in the registry and a type is associated with it; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>prodID</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves a type by passing a ProgID and server name. The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</para>
                <codeReference>Type_GetTypeFromProgID3#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for executing unmanaged code. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>progID</parameterReference>
            <content>
              <para>The progID of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>server</parameterReference>
            <content>
              <para>The server from which to load the type. If the server name is <languageKeyword>null</languageKeyword>, this method automatically reverts to the local machine. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>throwOnError</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to throw any exception that occurs.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>false</languageKeyword> to ignore any exception that occurs. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> associated with the specified program identifier (progID), if <parameterReference>progID</parameterReference> is a valid entry in the registry and a type is associated with it; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>progID</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.COMException</codeEntityReference>
            <content>
              <para>The specified progID is not registered. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example retrieves a type by passing a ProgID and server name. The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</para>
                <codeReference>Type_GetTypeFromProgID4#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for executing unmanaged code. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.GetTypeHandle(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the handle for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> of a specified object.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>o</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> for which to get the Type handle. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The handle for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> of the specified <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The handles are valid only in the application domain in which they were obtained.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example defines the class <codeInline>MyClass1</codeInline>, gets an instance of it, and retrieves the runtime handle of the object.</para>
                <codeReference>Type_GetTypeHandle#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.RuntimeTypeHandle</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.TypeHandle</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.GUID">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the GUID associated with the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>The GUID associated with the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>A GUID is associated with a type using the <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.GuidAttribute</codeEntityReference> attribute.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates the class <codeInline>MyClass1</codeInline> with a public method, creates a <languageKeyword>Type</languageKeyword> object corresponding to <codeInline>MyClass1</codeInline>, and gets the <codeEntityReference autoUpgrade="true">T:System.Guid</codeEntityReference> structure using the <languageKeyword>GUID</languageKeyword> property of the <languageKeyword>Type</languageKeyword> class.</para>
                <codeReference>Type_Guid#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Guid</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.HasElementType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> encompasses or refers to another type; that is, whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array, a pointer, or is passed by reference.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array, a pointer, or is passed by reference; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>For example, Type.GetType("Int32[]").HasElementType returns <languageKeyword>true</languageKeyword>, but Type.GetType("Int32").HasElementType returns <languageKeyword>false</languageKeyword>. HasElementType also returns <languageKeyword>true</languageKeyword> for "Int32*" and "Int32&amp;".</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example returns <languageKeyword>true</languageKeyword> or <languageKeyword>false</languageKeyword> depending on whether or not the object is an array, a reference type, or a pointer.</para>
                <codeReference>Type_HasElementType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.HasElementTypeImpl</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsArray</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsPointer</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsByRef</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetElementType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.HasElementTypeImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, implements the <codeEntityReference autoUpgrade="true">P:System.Type.HasElementType</codeEntityReference> property and determines whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> encompasses or refers to another type; that is, whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array, a pointer, or is passed by reference.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array, a pointer, or is passed by reference; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>For example, Type.GetType("Int32[]").HasElementTypeImpl returns <languageKeyword>true</languageKeyword>, but Type.GetType("Int32").HasElementTypeImpl returns <languageKeyword>false</languageKeyword>. HasElementTypeImpl also returns <languageKeyword>true</languageKeyword> for "Int32*" and "Int32&amp;".</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example defines the class <languageKeyword>MyTypeDelegator</languageKeyword>, which overrides the <languageKeyword>HasElementTypeImpl</languageKeyword> method. The main class checks for the <languageKeyword>HasElementType</languageKeyword> property and displays the element type.</para>
                <codeReference>Type_HasElementTypeImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.HasElementType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsArray</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsPointer</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsByRef</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetElementType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the constructor, method, property, or field member to invoke.</para>
              <para>-or- </para>
              <para>An empty string ("") to invoke the default member. </para>
              <para>-or-</para>
              <para>For <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> members, a string representing the DispID, for example "[DispID=3]".</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>invokeAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted. The access can be one of the <languageKeyword>BindingFlags</languageKeyword> such as <languageKeyword>Public</languageKeyword>, <languageKeyword>NonPublic</languageKeyword>, <languageKeyword>Private</languageKeyword>, <languageKeyword>InvokeMethod</languageKeyword>, <languageKeyword>GetField</languageKeyword>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <languageKeyword>BindingFlags.Public</languageKeyword> | <languageKeyword>BindingFlags.Instance</languageKeyword> will apply. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>target</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> on which to invoke the specified member. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>An array containing the arguments to pass to the member to invoke. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> representing the return value of the invoked member.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>CreateInstance</parameterReference> and <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>args</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> is not a valid <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> attribute.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>CreateInstance</parameterReference> combined with <parameterReference>InvokeMethod</parameterReference>, <parameterReference>GetField</parameterReference>, <parameterReference>SetField</parameterReference>, <parameterReference>GetProperty</parameterReference>, or <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains both <parameterReference>GetField</parameterReference> and <parameterReference>SetField</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains both <parameterReference>GetProperty</parameterReference> and <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>InvokeMethod</parameterReference> combined with <parameterReference>SetField</parameterReference> or <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>SetField</parameterReference> and <parameterReference>args</parameterReference> has more than one element.</para>
              <para>-or- </para>
              <para>This method is called on a COM object and one of the following binding flags was not passed in: <languageKeyword>BindingFlags.InvokeMethod</languageKeyword>, <languageKeyword>BindingFlags.GetProperty</languageKeyword>, <languageKeyword>BindingFlags.SetProperty</languageKeyword>, <languageKeyword>BindingFlags.PutDispProperty</languageKeyword>, or <languageKeyword>BindingFlags.PutRefDispProperty</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the named parameter arrays contains a string that is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The specified member is a class initializer. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingFieldException</codeEntityReference>
            <content>
              <para>The field or property cannot be found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>The method cannot be found.</para>
              <para>-or- </para>
              <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type that contains open type parameters, that is, <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> returns <languageKeyword>true</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetException</codeEntityReference>
            <content>
              <para>The specified member cannot be invoked on <parameterReference>target</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method matches the binding criteria. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The .NET Compact Framework does not currently support this property.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which members to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public members in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public members (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include static members up the hierarchy.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the members declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not members that were simply inherited.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> invocation flags can be used to denote what action to take with the member: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>CreateInstance</languageKeyword> to invoke a constructor. <parameterReference>name</parameterReference> is ignored. Not valid with other invocation flags.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>InvokeMethod</languageKeyword> to invoke a method, but not a constructor or a type initializer. Not valid with <languageKeyword>SetField</languageKeyword> or <languageKeyword>SetProperty</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>GetField</languageKeyword> to get the value of a field. Not valid with <languageKeyword>SetField</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>SetField</languageKeyword> to set the value of a field. Not valid with <languageKeyword>GetField</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>GetProperty</languageKeyword> to get a property. Not valid with <languageKeyword>SetProperty</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>SetProperty</languageKeyword> to set a property. Not valid with <languageKeyword>GetProperty</languageKeyword>.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>A method will be invoked if the following conditions are true: </para>
            <list class="bullet">
              <listItem>
                <para>The number of parameters in the method declaration equals the number of arguments in the <parameterReference>args</parameterReference> array (unless default arguments are defined on the member), and </para>
              </listItem>
              <listItem>
                <para>The type of each argument can be converted by the binder to the type of the parameter.</para>
              </listItem>
            </list>
            <para>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> values <languageKeyword>InvokeMethod</languageKeyword>, <languageKeyword>GetProperty</languageKeyword>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</para>
            <para>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)</codeEntityReference> method of the <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</para>
            <para>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <codeEntityReference autoUpgrade="true">N:System.Reflection</codeEntityReference> whenever the code is fully trusted.</para>
            <para>You can use <languageKeyword>Type.InvokeMember</languageKeyword> to set a field to a particular value by specifying <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.SetField</codeEntityReference>. For example, if you want to set a public instance field named F on class C, and F is a <languageKeyword>String</languageKeyword>, you can use code such as: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{"strings new value"});</codeInline>
            </para>
            <para>If F is a <languageKeyword>String[]</languageKeyword>, you can use code such as: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"});</codeInline>
            </para>
            <para>which will initialize the field F to this new array. You can also use <languageKeyword>Type.InvokeMember</languageKeyword> to set a position in an array by supplying the index of the value and then the next value by using code such as the following: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{1, "b"});</codeInline>
            </para>
            <para>This will change string "z" in the array that F holds to string "b".</para>
            <para>When you invoke an <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]". For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example uses <languageKeyword>InvokeMember</languageKeyword> to access members of a type.</para>
                <codeReference>InvokeMem#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting members that are not public. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to call unmanaged code. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Invokes a specific member of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the constructor, method, property, or field member to invoke.</para>
              <para>-or- </para>
              <para>An empty string ("") to invoke the default member. </para>
              <para>-or-</para>
              <para>For <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> members, a string representing the DispID, for example "[DispID=3]".</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>invokeAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted. The access can be one of the <languageKeyword>BindingFlags</languageKeyword> such as <languageKeyword>Public</languageKeyword>, <languageKeyword>NonPublic</languageKeyword>, <languageKeyword>Private</languageKeyword>, <languageKeyword>InvokeMethod</languageKeyword>, <languageKeyword>GetField</languageKeyword>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <languageKeyword>BindingFlags.Public</languageKeyword> | <languageKeyword>BindingFlags.Instance</languageKeyword> will apply. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>target</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> on which to invoke the specified member. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>An array containing the arguments to pass to the member to invoke. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>culture</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword> to use the current thread's <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> representing the return value of the invoked member.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>CreateInstance</parameterReference> and <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>args</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> is not a valid <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> attribute.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>CreateInstance</parameterReference> combined with <parameterReference>InvokeMethod</parameterReference>, <parameterReference>GetField</parameterReference>, <parameterReference>SetField</parameterReference>, <parameterReference>GetProperty</parameterReference>, or <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains both <parameterReference>GetField</parameterReference> and <parameterReference>SetField</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains both <parameterReference>GetProperty</parameterReference> and <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>InvokeMethod</parameterReference> combined with <parameterReference>SetField</parameterReference> or <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>SetField</parameterReference> and <parameterReference>args</parameterReference> has more than one element.</para>
              <para>-or- </para>
              <para>This method is called on a COM object and one of the following binding flags was not passed in: <languageKeyword>BindingFlags.InvokeMethod</languageKeyword>, <languageKeyword>BindingFlags.GetProperty</languageKeyword>, <languageKeyword>BindingFlags.SetProperty</languageKeyword>, <languageKeyword>BindingFlags.PutDispProperty</languageKeyword>, or <languageKeyword>BindingFlags.PutRefDispProperty</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the named parameter arrays contains a string that is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The specified member is a class initializer. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingFieldException</codeEntityReference>
            <content>
              <para>The field or property cannot be found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>The method cannot be found.</para>
              <para>-or- </para>
              <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type that contains open type parameters, that is, <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> returns <languageKeyword>true</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetException</codeEntityReference>
            <content>
              <para>The specified member cannot be invoked on <parameterReference>target</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method matches the binding criteria. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference> (the <parameterReference>culture</parameterReference> parameter), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>culture</parameterReference>.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which members to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public members in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public members (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include static members up the hierarchy.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the members declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not members that were simply inherited.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> invocation flags can be used to denote what action to take with the member: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>CreateInstance</languageKeyword> to invoke a constructor. <parameterReference>name</parameterReference> is ignored. Not valid with other invocation flags.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>InvokeMethod</languageKeyword> to invoke a method, but not a constructor or a type initializer. Not valid with <languageKeyword>SetField</languageKeyword> or <languageKeyword>SetProperty</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>GetField</languageKeyword> to get the value of a field. Not valid with <languageKeyword>SetField</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>SetField</languageKeyword> to set the value of a field. Not valid with <languageKeyword>GetField</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>GetProperty</languageKeyword> to get a property. Not valid with <languageKeyword>SetProperty</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>SetProperty</languageKeyword> to set a property. Not valid with <languageKeyword>GetProperty</languageKeyword>.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>A method will be invoked if the following conditions are true: </para>
            <list class="bullet">
              <listItem>
                <para>The number of parameters in the method declaration equals the number of arguments in the <parameterReference>args</parameterReference> array (unless default arguments are defined on the member).</para>
              </listItem>
              <listItem>
                <para>The type of each argument can be converted by the binder to the type of the parameter.</para>
              </listItem>
            </list>
            <para>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> values <languageKeyword>InvokeMethod</languageKeyword>, <languageKeyword>GetProperty</languageKeyword>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</para>
            <para>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)</codeEntityReference> method of the <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</para>
            <para>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</para>
            <para>You can use <languageKeyword>Type.InvokeMember</languageKeyword> to set a field to a particular value by specifying <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.SetField</codeEntityReference>. For example, if you want to set a public instance field named F on class C, and F is a <languageKeyword>String</languageKeyword> you can use code such as: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{"strings new value"}, null);</codeInline>
            </para>
            <para>If F is a <languageKeyword>String[]</languageKeyword>, you can use code such as: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null);</codeInline>
            </para>
            <para>which will initialize the field F to this new array. You can also use <languageKeyword>Type.InvokeMember</languageKeyword> to set a position in an array by supplying the index of the value and then the next value by using code such as the following: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{1, "b"}, null);</codeInline>
            </para>
            <para>This will change string "z" in the array that F holds to string "b".</para>
            <para>When you invoke an <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> member you can specify the DispID instead of the member name, using the string format "[DispID=##]". For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting members that are not public. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to call unmanaged code. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> containing the name of the constructor, method, property, or field member to invoke.</para>
              <para>-or- </para>
              <para>An empty string ("") to invoke the default member. </para>
              <para>-or-</para>
              <para>For <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> members, a string representing the DispID, for example "[DispID=3]".</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>invokeAttr</parameterReference>
            <content>
              <para>A bitmask comprised of one or more <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> that specify how the search is conducted. The access can be one of the <languageKeyword>BindingFlags</languageKeyword> such as <languageKeyword>Public</languageKeyword>, <languageKeyword>NonPublic</languageKeyword>, <languageKeyword>Private</languageKeyword>, <languageKeyword>InvokeMethod</languageKeyword>, <languageKeyword>GetField</languageKeyword>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <languageKeyword>BindingFlags.Public</languageKeyword> | <languageKeyword>BindingFlags.Instance</languageKeyword> will apply. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword>, to use the <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>target</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> on which to invoke the specified member. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>An array containing the arguments to pass to the member to invoke. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>modifiers</parameterReference>
            <content>
              <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> objects representing the attributes associated with the corresponding element in the <parameterReference>args</parameterReference> array. A parameter's associated attributes are stored in the member's signature. The default binder does not process this parameter. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>culture</parameterReference>
            <content>
              <para>The <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</para>
              <para>-or- </para>
              <para>
                <languageKeyword>null</languageKeyword> to use the current thread's <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>namedParameters</parameterReference>
            <content>
              <para>An array containing the names of the parameters to which the values in the <parameterReference>args</parameterReference> array are passed. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Object</codeEntityReference> representing the return value of the invoked member.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>CreateInstance</parameterReference> and <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>args</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>modifiers</parameterReference> is multidimensional.</para>
              <para>-or- </para>
              <para>
                <parameterReference>args</parameterReference> and <parameterReference>modifiers</parameterReference> do not have the same length.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> is not a valid <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> attribute.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>CreateInstance</parameterReference> combined with <parameterReference>InvokeMethod</parameterReference>, <parameterReference>GetField</parameterReference>, <parameterReference>SetField</parameterReference>, <parameterReference>GetProperty</parameterReference>, or <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains both <parameterReference>GetField</parameterReference> and <parameterReference>SetField</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains both <parameterReference>GetProperty</parameterReference> and <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>InvokeMethod</parameterReference> combined with <parameterReference>SetField</parameterReference> or <parameterReference>SetProperty</parameterReference>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>invokeAttr</parameterReference> contains <parameterReference>SetField</parameterReference> and <parameterReference>args</parameterReference> has more than one element.</para>
              <para>-or- </para>
              <para>The named parameter array is larger than the argument array.</para>
              <para>-or- </para>
              <para>This method is called on a COM object and one of the following binding flags was not passed in: <languageKeyword>BindingFlags.InvokeMethod</languageKeyword>, <languageKeyword>BindingFlags.GetProperty</languageKeyword>, <languageKeyword>BindingFlags.SetProperty</languageKeyword>, <languageKeyword>BindingFlags.PutDispProperty</languageKeyword>, or <languageKeyword>BindingFlags.PutRefDispProperty</languageKeyword>.</para>
              <para>-or- </para>
              <para>One of the named parameter arrays contains a string that is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The specified member is a class initializer. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingFieldException</codeEntityReference>
            <content>
              <para>The field or property cannot be found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>The method cannot be found.</para>
              <para>-or- </para>
              <para>The current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type that contains open type parameters, that is, <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> returns <languageKeyword>true</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetException</codeEntityReference>
            <content>
              <para>The specified member cannot be invoked on <parameterReference>target</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.AmbiguousMatchException</codeEntityReference>
            <content>
              <para>More than one method matches the binding criteria. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>
              <languageKeyword>InvokeMember</languageKeyword> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</para>
            <para>When you invoke an <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> member you can specify the DispID instead of the member name, using the string format "[DispID=##]". For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</para>
            <para>Although the default binder does not process <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference> or <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference> (the <parameterReference>modifiers</parameterReference> and <parameterReference>culture</parameterReference> parameters), you can use the abstract <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class to write a custom binder that does process <parameterReference>modifiers</parameterReference> and <parameterReference>culture</parameterReference>. <languageKeyword>ParameterModifier</languageKeyword> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
            <para>The <parameterReference>args</parameterReference> array and the <parameterReference>modifiers</parameterReference> array have the same length. A parameter specified in the <parameterReference>args</parameterReference> array can have the following attributes, which are specified in the <parameterReference>modifiers</parameterReference> array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which represent [In], [Out], [lcid], [retval], [optional], and a value specifying whether the parameter has a default value. A parameter's associated attributes are stored in the metadata and enhance interoperability.</para>
            <para>Each parameter in the <parameterReference>namedParameters</parameterReference> array gets the value in the corresponding element in the <parameterReference>args</parameterReference> array. If the length of <parameterReference>args</parameterReference> is greater than the length of <parameterReference>namedParameters</parameterReference>, the remaining argument values are passed in order.</para>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> filter flags can be used to define which members to include in the search: </para>
            <list class="bullet">
              <listItem>
                <para>You must specify either <languageKeyword>BindingFlags.Instance</languageKeyword> or <languageKeyword>BindingFlags.Static</languageKeyword> in order to get a return.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.Public</languageKeyword> to include public members in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.NonPublic</languageKeyword> to include non-public members (that is, private and protected members) in the search.</para>
              </listItem>
              <listItem>
                <para>Specify <languageKeyword>BindingFlags.FlattenHierarchy</languageKeyword> to include static members up the hierarchy.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> modifier flags can be used to change how the search works: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.IgnoreCase</languageKeyword> to ignore the case of <parameterReference>name</parameterReference>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>BindingFlags.DeclaredOnly</languageKeyword> to search only the members declared on the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, not members that were simply inherited.</para>
              </listItem>
            </list>
            <para>The following <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> invocation flags can be used to denote what action to take with the member: </para>
            <list class="bullet">
              <listItem>
                <para>
                  <languageKeyword>CreateInstance</languageKeyword> to invoke a constructor. <parameterReference>name</parameterReference> is ignored. Not valid with other invocation flags.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>InvokeMethod</languageKeyword> to invoke a method, but not a constructor or a type initializer. Not valid with <languageKeyword>SetField</languageKeyword> or <languageKeyword>SetProperty</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>GetField</languageKeyword> to get the value of a field. Not valid with <languageKeyword>SetField</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>SetField</languageKeyword> to set the value of a field. Not valid with <languageKeyword>GetField</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>GetProperty</languageKeyword> to get a property. Not valid with <languageKeyword>SetProperty</languageKeyword>.</para>
              </listItem>
              <listItem>
                <para>
                  <languageKeyword>SetProperty</languageKeyword> to set a property. Not valid with <languageKeyword>GetProperty</languageKeyword>.</para>
              </listItem>
            </list>
            <para>See <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> for more information.</para>
            <para>A method will be invoked if the following conditions are true: </para>
            <list class="bullet">
              <listItem>
                <para>The number of parameters in the method declaration equals the number of arguments in the <parameterReference>args</parameterReference> array (unless default arguments are defined on the member).</para>
              </listItem>
              <listItem>
                <para>The type of each argument can be converted by the binder to the type of the parameter.</para>
              </listItem>
            </list>
            <para>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> values <languageKeyword>InvokeMethod</languageKeyword>, <languageKeyword>GetProperty</languageKeyword>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</para>
            <para>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)</codeEntityReference> method of the <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</para>
            <para>
              <languageKeyword>InvokeMember</languageKeyword> can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.OptionalParamBinding</codeEntityReference> to be specified. For a parameter that has a default value, you can either supply a different value, or supply <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.Missing.Value</codeEntityReference> to use the default value.</para>
            <para>For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <languageKeyword>Missing.Value</languageKeyword> for the second argument. Unless you use <languageKeyword>Missing.Value</languageKeyword>, you may not omit optional parameters with the <languageKeyword>Invoke</languageKeyword> method. If you must do so, use <languageKeyword>InvokeMember</languageKeyword> instead.</para>
            <para>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <codeEntityReference autoUpgrade="true">N:System.Reflection</codeEntityReference> whenever the code is fully trusted.</para>
            <para>You can use <languageKeyword>Type.InvokeMember</languageKeyword> to set a field to a particular value by specifying <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.BindingFlags.SetField</codeEntityReference>. For example, if you want to set a public instance field named F on class C, and F is a <languageKeyword>String</languageKeyword>, you can use code such as: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{"strings new value"}, null, null, null);</codeInline>
            </para>
            <para>If F is a <languageKeyword>String[]</languageKeyword>, you can use code such as: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"}, null, null, null);</codeInline>
            </para>
            <para>which will initialize the field F to this new array. You can also use <languageKeyword>Type.InvokeMember</languageKeyword> to set a position in an array by supplying the index of the value and then the next value by using code such as the following: </para>
            <para>
              <codeInline>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null);</codeInline>
            </para>
            <para>This will change string "z" in the array that F holds to string "b".</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for reflecting members that are not public. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to call unmanaged code. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Binder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DefaultBinder</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterModifier</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ParameterAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.Type.InvokeMember">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Invokes a specific member of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
      </dduexml>
    </member>
    <member name="P:System.Type.IsAbstract">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is abstract and must be overridden.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is abstract; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>true</languageKeyword>. This is because it is not possible to create an instance of a generic type parameter.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example returns <languageKeyword>true</languageKeyword> if the specified object is <languageKeyword>abstract</languageKeyword>; otherwise, it returns <languageKeyword>false</languageKeyword>.</para>
                <codeReference>Type_IsAbstract#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsAnsiClass">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the string format attribute <languageKeyword>AnsiClass</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the string format attribute <languageKeyword>AnsiClass</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.StringFormatMask</codeEntityReference> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, this property pertains to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example gets the field information and checks for the <languageKeyword>AnsiClass</languageKeyword> attribute.</para>
                <codeReference>Type_IsAnsiClass#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsUnicodeClass</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsAutoClass</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsArray">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">P:System.Type.IsArray</codeEntityReference> property returns <languageKeyword>false</languageKeyword> for the <codeEntityReference autoUpgrade="true">T:System.Array</codeEntityReference> class.</para>
            <para>To check for an array, use code such as <codeInline>typeof(Array).IsAssignableFrom(type)</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates using the <languageKeyword>IsArray</languageKeyword> property.</para>
                <codeReference>TestIsArray#1</codeReference>
                <para>This code produces the following output: </para>
                <code>Type is System.Array. IsArray? False
Type is System.Int32[]. IsArray? True</code>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsArrayImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsArrayImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsArray</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an array; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>An instance of the <codeEntityReference autoUpgrade="true">T:System.Array</codeEntityReference> class must return <languageKeyword>false</languageKeyword> because it is an object, not an array.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example overrides the <languageKeyword>IsArrayImpl</languageKeyword> method in the <languageKeyword>MyTypeDelegator</languageKeyword> class, checks if a variable is an array, and displays the result.</para>
                <codeReference>Type_IsArrayImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsArray</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsAssignableFrom(System.Type)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines whether an instance of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> can be assigned from an instance of the specified <languageKeyword>Type</languageKeyword>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>c</parameterReference>
            <content>
              <para>The <languageKeyword>Type</languageKeyword> to compare with the current <languageKeyword>Type</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if <parameterReference>c</parameterReference> and the current <languageKeyword>Type</languageKeyword> represent the same type, or if the current <languageKeyword>Type</languageKeyword> is in the inheritance hierarchy of <parameterReference>c</parameterReference>, or if the current <languageKeyword>Type</languageKeyword> is an interface that <parameterReference>c</parameterReference> implements, or if <parameterReference>c</parameterReference> is a generic type parameter and the current <languageKeyword>Type</languageKeyword> represents one of the constraints of <parameterReference>c</parameterReference>. <languageKeyword>false</languageKeyword> if none of these conditions are true, or if <parameterReference>c</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <alert class="note">
              <para>A generic type definition is not assignable from a closed constructed type. That is, you cannot assign the closed constructed type <codeInline>MyGenericList&lt;int&gt;</codeInline> (<codeInline>MyGenericList(Of Integer)</codeInline> in Visual Basic) to a variable of type <codeInline>MyGenericList&lt;T&gt;</codeInline>.</para>
            </alert>
            <para>Determine the element types of a <languageKeyword>Type</languageKeyword> using <codeEntityReference autoUpgrade="true">M:System.Type.GetElementType</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates the <languageKeyword>IsAssignableFrom</languageKeyword> method using arrays.</para>
                <codeReference>TestIsAssignableFrom#1</codeReference>
                <para>This code produces the following output: </para>
                <code>int[2] is assignable from int? False
     int[2] is assignable from int[10]? True
     int[2,2] is assignable from int[2,4]? True
     int[2,4] is assignable from int[2,2]? True
     int[2,2] is assignable from int[10]? False
     int[2,2] is assignable from int[3,3,3]? False
    int[3,3,3] is assignable from int[2,2]? False</code>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="P:System.Type.IsAutoClass">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the string format attribute <languageKeyword>AutoClass</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the string format attribute <languageKeyword>AutoClass</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.StringFormatMask</codeEntityReference> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsAnsiClass</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsUnicodeClass</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsAutoLayout">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the class layout attribute <languageKeyword>AutoLayout</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the class layout attribute <languageKeyword>AutoLayout</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.LayoutMask</codeEntityReference> is used to select the class layout attributes. The class layout attributes (<languageKeyword>AutoLayout</languageKeyword>, <languageKeyword>SequentialLayout</languageKeyword> and <languageKeyword>ExplicitLayout</languageKeyword>) define how the fields of the class instance are laid out in memory.</para>
            <para>Use the <languageKeyword>AutoLayout</languageKeyword> attribute to let the runtime engine decide the best way to layout the objects of the class. Classes marked with the <languageKeyword>AutoLayout</languageKeyword> attribute indicate that the loader will choose the appropriate way to lay out the class; any layout information that may have been specified is ignored.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;.</codeInline></para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an instance of the type and displays the <languageKeyword>IsAutoLayout</languageKeyword> property.</para>
                <codeReference>Type_IsAutoLayout#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsLayoutSequential</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsExplicitLayout</codeEntityReference>
          <link xlink:href="3DD13C5D-A508-455B-8DCE-0A852882A5A7">[&lt;topic://cpconmetadataoverview&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsByRef">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is passed by reference.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is passed by reference; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>To get to the actual type, dereference the type that was passed by reference, and then call <codeEntityReference autoUpgrade="true">M:System.Type.GetElementType</codeEntityReference> on that type.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates a use of the <languageKeyword>IsByRef</languageKeyword> property to check whether a specified type is passed by reference. The example defines the class <languageKeyword>MyTypeDelegator</languageKeyword>, which overrides the <languageKeyword>HasElementTypeImpl</languageKeyword> method. The main class checks for the <languageKeyword>HasElementType</languageKeyword> property and displays the element type.</para>
                <codeReference>Type_HasElementTypeImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsByRefImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsByRefImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsByRef</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is passed by reference.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is passed by reference; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsByRef</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsClass">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a class; that is, not a value type or interface.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a class; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This property returns <languageKeyword>true</languageKeyword> for <languageKeyword>Type</languageKeyword> instances representing <codeEntityReference autoUpgrade="true">T:System.Enum</codeEntityReference> and <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference>.</para>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.ClassSemanticsMask</codeEntityReference> distinguishes a type declaration as class, interface, or value type.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property returns <languageKeyword>true</languageKeyword> if the generic type definition is a class definition; that is, it does not define an interface or a value type.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an instance of a type and indicates whether the type is a class.</para>
                <codeReference>Type_IsClass#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsInterface</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsValueType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsCOMObject">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a COM object.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a COM object; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method returns <languageKeyword>false</languageKeyword> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</para>
            <para>You can also load a COM class and get a <languageKeyword>Type</languageKeyword> object for that COM class by using the <link xlink:href="EC0A8D63-11B3-4ACD-B398-DA1E37E97382">[&lt;topic://cpgrftypelibraryimportertlbimpexe&gt;]</link> tool.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int</codeInline>&gt; (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example shows a use of the <languageKeyword>IsCOMObject</languageKeyword> property.</para>
                <codeReference>GaryMacInterop#4</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsCOMObjectImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsCOMObjectImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsCOMObject</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a COM object.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a COM object; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method returns <languageKeyword>false</languageKeyword> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsCOMObject</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsContextful">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> can be hosted in a context.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> can be hosted in a context; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see <codeEntityReference autoUpgrade="true">T:System.Runtime.Remoting.Contexts.Context</codeEntityReference>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates the <languageKeyword>IsContextful</languageKeyword>, <codeEntityReference autoUpgrade="true">P:System.Type.IsMarshalByRef</codeEntityReference>, and <codeEntityReference autoUpgrade="true">P:System.Type.IsPrimitive</codeEntityReference> properties of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</para>
                <codeReference>Type_IsContextful#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsContextfulImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsContextfulImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsContextful</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> can be hosted in a context.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> can be hosted in a context; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <para>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates a use of the <languageKeyword>IsContextfulImpl</languageKeyword> method.</para>
                <codeReference>Type_IsContextfulImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsContextful</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsEnum">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents an enumeration.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents an enumeration; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This property returns <languageKeyword>true</languageKeyword> for an enumeration, but not for the <codeEntityReference autoUpgrade="true">T:System.Enum</codeEntityReference> type itself.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates how to use the <languageKeyword>IsEnum</languageKeyword> property.</para>
                <codeReference>TestIsEnum#1</codeReference>
                <para>This code produces the following output: </para>
                <code>Is Color an enum? True.
Is Color a value type? True.
Is Enum an enum type? False.
Is Enum a value type? False.</code>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsExplicitLayout">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the class layout attribute <languageKeyword>ExplicitLayout</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the class layout attribute <languageKeyword>ExplicitLayout</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.LayoutMask</codeEntityReference> is used to select the class layout attributes. The class layout attributes (<languageKeyword>AutoLayout</languageKeyword>, <languageKeyword>SequentialLayout</languageKeyword> and <languageKeyword>ExplicitLayout</languageKeyword>) define how the fields of the class instance are laid out in memory.</para>
            <para>Classes marked with the <languageKeyword>ExplicitLayout</languageKeyword> attribute cause the loader to ignore field sequence and to use the explicit layout rules provided, in the form of field offsets, overall class size and alignment, or all of these.</para>
            <para>Use the <languageKeyword>ExplicitLayout</languageKeyword> attribute to specify the offsets at which each field starts, or to specify the overall size and, optionally, the packing size of the objects of the class. The packing size is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an instance of the specified type and displays the <languageKeyword>IsExplicitLayout</languageKeyword> property of the<codeInline> MyDemoAttribute</codeInline> class.</para>
                <codeReference>Type_IsExplicitLayout#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsAutoLayout</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsLayoutSequential</codeEntityReference>
          <link xlink:href="3DD13C5D-A508-455B-8DCE-0A852882A5A7">[&lt;topic://cpconmetadataoverview&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsImport">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> has a <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.ComImportAttribute</codeEntityReference> attribute applied, indicating that it was imported from a COM type library.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> has a <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.ComImportAttribute</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;.</codeInline></para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsInstanceOfType(System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines whether the specified object is an instance of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>o</parameterReference>
            <content>
              <para>The object to compare with the current <languageKeyword>Type</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the current <languageKeyword>Type</languageKeyword> is in the inheritance hierarchy of the object represented by <parameterReference>o</parameterReference>, or if the current <languageKeyword>Type</languageKeyword> is an interface that <parameterReference>o</parameterReference> supports. <languageKeyword>false</languageKeyword> if neither of these conditions is the case, or if <parameterReference>o</parameterReference> is <languageKeyword>null</languageKeyword>, or if the current <languageKeyword>Type</languageKeyword> is an open generic type (that is, <codeEntityReference autoUpgrade="true">P:System.Type.ContainsGenericParameters</codeEntityReference> returns <languageKeyword>true</languageKeyword>).</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
            <alert class="note">
              <para>A constructed type is not an instance of its generic type definition. That is, <codeInline>MyGenericList&lt;int&gt;</codeInline> (<codeInline>MyGenericList(Of Integer)</codeInline> in Visual Basic) is not an instance of <codeInline>MyGenericList&lt;T&gt;</codeInline> (<codeInline>MyGenericList(Of T)</codeInline> in Visual Basic).</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates the use of the <languageKeyword>IsInstanceOfType</languageKeyword> method.</para>
                <codeReference>TestIsInstanceOfType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="P:System.Type.IsInterface">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an interface; that is, not a class or a value type.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is an interface; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.ClassSemanticsMask</codeEntityReference> distinguishes a type declaration as class, interface or value type.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an interface, checks for the interface type, and indicates whether a class has the <languageKeyword>IsInterface</languageKeyword> property set.</para>
                <codeReference>Type_IsInterface#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsClass</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsValueType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsLayoutSequential">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the class layout attribute <languageKeyword>SequentialLayout</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the class layout attribute <languageKeyword>SequentialLayout</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.LayoutMask</codeEntityReference> is used to select the class layout attributes. The class layout attributes (<languageKeyword>AutoLayout</languageKeyword>, <languageKeyword>SequentialLayout</languageKeyword> and <languageKeyword>ExplicitLayout</languageKeyword>) define how the fields of the class instance are laid out in memory.</para>
            <para>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics". The documentation is available online at <externalLink><linkText>http://msdn.microsoft.com/net/ecma/</linkText><linkUri>http://msdn.microsoft.com/net/ecma/</linkUri></externalLink> and <externalLink><linkText>http://www.ecma-international.org/publications/standards/Ecma-335.htm</linkText><linkUri>http://www.ecma-international.org/publications/standards/Ecma-335.htm</linkUri></externalLink>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt; </codeInline>(<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an instance of a class for which the <languageKeyword>Sequential</languageKeyword> member of the <languageKeyword>LayoutKind</languageKeyword> enum in the <languageKeyword>StructLayoutAttribute</languageKeyword> class has been set, checks for the property IsLayoutSequential, and displays the result.</para>
                <codeReference>Type_IsLayoutSequential#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsAutoLayout</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsExplicitLayout</codeEntityReference>
          <link xlink:href="3DD13C5D-A508-455B-8DCE-0A852882A5A7">[&lt;topic://cpconmetadataoverview&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsMarshalByRef">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is marshaled by reference.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is marshaled by reference; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates the <languageKeyword>IsContextful</languageKeyword>, <codeEntityReference autoUpgrade="true">P:System.Type.IsMarshalByRef</codeEntityReference>, and <codeEntityReference autoUpgrade="true">P:System.Type.IsPrimitive</codeEntityReference> properties of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</para>
                <codeReference>Type_IsContextful#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsMarshalByRefImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsMarshalByRefImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsMarshalByRef</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is marshaled by reference.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is marshaled by reference; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method can be overridden by a derived class.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example determines whether the given type is marshaled by reference and displays the result.</para>
                <codeReference>Type_IsMarshalByRefImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsMarshalByRef</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNested">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a type whose definition is nested inside the definition of another type.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested inside another type; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">P:System.Type.IsNested</codeEntityReference> property returns <languageKeyword>true</languageKeyword> for all nested types, regardless of visibility. To test for nesting and visibility at the same time, use the related properties <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedAssembly</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedFamily</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedFamANDAssem</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedFamORAssem</codeEntityReference>, <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPrivate</codeEntityReference>, or <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPublic</codeEntityReference>.</para>
            <alert class="note">
              <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> enumeration member selects the visibility attributes for a type.</para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example displays the value of the <codeEntityReference autoUpgrade="true">P:System.Type.IsNested</codeEntityReference> property for both a protected nested class and a public nested class.</para>
                <codeReference>System.Type.IsNested#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedAssembly</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedFamily</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedFamANDAssem</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedFamORAssem</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPrivate</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPublic</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNestedAssembly">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only within its own assembly.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only within its own assembly; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example declares a nested class with visibility in its own assembly, and displays its <languageKeyword>IsNestedAssembly</languageKeyword> property value.</para>
                <codeReference>Type_IsNestedAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNestedFamANDAssem">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only to classes that belong to both its own family and its own assembly.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
            <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object's family is defined as all objects of the exact same <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> and of its subtypes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates a use of the <languageKeyword>IsNestedFamANDAssem</languageKeyword> property.</para>
                <codeReference>type_isnestedfamandassem#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNestedFamily">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only within its own family.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only within its own family; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
            <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object's family is defined as all objects of the exact same <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> and of its subtypes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_IsNestedFamily#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNestedFamORAssem">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only to classes that belong to either its own family or to its own assembly.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
            <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object's family is defined as all objects of the exact same <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> and of its subtypes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example declares a nested class with visibility in its own family or in its own assembly and displays <languageKeyword>IsNestedFamORAssem</languageKeyword> property value of the nested class.</para>
                <codeReference>Type_IsNestedFamORAssem#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNestedPrivate">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and declared private.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is nested and declared private; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example declares a nested class as private and displays the <languageKeyword>IsNestedPrivate</languageKeyword> property value of the nested class.</para>
                <codeReference>Type_IsNestedPrivate#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNestedPublic">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether a class is nested and declared public.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the class is nested and declared public; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example declares a public nested class and displays its <languageKeyword>IsNestedPublic</languageKeyword> property value.</para>
                <codeReference>Type.IsNestedPublic#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsNotPublic">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is not declared public.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is not declared public and is not a nested type; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Do not use with nested types; use <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPublic</codeEntityReference> instead.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property returns <languageKeyword>false</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This example shows the use of <languageKeyword>IsNotPublic</languageKeyword> to get the visibility of the type.</para>
                <codeReference>Classic Type.IsNotPublic Example#1</codeReference>
                <para>This code produces the following output: </para>
                <para>There are 27 members in System.IO.File.</para>
                <para>Is System.IO.File public? False </para>
                <para>The following code example demonstrates why you cannot use <languageKeyword>IsPublic</languageKeyword> and <languageKeyword>IsNotPublic</languageKeyword> for nested classes.</para>
                <codeReference>Classic Type.IsNotPublic Example#2</codeReference>
                <para>For nested classes, ignore the results of <languageKeyword>IsPublic</languageKeyword> and <languageKeyword>IsNotPublic</languageKeyword> and pay attention only to the results of <languageKeyword>IsNestedPublic</languageKeyword> and <languageKeyword>IsNestedPrivate</languageKeyword>. The reflection output for this code fragment would be as follows: </para>
                <table>
                  <tableHeader>
                    <row>
                      <entry>
                        <para>Class </para>
                      </entry>
                      <entry>
                        <para>IsNotPublic </para>
                      </entry>
                      <entry>
                        <para>IsPublic </para>
                      </entry>
                      <entry>
                        <para>IsNestedPublic </para>
                      </entry>
                      <entry>
                        <para>IsNestedPrivate </para>
                      </entry>
                    </row>
                  </tableHeader>
                  <row>
                    <entry>
                      <para>A </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                    <entry>
                      <para>TRUE </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>B </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                    <entry>
                      <para>TRUE </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <para>C </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                    <entry>
                      <para>FALSE </para>
                    </entry>
                    <entry>
                      <para>TRUE </para>
                    </entry>
                  </row>
                </table>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsPointer">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a pointer.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a pointer; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example shows a use of the <languageKeyword>IsPointer</languageKeyword> property.</para>
                <codeReference>Type_HasElementTypeImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsPointerImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsPointerImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsPointer</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a pointer.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a pointer; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsPointer</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsPrimitive">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is one of the primitive types.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is one of the primitive types; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The primitive types are <codeEntityReference autoUpgrade="true">T:System.Boolean</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Byte</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.SByte</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Int16</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.UInt16</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.UInt32</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Int64</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.UInt64</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Char</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Double</codeEntityReference>, and <codeEntityReference autoUpgrade="true">T:System.Single</codeEntityReference>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates the <languageKeyword>IsContextful</languageKeyword>, <codeEntityReference autoUpgrade="true">P:System.Type.IsMarshalByRef</codeEntityReference>, and <codeEntityReference autoUpgrade="true">P:System.Type.IsPrimitive</codeEntityReference> properties of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</para>
                <codeReference>Type_IsContextful#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Boolean</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Byte</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.SByte</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Int16</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.UInt16</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.UInt32</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Int64</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.UInt64</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Char</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Double</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Single</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsPrimitiveImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsPrimitiveImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>When overridden in a derived class, implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsPrimitive</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is one of the primitive types.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is one of the primitive types; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The primitive types are <codeEntityReference autoUpgrade="true">T:System.Boolean</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Byte</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.SByte</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Int16</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.UInt16</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.UInt32</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Int64</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.UInt64</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Char</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System.Double</codeEntityReference>, and <codeEntityReference autoUpgrade="true">T:System.Single</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example determines whether the given type is a primitive type and displays the result.</para>
                <codeReference>Type_IsPrimitiveImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Boolean</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Byte</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.SByte</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Int16</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.UInt16</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.UInt32</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Int64</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.UInt64</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Char</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Double</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Single</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsPrimitive</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsPublic">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is declared public.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is declared public and is not a nested type; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Do not use with nested types; use <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPublic</codeEntityReference> instead.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property returns <languageKeyword>true</languageKeyword>.</para>
            <para>
              <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.TypeAttributes.VisibilityMask</codeEntityReference> selects the visibility attributes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an instance of <languageKeyword>MyTestClass</languageKeyword>, checks for the <languageKeyword>IsPublic</languageKeyword> property, and displays the result.</para>
                <codeReference>Type.IsPublic#1</codeReference>
                <para>For nested classes, ignore the results of <languageKeyword>IsPublic</languageKeyword> and <languageKeyword>IsNotPublic</languageKeyword> and pay attention only to the results of <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPublic</codeEntityReference> and <codeEntityReference autoUpgrade="true">P:System.Type.IsNestedPrivate</codeEntityReference>.</para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsSealed">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is declared sealed.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is declared sealed; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter of a generic type, this property always returns <languageKeyword>true</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an instance of a <languageKeyword>sealed</languageKeyword> class, checks for the <languageKeyword>IsSealed</languageKeyword> property, and displays the result.</para>
                <codeReference>Type_IsSealed#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsSerializable">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is serializable.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is serializable; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates an instance of <languageKeyword>MyTestClass</languageKeyword> class, sets the [Serializable] attribute, and checks the <languageKeyword>IsSerializable</languageKeyword> property for <languageKeyword>true</languageKeyword> or <languageKeyword>false</languageKeyword>.</para>
                <codeReference>Type_IsSerializable#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Runtime.Serialization.ISerializable</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsSpecialName">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> has a name that requires special handling.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> has a name that requires special handling; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This example shows a use of <languageKeyword>IsSpecialName</languageKeyword> to filter internal or private members out of a list.</para>
                <codeReference>Classic Type.IsSpecialName Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsSubclassOf(System.Type)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Determines whether the class represented by the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> derives from the class represented by the specified <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>c</parameterReference>
            <content>
              <para>The <languageKeyword>Type</languageKeyword> to compare with the current <languageKeyword>Type</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <languageKeyword>Type</languageKeyword> represented by the <parameterReference>c</parameterReference> parameter and the current <languageKeyword>Type</languageKeyword> represent classes, and the class represented by the current <languageKeyword>Type</languageKeyword> derives from the class represented by <parameterReference>c</parameterReference>; otherwise, <languageKeyword>false</languageKeyword>. This method also returns <languageKeyword>false</languageKeyword> if <parameterReference>c</parameterReference> and the current <languageKeyword>Type</languageKeyword> represent the same class.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>The <parameterReference>c</parameterReference> parameter is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.IsSubclassOf(System.Type)</codeEntityReference> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface. Use the <codeEntityReference autoUpgrade="true">Overload:System.Type.GetInterface</codeEntityReference> method for that purpose.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Object</codeEntityReference> if it has no class constraint.</para>
            <alert class="note">
              <para>If the <codeEntityReference autoUpgrade="true">M:System.Type.IsSubclassOf(System.Type)</codeEntityReference> is the converse of <codeEntityReference autoUpgrade="true">M:System.Type.IsAssignableFrom(System.Type)</codeEntityReference>. That is, if <codeInline>t1.IsSubclassOf(t2)</codeInline> is <languageKeyword>true</languageKeyword>, then <codeInline>t2.IsAssignableFrom(t1)</codeInline> is also <languageKeyword>true</languageKeyword>.</para>
            </alert>
            <para>This method can be overridden by a derived class.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example demonstrates the use of the <languageKeyword>IsSubclassOf</languageKeyword> method.</para>
                <codeReference>TestIsSubclassOf#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.BaseType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsUnicodeClass">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the string format attribute <languageKeyword>UnicodeClass</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the string format attribute <languageKeyword>UnicodeClass</languageKeyword> is selected for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">F:System.Reflection.TypeAttributes.StringFormatMask</codeEntityReference> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns <languageKeyword>false</languageKeyword>.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsAnsiClass</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsAutoClass</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsValueType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a value type.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a value type; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Value types are those that are represented as sequences of bits; value types are not classes or interfaces. These are referred to as "structs" in some programming languages. Enums are a special case of value types.</para>
            <para>This property returns <languageKeyword>false</languageKeyword> for the <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference> class.</para>
            <para>This property returns true for enumerations, but not for the <codeEntityReference autoUpgrade="true">T:System.Enum</codeEntityReference> type itself. For an example that demonstrates this behavior, see <codeEntityReference autoUpgrade="true">P:System.Type.IsEnum</codeEntityReference>.</para>
            <para>This property is read-only.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example creates a variable of type <languageKeyword>MyEnum</languageKeyword>, checks for the <languageKeyword>IsValueType</languageKeyword> property, and displays the result.</para>
                <codeReference>Type_IsValueType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsClass</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsInterface</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsValueTypeImpl</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsClass</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsInterface</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.IsValueTypeImpl</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.IsValueTypeImpl">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Implements the <codeEntityReference autoUpgrade="true">P:System.Type.IsValueType</codeEntityReference> property and determines whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a value type; that is, not a class or an interface.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a value type; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Value types describe values that are represented as sequences of bits; value types are not classes or interfaces. These are referred to as "structs" in some programming languages. Enums are value types.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>Type_IsValueTypeImpl#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.TypeAttributes</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsClass</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsInterface</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.ValueType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.IsValueType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.IsVisible">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a value indicating whether the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> can be accessed by code outside the assembly.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is a public type or a public nested type such that all the enclosing types are public; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Use this property to determine whether a type is part of the public interface of a component assembly. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example tests two classes, only one of which is visible outside the assembly.</para>
                <codeReference>System.Type.IsVisible#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.MakeArrayType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a one-dimensional array of the current type, with a lower bound of zero.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing a one-dimensional array of the current type, with a lower bound of zero.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.MakeArrayType</codeEntityReference> method provides a way to generate array types whose element types are computed at run time.</para>
            <alert class="note">
              <para>The common language runtime makes a distinction between vectors —one-dimensional arrays that are always zero-based — and multidimensional arrays. This method overload is the only way to create a vector type. You cannot use the <codeEntityReference autoUpgrade="false">M:System.Type.MakeArrayType(System.Int32)</codeEntityReference> method overload to create vector types. </para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example creates array, <languageKeyword>ref</languageKeyword> (<languageKeyword>ByRef</languageKeyword> in Visual Basic), and pointer types for the <codeInline>Test</codeInline> class.</para>
                <codeReference>System.Type.MakeXxxType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeByRefType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakePointerType</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents an array of the current type.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.Type.MakeArrayType(System.Int32)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing an array of the current type, with the specified number of dimensions.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>rank</parameterReference>
            <content>
              <para>The number of dimensions for the array. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing an array of the current type, with the specified number of dimensions.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IndexOutOfRangeException</codeEntityReference>
            <content>
              <para>
                <parameterReference>rank</parameterReference> is invalid. For example, 0 or negative.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.MakeArrayType</codeEntityReference> method provides a way to generate array types whose element types are computed at run time.</para>
            <alert class="note">
              <para>The common language runtime makes a distinction between vectors —one-dimensional arrays that are always zero-based — and multidimensional arrays. You cannot use this method overload to create a vector type; if <parameterReference>rank</parameterReference> is 1, this method overload returns a multidimensional array type that happens to have one dimension. Use the <codeEntityReference autoUpgrade="false">M:System.Type.MakeArrayType</codeEntityReference> method overload to create vector types. </para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example creates array, <languageKeyword>ref</languageKeyword> (<languageKeyword>ByRef</languageKeyword> in Visual Basic), and pointer types for the <codeInline>Test</codeInline> class.</para>
                <codeReference>System.Type.MakeXxxType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeByRefType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakePointerType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.MakeByRefType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents the current type when passed as a <languageKeyword>ref</languageKeyword> parameter (<languageKeyword>ByRef</languageKeyword> parameter in Visual Basic).</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents the current type when passed as a <languageKeyword>ref</languageKeyword> parameter (<languageKeyword>ByRef</languageKeyword> parameter in Visual Basic).</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.MakeByRefType</codeEntityReference> method provides a way to generate <languageKeyword>ref</languageKeyword> types (<languageKeyword>ByRef</languageKeyword> in Visual Basic) for parameter lists.</para>
            <para>Using the syntax of Microsoft intermediate language (MSIL), if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>, this method returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing <codeInline>Int32&amp;</codeInline>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example creates array, <languageKeyword>ref</languageKeyword> (<languageKeyword>ByRef</languageKeyword> in Visual Basic), and pointer types for the <codeInline>Test</codeInline> class.</para>
                <codeReference>System.Type.MakeXxxType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeArrayType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakePointerType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.MakePointerType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents a pointer to the current type.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents a pointer to the current type.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.Type.MakePointerType</codeEntityReference> method provides a way to generate pointer types for parameter lists.</para>
            <para>Using the syntax of Microsoft intermediate language (MSIL), if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>, this method returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object representing <codeInline>Int32*</codeInline>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example creates array, <languageKeyword>ref</languageKeyword> (<languageKeyword>ByRef</languageKeyword> in Visual Basic), and pointer types for the <codeInline>Test</codeInline> class.</para>
                <codeReference>System.Type.MakeXxxType#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeByRefType</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.MakeArrayType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.MemberType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberTypes</codeEntityReference> value indicating that this member is a type or a nested type.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberTypes</codeEntityReference> value indicating that this member is a type or a nested type.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This property overrides <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.MemberInfo.MemberType</codeEntityReference>. Therefore, when you examine a set of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects—for example, the array returned by <codeEntityReference autoUpgrade="true">Overload:System.Type.GetMembers</codeEntityReference>—the <codeEntityReference autoUpgrade="true">P:System.Reflection.MemberInfo.MemberType</codeEntityReference> property returns <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.MemberTypes.NestedType</codeEntityReference> when a given member is a nested type.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents <codeInline>MyGenericType&lt;int&gt;</codeInline> (<codeInline>MyGenericType(Of Integer)</codeInline> in Visual Basic), the value of this property is determined by <codeInline>MyGenericType&lt;T&gt;</codeInline>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property always returns<languageKeyword></languageKeyword><codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Reflection.MemberTypes.TypeInfo</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example shows the <languageKeyword>MemberType</languageKeyword> field as a parameter to the <languageKeyword>GetMember</languageKeyword> method: </para>
                <codeReference>Classic Type.MemberType Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberTypes</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="F:System.Type.Missing">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Represents a missing value in the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> information. This field is read-only.</para>
        </summary>
        <remarks>
          <content>
            <para>Use the <languageKeyword>Missing</languageKeyword> field for invocation through reflection to obtain the default value of a parameter. If the <languageKeyword>Missing</languageKeyword> field is passed in for a parameter value and there is no default value for that parameter, an <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference> is thrown.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example shows the use of the <languageKeyword>Missing</languageKeyword> field to invoke a method with its default arguments.</para>
                <codeReference>Classic Type.Missing Example#1</codeReference>
                <para>This code produces the following output: </para>
                <para>a = 10 b = 55.3 c = 12 </para>
                <para>a = 10 b = 1.3 c = 1 </para>
                <para>a = 10 b = 1.2 c = 1 </para>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Missing</codeEntityReference>
          <link xlink:href="A018A35A-7957-4FBC-A983-5C4D3F5F618B">[&lt;topic://cpconaccessingdefaultargumentvalues&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.Module">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the module (the DLL) in which the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is defined.</para>
        </summary>
        <returnValue>
          <para>The name of the module in which the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> is defined.</para>
        </returnValue>
        <remarks>
          <content>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property returns the module in which the type was defined. For example, if you create an instance of <codeInline>MyGenericStack&lt;int&gt;</codeInline>, the <codeEntityReference autoUpgrade="true">P:System.Type.Module</codeEntityReference> property for the constructed type returns the module in which <codeInline>MyGenericStack&lt;T&gt;</codeInline> is defined.</para>
            <para>Similarly, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic parameter <parameterReference>T</parameterReference>, this property returns the assembly that contains the generic type that defines <parameterReference>T</parameterReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This following example demonstrates a use of the <codeEntityReference autoUpgrade="true">P:System.Type.Namespace</codeEntityReference> and <languageKeyword>Module</languageKeyword> properties and the <codeEntityReference autoUpgrade="true">M:System.Type.ToString</codeEntityReference> method of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
                <codeReference>Type_ToString#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.Module</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.Namespace">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the namespace of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>The namespace of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>, or <languageKeyword>null</languageKeyword> if the current instance represents a generic parameter.</para>
        </returnValue>
        <remarks>
          <content>
            <para>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a constructed generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic parameter <parameterReference>T</parameterReference>, this property returns the namespace that contains the generic type definition that defines <parameterReference>T</parameterReference>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object represents a generic parameter, this property returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This following example demonstrates a use of the <languageKeyword>Namespace</languageKeyword> and <codeEntityReference autoUpgrade="true">P:System.Type.Module</codeEntityReference> properties and the <codeEntityReference autoUpgrade="true">M:System.Type.ToString</codeEntityReference> method of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
                <codeReference>Type_ToString#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.FullName</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.ReflectedType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the class object that was used to obtain this member.</para>
        </summary>
        <returnValue>
          <para>The <languageKeyword>Type</languageKeyword> object through which this <languageKeyword>MemberInfo</languageKeyword> object was obtained.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This property implements the abstract property inherited from <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property returns the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This example displays the reflected type of a method in a derived class. Although the method <languageKeyword>m</languageKeyword> is declared in <languageKeyword>MyClassA</languageKeyword>, its reflected type is obtained from <languageKeyword>MyClassB</languageKeyword>.</para>
                <codeReference>Classic Type.ReflectedType Example#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.DeclaringType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.ToString">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <languageKeyword>String</languageKeyword> representing the name of the current <languageKeyword>Type</languageKeyword>.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference> representing the name of the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, <codeInline>(long)0.Type().ToString()</codeInline> returns "System.Int64" instead of merely "Int64".</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This following example demonstrates a use of the <codeEntityReference autoUpgrade="true">P:System.Type.Namespace</codeEntityReference> and <codeEntityReference autoUpgrade="true">P:System.Type.Module</codeEntityReference> properties and the <languageKeyword>ToString</languageKeyword> method of <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
                <codeReference>Type_ToString#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.TypeHandle">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the handle for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>The handle for the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The .NET Compact Framework does not currently support this property.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>
              <languageKeyword>TypeHandle</languageKeyword> encapsulates a pointer to an internal data structure that represents the type. This handle is unique during the process lifetime. The handle is valid only in the application domain in which it was obtained.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</para>
                <codeReference>Type_TypeHandle#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.RuntimeTypeHandle</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeHandle(System.Object)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.TypeInitializer">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the initializer for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference> containing the name of the class constructor for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Class initializers are also available through the <codeEntityReference autoUpgrade="true">M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</codeEntityReference> method, or through overloads of the <codeEntityReference autoUpgrade="true">Overload:System.Type.GetMember</codeEntityReference>, <codeEntityReference autoUpgrade="true">Overload:System.Type.GetMembers</codeEntityReference>, <codeEntityReference autoUpgrade="true">Overload:System.Type.GetConstructor</codeEntityReference>, and <codeEntityReference autoUpgrade="true">Overload:System.Type.GetConstructors</codeEntityReference> methods that take <codeEntityReference autoUpgrade="true">T:System.Reflection.BindingFlags</codeEntityReference> as a parameter.</para>
            <para>If the current <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> represents a type parameter in the definition of a generic type or generic method, this property returns <languageKeyword>null</languageKeyword>.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.ConstructorInfo</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.UnderlyingSystemType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Indicates the type provided by the common language runtime that represents this type.</para>
        </summary>
        <returnValue>
          <para>The underlying system type for the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.Type.BaseType</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.Type.StructLayoutAttribute">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets a <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.StructLayoutAttribute</codeEntityReference> that describes the layout of the current type.</para>
        </summary>
        <returnValue>
          <para>Gets a <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.StructLayoutAttribute</codeEntityReference> that describes the gross layout features of the current type.</para>
        </returnValue>
        <remarks>
          <content>
            <para>
              <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.StructLayoutAttribute</codeEntityReference> is not returned by the <codeEntityReference autoUpgrade="true">Overload:System.Reflection.MemberInfo.GetCustomAttributes</codeEntityReference> method. Instead, use this property to get it.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class). The example then uses the <codeEntityReference autoUpgrade="true">P:System.Type.StructLayoutAttribute</codeEntityReference> property to obtain a <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.StructLayoutAttribute</codeEntityReference> for each type, and displays the properties of the attributes.</para>
                <codeReference>Type.StructLayoutAttribute#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Runtime.InteropServices.StructLayoutAttribute</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.Type.MakeArrayType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> object that represents an array of the current type.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The name of the <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> to get. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>throwIfNotFound</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to throw a <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference> if the type cannot be found; <languageKeyword>false</languageKeyword> to return <languageKeyword>null</languageKeyword> if the type cannot be found.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ignoreCase</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to perform a case-insensitive search for <parameterReference>typeName</parameterReference>; <languageKeyword>false</languageKeyword> to perform a case-sensitive search for <parameterReference>typeName</parameterReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference> with the specified name, if found; otherwise, <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Reflection.TargetInvocationException</codeEntityReference>
            <content>
              <para>A class initializer is invoked and throws an exception. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>throwIfNotFound</parameterReference> is <languageKeyword>true</languageKeyword> and the type is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is invalid, for example if it contains invalid characters, or if it is a zero-length string. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If the assembly containing the type is not already loaded into the reflection-only context, and the type is assembly-qualified, using the <codeEntityReference autoUpgrade="true">M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)</codeEntityReference> method is equivalent to first loading the assembly for reflection only, using the <codeEntityReference autoUpgrade="true">Overload:System.Reflection.Assembly.ReflectionOnlyLoad</codeEntityReference> method, and then loading the type by calling the assembly's <codeEntityReference qualifyHint="true" autoUpgrade="true">Overload:System.Reflection.Assembly.GetType</codeEntityReference> method. For details on specifying type names, see the <codeEntityReference autoUpgrade="false">M:System.Type.GetType(System.String,System.Boolean,System.Boolean)</codeEntityReference> method overload.</para>
            <para>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</para>
            <para>The <parameterReference>throwIfNotFound</parameterReference> parameter only affects what happens when the type is not found. It does not affect any other exceptions that might be thrown. In particular, if the type is found but cannot be loaded, <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference> can be thrown even if <parameterReference>throwIfNotFound</parameterReference> is <languageKeyword>false</languageKeyword>.</para>
            <para>For more information about using the reflection-only context, see <link xlink:href="9818b660-52f5-423d-a9af-e75163aa7068">How to: Load Assemblies into the Reflection-Only Context</link>.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.String</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
          <codeEntityReference autoUpgrade="true">P:System.Type.AssemblyQualifiedName</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetAssembly(System.Type)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.GetType(System.String)</codeEntityReference>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>
          <link xlink:href="D90B1E39-9115-4F2A-81C0-05E7E74E5580">[&lt;topic://cpconSpecifyingFullyQualifiedTypeNames&gt;]</link>
          <link xlink:href="9818b660-52f5-423d-a9af-e75163aa7068">How to: Load Assemblies into the Reflection-Only Context</link>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.Type.System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Maps a set of names to a corresponding set of dispatch identifiers.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>riid</parameterReference>
            <content>
              <para>Reserved for future use. Must be IID_NULL.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>rgszNames</parameterReference>
            <content>
              <para>Passed-in array of names to be mapped.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>cNames</parameterReference>
            <content>
              <para>Count of the names to be mapped.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>lcid</parameterReference>
            <content>
              <para>The locale context in which to interpret the names.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>rgDispId</parameterReference>
            <content>
              <para>Caller-allocated array which receives the IDs corresponding to the names.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetIDsOfNames</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Provides access to properties and methods exposed by an object.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>dispIdMember</parameterReference>
            <content>
              <para>Identifies the member.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>riid</parameterReference>
            <content>
              <para>Reserved for future use. Must be IID_NULL.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>lcid</parameterReference>
            <content>
              <para>The locale context in which to interpret arguments.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>wFlags</parameterReference>
            <content>
              <para>Flags describing the context of the call.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>pDispParams</parameterReference>
            <content>
              <para>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>pVarResult</parameterReference>
            <content>
              <para>Pointer to the location where the result is to be stored.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>pExcepInfo</parameterReference>
            <content>
              <para>Pointer to a structure that contains exception information.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>puArgErr</parameterReference>
            <content>
              <para>The index of the first argument that has an error.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::Invoke</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>pcTInfo</parameterReference>
            <content>
              <para>Points to a location that receives the number of type information interfaces provided by the object.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetTypeInfoCount</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.Type.System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Retrieves the type information for an object, which can then be used to get the type information for an interface.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>iTInfo</parameterReference>
            <content>
              <para>The type information to return.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>lcid</parameterReference>
            <content>
              <para>The locale identifier for the type information.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ppTInfo</parameterReference>
            <content>
              <para>Receives a pointer to the requested type information object.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetTypeInfo</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
  </members>
</doc>