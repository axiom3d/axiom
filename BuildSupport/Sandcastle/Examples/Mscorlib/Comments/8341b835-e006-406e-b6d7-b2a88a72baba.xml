<?xml version="1.0" encoding="utf-8"?>
<doc xmlns:dev="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" fileAssetGuid="8341b835-e006-406e-b6d7-b2a88a72baba" revisionNumber="46">
  <assembly>
    <name>mscorlib</name>
  </assembly>
  <members>
    <member name="T:System.AppDomain">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Represents an application domain, which is an isolated environment where applications execute. This class cannot be inherited.</para>
        </summary>
        <remarks>
          <content>
            <para>Application domains, which are represented by <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> objects, help provide isolation, unloading, and security boundaries for executing managed code.</para>
            <list class="bullet">
              <listItem>
                <para>Use application domains to isolate tasks that might bring down a process. If the state of the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> that's executing a task becomes unstable, the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> can be unloaded without affecting the process. This is important when a process must run for long periods without restarting. You can also use application domains to isolate tasks that should not share data.</para>
              </listItem>
              <listItem>
                <para>If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running. However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded. Use this technique to minimize the working set of long-running processes that occasionally use large DLLs. </para>
              </listItem>
            </list>
            <para>Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads. Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</para>
            <para>Application domains are created using the <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)</codeEntityReference> method. <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> instances are used to load and execute assemblies (<codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>). When an <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> is no longer in use, it can be unloaded.</para>
            <para>The <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</para>
            <para>For more information on using application domains, see <link xlink:href="39E57D07-A740-4CD4-AE82-E119EA3856C1">Application Domains</link>.</para>
            <para>This class implements the <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, <codeEntityReference autoUpgrade="true">T:System._AppDomain</codeEntityReference>, and <codeEntityReference autoUpgrade="true">T:System.Security.IEvidenceFactory</codeEntityReference> interfaces.</para>
            <para>You should never create a remotable wrapper for an <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> object. Doing so could publish a remote reference to that <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference>, exposing methods such as <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.CreateInstance</codeEntityReference> to remote access and effectively destroying code access security for that <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference>. Malicious clients connecting to the remoted <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> could obtain access to any resource the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> itself has access to. Do not create remotable wrappers for any type that extends <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference> and that implements methods that could be used by malicious clients to bypass the security system.</para>
            <alert class="caution">
              <para>The default value for the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.AppDomainSetup.DisallowCodeDownload</codeEntityReference> property is <languageKeyword>false</languageKeyword>. This setting is unsafe for services. To prevent services from downloading partially trusted code, set this property to <languageKeyword>true</languageKeyword>.</para>
            </alert>
          </content>
        </remarks>
        <platformNotes>
          <platformNote>
            <platforms>
              <platform>NETCF</platform>
            </platforms>
            <content>
              <para>Loading assemblies into a domain neutral code area for use by multiple application domains is not supported.</para>
            </content>
          </platformNote>
        </platformNotes>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>This example shows how to create a new <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference>, instantiate a type in that new <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference>, and communicate with that typeâ€™s object. In addition, this example shows how to unload the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> causing the object to be garbage collected.</para>
                <codeReference>AppDomainX#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.AppendPrivatePath(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Appends the specified name of the directory to the private path.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>path</parameterReference>
            <content>
              <para>The name of the directory to be appended to the private path. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADAppendPrivatePath#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to use this method. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.AssemblyLoad">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when an assembly is loaded.</para>
        </summary>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">T:System.AssemblyLoadEventHandler</codeEntityReference> delegate for this event indicates what assembly was loaded.</para>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference> is thrown.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyLoad</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_AssemblyLoad#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>.</para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.AssemblyResolve">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when the resolution of an assembly fails.</para>
        </summary>
        <remarks>
          <content>
            <para>It is the responsibility of <codeEntityReference autoUpgrade="true">T:System.ResolveEventHandler</codeEntityReference> for this event to return the assembly that resolves the type, assembly, or resource.</para>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference> is thrown.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AssemblyResolve#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.BaseDirectory">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the base directory that the assembly resolver used to probe for assemblies.</para>
        </summary>
        <returnValue>
          <para>The base directory that the assembly resolver uses to probe for assemblies.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This property corresponds to the assembly resolver's APPBASE.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADSetup#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself, including if the path is in the form "file://" or \\UNC\dir or "c:\". Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ClearPrivatePath">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Resets the path that specifies the location of private assemblies to the empty string ("").</para>
        </summary>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</para>
            <para>For more information, see <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.AppDomainSetup.PrivateBinPath</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADClearPrivatePath#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.String.Empty</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ClearShadowCopyPath">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Resets the list of directories containing shadow copied assemblies to the empty string ("").</para>
        </summary>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The shadow copy path is a list of directories where shadow copied assemblies are stored.</para>
            <para>For more information, see <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.AppDomainSetup.ShadowCopyDirectories</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADShadowCopy#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.String.Empty</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of a specified COM type. Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The name of a file containing an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The name of the requested type. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance specified by <parameterReference>typeName</parameterReference>. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>The type cannot be loaded. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No public parameterless constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MemberAccessException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is an abstract class. </para>
              <para>-or-</para>
              <para>This member was invoked with a late-binding mechanism. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is an empty string (""). </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Use this method to create objects remotely without having to load the type locally.</para>
            <para>The return value must to be unwrapped to access the real object.</para>
            <para>A <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Runtime.InteropServices.ComVisibleAttribute</codeEntityReference> attribute with a value of <languageKeyword>true</languageKeyword> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference> is thrown.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates </para>
                <codeReference>AppDomain_CreateComInstanceFrom#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateComInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Creates a new instance of a specified COM type.</para>
        </summary>
        <remarks>
          <content>
          </content>
        </remarks>
      </overload>
</dduexml>
    </member>
    <member name="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of a specified COM type. Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of a file containing an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The name of the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>hashValue</parameterReference>
            <content>
              <para>Represents the value of the computed hash code. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>hashAlgorithm</parameterReference>
            <content>
              <para>Represents the hash algorithm used by the assembly manifest. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance specified by <parameterReference>typeName</parameterReference>. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>The type cannot be loaded. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No public parameterless constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MemberAccessException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> is an abstract class. </para>
              <para>-or-</para>
              <para>This member was invoked with a late-binding mechanism. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is the empty string (""). </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Use this method to create objects remotely without having to load the type locally.</para>
            <para>The return value must to be unwrapped to access the real object.</para>
            <para>A <codeEntityReference qualifyHint="true" autoUpgrade="true">T:System.Runtime.InteropServices.ComVisibleAttribute</codeEntityReference> attribute with a value of <languageKeyword>true</languageKeyword> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference> is thrown.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateComInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateDomain(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new application domain with the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>friendlyName</parameterReference>
            <content>
              <para>The friendly name of the domain. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The newly created application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>friendlyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <parameterReference>friendlyName</parameterReference> parameter is intended to identify the domain in a manner that is meaningful to humans. This string should be suitable for display in user interfaces.</para>
            <para>This method overload uses the <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> information from the default application domain.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates, in general, how to create a domain using one of the <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)</codeEntityReference> overloads.</para>
                <codeReference>AppDomain_Setup#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.AppDomain.FriendlyName</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Creates a new application domain.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new application domain with the given name using the supplied evidence.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>friendlyName</parameterReference>
            <content>
              <para>The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.FriendlyName</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityInfo</parameterReference>
            <content>
              <para>Evidence mapped through the security policy to establish a top-of-stack permission set. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The newly created application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>friendlyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method overload uses the <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> information from the default application domain.</para>
            <para>If <parameterReference>securityInfo</parameterReference> is not supplied, the evidence from the current application domain is used.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates, in general, how to create a domain using one of the <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)</codeEntityReference> overloads.</para>
                <codeReference>AppDomain_Setup#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="Overload:System.AppDomain.CreateDomain">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new application domain.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new application domain using the specified name, evidence, and application domain setup information.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>friendlyName</parameterReference>
            <content>
              <para>The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.FriendlyName</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityInfo</parameterReference>
            <content>
              <para>Evidence mapped through the security policy to establish a top-of-stack permission set. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>info</parameterReference>
            <content>
              <para>An object that contains application domain initialization information. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The newly created application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>friendlyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If <parameterReference>info</parameterReference> is not supplied, this method overload uses the <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> information from the default application domain.</para>
            <para>If <parameterReference>securityInfo</parameterReference> is not supplied, the evidence from the current application domain is used.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates, in general, how to create a domain using one of the <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)</codeEntityReference> overloads.</para>
                <codeReference>AppDomain_Setup#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference>. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>friendlyName</parameterReference>
            <content>
              <para>The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.FriendlyName</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityInfo</parameterReference>
            <content>
              <para>Evidence mapped through the security policy to establish a top-of-stack permission set. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>appBasePath</parameterReference>
            <content>
              <para>The base directory that the assembly resolver uses to probe for assemblies. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.BaseDirectory</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>appRelativeSearchPath</parameterReference>
            <content>
              <para>The path relative to the base directory where the assembly resolver should probe for private assemblies. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.RelativeSearchPath</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>shadowCopyFiles</parameterReference>
            <content>
              <para>If <languageKeyword>true</languageKeyword>, a shadow copy of an assembly is loaded into this application domain. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.ShadowCopyFiles</codeEntityReference>.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The newly created application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>friendlyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If <parameterReference>securityInfo</parameterReference> is not supplied, the evidence from the current application domain is used.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates, in general, how to create a domain using one of the <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)</codeEntityReference> overloads.</para>
                <codeReference>AppDomain_Setup#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain. Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>friendlyName</parameterReference>
            <content>
              <para>The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.FriendlyName</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityInfo</parameterReference>
            <content>
              <para>Evidence mapped through the security policy to establish a top-of-stack permission set. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>appBasePath</parameterReference>
            <content>
              <para>The base directory that the assembly resolver uses to probe for assemblies. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.BaseDirectory</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>appRelativeSearchPath</parameterReference>
            <content>
              <para>The path relative to the base directory where the assembly resolver should probe for private assemblies. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.RelativeSearchPath</codeEntityReference>. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>shadowCopyFiles</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to load a shadow copy of an assembly into the application domain. For more information, see <codeEntityReference autoUpgrade="true">P:System.AppDomain.ShadowCopyFiles</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>adInit</parameterReference>
            <content>
              <para>An <codeEntityReference autoUpgrade="true">T:System.AppDomainInitializer</codeEntityReference> delegate that represents a callback method to invoke when the new <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> object is initialized.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>adInitArgs</parameterReference>
            <content>
              <para>An array of string arguments to be passed to the callback represented by <parameterReference>adInit</parameterReference>, when the new <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> object is initialized.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The newly created application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>friendlyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The method represented by <parameterReference>adInit</parameterReference> is executed in the context of the newly created application domain.</para>
            <para>If <parameterReference>securityInfo</parameterReference> is not supplied, the evidence from the current application domain is used.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>friendlyName</parameterReference>
            <content>
              <para>The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see the description of <codeEntityReference autoUpgrade="true">P:System.AppDomain.FriendlyName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityInfo</parameterReference>
            <content>
              <para>Evidence mapped through the security policy to establish a top-of-stack permission set.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>info</parameterReference>
            <content>
              <para>An object that contains application domain initialization information.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>grantSet</parameterReference>
            <content>
              <para>A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>fullTrustAssemblies</parameterReference>
            <content>
              <para>An array of strong names representing assemblies to be considered fully trusted in the new application domain.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The newly created application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>friendlyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>If <parameterReference>securityInfo</parameterReference> is not supplied, the evidence from the current application domain is used.</para>
            <para>The information provided for <parameterReference>grantSet</parameterReference> and <parameterReference>fullTrustAssemblies</parameterReference> is used to create an <codeEntityReference autoUpgrade="true">T:System.Security.Policy.ApplicationTrust</codeEntityReference> object for the new application domain.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstance(System.String,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance specified by <parameterReference>typeName</parameterReference>. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No matching public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typename</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>See <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> for the format of <parameterReference>assemblyName</parameterReference>.</para>
            <para>An attempt to call <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is not <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, when this method attempts to return the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Creates a new instance of a specified type defined in a specified assembly.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.AppDomain.CreateInstance">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of a specified type defined in a specified assembly.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly. Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ignoreCase</parameterReference>
            <content>
              <para>A Boolean value specifying whether to perform a case-sensitive search or not. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A combination of zero or more bit flags that affect the search for the <parameterReference>typeName</parameterReference> constructor. If <parameterReference>bindingAttr</parameterReference> is zero, a case-sensitive search for public constructors is conducted. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects using reflection. If <parameterReference>binder</parameterReference> is null, the default binder is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <parameterReference>args</parameterReference> must be an empty array or null. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>culture</parameterReference>
            <content>
              <para>Culture-specific information that governs the coercion of <parameterReference>args</parameterReference> to the formal types declared for the <parameterReference>typeName</parameterReference> constructor. If <parameterReference>culture</parameterReference> is <languageKeyword>null</languageKeyword>, the <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference> for the current thread is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>One or more attributes that can participate in activation. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityAttributes</parameterReference>
            <content>
              <para>Information used to authorize creation of <parameterReference>typeName</parameterReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance specified by <parameterReference>typeName</parameterReference>. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No matching constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typename</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>See <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> for the format of <parameterReference>assemblyName</parameterReference>.</para>
            <para>An attempt to call <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is not <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, when this method attempts to return the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for the ability to invoke operations on all type members. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly. A parameter specifies an array of activation attributes.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>One or more attributes that can participate in activation. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance specified by <parameterReference>typeName</parameterReference>. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No matching public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typename</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>See <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> for the format of <parameterReference>assemblyName</parameterReference>.</para>
            <para>An attempt to call <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is not <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, when this method attempts to return the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for the ability to invoke operations on all type members. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type. Parameters specify the assembly where the type is defined, and the name of the type.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An instance of the object specified by <parameterReference>typeName</parameterReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No matching public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typename</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This is a convenience method that combines <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Runtime.Remoting.ObjectHandle.Unwrap</codeEntityReference>. This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>See <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> for the format of <parameterReference>assemblyName</parameterReference>. See the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property for the format of <parameterReference>typeName</parameterReference>.</para>
            <alert class="note">
              <para>If you make an early-bound call to a method <codeInline>M</codeInline> of an object of type <codeInline>T1</codeInline> that was returned by <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)</codeEntityReference>, and that method makes an early-bound call to a method of an object of type <codeInline>T2</codeInline> in an assembly <codeInline>C</codeInline> other than the current assembly or the assembly containing <codeInline>T1</codeInline>, assembly <codeInline>C</codeInline> is loaded into the current application domain. This loading occurs even if the early-bound call to <codeInline>T1.M()</codeInline> was made in the body of a <codeEntityReference autoUpgrade="true">T:System.Reflection.Emit.DynamicMethod</codeEntityReference>, or in other dynamically generated code. If the current domain is the default domain, assembly <codeInline>C</codeInline> cannot be unloaded until the process ends. If the current domain later attempts to load assembly <codeInline>C</codeInline>, the load might fail. </para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADDyno#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if code base is supplied by a configuration file. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Creates a new instance of a specified type.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.AppDomain.CreateInstanceAndUnwrap">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of a specified type.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type. Parameters specify the name of the type, and how it is found and created.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ignoreCase</parameterReference>
            <content>
              <para>A Boolean value specifying whether to perform a case-sensitive search or not. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A combination of zero or more bit flags that affect the search for the <parameterReference>typeName</parameterReference> constructor. If <parameterReference>bindingAttr</parameterReference> is zero, a case-sensitive search for public constructors is conducted. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects using reflection. If <parameterReference>binder</parameterReference> is null, the default binder is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <parameterReference>args</parameterReference> must be an empty array or null. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>culture</parameterReference>
            <content>
              <para>A culture-specific object used to govern the coercion of types. If <parameterReference>culture</parameterReference> is <languageKeyword>null</languageKeyword>, the <languageKeyword>CultureInfo</languageKeyword> for the current thread is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>An array of one or more attributes that can participate in activation. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityAttributes</parameterReference>
            <content>
              <para>Information used to authorize creation of <parameterReference>typeName</parameterReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An instance of the object specified by <parameterReference>typeName</parameterReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No matching constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typename</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This is a convenience method that combines <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Runtime.Remoting.ObjectHandle.Unwrap</codeEntityReference>. This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>See <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> for the format of <parameterReference>assemblyName</parameterReference>. See the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property for the format of <parameterReference>typeName</parameterReference>.</para>
            <alert class="note">
              <para>If you make an early-bound call to a method <codeInline>M</codeInline> of an object of type <codeInline>T1</codeInline> that was returned by <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)</codeEntityReference>, and that method makes an early-bound call to a method of an object of type <codeInline>T2</codeInline> in an assembly <codeInline>C</codeInline> other than the current assembly or the assembly containing <codeInline>T1</codeInline>, assembly <codeInline>C</codeInline> is loaded into the current application domain. This loading occurs even if the early-bound call to <codeInline>T1.M()</codeInline> was made in the body of a <codeEntityReference autoUpgrade="true">T:System.Reflection.Emit.DynamicMethod</codeEntityReference>, or in other dynamically generated code. If the current domain is the default domain, assembly <codeInline>C</codeInline> cannot be unloaded until the process ends. If the current domain later attempts to load assembly <codeInline>C</codeInline>, the load might fail. </para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the use of the <parameterReference>ignoreCase</parameterReference> parameter.</para>
                <codeReference>AppDomain_CreateInstance_IgnoreCase#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for the ability to invoke operations on all type members. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type. Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>An array containing one or more attributes that can participate in activation. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An instance of the object specified by <parameterReference>typeName</parameterReference>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> or <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No matching public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typename</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This is a convenience method that combines <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Runtime.Remoting.ObjectHandle.Unwrap</codeEntityReference>. This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>See <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> for the format of <parameterReference>assemblyName</parameterReference>. See the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property for the format of <parameterReference>typeName</parameterReference>.</para>
            <alert class="note">
              <para>If you make an early-bound call to a method <codeInline>M</codeInline> of an object of type <codeInline>T1</codeInline> that was returned by <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)</codeEntityReference>, and that method makes an early-bound call to a method of an object of type <codeInline>T2</codeInline> in an assembly <codeInline>C</codeInline> other than the current assembly or the assembly containing <codeInline>T1</codeInline>, assembly <codeInline>C</codeInline> is loaded into the current application domain. This loading occurs even if the early-bound call to <codeInline>T1.M()</codeInline> was made in the body of a <codeEntityReference autoUpgrade="true">T:System.Reflection.Emit.DynamicMethod</codeEntityReference>, or in other dynamically generated code. If the current domain is the default domain, assembly <codeInline>C</codeInline> cannot be unloaded until the process ends. If the current domain later attempts to load assembly <codeInline>C</codeInline>, the load might fail. </para>
            </alert>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADDyno#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to call unmanaged code when creating an instance of a delegate. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.ReflectionPermission</codeEntityReference>
            <content>
              <para>for the ability to invoke operations on all type members. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess</codeEntityReference></para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstance(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of a file that contains an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Type.FullName</codeEntityReference> property. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance, or <languageKeyword>null</languageKeyword> if <parameterReference>typeName</parameterReference> is not found. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> was not found in <parameterReference>assemblyFile</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No parameterless public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have sufficient permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The default constructor for <parameterReference>typeName</parameterReference> is invoked.</para>
            <para>For more information, see the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference> method.</para>
            <para>An attempt to call <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceFrom(System.String,System.String)</codeEntityReference> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is not <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, when this method attempts to return the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Creates a new instance of a specified type defined in the specified assembly file.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.AppDomain.CreateInstanceFrom">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of a specified type defined in the specified assembly file.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of a file that contains an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ignoreCase</parameterReference>
            <content>
              <para>A Boolean value specifying whether to perform a case-sensitive search or not. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A combination of zero or more bit flags that affect the search for the <parameterReference>typeName</parameterReference> constructor. If <parameterReference>bindingAttr</parameterReference> is zero, a case-sensitive search for public constructors is conducted. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects through reflection. If <parameterReference>binder</parameterReference> is null, the default binder is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <parameterReference>args</parameterReference> must be an empty array or null. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>culture</parameterReference>
            <content>
              <para>Culture-specific information that governs the coercion of <parameterReference>args</parameterReference> to the formal types declared for the <parameterReference>typeName</parameterReference> constructor. If <parameterReference>culture</parameterReference> is <languageKeyword>null</languageKeyword>, the <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference> for the current thread is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>One or more attributes that can participate in activation. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityAttributes</parameterReference>
            <content>
              <para>Information used to authorize creation of <parameterReference>typeName</parameterReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance, or <languageKeyword>null</languageKeyword> if <parameterReference>typeName</parameterReference> is not found. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> was not found in <parameterReference>assemblyFile</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No parameterless public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have sufficient permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference> method.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of a file that contains an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>One or more attributes that can participate in activation. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>An object that is a wrapper for the new instance, or <languageKeyword>null</languageKeyword> if <parameterReference>typeName</parameterReference> is not found. The return value needs to be unwrapped to access the real object.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> was not found in <parameterReference>assemblyFile</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have sufficient permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No matching public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The default constructor for <parameterReference>typeName</parameterReference> is invoked.</para>
            <para>For more information, see the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference> method.</para>
            <para>An attempt to call <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceFrom(System.String,System.String)</codeEntityReference> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is not <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, when this method attempts to return the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The name of a file that contains an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The requested object, or <languageKeyword>null</languageKeyword> if <parameterReference>typeName</parameterReference> is not found.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No parameterless public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have sufficient permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This is a convenience method that combines <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceFrom(System.String,System.String)</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Runtime.Remoting.ObjectHandle.Unwrap</codeEntityReference>. This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>For more information, see the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference> method.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Creates a new instance of a specified type defined in the specified assembly file.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.AppDomain.CreateInstanceFromAndUnwrap">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of a specified type defined in the specified assembly file.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The name of a file that contains an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ignoreCase</parameterReference>
            <content>
              <para>A Boolean value specifying whether to perform a case-sensitive search or not. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>bindingAttr</parameterReference>
            <content>
              <para>A combination of zero or more bit flags that affect the search for the <parameterReference>typeName</parameterReference> constructor. If <parameterReference>bindingAttr</parameterReference> is zero, a case-sensitive search for public constructors is conducted. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>binder</parameterReference>
            <content>
              <para>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <codeEntityReference autoUpgrade="true">T:System.Reflection.MemberInfo</codeEntityReference> objects through reflection. If <parameterReference>binder</parameterReference> is null, the default binder is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <parameterReference>args</parameterReference> must be an empty array or null. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>culture</parameterReference>
            <content>
              <para>Culture-specific information that governs the coercion of <parameterReference>args</parameterReference> to the formal types declared for the <parameterReference>typeName</parameterReference> constructor. If <parameterReference>culture</parameterReference> is <languageKeyword>null</languageKeyword>, the <codeEntityReference autoUpgrade="true">T:System.Globalization.CultureInfo</codeEntityReference> for the current thread is used. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>One or more attributes that can participate in activation. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityAttributes</parameterReference>
            <content>
              <para>Information used to authorize creation of <parameterReference>typeName</parameterReference>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The requested object, or <languageKeyword>null</languageKeyword> if <parameterReference>typeName</parameterReference> is not found.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No parameterless public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have sufficient permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This is a convenience method that combines <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceFrom(System.String,System.String)</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Runtime.Remoting.ObjectHandle.Unwrap</codeEntityReference>.</para>
            <para>For more information, see the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference> method.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The name of a file that contains an assembly that defines the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>typeName</parameterReference>
            <content>
              <para>The fully qualified name of the requested type. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>activationAttributes</parameterReference>
            <content>
              <para>One or more attributes that can participate in activation. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The requested object, or <languageKeyword>null</languageKeyword> if <parameterReference>typeName</parameterReference> is not found.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>
                <parameterReference>typeName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotSupportedException</codeEntityReference>
            <content>
              <para>The caller cannot provide activation attributes for an object that does not inherit from <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> was not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.TypeLoadException</codeEntityReference>
            <content>
              <para>
                <parameterReference>typeName</parameterReference> was not found in <parameterReference>assemblyName</parameterReference>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MissingMethodException</codeEntityReference>
            <content>
              <para>No parameterless public constructor was found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.MethodAccessException</codeEntityReference>
            <content>
              <para>The caller does not have sufficient permission to call this constructor. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This is a convenience method that combines <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateInstanceFrom(System.String,System.String)</codeEntityReference> and <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Runtime.Remoting.ObjectHandle.Unwrap</codeEntityReference>. This method calls the default constructor for <parameterReference>typeName</parameterReference>.</para>
            <para>For more information, see the <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference> method.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermissionAccess</codeEntityReference>
            <content>
              <para>for the ability to read the file containing the assembly manifest. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference></para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for the ability to access the location of the assembly if the assembly is not local. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Activator.CreateInstanceFrom(System.String,System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.CurrentDomain">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the current application domain for the current <codeEntityReference autoUpgrade="true">T:System.Threading.Thread</codeEntityReference>.</para>
        </summary>
        <returnValue>
          <para>The current application domain.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADApplicationBase#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly with the specified name and access mode.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The access mode for the dynamic assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>The caller does not have the required permission.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      <overload>
        <summary>
          <para>Defines a dynamic assembly in the current application domain.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="Overload:System.AppDomain.DefineDynamicAssembly">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly in the current application domain.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, and permission requests.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>requiredPermissions</parameterReference>
            <content>
              <para>The required permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>optionalPermissions</parameterReference>
            <content>
              <para>The optional permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>refusedPermissions</parameterReference>
            <content>
              <para>The refused permissions request. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload .</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, and evidence.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>evidence</parameterReference>
            <content>
              <para>The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Only fully trusted callers can supply their <parameterReference>evidence</parameterReference> when defining a dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>. The runtime will map the <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <parameterReference>evidence</parameterReference>. If <parameterReference>evidence</parameterReference> is <languageKeyword>null</languageKeyword>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> to the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> being defined and marks policy as resolved.</para>
            <para>If the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> was saved.</para>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>evidence</parameterReference>
            <content>
              <para>The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>requiredPermissions</parameterReference>
            <content>
              <para>The required permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>optionalPermissions</parameterReference>
            <content>
              <para>The optional permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>refusedPermissions</parameterReference>
            <content>
              <para>The refused permissions request. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Only fully trusted callers can supply their <parameterReference>evidence</parameterReference> when defining a dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>. The runtime will map the <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <parameterReference>evidence</parameterReference>. If <parameterReference>evidence</parameterReference> is <languageKeyword>null</languageKeyword>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> to the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> being defined and marks policy as resolved.</para>
            <para>If the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> was saved.</para>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, and storage directory.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>dir</parameterReference>
            <content>
              <para>The name of the directory where the assembly will be saved. If <parameterReference>dir</parameterReference> is <languageKeyword>null</languageKeyword>, the directory defaults to the current directory. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>dir</parameterReference>
            <content>
              <para>The name of the directory where the assembly will be saved. If <parameterReference>dir</parameterReference> is <languageKeyword>null</languageKeyword>, the directory defaults to the current directory. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>requiredPermissions</parameterReference>
            <content>
              <para>The required permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>optionalPermissions</parameterReference>
            <content>
              <para>The optional permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>refusedPermissions</parameterReference>
            <content>
              <para>The refused permissions request. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>dir</parameterReference>
            <content>
              <para>The name of the directory where the assembly will be saved. If <parameterReference>dir</parameterReference> is <languageKeyword>null</languageKeyword>, the directory defaults to the current directory. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>evidence</parameterReference>
            <content>
              <para>The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Only fully trusted callers can supply their <parameterReference>evidence</parameterReference> when defining a dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>. The runtime will map the <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <parameterReference>evidence</parameterReference>. If <parameterReference>evidence</parameterReference> is <languageKeyword>null</languageKeyword>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> to the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> being defined and marks policy as resolved.</para>
            <para>If the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> was saved.</para>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>dir</parameterReference>
            <content>
              <para>The name of the directory where the assembly will be saved. If <parameterReference>dir</parameterReference> is <languageKeyword>null</languageKeyword>, the directory defaults to the current directory. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>evidence</parameterReference>
            <content>
              <para>The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>requiredPermissions</parameterReference>
            <content>
              <para>The required permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>optionalPermissions</parameterReference>
            <content>
              <para>The optional permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>refusedPermissions</parameterReference>
            <content>
              <para>The refused permissions request. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Only fully trusted callers can supply their <parameterReference>evidence</parameterReference> when defining a dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>. The runtime will map the <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <parameterReference>evidence</parameterReference>. If <parameterReference>evidence</parameterReference> is <languageKeyword>null</languageKeyword>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> to the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> being defined and marks policy as resolved.</para>
            <para>If the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> was saved.</para>
            <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. For example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The unique identity of the dynamic assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>access</parameterReference>
            <content>
              <para>The mode in which the dynamic assembly will be accessed. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>dir</parameterReference>
            <content>
              <para>The name of the directory where the dynamic assembly will be saved. If <parameterReference>dir</parameterReference> is <languageKeyword>null</languageKeyword>, the directory defaults to the current directory. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>evidence</parameterReference>
            <content>
              <para>The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>requiredPermissions</parameterReference>
            <content>
              <para>The required permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>optionalPermissions</parameterReference>
            <content>
              <para>The optional permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>refusedPermissions</parameterReference>
            <content>
              <para>The refused permissions request. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>isSynchronized</parameterReference>
            <content>
              <para>
                <languageKeyword>true</languageKeyword> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <languageKeyword>false</languageKeyword>. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>Represents the dynamic assembly created.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentException</codeEntityReference>
            <content>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
              <para>-or- </para>
              <para>The <languageKeyword>Name</languageKeyword> property of <parameterReference>name</parameterReference> begins with white space, or contains a forward or backward slash. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Only fully trusted callers can supply their evidence when defining a dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>. The runtime will map the <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> through the security policy to determine the granted permissions. Partially trusted callers must supply <languageKeyword>null</languageKeyword> for the <parameterReference>evidence</parameterReference> parameter. If <parameterReference>evidence</parameterReference> is <languageKeyword>null</languageKeyword>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> to the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> being defined and marks policy as resolved.</para>
            <para>If the dynamic <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> was saved.</para>
            <para>The <parameterReference>name</parameterReference> parameter indirectly specifies a <codeEntityReference autoUpgrade="true">T:System.Version</codeEntityReference> object (as an <codeEntityReference autoUpgrade="true">M:System.OperatingSystem.#ctor(System.PlatformID,System.Version)</codeEntityReference> constructor parameter). However, this method only persists the major and minor version numbers, not the build and revision numbers. That is, for example, if the <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.LoadFrom(System.String)</codeEntityReference> method is used to indirectly recover the <languageKeyword>Version</languageKeyword> object for this assembly, only that object's major and minor version numbers will be as originally specified.</para>
            <para>If <parameterReference>isSynchronized</parameterReference> is <languageKeyword>true</languageKeyword>, the following methods of the resulting <codeEntityReference autoUpgrade="true">T:System.Reflection.Emit.AssemblyBuilder</codeEntityReference> will be synchronized: <codeEntityReference autoUpgrade="true">Overload:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule</codeEntityReference>, <codeEntityReference autoUpgrade="true">Overload:System.Reflection.Emit.AssemblyBuilder.DefineResource</codeEntityReference>, <codeEntityReference autoUpgrade="true">Overload:System.Reflection.Emit.AssemblyBuilder.AddResourceFile</codeEntityReference>, <codeEntityReference autoUpgrade="true">M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)</codeEntityReference>, <codeEntityReference autoUpgrade="true">Overload:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint</codeEntityReference>, and <codeEntityReference autoUpgrade="true">Overload:System.Reflection.Emit.AssemblyBuilder.Save</codeEntityReference>. If two of these methods are called on different threads, one will block until the other completes.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</codeEntityReference> method and <codeEntityReference autoUpgrade="true">E:System.AppDomain.AssemblyResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_DefineDynamicAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the code in another application domain that is identified by the specified delegate.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>callBackDelegate</parameterReference>
            <content>
              <para>A delegate that specifies a method to call. </para>
            </content>
          </parameter>
        </parameters>
        <remarks>
          <content>
            <para>
              <parameterReference>callBackDelegate</parameterReference> can specify a marshal-by-value, <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, or <codeEntityReference autoUpgrade="true">T:System.ContextBoundObject</codeEntityReference>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates using a static <codeEntityReference autoUpgrade="true">M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)</codeEntityReference> method.</para>
                <codeReference>AppDomain_DoCallBack#1</codeReference>
                <para>The following sample demonstrates using the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)</codeEntityReference> method by value.</para>
                <codeReference>AppDomain_DoCallBack#2</codeReference>
                <para>The following sample demonstrates using the <codeEntityReference autoUpgrade="true">M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)</codeEntityReference> method by reference.</para>
                <codeReference>AppDomain_DoCallBack#3</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.DomainUnload">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when an <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> is about to be unloaded.</para>
        </summary>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">T:System.EventHandler</codeEntityReference> delegate for this event can perform any termination activities before the application domain is unloaded.</para>
            <para>Each application domain that needs to perform processing when it is unloaded should register an event handler for this event. A shared event handler should not be used, because the <codeEntityReference autoUpgrade="true">T:System.EventHandler</codeEntityReference> delegate does not identify the domain that is being unloaded.</para>
            <alert class="note">
              <para>This event is never raised in the default application domain.</para>
            </alert>
            <para>Do not make assumptions about the thread the event is raised on. The event can be raised on a different thread than the one that called the <codeEntityReference autoUpgrade="true">M:System.AppDomain.Unload(System.AppDomain)</codeEntityReference> method.</para>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference> is thrown.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.DynamicDirectory">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the directory that the assembly resolver used to probe for dynamically-created assemblies.</para>
        </summary>
        <returnValue>
          <para>Get the directory that the assembly resolver uses to probe for dynamically-created assemblies.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This property is only available after an attempt has been made to load an assembly into this domain.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADDynamicBase#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to the path information. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.Evidence">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> associated with this application domain that is used as input to the security policy.</para>
        </summary>
        <returnValue>
          <para>Gets the <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> associated with this application domain that is used as input to the security policy.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADCreateDomain#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssembly(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the assembly contained in the specified file.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of the file that contains the assembly to execute. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
            <para>To create the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> to load and execute, use the <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)</codeEntityReference> method.</para>
          </content>
        </remarks>
        <platformNotes>
          <platformNote>
            <platforms>
              <platform>NETCF</platform>
            </platforms>
            <content>
              <para>Loading assemblies into a domain neutral code area for use by multiple application domains is not supported.</para>
            </content>
          </platformNote>
        </platformNotes>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates using one of the overloads of <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssembly(System.String)</codeEntityReference> on two different domains.</para>
                <codeReference>AppDomain_ExecuteAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      <overload>
        <summary>
          <para>Executes the assembly contained in the specified file.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the assembly contained in the specified file, using the specified evidence.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of the file that contains the assembly to execute. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>Evidence for loading the assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>The <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssembly(System.String)</codeEntityReference> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          </content>
        </remarks>
        <platformNotes>
          <platformNote>
            <platforms>
              <platform>NETCF</platform>
            </platforms>
            <content>
              <para>Loading assemblies into a domain neutral code area for use by multiple application domains is not supported.</para>
            </content>
          </platformNote>
        </platformNotes>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates using one of the overloads of <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssembly(System.String)</codeEntityReference> on two different domains.</para>
                <codeReference>AppDomain_ExecuteAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for reading a URI that does not begin with "file://". </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="Overload:System.AppDomain.ExecuteAssembly">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the assembly contained in the specified file.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the assembly contained in the specified file, using the specified evidence and arguments.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of the file that contains the assembly to execute. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>The supplied evidence for the assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>The arguments to the entry point of the assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          </content>
        </remarks>
        <platformNotes>
          <platformNote>
            <platforms>
              <platform>NETCF</platform>
            </platforms>
            <content>
              <para>Loading assemblies into a domain neutral code area for use by multiple application domains is not supported.</para>
            </content>
          </platformNote>
        </platformNotes>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates using one of the overloads of <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssembly(System.String)</codeEntityReference> on two different domains.</para>
                <codeReference>AppDomain_ExecuteAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for reading a URI that does not begin with "file://". </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the assembly contained in the specified file, using the specified evidence and arguments.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyFile</parameterReference>
            <content>
              <para>The name of the file that contains the assembly to execute. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>The supplied evidence for the assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>The arguments to the entry point of the assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>hashValue</parameterReference>
            <content>
              <para>Represents the value of the computed hash code. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>hashAlgorithm</parameterReference>
            <content>
              <para>Represents the hash algorithm used by the assembly manifest. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyFile</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          </content>
        </remarks>
        <platformNotes>
          <platformNote>
            <platforms>
              <platform>NETCF</platform>
            </platforms>
            <content>
              <para>Loading assemblies into a domain neutral code area for use by multiple application domains is not supported.</para>
            </content>
          </platformNote>
        </platformNotes>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates using one of the overloads of <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssembly(System.String)</codeEntityReference> on two different domains.</para>
                <codeReference>AppDomain_ExecuteAssembly#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for reading a URI that does not begin with "file://". </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the assembly given an <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>, using the specified evidence and arguments.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>An <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> object representing the name of the assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>Evidence for loading the assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>Command-line arguments to pass when starting the process. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> was found, but could not be loaded.</para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssemblyByName</codeEntityReference> method provides similar functionality to the <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssembly</codeEntityReference> method, but specifies the assembly by display name or <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> rather than by file location. </para>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
            <alert class="note">
              <para>When you use the <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssemblyByName(System.String)</codeEntityReference> method with an <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssemblyByName(System.String)</codeEntityReference> method supersede pieces of evidence supplied by the loader.</para>
            </alert>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for access to a Web site, when a display name is redirected to a URL.</para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Executes an assembly.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes an assembly given its display name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> was found, but could not be loaded.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssemblyByName</codeEntityReference> method provides similar functionality to the <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssembly</codeEntityReference> method, but specifies the assembly by display name or <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> rather than by file location. </para>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
            <para>To create the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> to load and execute, use the <codeEntityReference autoUpgrade="true">M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)</codeEntityReference> method.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for access to a Web site, when a display name is redirected to a URL.</para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>
          <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.Load(System.String)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="Overload:System.AppDomain.ExecuteAssemblyByName">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes an assembly.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes an assembly given its display name, using the specified evidence.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>Evidence for loading the assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> was found, but could not be loaded.</para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssemblyByName</codeEntityReference> method provides similar functionality to the <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssembly</codeEntityReference> method, but specifies the assembly by display name or <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> rather than by file location. </para>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>The <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssemblyByName(System.String)</codeEntityReference> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
            <alert class="note">
              <para>When you use the <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssemblyByName(System.String)</codeEntityReference> method with an <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssemblyByName(System.String)</codeEntityReference> method supersede pieces of evidence supplied by the loader.</para>
            </alert>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for access to a Web site, when a display name is redirected to a URL.</para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Executes the assembly given its display name, using the specified evidence and arguments.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>Evidence for loading the assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>args</parameterReference>
            <content>
              <para>Command-line arguments to pass when starting the process. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value returned by the entry point of the assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyName</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> was found, but could not be loaded.</para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>The assembly specified by <parameterReference>assemblyName</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssemblyByName</codeEntityReference> method provides similar functionality to the <codeEntityReference autoUpgrade="true">Overload:System.AppDomain.ExecuteAssembly</codeEntityReference> method, but specifies the assembly by display name or <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference> rather than by file location. </para>
            <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
            <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
            <alert class="note">
              <para>When you use the <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssemblyByName(System.String)</codeEntityReference> method with an <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <codeEntityReference autoUpgrade="true">M:System.AppDomain.ExecuteAssemblyByName(System.String)</codeEntityReference> method supersede pieces of evidence supplied by the loader.</para>
            </alert>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for access to a Web site, when a display name is redirected to a URL.</para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.FriendlyName">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the friendly name of this application domain.</para>
        </summary>
        <returnValue>
          <para>The friendly name of this application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>The friendly name of the default application domain is the name of the assembly file loaded in the application domain. The friendly name is formed by stripping the directory specification from the assembly's code base. For example, if an assembly with the file name <codeInline>"c:\MyAppDirectory\MyAssembly.exe"</codeInline> is loaded in the default application domain, the friendly name of that application domain is <codeInline>"MyAssembly.exe"</codeInline>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADApplicationBase#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.GetAssemblies">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the assemblies that have been loaded into the execution context of this application domain.</para>
        </summary>
        <returnValue>
          <para>An array of assemblies in this application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADGetAssemblies#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.GetCurrentThreadId">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the current thread identifier.</para>
        </summary>
        <returnValue>
          <para>A 32-bit signed integer that is the identifier of the current thread.</para>
        </returnValue>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to get the current thread identifier. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">T:System.Int32</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.GetData(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the value stored in the current application domain for the specified name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The name of a predefined application domain property, or the name of an application domain property you have defined. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The value of the <parameterReference>name</parameterReference> property.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference>.</para>
            <para>The cache automatically contains predefined system entries that are inserted when the application domain is created. You can inspect their values with the <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference> method, or the equivalent <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> properties. </para>
            <para>You can insert or modify your own user defined name-data pairs with the <codeEntityReference autoUpgrade="true">M:System.AppDomain.SetData(System.String,System.Object)</codeEntityReference> method and inspect their values with the <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference> method.</para>
            <para>The following table describes the <parameterReference>name</parameterReference> of each predefined system entry and its corresponding <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> property.</para>
            <table>
              <tableHeader>
                <row>
                  <entry>
                    <para>Value of 'name' </para>
                  </entry>
                  <entry>
                    <para>Property </para>
                  </entry>
                </row>
              </tableHeader>
              <row>
                <entry>
                  <para>"APPBASE" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.ApplicationBase</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"LOADER_OPTIMIZATION"</para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.LoaderOptimization</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"APP_CONFIG_FILE" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.ConfigurationFile</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"DYNAMIC_BASE" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.DynamicBase</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"DEV_PATH" </para>
                </entry>
                <entry>
                  <para>(no property) </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"APP_NAME" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.ApplicationName</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"PRIVATE_BINPATH" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.PrivateBinPath</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"BINPATH_PROBE_ONLY" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.PrivateBinPathProbe</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"SHADOW_COPY_DIRS" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.ShadowCopyDirectories</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"FORCE_CACHE_INSTALL" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.ShadowCopyFiles</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>"CACHE_BASE" </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.CachePath</codeEntityReference>
                  </para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>(application specific) </para>
                </entry>
                <entry>
                  <para>
                    <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.LicenseFile</codeEntityReference>
                  </para>
                </entry>
              </row>
            </table>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADGetData#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to the information in the path itself, if the property applies to a path. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.AppDomain.SetData(System.String,System.Object)</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.GetType">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the type of the current instance.</para>
        </summary>
        <returnValue>
          <para>A <codeEntityReference autoUpgrade="true">T:System.Type</codeEntityReference>.</para>
        </returnValue>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.InitializeLifetimeService">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gives the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> an infinite lifetime by preventing a lease from being created.</para>
        </summary>
        <returnValue>
          <para>Always <languageKeyword>null</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.IsFinalizingForUnload">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected. After finalization, the object is accessible but in an invalid state and therefore unusable. Eventually, garbage collection completes and reclaims the object.</para>
            <para>An object's finalization method is called in one of the following situations: during garbage collection, when the application domain that contains the object is unloaded, or when the common language runtime is shutting down.</para>
            <para>While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method. However, you cannot reliably do so because the accessed object might already have been finalized.</para>
            <alert class="note">
              <para>An exception to this rule is the <codeEntityReference autoUpgrade="true">T:System.Console</codeEntityReference> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</para>
            </alert>
            <para>Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading. If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</para>
          </content>
        </remarks>
        <relatedTopics>
          <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Environment.HasShutdownStarted</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.Load(System.Byte[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> with a common object file format (COFF) based image containing an emitted <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>rawAssembly</parameterReference>
            <content>
              <para>An array of type <languageKeyword>byte</languageKeyword> that is a COFF-based image containing an emitted assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The loaded assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>rawAssembly</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>rawAssembly</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the use of loading a raw assembly.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_LoadRaw#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      <overload>
        <summary>
          <para>Loads an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> into this application domain.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> with a common object file format (COFF) based image containing an emitted <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>. The raw bytes representing the symbols for the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> are also loaded.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>rawAssembly</parameterReference>
            <content>
              <para>An array of type <languageKeyword>byte</languageKeyword> that is a COFF-based image containing an emitted assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>rawSymbolStore</parameterReference>
            <content>
              <para>An array of type <languageKeyword>byte</languageKeyword> containing the raw bytes representing the symbols for the assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The loaded assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>rawAssembly</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>rawAssembly</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the use of loading a raw assembly.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_LoadRaw#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for reading a URI that does not begin with "file://". </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> with a common object file format (COFF) based image containing an emitted <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference>. The raw bytes representing the symbols for the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> are also loaded.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>rawAssembly</parameterReference>
            <content>
              <para>An array of type <languageKeyword>byte</languageKeyword> that is a COFF-based image containing an emitted assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>rawSymbolStore</parameterReference>
            <content>
              <para>An array of type <languageKeyword>byte</languageKeyword> containing the raw bytes representing the symbols for the assembly. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>securityEvidence</parameterReference>
            <content>
              <para>Evidence for loading the assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The loaded assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>rawAssembly</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>rawAssembly</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the use of loading a raw assembly.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_LoadRaw#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to provide evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for reading a path that is not in the form "file://" or "\\UNC\dir\" or "c:\". </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> given its <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyRef</parameterReference>
            <content>
              <para>An object that describes the assembly to load. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The loaded assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyRef</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyRef</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyRef</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method should only be used to load an assembly into the current application domain. This method is defined for interoperability callers who cannot call the static <codeEntityReference autoUpgrade="true">M:System.Reflection.Assembly.Load(System.String)</codeEntityReference> method.</para>
            <para>An attempt to call <codeEntityReference autoUpgrade="true">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> is not <codeEntityReference autoUpgrade="true">T:System.MarshalByRefObject</codeEntityReference>, when this method attempts to return the <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
            <alert class="note">
              <para>If both the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.AssemblyName.Name</codeEntityReference> property and the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.AssemblyName.CodeBase</codeEntityReference> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference> property). If the file is not found, the <codeEntityReference autoUpgrade="true">P:System.Reflection.AssemblyName.CodeBase</codeEntityReference> property is used to search for the assembly. If the assembly is found using <codeEntityReference autoUpgrade="true">P:System.Reflection.AssemblyName.CodeBase</codeEntityReference>, the display name is matched against the assembly. If the match fails, a <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference> is thrown.</para>
            </alert>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="Overload:System.AppDomain.Load">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> into this application domain.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> given its <codeEntityReference autoUpgrade="true">T:System.Reflection.AssemblyName</codeEntityReference>.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyRef</parameterReference>
            <content>
              <para>An object that describes the assembly to load. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>Evidence for loading the assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The loaded assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyRef</parameterReference> is <languageKeyword>null</languageKeyword></para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyRef</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyRef</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for reading a path that is not in the form "file://" or "\\UNC\dir\" or "c:\". </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.Load(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> given its display name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyString</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The loaded assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyString</parameterReference> is <languageKeyword>null</languageKeyword></para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyString</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyString</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Loads an <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> given its display name.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyString</parameterReference>
            <content>
              <para>The display name of the assembly. See <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference>.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>assemblySecurity</parameterReference>
            <content>
              <para>Evidence for loading the assembly. </para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>The loaded assembly.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyString</parameterReference> is <languageKeyword>null</languageKeyword></para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileNotFoundException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyString</parameterReference> is not found. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.BadImageFormatException</codeEntityReference>
            <content>
              <para>
                <parameterReference>assemblyString</parameterReference> is not a valid assembly. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.IO.FileLoadException</codeEntityReference>
            <content>
              <para>An assembly or module was loaded twice with two different evidences. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see the <codeEntityReference autoUpgrade="false">M:System.AppDomain.Load(System.Reflection.AssemblyName)</codeEntityReference> method overload.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to load an assembly with evidence. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Net.WebPermission</codeEntityReference>
            <content>
              <para>for reading a path that is not in the form "file://" or "\\UNC\dir\" or "c:\". </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.ProcessExit">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when the default application domain's parent process exits.</para>
        </summary>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">T:System.EventHandler</codeEntityReference> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</para>
            <para>In the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</para>
            <alert class="note">
              <para>The total execution time of all <codeEntityReference autoUpgrade="true">E:System.AppDomain.ProcessExit</codeEntityReference> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown. The default is three seconds, which can be overridden by an unmanaged host.</para>
            </alert>
            <para>In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</para>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference> is thrown.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.ProvideAssemblyEvidence">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when an assembly is loaded.</para>
        </summary>
        <remarks>
          <content>
            <para>To provide evidence for the assembly when handling this event, assign an <codeEntityReference autoUpgrade="true">T:System.Security.Policy.Evidence</codeEntityReference> object to the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Security.Policy.ProvideAssemblyEvidenceEventArgs.Evidence</codeEntityReference> property.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.RelativeSearchPath">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the path relative to the base directory where the assembly resolver should probe for private assemblies.</para>
        </summary>
        <returnValue>
          <para>The path relative to the base directory where the assembly resolver should probe for private assemblies.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Private assemblies are deployed in the same directory structure as the application.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>adproperties#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.ResourceResolve">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</para>
        </summary>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">T:System.ResolveEventHandler</codeEntityReference> for this event can attempt to locate the resource and load it.</para>
            <alert class="important">
              <para>This event is not raised if resolution fails because no file can be found for a valid linked resource.</para>
            </alert>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference>  is thrown.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Establishes the security policy level for this application domain.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>domainPolicy</parameterReference>
            <content>
              <para>The security policy level. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>domainPolicy</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Security.Policy.PolicyException</codeEntityReference>
            <content>
              <para>The security policy level has already been set. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Call this method before an assembly is loaded into the <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> in order for the security policy to have effect.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADSetAppDomainPolicy#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to use this method. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetCachePath(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Establishes the specified directory path as the location where assemblies are shadow copied.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>path</parameterReference>
            <content>
              <para>The fully qualified path to the shadow copy location. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADShadowCopy#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.CachePath</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetData(System.String,System.Object)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Assigns the specified value to the specified application domain property.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The name of a user-defined application domain property to create or change. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>data</parameterReference>
            <content>
              <para>The value of the property. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference>.</para>
            <para>The cache automatically contains predefined system entries that are inserted when the application domain is created. You cannot insert or modify system entries with this method. You can inspect their values with the <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference> method, or the equivalent <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> properties described in <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference>. </para>
            <para>You can insert or modify your own user defined name-data pairs with this method and inspect their values with the <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference> method.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADGetData#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference>
        </relatedTopics>
      <overload>
        <summary>
          <para>Assigns a value to an application domain property.</para>
        </summary>
      </overload>
</dduexml>
    </member>
    <member name="M:System.AppDomain.SetDynamicBase(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Establishes the specified directory path as the location where dynamically generated files are stored and accessed.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>path</parameterReference>
            <content>
              <para>The fully qualified path to where dynamic assemblies are stored. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method sets the <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.DynamicBase</codeEntityReference> property of the internal <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> associated with this instance.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADDynamicBase#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.FileIOPermission</codeEntityReference>
            <content>
              <para>for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.Read</codeEntityReference>, <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.DynamicBase</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>policy</parameterReference>
            <content>
              <para>One of the <codeEntityReference autoUpgrade="true">T:System.Security.Principal.PrincipalPolicy</codeEntityReference> values that specifies the type of the principal object to attach to threads. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Setting this value will only be effective if you set it before using the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Threading.Thread.CurrentPrincipal</codeEntityReference> property. For example, if you set <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Threading.Thread.CurrentPrincipal</codeEntityReference> to a given principal (for example, a generic principal) and then use the <codeEntityReference autoUpgrade="true">M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)</codeEntityReference> method to set the <codeEntityReference autoUpgrade="true">T:System.Security.Principal.PrincipalPolicy</codeEntityReference> to <codeEntityReference autoUpgrade="true">F:System.Security.Principal.PrincipalPolicy.WindowsPrincipal</codeEntityReference>, the current principal will remain the generic principal.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADPrincipal#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for ability to manipulate the principal object. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetShadowCopyFiles">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Turns on shadow copying.</para>
        </summary>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>adproperties#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetShadowCopyPath(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Establishes the specified directory path as the location of assemblies to be shadow copied.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>path</parameterReference>
            <content>
              <para>A list of directory names, where each name is separated by a semicolon. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>By default, a shadow copy includes all assemblies found through probing. The <codeEntityReference autoUpgrade="true">M:System.AppDomain.SetShadowCopyPath(System.String)</codeEntityReference> method restricts the shadow copy to the assemblies in the directories specified by <parameterReference>path</parameterReference>.</para>
            <para>The <codeEntityReference autoUpgrade="true">M:System.AppDomain.SetShadowCopyPath(System.String)</codeEntityReference> method does not specify additional directories to be searched for assemblies. Assemblies to be shadow-copied must already be located in the search path, for example under <codeEntityReference autoUpgrade="true">P:System.AppDomain.BaseDirectory</codeEntityReference>. The <codeEntityReference autoUpgrade="true">M:System.AppDomain.SetShadowCopyPath(System.String)</codeEntityReference> method specifies which search paths are eligible to be shadow-copied.</para>
            <para>This method sets the <codeEntityReference autoUpgrade="true">P:System.AppDomainSetup.ShadowCopyDirectories</codeEntityReference> property of the internal <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> associated with this instance.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADShadowCopy#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>principal</parameterReference>
            <content>
              <para>The principal object to attach to threads. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>principal</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.Security.Policy.PolicyException</codeEntityReference>
            <content>
              <para>The thread principal has already been set. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADPrincipal#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for ability to manipulate the principal object. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.SetupInformation">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the application domain configuration information for this instance.</para>
        </summary>
        <returnValue>
          <para>The application domain initialization information.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADCreateDomain#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.ShadowCopyFiles">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets an indication whether all assemblies loaded in the application domain are shadow copied.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if all assemblies loaded in the application domain are shadow copied, not just a particular one; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>Operations are attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>For more information, see <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.AppDomainSetup.ShadowCopyFiles</codeEntityReference>.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ToString">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Obtains a string representation that includes the friendly name of the application domain and any context policies.</para>
        </summary>
        <returnValue>
          <para>A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies." </para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>The application domain represented by the current <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> has been unloaded.</para>
            </content>
          </exception>
        </exceptions>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADToString#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.TypeResolve">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when the resolution of a type fails.</para>
        </summary>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">E:System.AppDomain.TypeResolve</codeEntityReference> event occurs when the common language runtime is unable to determine the assembly that can create the requested type. This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in. The latter situation can occur when <codeEntityReference qualifyHint="true" autoUpgrade="true">M:System.Type.GetType</codeEntityReference> is called with a type name that is not qualified with the assembly name.</para>
            <para>The <codeEntityReference autoUpgrade="true">T:System.ResolveEventHandler</codeEntityReference> for this event can attempt to locate and create the type.</para>
            <para>However, the <codeEntityReference autoUpgrade="true">E:System.AppDomain.TypeResolve</codeEntityReference> event does not occur if the runtime knows it is not possible to find a type in certain assemblies. For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</para>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference> is thrown.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">E:System.AppDomain.TypeResolve</codeEntityReference> event.</para>
                <para>For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see <link xlink:href="8F8C2C90-F15D-400E-87E7-A757E4F04D0E">[&lt;topic://cpconassemblynames&gt;]</link>.</para>
                <codeReference>AppDomain_TypeResolve#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.UnhandledException">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when an exception is not caught by an event handler.</para>
        </summary>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">T:System.UnhandledExceptionEventHandler</codeEntityReference> delegate for this event provides default handling for uncaught exceptions. When this event is not handled, the system default handler reports the exception to the user and terminates the application.</para>
            <para>This event occurs only for the application domain that is created by the system when an application is started. If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</para>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference> is thrown.</para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</link>.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following sample demonstrates the <codeEntityReference autoUpgrade="true">E:System.AppDomain.UnhandledException</codeEntityReference> event.</para>
                <codeReference>AppDomain_UnhandledException#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.Unload(System.AppDomain)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Unloads the specified application domain.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>domain</parameterReference>
            <content>
              <para>An application domain to unload. </para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>domain</parameterReference> is <languageKeyword>null</languageKeyword>. </para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.CannotUnloadAppDomainException</codeEntityReference>
            <content>
              <para>
                <parameterReference>domain</parameterReference> could not be unloaded. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains. This improves reliability, especially when the .NET Framework is hosted. When a thread calls <codeEntityReference autoUpgrade="true">M:System.AppDomain.Unload(System.AppDomain)</codeEntityReference>, the target domain is marked for unloading. The dedicated thread attempts to unload the domain, and all threads in the domain are aborted. If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a <languageKeyword>finally</languageKeyword> block, then after a period of time a <codeEntityReference autoUpgrade="true">T:System.CannotUnloadAppDomainException</codeEntityReference> is thrown in the thread that originally called <codeEntityReference autoUpgrade="true">M:System.AppDomain.Unload(System.AppDomain)</codeEntityReference>. If the thread that could not be aborted eventually ends, the target domain is not unloaded. Thus, in the .NET Framework version 2.0 <parameterReference>domain</parameterReference> is not guaranteed to unload, because it might not be possible to terminate executing threads. </para>
            <alert class="note">
              <para>In some cases, calling <codeEntityReference autoUpgrade="true">M:System.AppDomain.Unload(System.AppDomain)</codeEntityReference> causes an immediate <codeEntityReference autoUpgrade="true">T:System.CannotUnloadAppDomainException</codeEntityReference>, for example if it is called in a finalizer.</para>
            </alert>
            <para>The threads in <parameterReference>domain</parameterReference> are terminated using the <codeEntityReference autoUpgrade="true">M:System.Threading.Thread.Abort(System.Object)</codeEntityReference> method, which throws a <codeEntityReference autoUpgrade="true">T:System.Threading.ThreadAbortException</codeEntityReference> in the thread. Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a <languageKeyword>finally</languageKeyword> clause.</para>
          </content>
          <sections>
            <section>
              <title>Version Compatibility</title>
              <content>
                <para>In the .NET Framework version 1.0 and 1.1 if the thread that calls <codeEntityReference autoUpgrade="true">M:System.AppDomain.Unload(System.AppDomain)</codeEntityReference> is running in <parameterReference>domain</parameterReference>, another thread is started to perform the unload operation. If <parameterReference>domain</parameterReference> cannot be unloaded, a <codeEntityReference autoUpgrade="true">T:System.CannotUnloadAppDomainException</codeEntityReference> is thrown in that thread, not in the original thread that called <codeEntityReference autoUpgrade="true">M:System.AppDomain.Unload(System.AppDomain)</codeEntityReference>. However, if the thread that calls <codeEntityReference autoUpgrade="true">M:System.AppDomain.Unload(System.AppDomain)</codeEntityReference> is running outside <parameterReference>domain</parameterReference>, that thread receives the exception.</para>
              </content>
            </section>
          </sections>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <codeReference>ADUnload#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="Overload:System.AppDomain.CreateComInstanceFrom">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Creates a new instance of a specified COM type.</para>
        </summary>
        <remarks>
          <content>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.IsDefaultAppDomain">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns a value that indicates whether the application domain is the default application domain for the process.</para>
        </summary>
        <returnValue>
          <para>
            <languageKeyword>true</languageKeyword> if the current <codeEntityReference autoUpgrade="true">T:System.AppDomain</codeEntityReference> object represents the default application domain for the process; otherwise, <languageKeyword>false</languageKeyword>.</para>
        </returnValue>
        <remarks>
          <content>
            <para>Every managed process has a default application domain. Execution begins in the default domain.</para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example creates a second application domain and displays information about the default domain and the new domain.</para>
                <codeReference>System.AppDomain.IsDefaultAppDomain#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ReflectionOnlyGetAssemblies">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the assemblies that have been loaded into the reflection-only context of the application domain.</para>
        </summary>
        <returnValue>
          <para>An array of <codeEntityReference autoUpgrade="true">T:System.Reflection.Assembly</codeEntityReference> objects that represent the assemblies loaded into the reflection-only context of the application domain.</para>
        </returnValue>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.AppDomainUnloadedException</codeEntityReference>
            <content>
              <para>An operation is attempted on an unloaded application domain. </para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method returns the assemblies that have been loaded into the reflection-only context. To get the assemblies that have been loaded for execution, use the <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetAssemblies</codeEntityReference> method. </para>
          </content>
        </remarks>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetAssemblies</codeEntityReference> and <codeEntityReference autoUpgrade="true">M:System.AppDomain.ReflectionOnlyGetAssemblies</codeEntityReference> methods are used to display the assemblies loaded into each context.</para>
                <codeReference>AppDomain.ReflectionOnlyGetAssemblies#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
        <relatedTopics>
          <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetAssemblies</codeEntityReference>
        </relatedTopics>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.Id">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets an integer that uniquely identifies the application domain within the process. </para>
        </summary>
        <returnValue>
          <para>An integer that identifies the application domain.</para>
        </returnValue>
        <codeExamples>
          <codeExample>
            <legacy>
              <content>
                <para>The following code example creates a second application domain and displays information about the default domain and the new domain.</para>
                <codeReference>System.AppDomain.IsDefaultAppDomain#1</codeReference>
              </content>
            </legacy>
          </codeExample>
        </codeExamples>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.ApplyPolicy(System.String)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Returns the assembly display name after policy has been applied.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>assemblyName</parameterReference>
            <content>
              <para>The assembly display name, in the form provided by the <codeEntityReference qualifyHint="true" autoUpgrade="true">P:System.Reflection.Assembly.FullName</codeEntityReference> property.</para>
            </content>
          </parameter>
        </parameters>
        <returnValue>
          <para>A string containing the assembly display name after policy has been applied.</para>
        </returnValue>
        <remarks>
          <content>
            <para>The <codeEntityReference autoUpgrade="true">M:System.AppDomain.ApplyPolicy(System.String)</codeEntityReference> method takes an assembly display name and returns the post-policy display name. This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.DomainManager">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the domain manager that was provided by the host when the application domain was initialized.</para>
        </summary>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.AppDomainManager</codeEntityReference> object that represents the domain manager provided by the host when the application domain was initialized, or <languageKeyword>null</languageKeyword> if no domain manager was provided.</para>
        </returnValue>
        <remarks>
          <content>
            <para>An unmanaged host of the common language runtime (CLR) can provide a domain manager. The domain manager can participate in initializing the new application domain and supply other managers, such as a <codeEntityReference autoUpgrade="true">T:System.Security.HostSecurityManager</codeEntityReference>, that participate in the operations of the application domain.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to control policy for an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlDomainPolicy</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.ActivationContext">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the activation context for the current application domain.</para>
        </summary>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.ActivationContext</codeEntityReference> object that represents the activation context for the current application domain, or <languageKeyword>null</languageKeyword> if the domain has no activation context.</para>
        </returnValue>
        <remarks>
          <content>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.ApplicationIdentity">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets the identity of the application in the application domain.</para>
        </summary>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.ApplicationIdentity</codeEntityReference> object identifying the application in the application domain.</para>
        </returnValue>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to control policy for an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlDomainPolicy</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="P:System.AppDomain.ApplicationTrust">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</para>
        </summary>
        <returnValue>
          <para>An <codeEntityReference autoUpgrade="true">T:System.Security.Policy.ApplicationTrust</codeEntityReference> object that encapsulates permission and trust information for the application in the application domain. </para>
        </returnValue>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to control policy for an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlDomainPolicy</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Occurs when the resolution of an assembly fails in the reflection-only context.</para>
        </summary>
        <remarks>
          <content>
            <para>It is the responsibility of the <codeEntityReference autoUpgrade="true">T:System.ResolveEventHandler</codeEntityReference> for this event to return the assembly that resolves the assembly.</para>
            <para>To register an event handler for this event, you must have the required permissions, or a <codeEntityReference autoUpgrade="true">T:System.Security.SecurityException</codeEntityReference> is thrown. </para>
            <para>For more information about handling events, see <link xlink:href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Consuming Events</link>.</para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>to add an event handler for this event. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="Overload:System.AppDomain.SetData">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Assigns a value to an application domain property.</para>
        </summary>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>name</parameterReference>
            <content>
              <para>The name of a user-defined application domain property to create or change. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>data</parameterReference>
            <content>
              <para>The value of the property. </para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>permission</parameterReference>
            <content>
              <para>The permission to demand of the caller when the property is retrieved.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.ArgumentNullException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> is <languageKeyword>null</languageKeyword>.</para>
            </content>
          </exception>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.InvalidOperationException</codeEntityReference>
            <content>
              <para>
                <parameterReference>name</parameterReference> specifies a system-defined property string and <parameterReference>permission</parameterReference> is not <languageKeyword>null</languageKeyword>.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain. When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.</para>
            <para>You cannot use this method to assign a security demand to a system-defined property string.</para>
            <para>The cache automatically contains predefined system entries that are inserted when the application domain is created. You cannot insert or modify system entries with this method. You can inspect their values with the <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference> method or the equivalent <codeEntityReference autoUpgrade="true">T:System.AppDomainSetup</codeEntityReference> properties described in the Remarks section for the <codeEntityReference autoUpgrade="true">M:System.AppDomain.GetData(System.String)</codeEntityReference> method. </para>
          </content>
        </remarks>
        <permissions>
          <permission>
            <codeEntityReference autoUpgrade="true">T:System.Security.Permissions.SecurityPermission</codeEntityReference>
            <content>
              <para>for the ability to create and manipulate an application domain. Associated enumeration: <codeEntityReference qualifyHint="true" autoUpgrade="true">F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain</codeEntityReference>. </para>
            </content>
          </permission>
        </permissions>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Maps a set of names to a corresponding set of dispatch identifiers.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>riid</parameterReference>
            <content>
              <para>Reserved for future use. Must be IID_NULL.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>rgszNames</parameterReference>
            <content>
              <para>Passed-in array of names to be mapped.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>cNames</parameterReference>
            <content>
              <para>Count of the names to be mapped.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>lcid</parameterReference>
            <content>
              <para>The locale context in which to interpret the names.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>rgDispId</parameterReference>
            <content>
              <para>Caller-allocated array which receives the IDs corresponding to the names.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetIDsOfNames</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Retrieves the type information for an object, which can then be used to get the type information for an interface.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>iTInfo</parameterReference>
            <content>
              <para>The type information to return.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>lcid</parameterReference>
            <content>
              <para>The locale identifier for the type information.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>ppTInfo</parameterReference>
            <content>
              <para>Receives a pointer to the requested type information object.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetTypeInfo</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.System._AppDomain.GetTypeInfoCount(System.UInt32@)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>pcTInfo</parameterReference>
            <content>
              <para>Points to a location that receives the number of type information interfaces provided by the object.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetTypeInfoCount</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
    <member name="M:System.AppDomain.System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
      <dduexml xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
        <summary>
          <para>Provides access to properties and methods exposed by an object.</para>
        </summary>
        <parameters>
          <parameter>
            <parameterReference>dispIdMember</parameterReference>
            <content>
              <para>Identifies the member.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>riid</parameterReference>
            <content>
              <para>Reserved for future use. Must be IID_NULL.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>lcid</parameterReference>
            <content>
              <para>The locale context in which to interpret arguments.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>wFlags</parameterReference>
            <content>
              <para>Flags describing the context of the call.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>pDispParams</parameterReference>
            <content>
              <para>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>pVarResult</parameterReference>
            <content>
              <para>Pointer to the location where the result is to be stored.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>pExcepInfo</parameterReference>
            <content>
              <para>Pointer to a structure that contains exception information.</para>
            </content>
          </parameter>
          <parameter>
            <parameterReference>puArgErr</parameterReference>
            <content>
              <para>The index of the first argument that has an error.</para>
            </content>
          </parameter>
        </parameters>
        <exceptions>
          <exception>
            <codeEntityReference autoUpgrade="true">T:System.NotImplementedException</codeEntityReference>
            <content>
              <para>Late-bound access using the COM <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> interface is not supported.</para>
            </content>
          </exception>
        </exceptions>
        <remarks>
          <content>
            <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::Invoke</unmanagedCodeEntityReference>, see the MSDN Library.</para>
          </content>
        </remarks>
      </dduexml>
    </member>
  </members>
</doc>