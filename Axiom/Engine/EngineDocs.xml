<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AxiomEngine</name>
    </assembly>
    <members>
        <member name="T:Axiom.Animating.Animation">
            <summary>
            	An animation sequence. 
            </summary>
            <remarks>
            	This class defines the interface for a sequence of animation, whether that
            	be animation of a mesh, a path along a spline, or possibly more than one
            	type of animation in one. An animation is made up of many 'tracks', which are
            	the more specific types of animation.
            	<p/>
            	You should not create these animations directly. They will be created via a parent
            	object which owns the animation, e.g. Skeleton, SceneManager, etc.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Animation.name">
            <summary>Name of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.length">
            <summary>The total length of this animation (sum of the tracks).</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.trackList">
            <summary>Collection of AnimationTracks.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.interpolationMode">
            <summary>Interpolation mode of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.defaultInterpolationMode">
            <summary>Default interpolation mode of any animations.</summary>
        </member>
        <member name="M:Axiom.Animating.Animation.#cctor">
            <summary>Static constructor.</summary>
        </member>
        <member name="M:Axiom.Animating.Animation.#ctor(System.String,System.Single)">
            <summary>
            	Internal constructor, to prevent from using new outside of the engine.
            	<p/>
            	Animations should be created within objects that can own them (skeletons, scene managers, etc).
            </summary>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateTrack(System.Int16)">
            <summary>
            	Creates an AnimationTrack. 
            </summary>
            <param name="index">Numeric handle to give the track, used for accessing the track later.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateTrack(System.Int16,Axiom.Core.Node)">
            <summary>
            	Creates a new AnimationTrack automatically associated with a Node. 
            </summary>
            <param name="index">Numeric handle to give the track, used for accessing the track later.</param>
            <param name="target">Node object which will be affected by this track.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.Apply(System.Single,System.Single,System.Boolean)">
            <summary>
            	Applies an animation given a specific time point and weight.
            </summary>
            <remarks>
            	Where you have associated animation tracks with Node objects, you can eaily apply
            	an animation to those nodes by calling this method.
            </remarks>
            <param name="time">The time position in the animation to apply.</param>
            <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with
            	other animations.</param>
            <param name="accumulate"></param>
        </member>
        <member name="P:Axiom.Animating.Animation.Name">
            <summary>
            	Gets the name of this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.Length">
            <summary>
            	Gets the total length of this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.InterpolationMode">
            <summary>
            	Gets/Sets the current interpolation mode for this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.Tracks">
            <summary>
            	A collection of the tracks in this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.DefaultInterpolationMode">
            <summary>
            	Gets/Sets the default interpolation mode to be used for all animations.
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimationState">
            <summary>
            	Represents the state of an animation and the weight of it's influence. 
            </summary>
            <remarks>
            	Other classes can hold instances of this class to store the state of any animations
            	they are using.
            	This class implements the IControllerValue interface to enable automatic update of
            	animation state through controllers.
            </remarks>
        </member>
        <member name="T:Axiom.Controllers.IControllerValue">
            <summary>
            	Classes that will be controlled by any type of Controller should implement
            	this interface to define how the controller will modifiy it's local data.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.animationName">
            <summary>Name of this animation track.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.time">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.length">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.inverseLength">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.weight">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.isEnabled">
            <summary></summary>
        </member>
        <member name="M:Axiom.Animating.AnimationState.#ctor(System.String,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            	
            </summary>
            <param name="animationName"></param>
            <param name="time"></param>
            <param name="length"></param>
            <param name="weight"></param>
            <param name="isEnabled"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.#ctor(System.String,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="animationName"></param>
            <param name="time"></param>
            <param name="length"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.AddTime(System.Single)">
            <summary>
            	Modifies the time position, adjusting for animation length.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.op_Equality(Axiom.Animating.AnimationState,Axiom.Animating.AnimationState)">
            <summary>
            	Compares 2 animation states for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.AnimationState.op_Inequality(Axiom.Animating.AnimationState,Axiom.Animating.AnimationState)">
            <summary>
            	Compares 2 animation states for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Name">
            <summary>
            	Gets the name of the animation to which this state applies
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Time">
            <summary>
            	Gets/Sets the time position for this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Length">
            <summary>
            	Gets/Sets the total length of this animation (may be shorter than whole animation)
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Weight">
            <summary>
            Gets/Sets the weight (influence) of this animation
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.IsEnabled">
            <summary>
            	Gets/Sets whether this animation is enabled or not.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Value">
            <summary>
            	Gets/Sets the value to be used in a ControllerFunction.
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimationTrack">
            <summary>
            	A 'track' in an animation sequence, ie a sequence of keyframes which affect a
            	certain type of object that can be animated.
            </summary>
            <remarks>
            	This class is intended as a base for more complete classes which will actually
            	animate specific types of object, e.g. a bone in a skeleton to affect
            	skeletal animation. An animation will likely include multiple tracks each of which
            	can be made up of many KeyFrame instances. Note that the use of tracks allows each animable
            	object to have it's own number of keyframes, i.e. you do not have to have the
            	maximum number of keyframes for all animable objects just to cope with the most
            	animated one.
            	<p/>
            	Since the most common animable object is a Node, there are options in this class for associating
            	the track with a Node which will receive keyframe updates automatically when the 'apply' method
            	is called.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.index">
            <summary>Index of this animation track.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.parent">
            <summary>Animation that owns this track.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.target">
            <summary>Target node to be animated.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.maxKeyFrameTime">
            <summary>Maximum keyframe time.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.keyFrameList">
            <summary>Collection of key frames in this track.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.isSplineRebuildNeeded">
            <summary>Flag indicating we need to rebuild the splines next time.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.positionSpline">
            <summary>Spline for position interpolation.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.scaleSpline">
            <summary>Spline for scale interpolation.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.rotationSpline">
            <summary>Spline for rotation interpolation.</summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.#ctor(Axiom.Animating.Animation)">
            <summary>
            	Internal constructor, to prevent direction instantiation.  Should be created
            	via a call to the CreateTrack method of an Animation.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.#ctor(Axiom.Animating.Animation,Axiom.Core.Node)">
            <summary>
            	Internal constructor, to prevent direction instantiation.  Should be created
            	via a call to the CreateTrack method of an Animation.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)">
            <summary>
            	Creates a new KeyFrame and adds it to this animation at the given time index.
            </summary>
            <remarks>
            	It is better to create KeyFrames in time order. Creating them out of order can result 
            	in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
            	for you, so you don't need to create this one, just access it using KeyFrames[0];
            </remarks>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetInterpolatedKeyFrame(System.Single)">
            <summary>
            	Gets a KeyFrame object which contains the interpolated transforms at the time index specified.
            </summary>
            <remarks>
            	The KeyFrame objects held by this class are transformation snapshots at 
            	discrete points in time. Normally however, you want to interpolate between these
            	keyframes to produce smooth movement, and this method allows you to do this easily.
            	In animation terminology this is called 'tweening'. 
            </remarks>
            <param name="time">The time (in relation to the whole animation sequence).</param>
            <returns>
            	A new keyframe object containing the interpolated transforms. Note that the
            	position and scaling transforms are linearly interpolated (lerp), whilst the rotation is
            	spherically linearly interpolated (slerp) for the most natural result.
            </returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.Apply(System.Single,System.Single,System.Boolean)">
            <summary>
            	Applies an animation track at a certain position to the target node.
            </summary>
            <remarks>
            	When a track has bee associated with a target node, you can eaisly apply the animation
            	to the target by calling this method.
            </remarks>
            <param name="time">The time position in the animation to apply.</param>
            <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with
            	other animations.</param>
            <param name="accumulate"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.Apply(System.Single)">
            <summary>
            	Overloaded Apply method.  
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.ApplyToNode(Axiom.Core.Node,System.Single,System.Single,System.Boolean)">
            <summary>
            Sames as the Apply method, but applies to a specified Node instead of it's associated node.
            </summary>
            <param name="node"></param>
            <param name="time"></param>
            <param name="weight"></param>
            <param name="accumulate"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetKeyFramesAtTime(System.Single,Axiom.Animating.KeyFrame@,Axiom.Animating.KeyFrame@,System.UInt16@)">
             <summary>
            		Gets the 2 KeyFrame objects which are active at the time given, and the blend value between them.
             </summary>
             <remarks>
            		At any point in time  in an animation, there are either 1 or 2 keyframes which are 'active',
            		1 if the time index is exactly on a keyframe, 2 at all other times i.e. the keyframe before
            		and the keyframe after.
             </remarks>
             <param name="time">The time index in seconds.</param>
             <param name="keyFrame1">Receive the keyframe just before or at this time index.</param>
             <param name="keyFrame2">Receive the keyframe just after this time index.</param>
             <param name="firstKeyIndex">If supplied, will receive the index of the 'from' keyframe incase the caller needs it.</param>
             <returns>
            		Parametric value indicating how far along the gap between the 2 keyframes the time
                value is, e.g. 0.0 for exactly at 1, 0.25 for a quarter etc. By definition the range of this 
                value is:  0.0 &lt;= returnValue &lt; 1.0 .
            </returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.BuildInterpolationSplines">
            <summary>Used to rebuild the internal interpolation splines for translations, rotations, and scaling.</summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.Index">
            <summary>
            	The name of this animation track.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.KeyFrames">
            <summary>
            	Collection of the KeyFrames present in this AnimationTrack.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.TargetNode">
            <summary>
            	Gets/Sets the target node that this track is associated with.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Bone">
            <summary>
            Summary description for Bone.
            </summary>
        </member>
        <member name="T:Axiom.Core.Node">
            <summary>
            	Class representing a general-purpose node an articulated scene graph.
            </summary>
            <remarks>
            	A node in the scene graph is a node in a structured tree. A node contains
            	information about the transformation which will apply to
            	it and all of it's children. Child nodes can have transforms of their own, which
            	are combined with their parent's transformations.
            	
            	This is an abstract class - concrete classes are based on this for specific purposes,
            	e.g. SceneNode, Bone
            </remarks>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.IRenderable">
            <summary>
            	Interface defining the interface all renderable objects must implement.
            </summary>
            <remarks>
            	This interface abstracts renderable discrete objects which will be queued in the render pipeline,
            	grouped by material. Classes implementing this interface must be based on a single material, a single
            	world matrix (or a collection of world matrices which are blended by weights), and must be 
            	renderable via a single render operation.
            	<p/>
            	Note that deciding whether to put these objects in the rendering pipeline is done from the more specific
            	classes e.g. entities. Only once it is decided that the specific class is to be rendered is the abstract version
            	created (could be more than one per visible object) and pushed onto the rendering queue.
            </remarks>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.IRenderable.GetRenderOperation(Axiom.SubSystems.Rendering.RenderOperation)">
            <summary>
            Get the current render operation associated with this renderable object.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.IRenderable.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            	Returns the camera-relative squared depth of this renderable.
            </summary>
            <remarks>
            	Used to sort transparent objects. Squared depth is used rather than
            	actual depth to avoid having to perform a square root on the result.	
            </remarks>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderable.Shader">
            <summary>
            Get the shader associated with this renderable object.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderable.WorldTransforms">
            <summary>
            Gets the world transform matrix / matrices for this renderable object.
            </summary>
            <remarks>
             If the object has any derived transforms, these are expected to be up to date as long as
             all the SceneNode structures have been updated before this is called.
             
             This method will populate xform with 1 matrix if it does not use vertex blending. If it
             does use vertex blending it will fill the passed in pointer with an array of matrices,
             the length being the value returned from getNumWorldTransforms.
            </remarks>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderable.NumWorldTransforms">
            <summary>
            Gets the number of world transformations that will be used for this object.
            </summary>
            <remarks>
            When a renderable uses vertex blending, it uses multiple world matrices instead of a single
            one. Each vertex sent to the pipeline can reference one or more matrices in this list
            with given weights.
            If a renderable does not use vertex blending this method returns 1, which is the default for 
            simplicity.
            </remarks>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderable.UseIdentityProjection">
            <summary>
            Returns whether or not to use an 'identity' projection.
            </summary>
            <remarks>
            Usually IRenderable objects will use a projection matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity projection, which effectively projects in 2D using
            a {-1, 1} view space. Useful for overlay rendering. Normal renderables need
            not override this.
            </remarks>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderable.UseIdentityView">
            <summary>
            Returns whether or not to use an 'identity' projection.
            </summary>
            <remarks>
            Usually IRenderable objects will use a view matrix as determined
            by the active camera. However, if they want they can cancel this out
            and use an identity matrix, which means all geometry is assumed
            to be relative to camera space already. Useful for overlay rendering. 
            Normal renderables need not override this.
            </remarks>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderable.RenderDetail">
            <summary>
            	Will allow for setting per renderable scene detail levels.
            </summary>
        </member>
        <member name="F:Axiom.Core.Node.name">
            <summary>Name of this node.</summary>
        </member>
        <member name="F:Axiom.Core.Node.parent">
            <summary>Parent node (if any)</summary>
        </member>
        <member name="F:Axiom.Core.Node.childNodes">
            <summary>Collection of this nodes child nodes.</summary>
        </member>
        <member name="F:Axiom.Core.Node.childrenToUpdate">
            <summary>Collection of this nodes child nodes.</summary>
        </member>
        <member name="F:Axiom.Core.Node.needUpdate">
            <summary>Flag to indicate if our transform is out of date.</summary>
        </member>
        <member name="F:Axiom.Core.Node.orientation">
            <summary>Orientation of this node relative to it's parent.</summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedOrientation">
            <summary>World orientation of this node based on parents orientation.</summary>
        </member>
        <member name="F:Axiom.Core.Node.initialOrientation">
            <summary>Original orientation of this node, used for resetting to original.</summary>
        </member>
        <member name="F:Axiom.Core.Node.rotationFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.position">
            <summary>Position of this node relative to it's parent.</summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedPosition">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.initialPosition">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.translationFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.scale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.initialScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.scaleFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.inheritsScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.accumAnimWeight">
            <summary>Weight of applied animations so far, used for blending.</summary>
        </member>
        <member name="F:Axiom.Core.Node.cachedTransform">
            <summary>Cached derived transform as a 4x4 matrix.</summary>
        </member>
        <member name="M:Axiom.Core.Node.Scale(Axiom.MathLib.Vector3)">
             <summary>
             Scales the node, combining it's current scale with the passed in scaling factor. 
             </summary>
             <remarks>
            	This method applies an extra scaling factor to the node's existing scale, (unlike setScale
            	which overwrites it) combining it's current scale with the new one. E.g. calling this 
            	method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if
             the existing scale was 1.
             
            	Note that like rotations, scalings are oriented around the node's origin.
            </remarks>
             <param name="scale"></param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.MathLib.Vector3)">
            <summary>
            Moves the node along the cartesian axes.
            
            This method moves the node by the supplied vector along the
            world cartesian axes, i.e. along world x,y,z
            </summary>
            <param name="scale">Vector with x,y,z values representing the translation.</param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.MathLib.Matrix3,Axiom.MathLib.Vector3)">
            <summary>
            Moves the node along arbitrary axes.
            </summary>
            <remarks>
            This method translates the node by a vector which is relative to
            a custom set of axes.
            </remarks>
            <param name="pAxes">3x3 Matrix containg 3 column vectors each representing the
            X, Y and Z axes respectively. In this format the standard cartesian axes would be expressed as:
            	1 0 0
            	0 1 0
            	0 0 1
            	i.e. The Identity matrix.
            </param>
            <param name="move">Vector relative to the supplied axes.</param>
        </member>
        <member name="M:Axiom.Core.Node.Pitch(System.Single)">
            <summary>
            Rotate the node around the X-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Roll(System.Single)">
            <summary>
            Rotate the node around the Z-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Yaw(System.Single)">
            <summary>
            Rotate the node around the Y-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.MathLib.Vector3,System.Single)">
            <summary>
            Rotate the node around an arbitrary axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.MathLib.Quaternion)">
            <summary>
            Rotate the node around an arbitrary axis using a Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.ResetOrientation">
            <summary>
            Resets the nodes orientation (local axes as world axes, no rotation).
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.ResetToInitialState">
            <summary>
            Resets the position / orientation / scale of this node to it's initial state, see SetInitialState for more info.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.SetInitialState">
            <summary>
            Sets the current transform of this node to be the 'initial state' ie that
            position / orientation / scale to be used as a basis for delta values used
            in keyframe animation.
            </summary>
            <remarks>
            You never need to call this method unless you plan to animate this node. If you do
            plan to animate it, call this method once you've loaded the node with it's base state,
            ie the state on which all keyframes are based.
            
            If you never call this method, the initial state is the identity transform, ie do nothing.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String)">
            <summary>
            Creates a new name child node.
            </summary>
            <param name="pName"></param>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String,Axiom.MathLib.Vector3,Axiom.MathLib.Quaternion)">
            <summary>
            Creates a new named child node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild">
            <summary>
            Creates a new Child node.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(Axiom.MathLib.Vector3,Axiom.MathLib.Quaternion)">
            <summary>
            Creates a new child node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.NeedUpdate">
            <summary>
            	To be called in the event of transform changes to this node that require it's recalculation.
            </summary>
            <remarks>
            	This not only tags the node state as being 'dirty', it also requests it's parent to 
            	know about it's dirtiness so it will get an update next time.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Node.RequestUpdate(Axiom.Core.Node)">
            <summary>
            	Called by children to notify their parent that they need an update.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.CancelUpdate(Axiom.Core.Node)">
            <summary>
            	Called by children to notify their parent that they no longer need an update.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.UpdateFromParent">
            <summary>
            Triggers the node to update it's combined transforms.
            
            This method is called internally by the engine to ask the node
            to update it's complete transformation based on it's parents
            derived transform.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.MakeTransform(Axiom.MathLib.Vector3,Axiom.MathLib.Vector3,Axiom.MathLib.Quaternion)">
            <summary>
            Internal method for building a Matrix4 from orientation / scale / position. 
            </summary>
            <remarks>
            Transform is performed in the order rotate, scale, translation, i.e. translation is independent
            of orientation axes, scale does not affect size of translation, rotation and scaling are always
            centered on the origin.
            </remarks>
            <param name="position"></param>
            <param name="scale"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.MakeInverseTransform(Axiom.MathLib.Vector3,Axiom.MathLib.Vector3,Axiom.MathLib.Quaternion)">
            <summary>
            Internal method for building an inverse Matrix4 from orientation / scale / position. 
            </summary>
            <remarks>
            As makeTransform except it build the inverse given the same data as makeTransform, so
            performing -translation, 1/scale, -rotate in that order.
            </remarks>
            <param name="position"></param>
            <param name="scale"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChildImpl">
            <summary>
            Must be overridden in subclasses.  Specifies how a Node is created.  CreateChild uses this to create a new one and add it
            to the list of child nodes.  This allows subclasses to not have to override CreateChild and duplicate all its functionality.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.CreateChildImpl(System.String)">
            <summary>
            Must be overridden in subclasses.  Specifies how a Node is created.  CreateChild uses this to create a new one and add it
            to the list of child nodes.  This allows subclasses to not have to override CreateChild and duplicate all its functionality.
            </summary>
            <param name="name">The name of the node to add.</param>
        </member>
        <member name="M:Axiom.Core.Node.Update(System.Boolean,System.Boolean)">
            <summary>
            Internal method to update the Node.
            Updates this node and any relevant children to incorporate transforms etc.
            Don't call this yourself unless you are writing a SceneManager implementation.
            </summary>
            <param name="updateChildren">If true, the update cascades down to all children. Specify false if you wish to
            update children separately, e.g. because of a more selective SceneManager implementation.</param>
        </member>
        <member name="M:Axiom.Core.Node.WeightedTransform(System.Single,Axiom.MathLib.Vector3,Axiom.MathLib.Quaternion,Axiom.MathLib.Vector3)">
            <summary>
            This method transforms a Node by a weighted amount from it's
            initial state. If weighted transforms have already been applied, 
            the previous transforms and this one are blended together based
            on their relative weight. This method should not be used in
            combination with the unweighted rotate, translate etc methods.
            </summary>
            <param name="weight"></param>
            <param name="translate"></param>
            <param name="rotate"></param>
            <param name="scale"></param>
        </member>
        <member name="M:Axiom.Core.Node.GetRenderOperation(Axiom.SubSystems.Rendering.RenderOperation)">
            <summary>
            	This is only used if the SceneManager chooses to render the node. This option can be set
            	for SceneNodes at SceneManager.DisplaySceneNodes, and for entities based on skeletal 
            	models using Entity.DisplaySkeleton = true.
             </summary>
        </member>
        <member name="P:Axiom.Core.Node.Name">
            <summary>
            The name of this Node object.  It is autogenerated initially, so setting it is optional.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Parent">
            <summary>
            Get the Parent Node of the current Node.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.ChildNodes">
            <summary>
            A list of child nodes for this Node object.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Orientation">
            <summary>
            A Quaternion representing the nodes orientation.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Position">
            <summary>
            The position of the node relative to its parent.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.ScaleFactor">
            <summary>
            The scaling factor applied to this node.
            </summary>
            <remarks>
            Scaling factors, unlike other transforms, are not always inherited by child nodes. 
            Whether or not scalings affect both the size and position of the child nodes depends on
            the setInheritScale option of the child. In some cases you want a scaling factor of a parent node
            to apply to a child node (e.g. where the child node is a part of the same object, so you
            want it to be the same relative size and position based on the parent's size), but
            not in other cases (e.g. where the child node is just for positioning another object,
            you want it to maintain it's own size and relative position). The default is to inherit
            as with other transforms.
            
            Note that like rotations, scalings are oriented around the node's origin.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.InheritScale">
             <summary>
             Tells the node whether it should inherit scaling factors from it's parent node.
             </summary>
             <remarks>
            	Scaling factors, unlike other transforms, are not always inherited by child nodes. 
            	Whether or not scalings affect both the size and position of the child nodes depends on
            	the setInheritScale option of the child. In some cases you want a scaling factor of a parent node
            	to apply to a child node (e.g. where the child node is a part of the same object, so you
            	want it to be the same relative size and position based on the parent's size), but
            	not in other cases (e.g. where the child node is just for positioning another object,
            	you want it to maintain it's own size and relative position). The default is to inherit
            	as with other transforms.
            	If true, this node's scale and position will be affected by its parent's scale. If false,
            	it will not be affected.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.LocalAxes">
            <summary>
            Gets a matrix whose columns are the local axes based on
            the nodes orientation relative to it's parent.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedOrientation">
            <summary>
            Gets the orientation of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedPosition">
            <summary>
            Gets the position of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedScale">
            <summary>
            Gets the scaling factor of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.FullTransform">
            <summary>
            Gets the full transformation matrix for this node.
            </summary>
            <remarks>
            This method returns the full transformation matrix
            for this node, including the effect of any parent node
            transformations, provided they have been updated using the Node::Update method.
            This should only be called by a SceneManager which knows the
            derived transforms have been updated before calling this method.
            Applications using the engine should just use the relative transforms.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.WorldTransforms">
            <summary>
            	
            </summary>
            <remarks>
            	This is only used if the SceneManager chooses to render the node. This option can be set
            	for SceneNodes at SceneManager.DisplaySceneNodes, and for entities based on skeletal 
            	models using Entity.DisplaySkeleton = true.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.Shader">
            <summary>
            	
            </summary>
            <remarks>
            	This is only used if the SceneManager chooses to render the node. This option can be set
            	for SceneNodes at SceneManager.DisplaySceneNodes, and for entities based on skeletal 
            	models using Entity.DisplaySkeleton = true.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Bone.manuallyControlled">
            <summary>Determines whether this bone is controlled at runtime.</summary>
        </member>
        <member name="P:Axiom.Animating.Bone.ManuallyControlled">
            <summary>
            	Determines whether this bone is controlled at runtime.
            </summary>
        </member>
        <member name="T:Axiom.Animating.VertexBoneAssignment">
            <summary>
            	Records the assignment of a single vertex to a single bone with the corresponding weight.
             </summary>
             <remarks>
            	This simple struct simply holds a vertex index, bone index and weight representing the
            	assignment of a vertex to a bone for skeletal animation. There may be many of these
            	per vertex if blended vertex assignments are allowed.
            </remarks>
        </member>
        <member name="T:Axiom.Animating.InterpolationMode">
            <summary>
            	Types of interpolation used in animation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.InterpolationMode.Linear">
            <summary>
            	More robotic movement, not as realistic.
             </summary>
        </member>
        <member name="F:Axiom.Animating.InterpolationMode.Spline">
            <summary>
            	Smooth movement between keyframes.
             </summary>
        </member>
        <member name="T:Axiom.Animating.SkeletalAnimBlendMode">
            <summary>
            	Used to specify how animations are applied to a skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletalAnimBlendMode.Average">
            <summary>
            	Animations are applied by calculating a weighted average of all animations.
             </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletalAnimBlendMode.Cumulative">
            <summary>
            	Animations are applied bu calculating a weighted cumulative total.
            </summary>
        </member>
        <member name="T:Axiom.Animating.KeyFrame">
            <summary>
            A key frame in an animation sequence defined by an AnimationTrack.
            </summary>
            <remarks>
            This class can be used as a basis for all kinds of key frames. 
            The unifying principle is that multiple KeyFrames define an 
            animation sequence, with the exact state of the animation being an 
            interpolation between these key frames.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.KeyFrame.#ctor">
            <summary>
            Creates a new keyframe starting at time 0.
            </summary>
        </member>
        <member name="M:Axiom.Animating.KeyFrame.#ctor(System.Single)">
            <summary>
            Creates a new keyframe with the specified time.  
            Should really be created by AnimationTrack.CreateKeyFrame() instead.
            </summary>
            <param name="pTime"></param>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Rotation">
            <summary>
            Sets the rotation applied by this keyframe.
            Use Quaternion methods to convert from angle/axis or Matrix3 if
            you don't like using Quaternions directly.
            </summary>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Scale">
            <summary>
            Sets the scaling factor applied by this keyframe to the animable
            object at it's time index.
            beware of supplying zero values for any component of this
            vector, it will scale the object to zero dimensions.
            </summary>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Translate">
            <summary>
            Sets the translation associated with this keyframe. 
            </summary>
            <remarks>
            The translation factor affects how much the keyframe translates (moves) it's animable
            object at it's time index.
            </remarks>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Time">
            <summary>
            Gets the time of this keyframe in the animation sequence.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Skeleton">
            <summary>
            	A collection of Bone objects used to animate a skinned mesh.
             </summary>
             <remarks>
            	Skeletal animation works by having a collection of 'bones' which are 
            	actually just joints with a position and orientation, arranged in a tree structure.
            	For example, the wrist joint is a child of the elbow joint, which in turn is a
            	child of the shoulder joint. Rotating the shoulder automatically moves the elbow
            	and wrist as well due to this hierarchy.
            	<p/>
            	So how does this animate a mesh? Well every vertex in a mesh is assigned to one or more
            	bones which affects it's position when the bone is moved. If a vertex is assigned to 
            	more than one bone, then weights must be assigned to determine how much each bone affects
            	the vertex (actually a weight of 1.0 is used for single bone assignments). 
            	Weighted vertex assignments are especially useful around the joints themselves
            	to avoid 'pinching' of the mesh in this region. 
            	<p/>
            	Therefore by moving the skeleton using preset animations, we can animate the mesh. The
            	advantage of using skeletal animation is that you store less animation data, especially
            	as vertex counts increase. In addition, you are able to blend multiple animations together
            	(e.g. walking and looking around, running and shooting) and provide smooth transitions
            	between animations without incurring as much of an overhead as would be involved if you
            	did this on the core vertex data.
            	<p/>
            	Skeleton definitions are loaded from datafiles, namely the .xsf file format. They
            	are loaded on demand, especially when referenced by a Model.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Skeleton.MAX_BONE_COUNT">
            <summary>Maximum total available bone matrices that are available during blending.</summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone(System.String)">
            <summary>
            Creates a new bone.
            </summary>
        </member>
        <member name="T:Axiom.Core.SkeletonManager">
            <summary>
            Summary description for SkeletonManager.
            </summary>
        </member>
        <member name="T:Axiom.Audio.AudioStream">
            <summary>
            Summary description for AudioStream.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.Resource" -->
        <member name="M:Axiom.Core.Resource.#ctor">
            <summary>
            	Default constructor.
            </summary>
            <remarks>Subclasses must initialize name and size.</remarks>
        </member>
        <member name="M:Axiom.Core.Resource.Load">
            <summary>
            	Loads the resource, if not loaded already.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.Unload">
            <summary>
            	Unloads the resource data, but retains enough info. to be able to recreate it
            	on demand.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.Touch">
            <summary>
            	Indicates this resource has been used.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.Dispose">
            <summary>
            	Dispose method.  Made virtual to allow subclasses to destroy resources their own way.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Size">
            <summary>
            	Size of this resource.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Name">
            <summary>
            	Name of this resource.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.IsLoaded">
            <summary>
            	Is this resource loaded?
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.LastAccessed">
            <summary>
            	The time the resource was last touched.
            </summary>
        </member>
        <member name="F:Axiom.Audio.AudioStream.MAX_CACHE_SIZE">
            <summary>Max size of .wav file to be cached.  Larger sound files are streamed in.</summary>
        </member>
        <member name="M:Axiom.Audio.AudioStream.Load">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Audio.AudioStream.Unload">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Audio.AudioStream.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="T:Axiom.Audio.AudioSystem">
            <summary>
            Summary description for Audio.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceManager">
            <summary>
            	Defines a generic resource handler.
            </summary>
            <remarks>
            	A resource manager is responsible for managing a pool of
            	resources of a particular type. It must index them, look
            	them up, load and destroy them. It may also need to stay within
            	a defined memory budget, and temporaily unload some resources
            	if it needs to to stay within this budget.
            	<p/>
            	Resource managers use a priority system to determine what can
            	be unloaded, and a Least Recently Used (LRU) policy within
            	resources of the same priority.
            </remarks>
        </member>
        <member name="F:Axiom.Core.ResourceManager.resourceList">
            <summary>A cached list of all resources in memory.</summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.filePaths">
            <summary>A lookup table used to find a common archive associated with a filename.</summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.archives">
            <summary>A cached list of archives specific to a resource type.</summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.commonFilePaths">
            <summary>A lookup table used to find a archive associated with a filename.</summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.commonArchives">
            <summary>A cached list of archives common to all resource types.</summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Load(Axiom.Core.Resource,System.Int32)">
            <summary>
            	Loads a resource.  Resource will be subclasses of Resource.
            </summary>
            <param name="resource">Resource to load.</param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Unload(Axiom.Core.Resource)">
            <summary>
            	Unloads a Resource from the managed resources list, calling it's Unload() method.
            </summary>
            <remarks>
            	This method removes a resource from the list maintained by this manager, and unloads it from
            	memory. It does NOT destroy the resource itself, although the memory used by it will be largely
            	freed up. This would allow you to reload the resource again if you wished. 
            </remarks>
            <param name="resource"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.UnloadAndDestroyAll">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddSearchPath(System.String)">
            <summary>
            	Adds a relative path to search for resources of this type.
            </summary>
            <remarks>
            	This method adds the supplied path to the list of relative locations that that will be searched for
            	a single type of resource only. Each subclass of ResourceManager will maintain it's own list of
            	specific subpaths, which it will append to the current path as it searches for matching files.
            </remarks>
            <param name="path"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddCommonSearchPath(System.String)">
            <summary>
            	Adds a relative search path for resources of ALL types.
            </summary>
            <remarks>
            	This method has the same effect as ResourceManager.AddSearchPath, except that the path added
            	applies to ALL resources, not just the one managed by the subclass in question.
            </remarks>
            <param name="path"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddArchive(System.String,System.String)">
            <summary>
            	Adds an archive to 
            </summary>
            <param name="name"></param>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddCommonArchive(System.String,System.String)">
            <summary>
            	Adds an archive to 
            </summary>
            <param name="name"></param>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.CheckUsage">
            <summary>
            	Makes sure we are still within budget.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.FindResourceData(System.String)">
            <summary>
            	Locates resource data within the archives known to the ResourceManager.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.FindCommonResourceData(System.String)">
            <summary>
            	Locates resource data within the archives known to the ResourceManager.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Create(System.String)">
            <summary>
            	Creates a new blank resource, compatible with this manager.
            </summary>
            <remarks>
            	Resource managers handle disparate types of resources. This method returns a pointer to a
            	valid new instance of the kind of resource managed here. The caller should  complete the
            	details of the returned resource and call ResourceManager.Load to load the resource. Note
            	that it is the CALLERS responsibility to destroy this object when it is no longer required
            	(after calling ResourceManager.Unload if it had been loaded).
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.ResourceManager.MemoryBudget">
            <summary>
            	Sets a limit on the amount of memory this resource handler may use.	
            </summary>
            <remarks>
            	If, when asked to load a new resource, the manager believes it will exceed this memory
            	budget, it will temporarily unload a resource to make room for the new one. This unloading
            	is not permanent and the Resource is not destroyed; it simply needs to be reloaded when
            	next used.
            </remarks>
        </member>
        <member name="P:Axiom.Core.ResourceManager.MemoryUsage">
            <summary>
            	Gets/Sets the current memory usages by all resource managers.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.Item(System.String)">
            <summary>
            	
            </summary>
        </member>
        <member name="T:Axiom.Audio.IAudioSystem">
            <summary>
            Summary description for IAudioSystem.
            </summary>
        </member>
        <member name="M:Axiom.Audio.IAudioSystem.CreateSound(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Audio.AudioSystem.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Audio.IAudioSystemFactory">
            <summary>
            Summary description for IAudioSystemFactory.
            </summary>
        </member>
        <member name="M:Axiom.Audio.IAudioSystemFactory.Create">
            <summary>
            	
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Axiom.Audio.ISound">
            <summary>
            Summary description for ISound.
            </summary>
        </member>
        <member name="M:Axiom.Audio.ISound.Play(System.Boolean)">
            <summary>
            
            </summary>
            <param name="loop"></param>
        </member>
        <member name="M:Axiom.Audio.ISound.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Audio.ISound.Destroy">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Audio.ISound.Position">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Audio.ISound.Volumes">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Collections.AnimationCollection">
            <summary>
            Summary description for AnimationCollection.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AxiomCollection">
            <summary>
            	Serves as a basis for strongly typed collections in the engine.
            </summary>
            <remarks>
            	<b>GODDAMIT WHY DO WE HAVE TO GO THROUGH THIS SHIT!</b>
            	Can't wait for Generics in .Net Framework 2.0!   
            </remarks>
        </member>
        <member name="F:Axiom.Collections.AxiomCollection.objectList">
            <summary></summary>
        </member>
        <member name="F:Axiom.Collections.AxiomCollection.parent">
            <summary></summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.#ctor">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.#ctor(System.Object)">
            <summary>
            	
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Add(System.Object)">
            <summary>
            	Accepts an unnamed object and names it manually.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Add(System.Object,System.Object)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="key"></param>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Clear">
            <summary>
            	Clears all objects from the collection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Remove(System.Object)">
            <summary>
            	Removes the item from the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.ContainsKey(System.Object)">
            <summary>
            	Tests if there is a dupe entry in here.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Reset">
            <summary>
            	Resets the in progress enumerator.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.MoveNext">
            <summary>
            	Moves to the next item in the enumeration if there is one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.OnItemAdded(System.Object)">
            <summary>
            	Called to fire the ItemAdded event.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.OnItemRemoved(System.Object)">
            <summary>
            	Called to fire the ItemRemoved event.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.OnCleared">
            <summary>
             Called to fire the Cleared event
            </summary>
        </member>
        <member name="P:Axiom.Collections.AxiomCollection.Item(System.Int32)">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Collections.AxiomCollection.Item(System.Object)">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Collections.AxiomCollection.Current">
            <summary>
            	Returns the current object in the enumeration.
            </summary>
        </member>
        <member name="E:Axiom.Collections.AxiomCollection.ItemAdded">
            <summary>An event that is fired when items are added to the collection. </summary>
        </member>
        <member name="E:Axiom.Collections.AxiomCollection.ItemRemoved">
            <summary>An event that is fired when items are removed from the collection. </summary>
        </member>
        <member name="E:Axiom.Collections.AxiomCollection.Cleared">
            <summary>An event that is fired when the collection is cleared. </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationCollection.Add(Axiom.Animating.Animation)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AnimationCollection.Add(System.String,Axiom.Animating.Animation)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.AnimationCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.AnimationCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AnimationStateCollection">
            <summary>
            Summary description for AnimationStateCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationStateCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationStateCollection.Add(Axiom.Animating.AnimationState)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AnimationStateCollection.Add(System.String,Axiom.Animating.AnimationState)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.AnimationStateCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.AnimationStateCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AnimationTrackCollection">
            <summary>
            Summary description for AnimationTrackCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationTrackCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationTrackCollection.Add(Axiom.Animating.AnimationTrack)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AnimationTrackCollection.Add(System.Int16,Axiom.Animating.AnimationTrack)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.AnimationTrackCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.AnimationTrackCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.BillboardSetCollection">
            <summary>
            Summary description for BillboardSetCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.BillboardSetCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.BillboardSetCollection.Add(Axiom.Core.BillboardSet)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.BillboardSetCollection.Add(System.String,Axiom.Core.BillboardSet)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.BillboardSetCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.BillboardSetCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.CameraCollection">
            <summary>
            Summary description for CameraCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.CameraCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.CameraCollection.Add(Axiom.Core.Camera)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.CameraCollection.Add(System.String,Axiom.Core.Camera)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.CameraCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.CameraCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.EntityCollection">
            <summary>
            Summary description for EntityCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.EntityCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.EntityCollection.#ctor(Axiom.Core.Entity)">
            <summary>
            	Constructor that takes a parent object to, and calls the base class constructor to 
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:Axiom.Collections.EntityCollection.Add(Axiom.Core.Entity)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.EntityCollection.Add(System.String,Axiom.Core.Entity)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.EntityCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.EntityCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.HashList">
            <summary>
            	Summary description for HashList.
            </summary>
        </member>
        <member name="T:Axiom.Collections.KeyFrameCollection">
            <summary>
            Summary description for KeyFrameCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.KeyFrameCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.KeyFrameCollection.Add(Axiom.Animating.KeyFrame)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.KeyFrameCollection.Add(System.Single,Axiom.Animating.KeyFrame)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.KeyFrameCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="T:Axiom.Collections.LightCollection">
            <summary>
            Summary description for LightCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.LightCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.LightCollection.Add(Axiom.Core.Light)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.LightCollection.Add(System.String,Axiom.Core.Light)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.LightCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.LightCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.MeshCollection">
            <summary>
            Summary description for MeshCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.MeshCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.MeshCollection.Add(Axiom.Core.Mesh)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.MeshCollection.Add(System.String,Axiom.Core.Mesh)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.MeshCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.MeshCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.MovableObjectCollection">
            <summary>
            Summary description for MovableObjectCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.MovableObjectCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.MovableObjectCollection.Add(Axiom.Core.SceneObject)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.MovableObjectCollection.Add(System.String,Axiom.Core.SceneObject)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.MovableObjectCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.MovableObjectCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.NodeCollection">
            <summary>
            Summary description for NodeCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.NodeCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.NodeCollection.#ctor(Axiom.Core.Node)">
            <summary>
            	Constructor that takes a parent object to, and calls the base class constructor to 
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:Axiom.Collections.NodeCollection.Add(Axiom.Core.Node)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.NodeCollection.Add(System.String,Axiom.Core.Node)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.NodeCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.NodeCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.RenderSystemCollection">
            <summary>
            Summary description for RenderSystemCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderSystemCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderSystemCollection.Add(Axiom.SubSystems.Rendering.RenderSystem)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.RenderSystemCollection.Add(System.String,Axiom.SubSystems.Rendering.RenderSystem)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.RenderSystemCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.RenderSystemCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.RenderWindowCollection">
            <summary>
            Summary description for RenderWindowCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderWindowCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderWindowCollection.Add(Axiom.SubSystems.Rendering.RenderWindow)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.RenderWindowCollection.Add(System.String,Axiom.SubSystems.Rendering.RenderWindow)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.RenderWindowCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.RenderWindowCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.SceneNodeCollection">
            <summary>
            Summary description for SceneNodeCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneNodeCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneNodeCollection.Add(Axiom.Core.SceneNode)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.SceneNodeCollection.Add(System.String,Axiom.Core.SceneNode)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.SceneNodeCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.SceneNodeCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.SubEntityCollection">
            <summary>
            Summary description for SubEntityCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SubEntityCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SubEntityCollection.Add(Axiom.Core.SubEntity)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.SubEntityCollection.Add(System.String,Axiom.Core.SubEntity)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.SubEntityCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.SubEntityCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.TextureLayerCollection">
            <summary>
            Summary description for TextureLayerCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.TextureLayerCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.TextureLayerCollection.Add(Axiom.Core.TextureLayer)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.TextureLayerCollection.Add(System.String,Axiom.Core.TextureLayer)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.TextureLayerCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.TextureLayerCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.ViewportCollection">
            <summary>
            Summary description for ViewportCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor(Axiom.SubSystems.Rendering.RenderTarget)">
            <summary>
            	Constructor that takes a parent object to, and calls the base class constructor to 
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.Add(Axiom.Core.Viewport)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.ViewportCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="T:Axiom.Configuration.Config">
            <summary>
            Summary description for XConfig.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.MultipyControllerFunction">
            <summary>
            Summary description for MultiplyControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.BaseControllerFunction">
            <summary>
            	Subclasses of this class are responsible for performing a function on an input value for a Controller.
             </summary>
             <remarks>
            	This abstract class provides the interface that needs to be supported for a custom function which
            	can be 'plugged in' to a Controller instance, which controls some object value based on an input value.
            	For example, the WaveControllerFunction class provided by Ogre allows you to use various waveforms to
            	translate an input value to an output value.
            	<p/>
            	This base class implements IControllerFunction, but leaves the implementation up to the subclasses.
            </remarks>
        </member>
        <member name="T:Axiom.Controllers.IControllerFunction">
            <summary>
            	Interface describing the required methods of a Controller Function.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.IControllerFunction.Execute(System.Single)">
            <summary>
            	Called by a controller every frame to have this function run and return on the supplied
            	source value and return the result.
            </summary>
            <param name="val"></param>
        </member>
        <member name="F:Axiom.Controllers.BaseControllerFunction.useDeltaInput">
            <summary>
            	If true, function will add input values together and wrap at 1.0 before evaluating.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.BaseControllerFunction.deltaCount">
            <summary>
            	Value to be added during evaluation.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.BaseControllerFunction.AdjustInput(System.Single)">
            <summary>
            	Adjusts the input value by a delta.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Controllers.Canned.NodeRotationControllerValue">
            <summary>
            Summary description for NodeRotationControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.TexCoordModifierControllerValue">
            <summary>
            Summary description for TexCoordModifierControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.WaveformControllerFunction">
            <summary>
            	Summary description for WaveformControllerFunction.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Controller">
            <summary>
            	Instances of this class 'control' the value of another object in the system.
            </summary>
             <remarks>
            	Controller classes are used to manage the values of object automatically based
            	on the value of some input. For example, a Controller could animate a texture
            	by controlling the current frame of the texture based on time, or a different Controller
            	could change the colour of a material used for a spaceship shield mesh based on the remaining
            	shield power level of the ship.
            	<p/>
            	The Controller is an intentionally abstract concept - it can generate values
            	based on input and a function, which can either be one of the standard ones
            	supplied, or a function can be 'plugged in' for custom behavior - see the <see cref="!:ControllerFunction"/> class for details.
            	Both the input and output values are via <see cref="!:ControllerValue"/> objects, meaning that any value can be both
            	input and output of the controller.
            	<p/>
            	While this is very flexible, it can be a little bit confusing so to make it simpler the most often used
            	controller setups are available by calling methods on the ControllerManager object.
            </remarks>
        </member>
        <member name="F:Axiom.Controllers.Controller.source">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller.destination">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller.function">
            <summary>
            	Local reference to the function to be used for this controller.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller.isEnabled">
            <summary>
            	States whether or not this controller is enabled.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Controller.#ctor(Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerFunction)">
            <summary>
            	Main constructor.  Should not be used directly, rather a controller should be created using the
            	ControllerManager so it can keep track of them.
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="function"></param>
        </member>
        <member name="M:Axiom.Controllers.Controller.Update">
            <summary>
            	Called to update the destination value for this controller.  Will be called during
            	the render loop by ControllerManager.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.Source">
            <summary>
            	The value that returns the source data for this controller.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.Destination">
            <summary>
            	The object the sets the destination objects value.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.Function">
            <summary>
            	Gets/Sets the eference to the function to be used for this controller.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.IsEnabled">
            <summary>
            	Gets/Sets whether this controller is active or not.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.ControllerManager">
            <summary>
            Summary description for ControllerManager.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.controllers">
            <summary>
            	List of references to controllers in a scene.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.frameTimeController">
            <summary>
            	Local instance of a FrameTimeControllerValue to be used for time based controllers.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateController(Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerFunction)">
            <summary>
            	Overloaded method.  Creates a new controller, using a reference to a FrameTimeControllerValue as
            	the source.
            </summary>
            <param name="destination">Controller value to use as the destination.</param>
            <param name="function">Controller funcion that will use the source value to set the destination.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateController(Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerFunction)">
            <summary>
            	Factory method for creating an instance of a controller based on the input provided.
            </summary>
            <param name="source">Controller value to use as the source.</param>
            <param name="destination">Controller value to use as the destination.</param>
            <param name="function">Controller funcion that will use the source value to set the destination.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.UpdateAll">
            <summary>
            	Causes all registered controllers to execute.  This will depend on RenderSystem.BeginScene already
            	being called so that the time since last frame can be obtained for calculations.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.WaveformType">
            <summary>
            Enumerates the wave types usable with the engine.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Sine">
            <summary>Standard sine wave which smoothly changes from low to high and back again.</summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Triangle">
            <summary>An angular wave with a constant increase / decrease speed with pointed peaks.</summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Square">
            <summary>Half of the time is spent at the min, half at the max with instant transition between. </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Sawtooth">
            <summary>Gradual steady increase from min to max over the period with an instant return to min at the end. </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.InverseSawtooth">
            <summary>Gradual steady decrease from max to min over the period, with an instant return to max at the end. </summary>
        </member>
        <member name="T:Axiom.Controllers.FrameTimeControllerValue">
            <summary>
            Summary description for FrameTimeControllerValue.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.FrameTimeControllerValue.frameTime">
            <summary>
            	Stores the value of the time elapsed since the last frame.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.FrameTimeControllerValue.timeFactor">
            <summary>
            	Float value that should be used to scale controller time.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.FrameTimeControllerValue.RenderSystem_FrameStarted(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	Event handler to the Frame Started event so that we can capture the
            	time since last frame to use for controller functions.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Controllers.FrameTimeControllerValue.Axiom#Controllers#IControllerValue#Value">
            <summary>
            	Gets a time scaled value to use for controller functions.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.FrameTimeControllerValue.TimeFactor">
            <summary>
            	Float value that should be used to scale controller time.  This could be used
            	to either speed up or slow down controller functions independent of slowing
            	down the render loop.
            </summary>
        </member>
        <member name="T:Axiom.Core.AxisAlignedBox">
            <summary>
            	A 3D box aligned with the x/y/z axes.
            </summary>
            <remarks>
            	This class represents a simple box which is aligned with the
                axes. Internally it only stores 2 points as the extremeties of
                the box, one which is the minima of all 3 axes, and the other
                which is the maxima of all 3 axes. This class is typically used
                for an axis-aligned bounding box (AABB) for collision and
                visibility determination.
            </remarks>
        </member>
        <member name="M:Axiom.Core.AxisAlignedBox.Transform(Axiom.MathLib.Matrix4)">
            <summary>
            
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Axiom.Core.AxisAlignedBox.UpdateCorners">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.AxisAlignedBox.SetExtents(Axiom.MathLib.Vector3,Axiom.MathLib.Vector3)">
            <summary>
            	Sets both Minimum and Maximum at once, so that UpdateCorners only
            	needs to be called once as well.
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:Axiom.Core.AxisAlignedBox.Merge(Axiom.Core.AxisAlignedBox)">
            <summary>
            	Allows for merging two boxes together (combining).
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.AxisAlignedBox.Maximum">
            <summary>
            	Gets/Sets the maximum corner of the box.
            </summary>
        </member>
        <member name="P:Axiom.Core.AxisAlignedBox.Minimum">
            <summary>
            	Gets/Sets the minimum corner of the box.
            </summary>
        </member>
        <member name="P:Axiom.Core.AxisAlignedBox.Corners">
            <summary>
            	Returns an array of 8 corner points, useful for
            	collision vs. non-aligned objects.
             </summary>
             <remarks>
            	If the order of these corners is important, they are as
            	follows: The 4 points of the minimum Z face (note that
            	because we use right-handed coordinates, the minimum Z is
            	at the 'back' of the box) starting with the minimum point of
            	all, then anticlockwise around this face (if you are looking
            	onto the face from outside the box). Then the 4 points of the
            	maximum Z face, starting with maximum point of all, then
            	anticlockwise around this face (looking onto the face from
            	outside the box). Like this:
            	<pre>
            		 1-----2
            	    /|     /|
            	  /  |   /  |
            	5-----4   |
            	|   0-|--3
            	|  /   |  /
            	|/     |/
            	6-----7
            	</pre>
            </remarks>
        </member>
        <member name="P:Axiom.Core.AxisAlignedBox.IsNull">
            <summary>
            	Gets/Sets the value of whether this box is null (i.e. not dimensions, etc).
            </summary>
        </member>
        <member name="P:Axiom.Core.AxisAlignedBox.Null">
            <summary>
            	Returns a null box
            </summary>
        </member>
        <member name="T:Axiom.Core.Billboard">
            <summary>
            	A billboard is a primitive which always faces the camera in every frame.
            </summary>
            <remarks>
            	Billboards can be used for special effects or some other trickery which requires the
            	triangles to always facing the camera no matter where it is. The engine groups billboards into
            	sets for efficiency, so you should never create a billboard on it's own (it's ok to have a
            	set of one if you need it).
            	<p/>
            	Billboards have their geometry generated every frame depending on where the camera is. It is most
            	beneficial for all billboards in a set to be identically sized since the engine can take advantage of this and
            	save some calculations - useful when you have sets of hundreds of billboards as is possible with special
            	effects. You can deviate from this if you wish (example: a smoke effect would probably have smoke puffs
            	expanding as they rise, so each billboard will legitimately have it's own size) but be aware the extra
            	overhead this brings and try to avoid it if you can.
            	<p/>
            	Billboards are just the mechanism for rendering a range of effects such as particles. It is other classes
            	which use billboards to create their individual effects, so the methods here are quite generic.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor(Axiom.MathLib.Vector3,Axiom.Core.BillboardSet)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="owner"></param>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor(Axiom.MathLib.Vector3,Axiom.Core.BillboardSet,Axiom.Core.ColorEx)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="owner"></param>
            <param name="color"></param>
        </member>
        <member name="M:Axiom.Core.Billboard.NotifyOwner(Axiom.Core.BillboardSet)">
            <summary>
            	Internal method for notifying a billboard of it's owner.
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:Axiom.Core.Billboard.Dimensions">
            <summary>
            	Width and height of this billboard, if it has it's own.
            </summary>
        </member>
        <member name="P:Axiom.Core.Billboard.HasOwnDimensions">
            <summary>
            	Sepcifies whether or not this billboard has different dimensions than the rest in the set.
            </summary>
        </member>
        <member name="T:Axiom.Core.BillboardSet">
            <summary>
            	A collection of billboards (faces which are always facing the camera) with the same (default) dimensions, material
            	and which are fairly close proximity to each other.
             </summary>
             <remarks>
            	Billboards are rectangles made up of 2 tris which are always facing the camera. They are typically used
            	for special effects like particles. This class collects together a set of billboards with the same (default) dimensions,
            	material and relative locality in order to process them more efficiently. The entire set of billboards will be
            	culled as a whole (by default, although this can be changed if you want a large set of billboards
            	which are spread out and you want them culled individually), individual Billboards have locations which are relative to the set (which itself derives it's
            	position from the SceneNode it is attached to since it is a SceneObject), they will be rendered as a single rendering operation,
            	and some calculations will be sped up by the fact that they use the same dimensions so some workings can be reused.
            	<p/>
            	A BillboardSet can be created using the SceneManager.CreateBillboardSet method. They can also be used internally
            	by other classes to create effects.
            </remarks>
        </member>
        <member name="T:Axiom.Core.SceneObject">
            <summary>
            Abstract class definining a movable object in a scene.
            </summary>
            <remarks>
            Instances of this class are discrete, relatively small, movable objects
            which are attached to SceneNode objects to define their position.						  
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneObject.UpdateRenderQueue(Axiom.SubSystems.Rendering.RenderQueue)">
            <summary>
            	An abstract method that causes the specified RenderQueue to update itself.  
            </summary>
            <remarks>This is an internal method used by the engine assembly only.</remarks>
            <param name="queue">The render queue that this object should be updated in.</param>
        </member>
        <member name="M:Axiom.Core.SceneObject.NotifyAttached(Axiom.Core.SceneNode)">
            <summary>
            	Internal method called to notify the object that it has been attached to a node.
            </summary>
            <param name="node">Scene node to notify.</param>
        </member>
        <member name="M:Axiom.Core.SceneObject.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            	Internal method to notify the object of the camera to be used for the next rendering operation.
            </summary>
            <remarks>
            	Certain objects may want to do specific processing based on the camera position. This method notifies
            	them incase they wish to do this.
            </remarks>
            <param name="camera"></param>
        </member>
        <member name="P:Axiom.Core.SceneObject.BoundingBox">
            <summary>
            	An abstract method required by subclasses to return the bounding box of this object.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneObject.ParentNode">
            <summary>
            	Gets the parent node that this object is attached to.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneObject.IsAttached">
            <summary>
            	See if this object is attached to another node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneObject.IsVisible">
            <summary>
            	States whether or not this object should be visible.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneObject.Name">
            <summary>
            	Name of this SceneObject.
            </summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.aab">
            <summary>Bounds of all billboards in this set</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.originType">
            <summary>Origin of each billboard</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.defaultDimensions">
            <summary>Default width/height of each billboard.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.shaderName">
            <summary>Name of the shader to use</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.shader">
            <summary>Reference to the shader to use</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.allDefaultSize">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.autoExtendPool">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.cullIndividual">
            <summary>Indicates whether or not each billboard should be culled individually.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.billboardType">
            <summary>Type of billboard to render.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.commonDirection">
            <summary>Common direction for billboard oriented with type Common.</summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.#ctor">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.#ctor(System.String,System.Int32)">
            <summary>
            	Public constructor.  Should not be created manually, must be created using a SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyBillboardResized">
            <summary>
            	Callback used by Billboards to notify their parent that they have been resized.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.IncreasePool(System.Int32)">
            <summary>
            	Internal method for increasing pool size.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.IsBillboardVisible(Axiom.Core.Camera,Axiom.Core.Billboard)">
            <summary>
            	Determines whether the supplied billboard is visible in the camera or not.
            </summary>
            <param name="camera"></param>
            <param name="billboard"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateBillboardAxes(Axiom.Core.Camera,Axiom.MathLib.Vector3@,Axiom.MathLib.Vector3@)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="camera"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateBillboardAxes(Axiom.Core.Camera,Axiom.MathLib.Vector3@,Axiom.MathLib.Vector3@,Axiom.Core.Billboard)">
            <summary>
            	Generates billboard corners.
            </summary>
            <param name="camera"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="billboard"></param>
            <remarks>Billboard param only required for type OrientedSelf</remarks>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GetParametericOffsets(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            	Generate parametric offsets based on the origin.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="top"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateVertices(System.Single[],System.Int32[],Axiom.MathLib.Vector3[],Axiom.Core.Billboard)">
            <summary>
            	Generates vertex data for a billboard.
            </summary>
            <param name="position">Vertex positions.</param>
            <param name="colors">Vertex colors</param>
            <param name="offsets">Array of 4 Vector3 offsets.</param>
            <param name="billboard">A billboard.</param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateVertexOffsets(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Axiom.MathLib.Vector3@,Axiom.MathLib.Vector3@,Axiom.MathLib.Vector3[])">
            <summary>
            	Generates vertex offsets.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="top"></param>
            <param name="bottom"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="destVec"></param>
            <remarks>
            	Takes in parametric offsets as generated from GetParametericOffsets, width and height values
            	and billboard x and y axes as generated from GenerateBillboardAxes. 
            	Fills output array of 4 vectors with vector offsets
            	from origin for left-top, right-top, left-bottom, right-bottom corners.
            </remarks>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(Axiom.MathLib.Vector3)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(Axiom.MathLib.Vector3,Axiom.Core.ColorEx)">
            <summary>
            	Creates a new billboard and adds it to this set.
            </summary>
            <param name="position"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.Clear">
            <summary>
            	Empties all of the active billboards from this set.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.UpdateBounds">
            <summary>
            	Update the bounds of the BillboardSet.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            	Generate the vertices for all the billboards relative to the camera
            </summary>
            <param name="camera"></param>
        </member>
        <member name="P:Axiom.Core.BillboardSet.AutoExtend">
            <summary>
            	Tells the set whether to allow automatic extension of the pool of billboards.
             </summary>
             <remarks>
            	A BillboardSet stores a pool of pre-constructed billboards which are used as needed when
            	a new billboard is requested. This allows applications to create / remove billboards efficiently
            	without incurring construction / destruction costs (a must for sets with lots of billboards like
            	particle effects). This method allows you to configure the behaviour when a new billboard is requested
            	but the billboard pool has been exhausted.
            	<p/>
            	The default behaviour is to allow the pool to extend (typically this allocates double the current
            	pool of billboards when the pool is expended), equivalent to calling this property to
            	true. If you set the property to false however, any attempt to create a new billboard
            	when the pool has expired will simply fail silently, returning a null pointer.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.PoolSize">
            <summary>
            	Adjusts the size of the pool of billboards available in this set.
             </summary>
             <remarks>
            	See the BillboardSet.AutoExtend property for full details of the billboard pool. This method adjusts
            	the preallocated size of the pool. If you try to reduce the size of the pool, the set has the option
            	of ignoring you if too many billboards are already in use. Bear in mind that calling this method will
            	incur significant construction / destruction calls so should be avoided in time-critical code. The same
            	goes for auto-extension, try to avoid it by estimating the pool size correctly up-front.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BillboardOrigin">
            <summary>
            	Gets/Sets the point which acts as the origin point for all billboards in this set.
             </summary>
             <remarks>
            	This setting controls the fine tuning of where a billboard appears in relation to it's
            	position. It could be that a billboard's position represents it's center (e.g. for fireballs),
            	it could mean the center of the bottom edge (e.g. a tree which is positioned on the ground),
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.DefaultDimensions">
            <summary>
            	Sets the default dimensions of the billboards in this set.
             </summary>
             <remarks>
            	All billboards in a set are created with these default dimensions. The set will render most efficiently if
            	all the billboards in the set are the default size. It is possible to alter the size of individual
            	billboards at the expense of extra calculation. See the Billboard class for more info.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.ShaderName">
            <summary>
            	Gets/Sets the name of the shader to use for this billboard set.
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.CullIndividual">
            <summary>
            	Sets whether culling tests billboards in this individually as well as in a group.
             </summary>
             <remarks>
            	Billboard sets are always culled as a whole group, based on a bounding box which 
            	encloses all billboards in the set. For fairly localised sets, this is enough. However, you
            	can optionally tell the set to also cull individual billboards in the set, i.e. to test
            	each individual billboard before rendering. The default is not to do this.
            	<p/>
            	This is useful when you have a large, fairly distributed set of billboards, like maybe 
            	trees on a landscape. You probably still want to group them into more than one
            	set (maybe one set per section of landscape), which will be culled coarsely, but you also
            	want to cull the billboards individually because they are spread out. Whilst you could have
            	lots of single-tree sets which are culled separately, this would be inefficient to render
            	because each tree would be issued as it's own rendering operation.
            	<p/>
            	By setting this property to true, you can have large billboard sets which 
            	are spaced out and so get the benefit of batch rendering and coarse culling, but also have
            	fine-grained culling so unnecessary rendering is avoided.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BillboardType">
            <summary>
            	Gets/Sets the type of billboard to render.
             </summary>
             <remarks>
            	The default sort of billboard (Point), always has both x and y axes parallel to 
            	the camera's local axes. This is fine for 'point' style billboards (e.g. flares,
            	smoke, anything which is symmetrical about a central point) but does not look good for
            	billboards which have an orientation (e.g. an elongated raindrop). In this case, the
            	oriented billboards are more suitable (OrientedCommon or OrientedSelf) since they retain an independant Y axis
            	and only the X axis is generated, perpendicular to both the local Y and the camera Z.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.CommonDirection">
            <summary>
            	Use this to specify the common direction given to billboards of type OrientedCommon.
             </summary>
             <remarks>
            	Use OrientedCommon when you want oriented billboards but you know they are always going to 
            	be oriented the same way (e.g. rain in calm weather). It is faster for the system to calculate
            	the billboard vertices if they have a common direction.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.Billboards">
            <summary>
            	Gets the list of active billboards.
            </summary>
        </member>
        <member name="T:Axiom.Core.Camera">
             <summary>
            		A viewpoint from which the scene will be rendered.
             </summary>
            <remarks>
            		The engine renders scenes from a camera viewpoint into a buffer of
            		some sort, normally a window or a texture (a subclass of
            		RenderTarget). the engine cameras support both perspective projection (the default,
            		meaning objects get smaller the further away they are) and
            		orthographic projection (blueprint-style, no decrease in size
            		with distance). Each camera carries with it a style of rendering,
            		e.g. full textured, flat shaded, wireframe), field of view,
            		rendering distances etc, allowing you to use the engine to create
            		complex multi-window views if required. In addition, more than
            		one camera can point at a single render target if required,
            		each rendering to a subset of the target, allowing split screen
            		and picture-in-picture views.
            		<p/>
            		Cameras maintain their own aspect ratios, field of view, and frustrum,
            		and project co-ordinates into a space measured from -1 to 1 in x and y,
            		and 0 to 1 in z. At render time, the camera will be rendering to a
            		Viewport which will translate these parametric co-ordinates into real screen
            		co-ordinates. Obviously it is advisable that the viewport has the same
            		aspect ratio as the camera to avoid distortion (unless you want it!).
            		<p/>
            		Note that a Camera can be attached to a SceneNode, using the method
            		SceneNode.Objects.Add. If this is done the Camera will combine it's own
            		position/orientation settings with it's parent SceneNode. 
            		This is useful for implementing more complex Camera / object
            		relationships i.e. having a camera attached to a world object.
             </remarks>
        </member>
        <member name="F:Axiom.Core.Camera.coeffL">
            Temp coefficient values calculated from a frustum change,
            			used when establishing the frustum planes when the view changes. 
        </member>
        <member name="M:Axiom.Core.Camera.UpdateFrustum">
            <summary>
            	Updates the frustum data.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.UpdateView">
            <summary>
            	Updates the view matrix.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.IsViewOutOfDate">
            <summary>
            	Evaluates whether or not the view matrix is out of date.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.IsFrustumOutOfDate">
            <summary>
            	Evaluates whether or not the view frustum is out of date.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.Move(Axiom.MathLib.Vector3)">
            <summary>
            Moves the camera's position by the vector offset provided along world axes.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Axiom.Core.Camera.MoveRelative(Axiom.MathLib.Vector3)">
            <summary>
            Moves the camera's position by the vector offset provided along it's own axes (relative to orientation).
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Axiom.Core.Camera.LookAt(Axiom.MathLib.Vector3)">
            <summary>
            	Specifies a target that the camera should look at.
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Pitch(System.Single)">
            <summary>
            	Pitches the camera up/down counter-clockwise around it's local x axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Yaw(System.Single)">
            <summary>
            	Rolls the camera counter-clockwise, in degrees, around its local y axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Roll(System.Single)">
            <summary>
            	Rolls the camera counter-clockwise, in degrees, around its local z axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Rotate(Axiom.MathLib.Quaternion)">
            <summary>
            	Rotates the camera about an arbitrary axis.
            </summary>
            <param name="quat"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Rotate(Axiom.MathLib.Vector3,System.Single)">
            <summary>
            	Rotates the camera about an arbitrary axis.
            </summary>
            <param name="axis"></param>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.IsObjectVisible(Axiom.Core.AxisAlignedBox)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.IsObjectVisible(Axiom.Core.AxisAlignedBox,Axiom.Enumerations.FrustumPlane@)">
            <summary>
            	Tests whether the given box is visible in the Frustum.
             </summary>
            <param name="box"> Bounding box to be checked.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Camera.IsObjectVisible(Axiom.Core.Sphere)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.IsObjectVisible(Axiom.Core.Sphere,Axiom.Enumerations.FrustumPlane@)">
            <summary>
            	Tests whether the given sphere is in the viewing frustum.
            </summary>
            <param name="sphere">Bounding sphere to be checked.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Camera.IsObjectVisible(Axiom.MathLib.Vector3)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.IsObjectVisible(Axiom.MathLib.Vector3,Axiom.Enumerations.FrustumPlane@)">
            <summary>
            	Tests whether the given 3D point is in the viewing frustum.
            </summary>
            <param name="vector">3D point to check for frustum visibility.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Camera.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode,Axiom.MathLib.Vector3)">
            <summary>
            	Enables / disables automatic tracking of a SceneNode.
            </summary>
            <remarks>
            	If you enable auto-tracking, this Camera will automatically rotate to
            	look at the target SceneNode every frame, no matter how 
            	it or SceneNode move. This is handy if you want a Camera to be focused on a
            	single object or group of objects. Note that by default the Camera looks at the 
            	origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            	attached to this target node is quite big and you want to point the camera at
            	a specific point on it, provide a vector in the 'offset' parameter and the 
            	camera's target point will be adjusted.
            </remarks>
            <param name="enabled">If true, the Camera will track the SceneNode supplied as the next 
            	parameter (cannot be null). If false the camera will cease tracking and will
            	remain in it's current orientation.
             </param> 
            <param name="target">The SceneNode which this Camera will track. Make sure you don't
            	delete this SceneNode before turning off tracking (e.g. SceneManager.ClearScene will
            	delete it so be careful of this). Can be null if and only if the enabled param is false.
            </param>
            <param name="offset">If supplied, the camera targets this point in local space of the target node
            	instead of the origin of the target node. Good for fine tuning the look at point.
            </param>
        </member>
        <member name="M:Axiom.Core.Camera.RenderScene(Axiom.Core.Viewport,System.Boolean)">
            <summary>
            	Called to ask a camera to render the scene into the given viewport.
            </summary>
            <param name="viewport"></param>
            <param name="showOverlays"></param>
        </member>
        <member name="M:Axiom.Core.Camera.AutoTrack">
            <summary>
            	Updates an auto-tracking camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.SceneManager">
            <summary>
            Returns the current SceneManager that this camera is using.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Core.Camera.ProjectionType" -->
        <member name="P:Axiom.Core.Camera.SceneDetail">
            <summary>
            	Sets the level of rendering detail required from this camera.
            </summary>
            <remarks>
            	Each camera is set to render at full detail by default, that is
            	with full texturing, lighting etc. This method lets you change
            	that behavior, allowing you to make the camera just render a
            	wireframe view, for example.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.Frustum">
            <summary>
            	Gets the viewing frustum of this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Position">
            <summary>
            Gets/Sets the cameras position.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Direction">
            <summary>
            Gets/Sets the cameras direction vector.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.FixedYawAxis">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.NumRenderedFaces">
            <summary>
            Gets the last count of triangles visible in the view of this camera.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Core.Camera.FOV" -->
        <member name="P:Axiom.Core.Camera.Near">
            <summary>
            	Gets/Sets the position of the near clipping plane.
            </summary>
            <remarks>
            	The position of the near clipping plane is the distance from the cameras position to the screen
            	on which the world is projected. The near plane distance, combined with the field-of-view and the
            	aspect ratio, determines the size of the viewport through which the world is viewed (in world
            	co-ordinates). Note that this world viewport is different to a screen viewport, which has it's
            	dimensions expressed in pixels. The cameras viewport should have the same aspect ratio as the
            	screen viewport it renders into to avoid distortion.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.Far">
            <summary>
            	Gets/Sets the distance to the far clipping plane.
             </summary>
             <remarks>
            	The view frustrum is a pyramid created from the camera position and the edges of the viewport.
            	This frustrum does not extend to infinity - it is cropped near to the camera and there is a far
            	plane beyond which nothing is displayed. This method sets the distance for the far plane. Different
            	applications need different values: e.g. a flight sim needs a much further far clipping plane than
            	a first-person shooter. An important point here is that the larger the gap between near and far
            	clipping planes, the lower the accuracy of the Z-buffer used to depth-cue pixels. This is because the
            	Z-range is limited to the size of the Z buffer (16 or 32-bit) and the max values must be spread over
            	the gap between near and far clip planes. The bigger the range, the more the Z values will
            	be approximated which can cause artifacts when lots of objects are close together in the Z-plane. So
            	make sure you clip as close to the camera as you can - don't set a huge value for the sake of
            	it.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.AspectRatio">
            <summary>
            	Gets/Sets the aspect ratio to use for the camera viewport.
            </summary>
            <remarks>
            	The ratio between the x and y dimensions of the rectangular area visible through the camera
            	is known as aspect ratio: aspect = width / height .
            	<p/>
            	The default for most fullscreen windows is 1.3333f - this is also assumed unless you
            	use this property to state otherwise.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.ProjectionMatrix">
            <summary>
            Gets the projection matrix for this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.ViewMatrix">
            <summary>
            Gets the view matrix for this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedOrientation">
            <summary>
            	Gets the derived orientation of the camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedPosition">
            <summary>
            	Gets the derived position of the camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedDirection">
            <summary>
            	Gets the derived direction of the camera.
            </summary>
        </member>
        <member name="T:Axiom.Core.ColorEx">
            <summary>
            	This class is necessary so we can store the color components as floating 
            	point values.  It serves as an intermediary to System.Drawing.Color, which
            	stores them as byte values.  This doesn't allow for slow color component
            	interpolation, because with the values always being cast back to a byte would lose
            	any small interpolated values (i.e. 223 - .25 as a byte is 223).
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.a">
            <summary>
            	Alpha value [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.r">
            <summary>
            	Red color component [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.g">
            <summary>
            	Green color component [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.b">
            <summary>
            	Blue color component [0,1].
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Constructor taking all component values.
            </summary>
            <param name="a">Alpha value.</param>
            <param name="r">Red color component.</param>
            <param name="g">Green color component.</param>
            <param name="b">Blue color component.</param>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToColor">
            <summary>
            	Converts this instance to a <see cref="T:System.Drawing.Color"/> structure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToABGR">
            <summary>
            	Converts this color value to packed ABGR format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToARGB">
            <summary>
            	Converts this color value to packed ARBG format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToArrayRGBA">
            <summary>
            	Returns the color components in a 4 elements array in RGBA order.
            </summary>
            <remarks>
            	Primarily used to help in OpenGL.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.FromColor(System.Drawing.Color)">
            <summary>
            	Static method used to create a new <code>ColorEx</code> instance based
            	on an existing <see cref="T:System.Drawing.Color"/> structure.
            </summary>
            <param name="color">.Net color structure to use as a basis.</param>
            <returns>A new <code>ColorEx instance.</code></returns>
        </member>
        <member name="T:Axiom.Core.FrameEvent">
            <summary>
            	A delegate for defining frame events.
            </summary>
        </member>
        <member name="T:Axiom.Core.FrameEventArgs">
            <summary>
            	Used to supply info to the FrameStarted and FrameEnded events.
            </summary>
        </member>
        <member name="T:Axiom.Core.Engine">
            <summary>
            The Engine class is the main container of all the subsystems.  This includes the RenderSystem, various ResourceManagers, etc.
            </summary>
        </member>
        <member name="F:Axiom.Core.Engine.isSetupComplete">
            <summary>A flag which safeguards against Setup being run more than once.</summary>
        </member>
        <member name="M:Axiom.Core.Engine.Initialize(System.Boolean)">
            <summary>
            
            </summary>
            <param name="autoCreateWindow"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Engine.ShowConfigDialog">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Engine.ConvertColor(Axiom.Core.ColorEx)">
            <summary>
            	Asks the current API to convert an instance of ColorEx to a 4 byte packed
            	int value the way it would expect it. 		
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Engine.ShowDebugOverlay(System.Boolean)">
            <summary>
            
            </summary>
            <param name="makeVisible"></param>
        </member>
        <member name="M:Axiom.Core.Engine.Setup">
            <summary>
            Used to setup the engine and all it's dependencies.  
            This should be called before anything else is.
            </summary>
        </member>
        <member name="M:Axiom.Core.Engine.StartRendering">
            <summary>
            	Starts the default rendering loop.
            </summary>
        </member>
        <member name="M:Axiom.Core.Engine.Shutdown">
            <summary>
            	Shuts down the engine and unloads plugins.
            </summary>
        </member>
        <member name="M:Axiom.Core.Engine.Dispose">
            <summary>
            	Called to shutdown the engine and dispose of all it's resources.
            </summary>
        </member>
        <member name="M:Axiom.Core.Engine.OnFrameStarted(Axiom.Core.FrameEventArgs)">
            <summary>
            	Used to manually fire the FrameStarted event.
            </summary>
            <param name="pEventArgs"></param>
        </member>
        <member name="M:Axiom.Core.Engine.OnFrameEnded(Axiom.Core.FrameEventArgs)">
            <summary>
            	Used to manually fire the FrameEnded event.
            </summary>
            <param name="pEventArgs"></param>
        </member>
        <member name="M:Axiom.Core.Engine.LoadPlugins">
            <summary>
            Searches for IPlugin implementations for the engine and loads them.
            </summary>
        </member>
        <member name="M:Axiom.Core.Engine.UnloadPlugins">
            <summary>
            Used to unload any previously loaded plugins.
            </summary>
        </member>
        <member name="E:Axiom.Core.Engine.FrameStarted">
            <summary>
            Fired as a frame is about to be rendered.
            </summary>
        </member>
        <member name="E:Axiom.Core.Engine.FrameEnded">
            <summary>
            Fired after a frame has completed rendering.
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.Name">
            <summary>
            Specifies the name of the engine that will be used where needed (i.e. log files, etc).  
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.Copyright">
            <summary>
            Specifies the name of the engine that will be used where needed (i.e. log files, etc).  
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.Version">
            <summary>
            Returns the current version of the Engine assembly.
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.SceneManager">
            <summary>
            The current SceneManager in use by the engine.
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.SceneManagers">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.RenderSystem">
            <summary>
            Gets/Sets the current active RenderSystem that the engine is using.
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.TextureManager">
            <summary>
            	Gets/Sets the current texture manager.  Should be set in RenderSystem plugins.
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.RenderSystems">
            <summary>
            The list of available render systems for the engine to use (made available via plugins.
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.InputSystem">
            <summary>
            	Gets/Sets the current system to use for reading input.
            </summary>
        </member>
        <member name="P:Axiom.Core.Engine.CurrentFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="T:Axiom.Core.Entity">
            <summary>
            The Entity class serves as the base class for all objects in the engine.   
            It represents the minimum functionality required for an object in a 3D SceneGraph.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.model">
            <summary>3D Model that represents this entity</summary>
        </member>
        <member name="F:Axiom.Core.Entity.subEntityList">
            <summary>List of sub entities.</summary>
        </member>
        <member name="F:Axiom.Core.Entity.sceneMgr">
            <summary>SceneManager responsible for creating this entity.</summary>
        </member>
        <member name="M:Axiom.Core.Entity.#ctor(System.String,Axiom.Core.Model,Axiom.Core.SceneManager)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="model"></param>
            <param name="creator"></param>
        </member>
        <member name="M:Axiom.Core.Entity.BuildSubEntities">
            <summary>
            	Used to build a list of sub-entities from the meshes located in the model.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.UpdateRenderQueue(Axiom.SubSystems.Rendering.RenderQueue)">
            <summary>
            	
            </summary>
            <param name="queue"></param>
        </member>
        <member name="P:Axiom.Core.Entity.MeshLODIndex">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.Core.Entity.Model">
            <summary>
            	Gets the 3D model associated with this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.SubEntities">
            <summary>
            	Gets the collection of sub entities belonging to this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.ShaderName">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Core.Frustum">
            <summary>
            Summary description for Frustrum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.Item(Axiom.Enumerations.FrustumPlane)">
            <summary>
            	An indexer that accepts a FrustumPlane enum value and return the appropriate plane side of the Frustum.
            </summary>
        </member>
        <member name="T:Axiom.Core.GarbageManager">
            <summary>
            	Used to globally register disposable items that should all be destroyed on
            	Engine shutdown.  Any object in the engine that supports IDisposable should
            	be registered with this manager to ensure it will get disposed of 
            	immediately on shutdown.
            </summary>
        </member>
        <member name="T:Axiom.Core.IPlugin">
            <summary>
            	Any class that wants to entend the functionality of the engine can implement this
            	interface.  Classes implementing this interface will automatically be loaded and
            	started by the engine during the initialization phase.  Examples of plugins would be
            	RenderSystems, SceneManagers, etc, which can register themself using the 
            	singleton instance of the Engine class.
            </summary>
        </member>
        <member name="M:Axiom.Core.IPlugin.Start">
            <summary>
            Called to start the plugin.
            </summary>
        </member>
        <member name="M:Axiom.Core.IPlugin.Stop">
            <summary>
            Called while the engine is shutting down.
            </summary>
        </member>
        <member name="T:Axiom.Core.SubSystemAttribute">
            <summary>
            	This is an interface that all engine subsystems should inherit from.  Subsystems will be
            	made available to the engine via plugins, and can be requested in any application.
            	<p/>
            	<code>Engine.Instance.GetSubSystem(SubSystems.Rendering, "OpenGL");</code>
            </summary>
        </member>
        <member name="T:Axiom.Core.Light">
            <summary>
            Summary description for Light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.type">
            <summary>Type of light.</summary>
        </member>
        <member name="F:Axiom.Core.Light.position">
            <summary>Position of this light.</summary>
        </member>
        <member name="F:Axiom.Core.Light.direction">
            <summary>Direction of this light.</summary>
        </member>
        <member name="F:Axiom.Core.Light.derivedPosition">
            <summary>Dervied position of this light.</summary>
        </member>
        <member name="F:Axiom.Core.Light.derivedDirection">
            <summary>Dervied direction of this light.</summary>
        </member>
        <member name="F:Axiom.Core.Light.lastParentOrientation">
            <summary>Stored version of parent orientation.</summary>
        </member>
        <member name="F:Axiom.Core.Light.lastParentPosition">
            <summary>Stored version of parent position.</summary>
        </member>
        <member name="F:Axiom.Core.Light.diffuse">
            <summary>Diffuse color.</summary>
        </member>
        <member name="F:Axiom.Core.Light.specular">
            <summary>Specular color.</summary>
        </member>
        <member name="F:Axiom.Core.Light.spotOuter">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.spotInner">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.spotFalloff">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.range">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationConst">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationLinear">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationQuad">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.isModified">
            <summary></summary>
        </member>
        <member name="M:Axiom.Core.Light.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.#ctor(System.String)">
            <summary>
            	Normal constructor. Should not be called directly, but rather the SceneManager.CreateLight method should be used.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Light.SetSpotlightRange(System.Single,System.Single,System.Single)">
            <summary>
            	Sets the spotlight parameters in a single call.
            </summary>
            <param name="innerAngle"></param>
            <param name="outerAngle"></param>
            <param name="falloff"></param>
        </member>
        <member name="M:Axiom.Core.Light.SetAttenuation(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the attenuation parameters of the light in a single call.
            </summary>
            <param name="range"></param>
            <param name="constant"></param>
            <param name="linear"></param>
            <param name="quadratic"></param>
        </member>
        <member name="P:Axiom.Core.Light.Type">
            <summary>
            	Gets/Sets the type of light this is.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Position">
            <summary>
            	Gets/Sets the position of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Direction">
            <summary>
            	Gets/Sets the direction of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightInnerAngle">
            <summary>
            	Gets the inner angle of the spotlight.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightOuterAngle">
            <summary>
            	Gets the outer angle of the spotlight.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightFalloff">
            <summary>
            	Gets the spotlight falloff.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Diffuse">
            <summary>
            	Gets/Sets the diffuse color of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Specular">
            <summary>
            	Gets/Sets the diffuse color of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationRange">
            <summary>
            	Gets the attenuation range value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationConstant">
            <summary>
            	Gets the constant attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationLinear">
            <summary>
            	Gets the linear attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationQuadratic">
            <summary>
            	Gets the quadratic attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.IsModified">
            <summary>
            	Gets whether or not this light has been modified.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.DerivedPosition">
            <summary>
            	Gets the derived position of this light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.DerivedDirection">
            <summary>
            	Gets the derived position of this light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.IsVisible">
            <summary>
            	Override IsVisible to ensure we are updated when this changes.
            </summary>
        </member>
        <member name="T:Axiom.Core.Log">
            <summary>
            Summary description for Log.
            </summary>
        </member>
        <member name="T:Axiom.Core.Mesh">
            <summary>
            	Defines a part of a complete 3D model.
            </summary>
            <remarks>
            	Models which make up the definition of a discrete 3D object
            	are made up of potentially multiple parts. This is because
            	different parts of the model may use different materials or
            	use different vertex formats, such that a rendering state
            	change is required between them.
            	<p/>
            	Like the Model class, instatiations of 3D objects in the scene
            	share the Mesh instances, and have the option of overriding
            	their material differences on a per-object basis if required.
            	See the SubEntity class for more information.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Mesh.parent">
            <summary>The parent model that this mesh belongs to.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.shaderName">
            <summary>Name of the shader assigned to this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.name">
            <summary>Name of this Mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.useSharedVertices">
            <summary>Indicates if this submesh shares vertex data with other meshes or whether it has it's own vertices.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.isShaderInitialized">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Mesh.numFaces">
            <summary>Number of faces in this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.faceIndices">
            <summary>Indices to use for parent geometry when using shared vertices.</summary>
        </member>
        <member name="M:Axiom.Core.Mesh.#ctor(System.String)">
            <summary>
            	Basic contructor.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.GetRenderOperation(Axiom.SubSystems.Rendering.RenderOperation)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetRenderOperation(Axiom.SubSystems.Rendering.RenderOperation,System.Int32)">
            <summary>
            
            </summary>
            <param name="op"></param>
            <param name="lodIndex"></param>
            <returns></returns>
            DOC
        </member>
        <member name="P:Axiom.Core.Mesh.ShaderName">
            <summary>
            	Gets/Sets the name of the shader this Mesh will be using.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.Parent">
            <summary>
            	Gets/Sets the parent mode of this Mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IsShaderInitialized">
            <summary>
            	Gets whether or not a shader has been set for this mesh.
            </summary>
        </member>
        <member name="T:Axiom.Core.Model">
            <summary>
            Summary description for Model.
            </summary>
        </member>
        <member name="F:Axiom.Core.Model.sharedVertexData">
            <summary>Shared vertex data between multiple meshes.</summary>
        </member>
        <member name="F:Axiom.Core.Model.meshList">
            <summary>Collection of sub meshes for this model.</summary>
        </member>
        <member name="F:Axiom.Core.Model.updateBounds">
            <summary>Flag that states whether or not the bounding box for this model needs to be re-calced.</summary>
        </member>
        <member name="F:Axiom.Core.Model.manuallyDefined">
            <summary>Flag that states whether or not this model will be loaded from a file, or constructed manually.</summary>
        </member>
        <member name="M:Axiom.Core.Model.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Model.Load">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Model.Unload">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Model.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Model.CreateMesh(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Model.SetVertexBufferPolicy(Axiom.SubSystems.Rendering.BufferUsage,System.Boolean)">
            <summary>
            
            </summary>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            DOC
        </member>
        <member name="M:Axiom.Core.Model.SetIndexBufferPolicy(Axiom.SubSystems.Rendering.BufferUsage,System.Boolean)">
            <summary>
            
            </summary>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            DOC
        </member>
        <member name="P:Axiom.Core.Model.BoundingSphereRadius">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.Core.Model.ManuallyDefined">
            <summary>
            	Defines whether this mesh is to be loaded from a resource, or created manually at runtime.
            </summary>
        </member>
        <member name="P:Axiom.Core.Model.SharedVertexData">
            <summary>
            	Gets/Sets the shared VertexData for this model.
            </summary>
        </member>
        <member name="T:Axiom.Core.ModelManager">
            <summary>
            Summary description for ModelManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.ModelManager.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.ModelManager.Create(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ModelManager.CreateManual(System.String)">
            <summary>
            	Creates a barebones Model object that can be used to manually define geometry later on.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ModelManager.CreatePlane(System.String,Axiom.Core.Plane,System.Int32,System.Int32)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name">Name of the plane model.</param>
            <param name="plane">Plane to use for distance and orientation of the model.</param>
            <param name="width">Width in world coordinates.</param>
            <param name="height">Height in world coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ModelManager.CreatePlane(System.String,Axiom.Core.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.MathLib.Vector3,Axiom.SubSystems.Rendering.BufferUsage,Axiom.SubSystems.Rendering.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name">Name of the plane model.</param>
            <param name="plane">Plane to use for distance and orientation of the model.</param>
            <param name="width">Width in world coordinates.</param>
            <param name="height">Height in world coordinates.</param>
            <param name="xSegments">Number of x segments for tesselation.</param>
            <param name="ySegments">Number of y segments for tesselation.</param>
            <param name="normals">If true, plane normals are created.</param>
            <param name="numTexCoordSets">Number of 2d texture coord sets to use.</param>
            <param name="uTile">Number of times the texture should be repeated in the u direction.</param>
            <param name="vTile">Number of times the texture should be repeated in the v direction.</param>
            <param name="upVec">The up direction of the plane.</param>
            <returns></returns>
            DOC: Add new params
        </member>
        <member name="M:Axiom.Core.ModelManager.Load(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Core.ModelManager.Tesselate2DMesh(Axiom.Core.Mesh,System.Int32,System.Int32,System.Boolean,Axiom.SubSystems.Rendering.BufferUsage,System.Boolean)">
            <summary>
            	Used to generate a face list based on vertices.
            </summary>
            <param name="mesh"></param>
            <param name="xSegments"></param>
            <param name="ySegments"></param>
            <param name="doubleSided"></param>
        </member>
        <member name="T:Axiom.Core.Overlay">
            <summary>
            Summary description for Overlay.
            </summary>
        </member>
        <member name="M:Axiom.Core.Overlay.Load">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Overlay.Unload">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Overlay.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="T:Axiom.Core.OverlayManager">
            <summary>
            Summary description for OverlayManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.OverlayManager.Create(System.String)">
            <summary>
            	Creates and return a new overlay.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.OverlayManager.QueueOverlaysForRendering(Axiom.Core.Camera,Axiom.SubSystems.Rendering.RenderQueue,Axiom.Core.Viewport)">
            <summary>
            	Internal method for queueing the visible overlays for rendering.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
            <param name="viewport"></param>
        </member>
        <member name="P:Axiom.Core.OverlayManager.HasViewportChanged">
            <summary>
            	Gets if the viewport has changed dimensions. 
            </summary>
            <remarks>
            	This is used by pixel-based GuiControls to work out if they need to reclaculate their sizes.
            </remarks>																				  
        </member>
        <member name="P:Axiom.Core.OverlayManager.ViewportHeight">
            <summary>
            	Gets the height of the destination viewport in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.OverlayManager.ViewportWidth">
            <summary>
            	Gets the width of the destination viewport in pixels.
            </summary>
        </member>
        <member name="T:Axiom.Core.Plane">
            <summary>
            Defines a plane in 3D space.
            </summary>
            <remarks>
            A plane is defined in 3D space by the equation
            Ax + By + Cz + D = 0
            
            This equates to a vector (the normal of the plane, whose x, y
            and z components equate to the coefficients A, B and C
            respectively), and a constant (D) which is the distance along
            the normal you have to go to move the plane back to the origin.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Plane.GetDistance(Axiom.MathLib.Vector3)">
            <summary>
            This is a pseudodistance. The sign of the return value is
            positive if the point is on the positive side of the plane,
            negative if the point is on the negative side, and zero if the
             point is on the plane.
            The absolute value of the return value is the true distance only
            when the plane normal is a unit length vector.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Plane.Normal">
            <summary>
            	The normal of the plane.
            </summary>
        </member>
        <member name="P:Axiom.Core.Plane.D">
            <summary>
            	The distance from the origin to the plane along the Normal vector.
            </summary>
        </member>
        <member name="T:Axiom.Core.RenderQueueEvent">
            <summary>
            	Delegate for speicfying the method signature for a render queue event.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneManager">
            <summary>
            Manages the rendering of a 'scene' i.e. a collection of primitives.
            </summary>
            <remarks>
            	This class defines the basic behaviour of the 'Scene Manager' family. These classes will
            	organise the objects in the scene and send them to the rendering system, a subclass of
            	RenderSystem. This basic superclass does no sorting, culling or organising of any sort.
               <p/>
            	Subclasses may use various techniques to organise the scene depending on how they are
            	designed (e.g. BSPs, octrees etc). As with other classes, methods marked as interanl are 
            	designed to be called by other classes in the engine, not by user applications.
             </remarks>
        </member>
        <member name="F:Axiom.Core.SceneManager.renderQueue">
            <summary>A queue of objects for rendering.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.targetRenderSystem">
            <summary>A reference to the current active render system..</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.hasCameraChanged">
            <summary>Denotes whether or not the camera has been changed.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.ambientColor">
            <summary>The ambient color, cached from the RenderSystem</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.cameraList">
            <summary>A list of the valid cameras for this scene for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.lightList">
            <summary>A list of lights in the scene for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.entityList">
            <summary>A list of entities in the scene for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.sceneNodeList">
            <summary>A list of scene nodes (includes all in the scene graph).</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.billboardSetList">
            <summary>A list of billboard set for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.animationList">
            <summary>A list of animations for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.animationStateList">
            <summary>A list of animation states for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.camInProgress">
            <summary>A reference to the current camera being used for rendering.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.rootSceneNode">
            <summary>The root of the scene graph heirarchy.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.displayNodes">
            <summary>Flag indicating whether SceneNodes will be rendered as a set of 3 axes.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.showBoundingBoxes">
            <summary>Flag that specifies whether scene nodes will have their bounding boxes rendered as a wire frame.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.optionList">
            <summary>Hashtable of options that can be used by this or any other scene manager.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.lastShaderUsed">
            <summary>Cache the last shader used during SetShader so we can comapare and reduce state changes.</summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSceneNode">
            <summary>
            	Creates an instance of a SceneNode.
            </summary>
            <remarks>
               Note that this does not add the SceneNode to the scene hierarchy.
            	This method is for convenience, since it allows an instance to
            	be created for which the SceneManager is responsible for
            	allocating and releasing memory, which is convenient in complex
            	scenes.
            	<p/>
                To include the returned SceneNode in the scene, use the AddChild
            	method of the SceneNode which is to be it's parent.
            	<p/>
                Note that this method takes no parameters, and the node created is unnamed (it is
                actually given a generated name, which you can retrieve if you want).
                If you wish to create a node with a specific name, call the alternative method
                which takes a name parameter.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSceneNode(System.String)">
            <summary>
            	Creates an instance of a SceneNode with a given name.
            </summary>
            <remarks>
            	Note that this does not add the SceneNode to the scene hierarchy.
            	This method is for convenience, since it allows an instance to
            	be created for which the SceneManager is responsible for
            	allocating and releasing memory, which is convenient in complex
            	scenes.
            	<p/>
            	To include the returned SceneNode in the scene, use the AddChild
            	method of the SceneNode which is to be it's parent.
            	<p/>
            	Note that this method takes a name parameter, which makes the node easier to
            	retrieve directly again later.
            </remarks>
            <param name="pName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAnimation(System.String,System.Single)">
            <summary>
            	Creates an animation which can be used to animate scene nodes.
            </summary>
            <remarks>
            	An animation is a collection of 'tracks' which over time change the position / orientation
            	of Node objects. In this case, the animation will likely have tracks to modify the position
            	/ orientation of SceneNode objects, e.g. to make objects move along a path.
            	<p/>
            	You don't need to use an Animation object to move objects around - you can do it yourself
            	using the methods of the Node in your application. However, when you need relatively
            	complex scripted animation, this is the class to use since it will interpolate between
            	keyframes for you and generally make the whole process easier to manage.
            	<p/>
            	A single animation can affect multiple Node objects (each AnimationTrack affects a single Node).
            	In addition, through animation blending a single Node can be affected by multiple animations,
            	although this is more useful when performing skeletal animation (see Skeleton.CreateAnimation).
            </remarks>
            <param name="name"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Core.SceneManager.CreateAnimationState(System.String)" -->
        <member name="M:Axiom.Core.SceneManager.CreateBillboardSet(System.String)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateBillboardSet(System.String,System.Int32)">
            <summary>
            	Creates a billboard set which can be uses for particles, sprites, etc.
            </summary>
            <param name="name"></param>
            <param name="poolSize"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateCamera(System.String)">
            <summary>
            	Creates a camera to be managed by this scene manager.
            </summary>
            <remarks>
            	This camera can be added to the scene at a later time using
            	the AttachObject method of the SceneNode class.
             </remarks>
             <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateEntity(System.String,System.String)">
            <summary>
            	Create an Entity (instance of a discrete mesh).
            </summary>
            <param name="name">The name to be given to the entity (must be unique).</param>
            <param name="meshName">The name of the mesh to load.  Will be loaded if not already.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateEntity(System.String,Axiom.Enumerations.PrefabEntity)">
            <summary>
            	Create an Entity (instance of a discrete mesh).
            </summary>
            <param name="name">The name to be given to the entity (must be unique).</param>
            <param name="meshName">The name of the mesh to load.  Will be loaded if not already.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateLight(System.String)">
            <summary>
            	Creates a light that will be managed by this scene manager.
            </summary>
            <remarks>
            	Lights can either be in a fixed position and independent of the
            	scene graph, or they can be attached to SceneNodes so they derive
            	their position from the parent node. Either way, they are created
            	using this method so that the SceneManager manages their
            	existence.
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateShader(System.String)">
            <summary>
            	Creates a new (blank) shader with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.ClearScene">
            <summary>
            	Empties the entire scene, inluding all SceneNodes, Cameras, Entities and Lights etc.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.LoadWorldGeometry(System.String)">
            <summary>
            	Loads the source of the 'world' geometry, i.e. the large, mainly static geometry
            	making up the world e.g. rooms, landscape etc.
            </summary>
            <remarks>
            	Depending on the type of SceneManager (subclasses will be specialised
            	for particular world geometry types) you have requested via the Root or
            	SceneManagerEnumerator classes, you can pass a filename to this method and it
            	will attempt to load the world-level geometry for use. If you try to load
            	an inappropriate type of world data an exception will be thrown. The default
            	SceneManager cannot handle any sort of world geometry and so will always
            	throw an exception. However subclasses like BspSceneManager can load
            	particular types of world geometry e.g. "q3dm1.bsp".
            </remarks>
            <param name="fileName"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetShader(Axiom.Core.Shader,System.Int32)">
            <summary>Internal method for setting a material for subsequent rendering.</summary>
            <remarks>
            	If this method returns a non-zero value, it means that not all
            	the remaining texture layers can be rendered in one pass, and a
            	subset of them have been set up in the RenderSystem for the first
            	pass - the caller should render the geometry then call this
            	method again to set the remaining texture layers and re-render
            	the geometry again.
            </remarks>
            <param name="shader">The shader to set.</param>
            <param name="numLayers">
            	The top 'n' number of layers to be processed,
               will only be less than total layers if a previous call
               resulted in a multipass render being required.
             </param>
            <returns>
            	The number of layers unprocessed because of insufficient
            	available texture units in the hardware.
            </returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSkyboxPlane(Axiom.Enumerations.BoxPlane,System.Single,Axiom.MathLib.Quaternion)">
            <summary>
            	Utility method for creating the planes of a skybox.
            </summary>
            <param name="plane"></param>
            <param name="distance"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSkydomePlane(Axiom.Enumerations.BoxPlane,System.Single,System.Single,System.Single,Axiom.MathLib.Quaternion)">
            <summary>
            	Utility method for creating the planes of a skydome.
            </summary>
            <param name="plane"></param>
            <param name="distance"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.UseRenderableViewProjection(Axiom.SubSystems.Rendering.IRenderable)">
            <summary>
            	Protected method used by RenderVisibleObjects to deal with renderables
            	which override the camera's own view / projection materices.
            </summary>
            <param name="renderable"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.OnRenderQueueStarted(Axiom.Enumerations.RenderQueueGroupID)">
            <summary>
            	Used to first the QueueStarted event.  
            </summary>
            <param name="group"></param>
            <returns>True if the queue should be skipped.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.OnRenderQueueEnded(Axiom.Enumerations.RenderQueueGroupID)">
            <summary>
            	Used to first the QueueEnded event.  
            </summary>
            <param name="group"></param>
            <returns>True if the queue should be repeated.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetFog(Axiom.SubSystems.Rendering.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the fogging mode applied to the scene.
            </summary>
            <remarks>
            	This method sets up the scene-wide fogging effect. These settings
            	apply to all geometry rendered, UNLESS the material with which it
            	is rendered has it's own fog settings (see Material.SetFog).
            </remarks>
            <param name="mode">Set up the mode of fog as described in the FogMode
            	enum, or set to FogMode.None to turn off.</param>
            <param name="color">The color of the fog. Either set this to the same
            	as your viewport background color, or to blend in with a skydome or skybox.</param>
            <param name="density">The density of the fog in Exp or Exp2.
            	mode, as a value between 0 and 1. The default is 0.001. </param>
            <param name="linearStart">Distance in world units at which linear fog starts to
            	encroach. Only applicable if mode is</param>
            <param name="linearEnd">Distance in world units at which linear fog becomes completely
            	opaque. Only applicable if mode is</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="enable"></param>
            <param name="shaderName"></param>
            <param name="distance"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single,System.Boolean,Axiom.MathLib.Quaternion)">
            <summary>
            	Enables / disables a 'sky box' i.e. a 6-sided box at constant
            	distance from the camera representing the sky.
            </summary>
            <remarks>
            	You could create a sky box yourself using the standard mesh and
            	entity methods, but this creates a plane which the camera can
            	never get closer or further away from - it moves with the camera.
            	(you could create this effect by creating a world box which
            	was attached to the same SceneNode as the Camera too, but this
            	would only apply to a single camera whereas this skybox applies
            	to any camera using this scene manager).
            	<p/>
            	The shader you use for the skybox can either contain layers
            	which are single textures, or they can be cubic textures, i.e.
            	made up of 6 images, one for each plane of the cube. See the
            	TextureLayer class for more information.
            </remarks>
            <param name="enable">True to enable the skybox, false to disable it</param>
            <param name="shaderName">The name of the shader the box will use.</param>
            <param name="distance">Distance in world coordinates from the camera to each plane of the box. </param>
            <param name="drawFirst">
            	If true, the box is drawn before all other
            	geometry in the scene, without updating the depth buffer.
            	This is the safest rendering method since all other objects
            	will always appear in front of the sky. However this is not
            	the most efficient way if most of the sky is often occluded
            	by other objects. If this is the case, you can set this
            	parameter to false meaning it draws <em>after</em> all other
            	geometry which can be an optimisation - however you must
            	ensure that the distance value is large enough that no
            	objects will 'poke through' the sky box when it is rendered.
            </param>
            <param name="orientation">
            	Specifies the orientation of the box. By default the 'top' of the box is deemed to be
            	in the +y direction, and the 'front' at the -z direction.
            	You can use this parameter to rotate the sky if you want.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderScene(Axiom.Core.Camera,Axiom.Core.Viewport,System.Boolean)">
            <summary>
            	Prompts the class to send its contents to the renderer.
            </summary>
            <remarks>
            	This method prompts the scene manager to send the
            	contents of the scene it manages to the rendering
            	pipeline, possibly preceded by some sorting, culling
            	or other scene management tasks. Note that this method is not normally called
            	directly by the user application; it is called automatically
            	by the engine's rendering loop.
            </remarks>
            <param name="camera">Pointer to a camera from whose viewpoint the scene is to be rendered.</param>
            <param name="viewport">The target viewport</param>
            <param name="showOverlays">Whether or not any overlay objects should be rendered</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.UpdateSceneGraph(Axiom.Core.Camera)">
            <summary>
            	Internal method for updating the scene graph ie the tree of SceneNode instances managed by this class.
            </summary>
            <remarks>
            	This must be done before issuing objects to the rendering pipeline, since derived transformations from
            	parent nodes are not updated until required. This SceneManager is a basic implementation which simply
            	updates all nodes from the root. This ensures the scene is up to date but requires all the nodes
            	to be updated even if they are not visible. Subclasses could trim this such that only potentially visible
            	nodes are updated.
            </remarks>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.FindVisibleObjects(Axiom.Core.Camera)">
            <summary>
            	Internal method which parses the scene to find visible objects to render.
            </summary>
            <remarks>
            	If you're implementing a custom scene manager, this is the most important method to
            	override since it's here you can apply your custom world partitioning scheme. Once you
            	have added the appropriate objects to the render queue, you can let the default
            	SceneManager objects RenderVisibleObjects handle the actual rendering of the objects
            	you pick.
            	<p/>
            	Any visible objects will be added to a rendering queue, which is indexed by material in order
            	to ensure objects with the same material are rendered together to minimise render state changes.
            </remarks>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ApplySceneAnimations">
            <summary>
            	Internal method for applying animations to scene nodes.
            </summary>
            <remarks>
            	Uses the internally stored AnimationState objects to apply animation to SceneNodes.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderVisibleObjects">
            <summary>
            	Sends visible objects found in FindVisibleObjects to the rendering engine.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.QueueSkiesForRendering(Axiom.Core.Camera)">
            <summary>
            	Internal method for queueing the sky objects with the params as 
            	previously set through SetSkyBox, SetSkyPlane and SetSkyDome.
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderMesh(Axiom.Core.Mesh)">
            <summary>
            	Internal method for issuing geometry for a mesh to the RenderSystem pipeline.
            </summary>
            <remarks>
            	Not recommended for manual usage, leave the engine to use this one as appropriate!
            	<p/>
            	It's assumed that material and world / view / projection transforms have already been set.
            </remarks>
            <param name="subMesh"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.UpdateDynamicLights">
            <summary>
            	Sends any updates to the dynamic lights in the world to the renderer.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyPlane(System.Boolean,Axiom.Core.Plane,System.String,System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            	Enables / disables a 'sky plane' i.e. a plane at constant
            	distance from the camera representing the sky.
            </summary>
            <param name="enable">True to enable the plane, false to disable it.</param>
            <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera.</param>
            <param name="materialName">The name of the material the plane will use.</param>
            <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane.</param>
            <param name="tiling">How many times to tile the texture across the sky.</param>
            <param name="drawFirst">
            	If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer.
            	This is the safest rendering method since all other objects
            	will always appear in front of the sky. However this is not
            	the most efficient way if most of the sky is often occluded
            	by other objects. If this is the case, you can set this
            	parameter to false meaning it draws <em>after</em> all other
            	geometry which can be an optimisation - however you must
            	ensure that the plane.d value is large enough that no objects
            	will 'poke through' the sky plane when it is rendered.
             </param>
            <param name="bow">
            	If above zero, the plane will be curved, allowing
            	the sky to appear below camera level.  Curved sky planes are 
            	simular to skydomes, but are more compatable with fog.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyPlane(System.Boolean,Axiom.Core.Plane,System.String)">
            <summary>
            	Overload.
            </summary>
            <param name="enable"></param>
            <param name="plane"></param>
        </member>
        <member name="E:Axiom.Core.SceneManager.QueueStarted">
            <summary>An event that will fire when a render queue is starting to be rendered.</summary>
        </member>
        <member name="E:Axiom.Core.SceneManager.QueueEnded">
            <summary>An event that will fire when a render queue is finished being rendered.</summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.TargetRenderSystem">
            <summary>
            Gets/Sets the target render system that this scene manager should be using.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.RootSceneNode">
            <summary>
            	Gets the SceneNode at the root of the scene hierarchy.
            </summary>
            <remarks>
            	The entire scene is held as a hierarchy of nodes, which
            	allows things like relative transforms, general changes in
            	rendering state etc (See the SceneNode class for more info).
            	In this basic SceneManager class, you are free to
            	structure this hierarchy however you like, since 
            	it has no real significance apart from making transforms
            	relative to each node (more specialised subclasses will
            	provide utility methods for building specific node structures
            	e.g. loading a BSP tree).
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.AmbientLight">
            <summary>
            	Gets/Sets the ambient light level to be used for the scene.
            </summary>
            <remarks>
            	This sets the color and intensity of the ambient light in the scene, i.e. the
            	light which is 'sourceless' and illuminates all objects equally.
            	The color of an object is affected by a combination of the light in the scene,
            	and the amount of light that object reflects (in this case based on the Shader.Ambient
            	property).
            	<p/>
            	By default the ambient light in the scene is Black, i.e. no ambient light. This
            	means that any objects rendered with a Shader which has lighting enabled 
            	(see Shader.LightingEnabled) will not be visible unless you have some dynamic lights in your scene.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.Options">
            <summary>
            	Method for setting a specific option of the Scene Manager. These options are usually
            	specific for a certain implementation of the Scene Manager class, and may (and probably
            	will) not exist across different implementations.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShowBoundingBoxes">
            <summary>
            	Gets/Sets a value that forces all nodes to render their bounding boxes.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.DisplayNodes">
            <summary>
            	Gets/Sets whether or not to display the nodes themselves in addition to their objects.
            </summary>
            <remarks>
            	What will be displayed is the local axes of the node (for debugging mainly).
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogMode">
            <summary>
            	Gets the fog mode that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogStart">
            <summary>
            	Gets the fog starting point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogEnd">
            <summary>
            	Gets the fog ending point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogDensity">
            <summary>
            	Gets the fog density that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogColor">
            <summary>
            	Gets the fog color that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneManagerList">
            <summary>
            Summary description for SceneManagerEnumerator.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManagerList.RegisterRenderSystem(Axiom.SubSystems.Rendering.RenderSystem)">
            <summary>
            Register a new render system with the SceneManagerList.
            </summary>
            <param name="pSystem"></param>
        </member>
        <member name="P:Axiom.Core.SceneManagerList.Item(Axiom.Enumerations.SceneType)">
            <summary>
            Indexer to allow easy access to the scene manager list.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneNode">
            <summary>
            	Represents a node in a scene graph.
            </summary>
            <remarks>
            	A SceneNode is a type of Node which is used to organize objects in a scene.
            	It has the same hierarchical transformation properties of the generic Node class,
            	but also adds the ability to attach world objects to the node, and stores hierarchical
            	bounding volumes of the nodes in the tree.
            	Child nodes are contained within the bounds of the parent, and so on down the
            	tree, allowing for fast culling.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneNode.objectList">
            <summary>A collection of all objects attached to this scene node.</summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.creator">
            <summary>Reference to the scene manager who created me.</summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.wireBox">
            <summary>Renderable bounding box for this node.</summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.showBoundingBox">
            <summary>Whether or not to display this node's bounding box.</summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.worldAABB">
            <summary>Bounding box.  Updated through Update.</summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Basic constructor.  Takes a scene manager reference to record the creator.
            </summary>
            <remarks>
            	Can be created manually, but should be left the Create* Methods.
            </remarks>
            <param name="creator"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.#ctor(Axiom.Core.SceneManager,System.String)">
            <summary>
            	Overloaded constructor.  Takes a scene manager reference to record the creator, and a name for the node.
            </summary>
            <param name="creator"></param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.Update(System.Boolean,System.Boolean)">
            <summary>
            	Internal method to update the Node.
            </summary>
            <remarks>
            	Updates this scene node and any relevant children to incorporate transforms etc.
            	Don't call this yourself unless you are writing a SceneManager implementation.
            </remarks>
            <param name="?"></param>
            <param name="hasParentChanged"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.SubSystems.Rendering.RenderQueue)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.SubSystems.Rendering.RenderQueue,System.Boolean,System.Boolean)">
            <summary>
            	Internal method which locates any visible objects attached to this node and adds them to the passed in queue.
            </summary>
            <param name="camera">Active camera.</param>
            <param name="queue">Queue to which these objects should be added.</param>
            <param name="includeChildren">If true, cascades down to all children.</param>
            <param name="displayNodes">Renders the local axes for the node.</param>
        </member>
        <member name="M:Axiom.Core.SceneNode.AddBoundingBoxToQueue(Axiom.SubSystems.Rendering.RenderQueue)">
            <summary>
            	Adds this nodes bounding box (wireframe) to the RenderQueue.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.UpdateBounds">
            <summary>
            	Tell the SceneNode to update the world bound info it stores.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.ObjectAttached(System.Object,System.EventArgs)">
            <summary>
            	New object attached.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.ObjectRemoved(System.Object,System.EventArgs)">
            <summary>
            	Object removed.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.ObjectsCleared(System.Object,System.EventArgs)">
            <summary>
            	Object list cleared.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildImpl">
            <summary>
            	
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildImpl(System.String)">
            <summary>
            	
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.SceneNode.ShowBoundingBox">
            <summary>
            	Gets/Sets whether or not to display the bounding box for this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.Objects">
            <summary>
            	Gets a MovableObjectColletion containing this SceneNode's attached objects.
            </summary>
            <remarks>
            	Use this property for adding and removing objects.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneNode.Creator">
            <summary>
            	Gets a reference to the SceneManager that created this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.WorldAABB">
            <summary>
            	Gets the axis-aligned bounding box of this node (and hence all child nodes).
            </summary>
            <remarks>
            	Usage not recommended unless you are extending a SceneManager, because the bounding box returned
            	from this method is only up to date after the SceneManager has called Update.
            </remarks>
        </member>
        <member name="T:Axiom.Core.Shader">
            <summary>
            An object that contains texture data and information on how it is rendered.
            </summary>
        </member>
        <member name="F:Axiom.Core.Shader.isTransparent">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.numTextureLayers">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.textureLayers">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.ambient">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.diffuse">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.specular">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.emissive">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.shininess">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.sourceBlendFactor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.destBlendFactor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.depthCheck">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.depthWrite">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.depthFunc">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.depthBias">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.cullMode">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.manualCullMode">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.lightingEnabled">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.shading">
            <summary>Shading option.</summary>
        </member>
        <member name="F:Axiom.Core.Shader.textureFiltering">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.fogOverride">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.fogMode">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.fogColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.fogStart">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.fogEnd">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.fogDensity">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.deferLoad">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Shader.defaultSettings">
            <summary></summary>
        </member>
        <member name="M:Axiom.Core.Shader.SetSceneBlending(Axiom.SubSystems.Rendering.SceneBlendType)">
            <summary>
            
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Core.Shader.SetSceneBlending(Axiom.SubSystems.Rendering.SceneBlendFactor,Axiom.SubSystems.Rendering.SceneBlendFactor)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dest"></param>
        </member>
        <member name="M:Axiom.Core.Shader.CompareSurfaceParams(Axiom.Core.Shader)">
            <summary>
            	Internal helper method for comparing the surface parameters of 2 shaders.
            </summary>
            <param name="cmp">Shaders to compare to this one.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Shader.AddTextureLayer(System.String)">
            <summary>
            
            </summary>
            <param name="textureName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Shader.AddTextureLayer(System.String,System.Int32)">
            <summary>
            	
            </summary>
            <param name="textureName"></param>
            <param name="stage"></param>
        </member>
        <member name="M:Axiom.Core.Shader.CompareTo(System.Object)">
            <summary>
            	Used for comparing 2 Shader objects.
            </summary>
            <remarks>
            	This comparison will be used in RenderQueue group sorting of Shaders materials.
            	If this object is transparent and the object being compared is not, this is greater that obj.
            	If this object is not transparent and the object being compared is, obj is greater than this.
            </remarks>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Shader.Load">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Shader.Unload">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Shader.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.IsTransparent">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.NumTextureLayers">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.Ambient">
            <summary>
            	Ambient color of this shader.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.Diffuse">
            <summary>
            	Diffuse color of this shader.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.Specular">
            <summary>
            	Specular color of this shader.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.Emissive">
            <summary>
            	Emissive color of this shader.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.Shininess">
            <summary>
            	Shininess value of this shader.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.TextureLayers">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.TextureFiltering">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.Lighting">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.SourceBlendFactor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.DestBlendFactor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.DepthWrite">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.DepthCheck">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.FogOverride">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.FogMode">
            <summary>
            	Gets the fog mode that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.FogStart">
            <summary>
            	Gets the fog starting point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.FogEnd">
            <summary>
            	Gets the fog ending point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.FogDensity">
            <summary>
            	Gets the fog density that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.Shader.FogColor">
            <summary>
            	Gets the fog color that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="T:Axiom.Core.ShaderManager">
            <summary>
            Summary description for ShaderManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.ShaderManager.ParseAllSources(System.String)">
            <summary>
            
            </summary>
            <param name="extension"></param>
        </member>
        <member name="T:Axiom.Core.SimpleRenderable">
            <summary>
            Summary description for SimpleRenderable.
            </summary>
        </member>
        <member name="M:Axiom.Core.SimpleRenderable.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.SimpleRenderable.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SimpleRenderable.UpdateRenderQueue(Axiom.SubSystems.Rendering.RenderQueue)">
            <summary>
            
            </summary>
            <param name="queue"></param>
        </member>
        <member name="P:Axiom.Core.SimpleRenderable.BoundingBox">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SimpleRenderable.Shader">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SimpleRenderable.WorldTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Core.Sphere">
            <summary>
            	A standard sphere, used mostly for bounds checking.
            </summary>
            <remarks>
            	A sphere in math texts is normally represented by the function
            	x^2 + y^2 + z^2 = r^2 (for sphere's centered on the origin). We store spheres
            	simply as a center point and a radius.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Sphere.#ctor">
            <summary>
            	Creates a unit sphere centered at the origin.
            </summary>
        </member>
        <member name="M:Axiom.Core.Sphere.#ctor(Axiom.MathLib.Vector3,System.Single)">
            <summary>
            Creates an arbitrary spehere.
            </summary>
            <param name="center">Center point of the sphere.</param>
            <param name="radius">Radius of the sphere.</param>
        </member>
        <member name="P:Axiom.Core.Sphere.Center">
            <summary>
            	Gets/Sets the center of the sphere.
            </summary>
        </member>
        <member name="P:Axiom.Core.Sphere.Radius">
            <summary>
            	Gets/Sets the radius of the sphere.
            </summary>
        </member>
        <member name="T:Axiom.Core.SubEntity">
            <summary>
            	Utility class which defines the sub-parts of an Entity.
            </summary>
            <remarks>
            	Just as models are split into meshes, an Entity is made up of
            	potentially multiple SubEntities. These are mainly here to provide the
            	link between the Shader which the SubEntity uses (which may be the
            	default Material for the Mesh or may have been changed for this
            	object) and the Mesh data.
            	<p/>
            	SubEntity instances are never created manually. They are created at
            	the same time as their parent Entity by the SceneManager method
            	CreateEntity.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SubEntity.parent">
            <summary>Reference to the parent Entity.</summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.shaderName">
            <summary>Name of the shader being used.</summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.shader">
            <summary>Reference to the shader being used by this SubEntity.</summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.mesh">
            <summary>Reference to the mesh that represents the geometry for this SubEntity.</summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.renderDetail">
            <summary></summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.#ctor">
            <summary>
            	Internal constructor, only allows creation of SubEntities within the engine core.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.GetRenderOperation(Axiom.SubSystems.Rendering.RenderOperation)">
            <summary>
            
            </summary>
            <param name="op"></param>
            DOC
        </member>
        <member name="P:Axiom.Core.SubEntity.ShaderName">
            <summary>
            	Gets/Sets the name of the shader used for this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Mesh">
            <summary>
            	Gets/Sets the mesh to be used for rendering this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Parent">
            <summary>
            	Gets/Sets the parent entity of this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Shader">
            <summary>
            	Gets/Sets a reference to the shader being used by this SubEntity.
            </summary>
            <remarks>
            	By default, the SubEntity will use the shader defined by the Mesh.  However,
            	this can be overridden by the SubEntity in the case where several entities use the
            	same Mesh instance, but want to shade it different.
            </remarks>
        </member>
        <member name="T:Axiom.Core.Texture">
            <summary>
            	Abstract class representing a Texture resource.
            </summary>
            <remarks>
            	The actual concrete subclass which will exist for a texture
            	is dependent on the rendering system in use (Direct3D, OpenGL etc).
            	This class represents the commonalities, and is the one 'used'
            	by programmers even though the real implementation could be
            	different in reality. Texture objects are created through
            	the 'Create' method of the TextureManager concrete subclass.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Texture.width">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.height">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.bpp">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.srcWidth">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.srcHeight">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.srcBpp">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.hasAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.format">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.usage">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.numMipMaps">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Texture.gamma">
            <summary></summary>
        </member>
        <member name="M:Axiom.Core.Texture.Enable32Bit(System.Boolean)">
            <summary>
            
            </summary>
            <param name="enable"></param>
        </member>
        <member name="M:Axiom.Core.Texture.Load">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Texture.LoadImage(System.Drawing.Bitmap)">
            <summary>
            
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:Axiom.Core.Texture.Unload">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Texture.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.NumMipMaps">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Core.TextureLayer">
            <summary>
            Summary description for TextureLayer.
            </summary>
        </member>
        <member name="F:Axiom.Core.TextureLayer.textureName">
            <summary>Name of the texture for this layer.</summary>
        </member>
        <member name="F:Axiom.Core.TextureLayer.deferredLoad">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.TextureLayer.texCoordSet">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.TextureLayer.isBlank">
            <summary>Is this a blank layer?</summary>
        </member>
        <member name="F:Axiom.Core.TextureLayer.numFrames">
            <summary>Number of frames for this layer.</summary>
        </member>
        <member name="F:Axiom.Core.TextureLayer.frames">
            <summary>store names of textures for animation frames.</summary>
        </member>
        <member name="M:Axiom.Core.TextureLayer.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureLayer.#ctor(System.Boolean)">
            <summary>
            	Basic constructor.
            </summary>
            <param name="deferred"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.SetCubicTexture(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="textureName"></param>
            <param name="forUVW"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.SetCubicTexture(System.String[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="textureNames"></param>
            <param name="forUVW"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.SetColorOperation(Axiom.SubSystems.Rendering.LayerBlendOperation)">
            <summary>
            	
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.SetColorOperationEx(Axiom.SubSystems.Rendering.LayerBlendOperationEx,Axiom.SubSystems.Rendering.LayerBlendSource,Axiom.SubSystems.Rendering.LayerBlendSource)">
            <summary>
            	
            </summary>
            <param name="operation"></param>
            <param name="source1"></param>
            <param name="source2"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.SetColorOperationEx(Axiom.SubSystems.Rendering.LayerBlendOperationEx,Axiom.SubSystems.Rendering.LayerBlendSource,Axiom.SubSystems.Rendering.LayerBlendSource,Axiom.Core.ColorEx,Axiom.Core.ColorEx,System.Single)">
            <summary>
            	
            </summary>
            <param name="operation"></param>
            <param name="source1"></param>
            <param name="source2"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.SetAlphaOperation(Axiom.SubSystems.Rendering.LayerBlendOperationEx)">
            <summary>
            	
            </summary>
            <param name="operation"></param>
            <param name="source1"></param>
            <param name="source2"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.SetAlphaOperation(Axiom.SubSystems.Rendering.LayerBlendOperationEx,Axiom.SubSystems.Rendering.LayerBlendSource,Axiom.SubSystems.Rendering.LayerBlendSource,System.Single,System.Single,System.Single)">
            <summary>
            	
            </summary>
            <param name="operation"></param>
            <param name="source1"></param>
            <param name="source2"></param>
        </member>
        <member name="M:Axiom.Core.TextureLayer.GetFrameTextureName(System.Int32)">
            <summary>
            
            </summary>
            <param name="frame"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureLayer.recalcTextureMatrix">
            <summary>
            	Used to update the texture matrix if need be.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureLayer.Load">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureLayer.Clone">
            <summary>
            	Used to clone a texture layer.  Mainly used during a call to Clone on a Shader.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.TextureLayer.TextureName">
            <summary>
            	Gets/Sets the name of the texture for this texture layer.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.DeferredLoad">
            <summary>
            	Gets/Sets whether or not the texture loading should be deferred.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.TexCoordSet">
            <summary>
            	Gets/Sets the texture coordinate set to be used by this texture layer.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.TextureAddressing">
            <summary>
            	Get/Set the texture addressing mode for this layer.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.ColorBlendMode">
            <summary>
            	Gets a structure that describes the layer blending mode parameters.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.AlphaBlendMode">
            <summary>
            	Gets a structure that describes the layer blending mode parameters.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.Blank">
            <summary>
            	Gets/Sets whether this layer is blank or not.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.CurrentFrame">
            <summary>
            	Gets/Sets the current frame this texture layer should be using.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.NumFrames">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureLayer.TextureMatrix">
            <summary>
            	Gets/Sets the Matrix4 that represents transformation to the texture in this
            	layer.
            </summary>
        </member>
        <member name="T:Axiom.Core.LayerBlendModeEx">
            <summary>
            	Utility class for handling texture layer blending parameters.
            </summary>
        </member>
        <member name="M:Axiom.Core.LayerBlendModeEx.op_Equality(Axiom.Core.LayerBlendModeEx,Axiom.Core.LayerBlendModeEx)">
            <summary>
            	Compares to blending modes for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.LayerBlendModeEx.op_Inequality(Axiom.Core.LayerBlendModeEx,Axiom.Core.LayerBlendModeEx)">
            <summary>
            	Compares to blending modes for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.TextureManager">
            <summary>
            	Texture manager serves as an abstract singleton for all API specific texture managers.
            	When a class inherits from this and is created, a instance of that class (i.e. GLTextureManager)
            	is stored in the global singleton instance of the TextureManager.  
            	Note: This will not take place until the RenderSystem is initialized and at least one RenderWindow
            	has been created.
            </summary>
        </member>
        <member name="F:Axiom.Core.TextureManager.is32Bit">
            <summary></summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String,System.Int32,System.Single,System.Int32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="numMipMaps"></param>
            <param name="gamma"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,System.Drawing.Bitmap)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <param name="image"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,System.Drawing.Bitmap,System.Int32,System.Single,System.Int32)">
            <summary>
            	Loads a pre-existing image into the texture.
            </summary>
            <param name="name"></param>
            <param name="image"></param>
            <param name="numMipMaps"></param>
            <param name="gamma"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.TextureManager.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureManager.DefaultNumMipMaps">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Core.VertexBuffer">
            <summary>
            Summary description for VertexBuffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.VertexBuffer.numVertices">
            Count of the number of vertices contained herein.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.numIndices">
            Count of the number of vertices contained herein.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.numFaces">
            <summary>Number of faces.</summary>
        </member>
        <member name="F:Axiom.Core.VertexBuffer.hasNormals">
            If true, vertex normals are present in the data.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.numTexCoordSets">
            Number of texture coordinates sets present in the data.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.numTexCoordDimensions">
            Number of texture dimensions in each set of texture coords.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.hasColors">
            If true, vertex colors are present in the data.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.vertices">
            Position (x,y,z) components of shared vertices.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.indices">
            Position (x,y,z) components of shared vertices.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.useIndices">
            <summary>Use indices?</summary>
        </member>
        <member name="F:Axiom.Core.VertexBuffer.texCoords">
            Texture coordinate components of shared vertices.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.normals">
            Vertex normal components of shared vertices.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.colors">
            Vertex color components of shared vertices - RGBA packed.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.vertexStride">
            The 'Stride' between sets of vertex data. 0 indicates data is packed with no gaps.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.normalStride">
            The 'Stride' between sets of normal data. 0 indicates data is packed with no gaps.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.texCoordStride">
            The 'Stride' between each set of texture data. 0 indicates data is packed with no gaps.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.colorStride">
            The 'Stride' between sets of diffuse color data. 0 indicates data is packed with no gaps.
        </member>
        <member name="F:Axiom.Core.VertexBuffer.numBlendWeightsPerVertex">
            The number of vertex blending weights per vertex
        </member>
        <member name="F:Axiom.Core.VertexBuffer.blendingWeights">
            Optional pointer to a list of vertex blending details, organized in vertex order. 
            			The number of weights per vertex is recorded in numBlendWeightsPerVertex - there must
            			be this many for every vertex: set the weight to 0 for those vertices that don't 
            			use all the entries (if some vertices have more than others)
        </member>
        <member name="T:Axiom.Core.VertexBlendData">
            <summary>
            Vertex blend info.
            </summary>
        </member>
        <member name="T:Axiom.Core.Viewport">
            <summary>
            	Summary description for Viewport.
            	An abstraction of a viewport, i.e. a rendering region on a render
            	target.
            </summary>
            <remarks>
            	A viewport is the meeting of a camera and a rendering surface -
            	the camera renders the scene from a viewpoint, and places its
            	results into some subset of a rendering target, which may be the
            	whole surface or just a part of the surface. Each viewport has a
            	single camera as source and a single target as destination. A
            	camera only has 1 viewport, but a render target may have several.
            	A viewport also has a Z-order, i.e. if there is more than one
            	viewport on a single render target and they overlap, one must
            	obscure the other in some predetermined way.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Viewport.#ctor(Axiom.Core.Camera,Axiom.SubSystems.Rendering.RenderTarget,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            	The constructor. Dimensions of the viewport are expressed as a pecentage between
            	0 and 100. This allows the dimensions to apply irrespective of
            	changes in the target's size: e.g. to fill the whole area,
            	values of 0,0,100,100 are appropriate.
            </summary>
            <param name="pCamera">Pointer to a camera to be the source for the image.</param>
            <param name="pTarget">Pointer to the render target to be the destination for the rendering.</param>
            <param name="left">Left</param>
            <param name="top">Top</param>
            <param name="width">Width</param>
            <param name="height">Height</param>
            <param name="pZOrder">Relative Z-order on the target. Lower = further to the front.</param>
        </member>
        <member name="M:Axiom.Core.Viewport.UpdateDimensions">
            <summary>
            	Notifies the viewport of a possible change in dimensions.
            </summary>
            <remarks>
            	Used by the target to update the viewport's dimensions
            	(usually the result of a change in target size).
            </remarks>
        </member>
        <member name="M:Axiom.Core.Viewport.Update">
            <summary>
            Instructs the viewport to updates its contents.
            </summary>
        </member>
        <member name="M:Axiom.Core.Viewport.SetDimensions(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Allows setting the dimensions of the viewport (after creation).
            </summary>
            <remarks>
            	Dimensions relative to the size of the target,
            	represented as real values between 0 and 1. i.e. the full
            	target area is 0, 0, 1, 1.
            </remarks>
            <param name="left"></param>
            <param name="top"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="P:Axiom.Core.Viewport.Target">
            <summary>
            Retrieves a reference to the render target for this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Camera">
            <summary>
            Retrieves a reference to the camera for this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.BackgroundColor">
            <summary>
            Gets and sets the background color which will be used to clear the screen every frame.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Top">
            <summary>
            Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Left">
            <summary>
            Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Width">
            <summary>
            Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Height">
            <summary>
            Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ZOrder">
            <summary>
            Gets the ZOrder of this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualTop">
            <summary>
            Gets one of the actual dimensions of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualLeft">
            <summary>
            Gets one of the actual dimensions of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualWidth">
            <summary>
            Gets one of the actual dimensions of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualHeight">
            <summary>
            Gets one of the actual dimensions of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ClearEveryFrame">
            <summary>
            	Determines whether to clear the viewport before rendering.
            </summary>
            <remarks>
            	If you expecting every pixel on the viewport to be redrawn
            	every frame, you can save a little time by not clearing the
            	viewport before every frame. Do so by passing 'false' to this
            	method (the default is to clear every frame).
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Core.Viewport.OverlaysEnabled" -->
        <member name="P:Axiom.Core.Viewport.NumRenderedFaces">
            <summary>
            	Returns the number of faces rendered to this viewport during the last frame.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.IsUpdated">
            <summary>
            Gets and sets the IsUpdated value.
            </summary>
        </member>
        <member name="T:Axiom.Core.WireBoundingBox">
            <summary>
            Summary description for WireBoundingBox.
            </summary>
        </member>
        <member name="T:Axiom.Enumerations.BillboardOrigin">
            <summary>
            	Covers what a billboards position means.
            </summary>
        </member>
        <member name="T:Axiom.Enumerations.BillboardType">
            <summary>
            	Type of billboard to use for a BillboardSet.
            </summary>
        </member>
        <member name="F:Axiom.Enumerations.BillboardType.Point">
            <summary>Standard point billboard (default), always faces the camera completely and is always upright</summary>
        </member>
        <member name="F:Axiom.Enumerations.BillboardType.OrientedCommon">
            <summary>Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera</summary>
        </member>
        <member name="F:Axiom.Enumerations.BillboardType.OrientedSelf">
            <summary>Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera</summary>
        </member>
        <member name="T:Axiom.Enumerations.BoxPlane">
            <summary>
            	Specifying the side of a box, used for things like skyboxes, etc.
            </summary>
        </member>
        <member name="T:Axiom.Enumerations.DynamicsBodyType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Enumerations.DynamicsBodyType.Box">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.DynamicsBodyType.Sphere">
            <summary></summary>
        </member>
        <member name="T:Axiom.Enumerations.FrustumPlane">
            <summary>
            Defines the 6 planes the make up a frustum.  
            </summary>
        </member>
        <member name="F:Axiom.Enumerations.FrustumPlane.None">
            <summary>Used for methods that require returning a value of this type but cannot return null.</summary>
        </member>
        <member name="T:Axiom.Enumerations.PlaneSide">
            <summary>
            The "positive side" of the plane is the half space to which the
            plane normal points. The "negative side" is the other half
            space. The flag "no side" indicates the plane itself.
            </summary>
        </member>
        <member name="T:Axiom.Enumerations.PrefabEntity">
            <summary>
            	Canned entities that can be created on demand.
            </summary>
        </member>
        <member name="F:Axiom.Enumerations.PrefabEntity.Plane">
            <summary>A flat plane.</summary>
        </member>
        <member name="F:Axiom.Enumerations.PrefabEntity.Teapot">
            <summary>The obligatory teapot.</summary>
        </member>
        <member name="F:Axiom.Enumerations.PrefabEntity.Box">
            <summary>Typical box.</summary>
        </member>
        <member name="F:Axiom.Enumerations.PrefabEntity.Pyramid">
            <summary>Full cairo action.</summary>
        </member>
        <member name="T:Axiom.Enumerations.RenderQueueGroupID">
            <summary>
            	Priorities that can be assigned to renderable objects for sorting.
            </summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Background">
            <summary>Objects that must be rendered first (like backgrounds).</summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.One">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Two">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Three">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Four">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Main">
            <summary>Default queue.</summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Six">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Seven">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Eight">
            <summary></summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Nine">
            <summary>Last queue before overlays, used for skyboxes if rendered last.</summary>
        </member>
        <member name="F:Axiom.Enumerations.RenderQueueGroupID.Overlay">
            <summary>Use this queue for objects which must be rendered last e.g. overlays</summary>
        </member>
        <member name="T:Axiom.Enumerations.Resource">
            <summary>
            The types of resources that the engine can make use of.
            </summary>
        </member>
        <member name="T:Axiom.Enumerations.SceneType">
            <summary>
            The different types of scenes types that can be handled by the engine.  The various types can
            be altered by plugin functionality (i.e. BSP for interior, OctTree for Exterior, etc).
            </summary>
        </member>
        <member name="T:Axiom.EventSystem.EventProcessor">
            <summary>
            Summary description for EventProcessor.
            </summary>
        </member>
        <member name="F:Axiom.EventSystem.EventProcessor.eventQueue">
            <summary>Holds queued events in a FIFO manner.</summary>
        </member>
        <member name="T:Axiom.EventSystem.IKeyTarget">
            <summary>
            Summary description for IKeyTarget.
            </summary>
        </member>
        <member name="E:Axiom.EventSystem.IKeyTarget.KeyUp">
            <summary>
            
            </summary>
        </member>
        <member name="E:Axiom.EventSystem.IKeyTarget.KeyDown">
            <summary>
            	
            </summary>
        </member>
        <member name="T:Axiom.EventSystem.IMouseTarget">
            <summary>
            Summary description for IMouseTarget.
            </summary>
        </member>
        <member name="E:Axiom.EventSystem.IMouseTarget.MouseMoved">
            <summary>
            
            </summary>
        </member>
        <member name="E:Axiom.EventSystem.IMouseTarget.MouseEnter">
            <summary>
            
            </summary>
        </member>
        <member name="E:Axiom.EventSystem.IMouseTarget.MouseLeave">
            <summary>
            
            </summary>
        </member>
        <member name="E:Axiom.EventSystem.IMouseTarget.MouseDown">
            <summary>
            
            </summary>
        </member>
        <member name="E:Axiom.EventSystem.IMouseTarget.MouseUp">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.EventSystem.IScriptTarget">
            <summary>
            Summary description for IScriptTarget.
            </summary>
        </member>
        <member name="T:Axiom.EventSystem.ScriptEventArgs">
            <summary>
            Summary description for ScriptEvent.
            </summary>
        </member>
        <member name="T:Axiom.Exceptions.AxiomException">
            <summary>
            Summary description for AxiomException.
            </summary>
        </member>
        <member name="T:Axiom.Exceptions.PluginException">
            <summary>
            Summary description for PluginException.
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.Archive">
            <summary>
            Summary description for Archive.
            </summary>
        </member>
        <member name="F:Axiom.FileSystem.Archive.archiveName">
            <summary>Name of archive, can be folder path, zip name, etc.</summary>
        </member>
        <member name="M:Axiom.FileSystem.Archive.ReadFile(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Axiom.FileSystem.Folder">
            <summary>
            Summary description for Folder.
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.Zip">
            <summary>
            Summary description for Zip.
            </summary>
        </member>
        <member name="T:Axiom.Fonts.Font">
            <summary>
            	This class is simply a way of getting a font texture into the engine and
            	to easily retrieve the texture coordinates required to accurately render them.
            	Fonts can either be loaded from precreated textures, or the texture can be generated
            	using a truetype font. You can either create the texture manually in code, or you
            	can use an XML font script to define it (probably more practical since you can reuse
            	the definition more easily)
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font.fontType">
            <summary></summary>
        </member>
        <member name="F:Axiom.Fonts.Font.source">
            <summary></summary>
        </member>
        <member name="F:Axiom.Fonts.Font.shader">
            <summary>Shader create for use on entities by this font.</summary>
        </member>
        <member name="M:Axiom.Fonts.Font.#ctor(System.String)">
            <summary>
            	Constructor, should be called through FontManager.Create.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.Font.GetCharTexCoords(System.Char,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            	Retreives the texture coordinates for the specifed character in this font.
            </summary>
            <param name="c"></param>
            <param name="u1"></param>
            <param name="u2"></param>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:Axiom.Fonts.Font.GetCharAspectRatio(System.Char)">
            <summary>
            	Finds the aspect ratio of the specified character in this font.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Fonts.FontType">
            <summary>
            	Possible font sources for use in the engine.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FontType.TrueType">
            <summary>System truetype fonts, as well as supplementary .ttf files.</summary>
        </member>
        <member name="F:Axiom.Fonts.FontType.Image">
            <summary>Character image map created by an artist.</summary>
        </member>
        <member name="T:Axiom.Fonts.FontManager">
            <summary>
            Summary description for FontManager.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FontManager.fontList">
            <summary>Local list of manually loaded TrueType fonts.</summary>
        </member>
        <member name="T:Axiom.Gui.GuiControl">
            <summary>
            	Abstract class used to derive controls that can be placed in an overlay (GUI).
            </summary>
        </member>
        <member name="F:Axiom.Gui.GuiControl.childControls">
            <summary>A list of child controls within this control.</summary>
        </member>
        <member name="F:Axiom.Gui.GuiControl.parentControl">
            <summary>Parent control if this is a child control of another one.</summary>
        </member>
        <member name="M:Axiom.Gui.GuiControl.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.Gui.MetricsMode">
            <summary>
            	Describes how the position / size of an element is to be treated. 
            </summary>
        </member>
        <member name="F:Axiom.Gui.MetricsMode.Relative">
            <summary>'left', 'top', 'height' and 'width' are parametrics from 0.0 to 1.0</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Gui.MetricsMode.Pixels" -->
        <member name="T:Axiom.Gui.HorizontalAlignment">
            <summary>
            	Describes where '0' is in relation to the parent in the horizontal dimension.  Affects how 'left' is interpreted.
            </summary>
        </member>
        <member name="T:Axiom.Gui.VerticalAlignment">
            <summary>
            	Describes where '0' is in relation to the parent in the vertical dimension.  Affects how 'top' is interpreted.
            </summary>
        </member>
        <member name="T:Axiom.Gui.GuiManager">
            <summary>
            Summary description for GuiManager.
            </summary>
        </member>
        <member name="T:Axiom.Input.InputSystem">
            <summary>
            	Abstract class which allows input to be read from various
            	controllers.
             </summary>
             <remarks>
            	Temporary implementation only. This class is likely to be
            	refactored into a better design when I get time to look at it
            	properly. For now it's a quick-and-dirty way to get what I need.
            </remarks>
        </member>
        <member name="M:Axiom.Input.InputSystem.Initialize(Axiom.SubSystems.Rendering.RenderWindow,System.Collections.Queue,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Subclasses should initialize the underlying input subsystem using this
            	method.
            </summary>
            <param name="window"></param>
            <param name="eventQueue">Used for buffering input.  Events will be added to the queue by the input reader.</param>
            <param name="useKeyboard"></param>
            <param name="useMouse"></param>
            <param name="useGamepad"></param>
        </member>
        <member name="M:Axiom.Input.InputSystem.Capture">
            <summary>
            	Captures the state of all the input devices.
            </summary>
             <remarks>
            	This method captures the state of all input devices and
            	stores it internally for use when the enquiry methods are
            	next called. This is done to ensure that all input is
            	captured at once and therefore combinations of input are not
            	subject to time differences when methods are called.
            </remarks>
        </member>
        <member name="M:Axiom.Input.InputSystem.IsKeyPressed(System.Windows.Forms.Keys)">
            <summary>
            	Used to check if a particular key was pressed during the last call to Capture.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Input.InputSystem.RelativeMouseX">
            <summary>
            	Retrieves the relative (compared to the last input poll) mouse movement
            	on the X (horizontal) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputSystem.RelativeMouseY">
            <summary>
            	Retrieves the relative (compared to the last input poll) mouse movement
            	on the Y (vertical) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputSystem.RelativeMouseZ">
            <summary>
            	Retrieves the relative (compared to the last input poll) mouse movement
            	on the Z (mouse wheel) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputSystem.AbsoluteMouseX">
            <summary>
            	Retrieves the absolute mouse position on the X (horizontal) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputSystem.AbsoluteMouseY">
            <summary>
            	Retrieves the absolute mouse position on the Y (vertical) axis.
            </summary>
        </member>
        <member name="P:Axiom.Input.InputSystem.AbsoluteMouseZ">
            <summary>
            	Retrieves the absolute mouse position on the Z (mouse wheel) axis.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.Particle">
            <summary>
            	An extension of Billboard that allows for each particle to have particle system specific info.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.timeToLive">
            <summary>Time (in seconds) before this particle is destroyed.</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.Particle.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.ParticleSystems.ParticleAffector" -->
        <member name="F:Axiom.ParticleSystems.ParticleAffector.type">
            <summary>Name of the affector type.  Must be initialized by subclasses.</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.AffectParticles(Axiom.ParticleSystems.ParticleSystem,System.Single)">
            <summary>
            	Method called to allow the affector to 'do it's stuff' on all active particles in the system.
            </summary>
            <remarks>
            	This is where the affector gets the chance to apply it's effects to the particles of a system.
            	The affector is expected to apply it's effect to some or all of the particles in the system
            	passed to it, depending on the affector's approach.
            </remarks>
            <param name="system">Reference to a ParticleSystem to affect.</param>
            <param name="timeElapsed">The number of seconds which have elapsed since the last call.</param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleAffector.Type">
            <summary>
            	Gets the type name of this affector.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleAffectorFactory">
            <summary>
            	Abstract class defining the interface to be implemented by creators of ParticleAffector subclasses.
            </summary>
            <remarks>
            	Plugins or 3rd party applications can add new types of particle affectors  by creating
            	subclasses of the ParticleAffector class. Because multiple instances of these affectors may be
            	required, a factory class to manage the instances is also required. 
            	<p/>
            	ParticleAffectorFactory subclasses must allow the creation and destruction of ParticleAffector
            	subclasses. They must also be registered with the ParticleSystemManager. All factories have
            	a name which identifies them, examples might be 'ForceVector', 'Attractor', or 'Fader', and these can be 
            	also be used from particle system scripts.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.Create">
            <summary>
            	Creates a new affector instance.
            </summary>
            <remarks>
            	Subclasses MUST add a reference to the affectorList.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.Destroy(Axiom.ParticleSystems.ParticleAffector)">
            <summary>
            	Destroys the affector referenced by the parameter.
            </summary>
            <param name="e">The Affector to destroy.</param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleAffectorFactory.Name">
            <summary>
            	Returns the name of the factory, which identifies the affector type this factory creates.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter">
            <summary>
            	Abstract class defining the interface to be implemented by particle emitters.
            </summary>
            <remarks>
            	Particle emitters are the sources of particles in a particle system. 
            	This class defines the ParticleEmitter interface, and provides a basic implementation 
            	for tasks which most emitters will do (these are of course overridable).
            	Particle emitters can be  grouped into types, e.g. 'point' emitters, 'box' emitters etc; each type will 
            	create particles with a different starting point, direction and velocity (although
            	within the types you can configure the ranges of these parameters). 
            	<p/>
            	Because there are so many types of emitters you could use, the engine chooses not to dictate
            	the available types. It comes with some in-built, but allows plugins or games to extend the emitter types available.
            	This is done by subclassing ParticleEmitter to have the appropriate emission behavior you want,
            	and also creating a subclass of ParticleEmitterFactory which is responsible for creating instances 
            	of your new emitter type. You register this factory with the ParticleSystemManager using
            	AddEmitterFactory, and from then on emitters of this type can be created either from code or through
            	XML particle scripts by naming the type.
            	<p/>
            	This same approach is used for ParticleAffectors (which modify existing particles per frame).
            	This means that the engine is particularly flexible when it comes to creating particle system effects,
            	with literally infinite combinations of emitter and affector types, and parameters within those
            	types.
            </remarks>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.position">
            <summary>Position relative to the center of the ParticleSystem</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.emissionRate">
            <summary> Rate in particles per second at which this emitter wishes to emit particles</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.type">
            <summary>Name of the type of emitter, MUST be initialized by subclasses</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.direction">
            <summary>Base direction of the emitter, may not be used by some emitters</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.up">
            <summary>Notional up vector, just used to speed up generation of variant directions</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.angle">
            <summary>Angle around direction which particles may be emitted, internally radians but degrees for interface</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.minSpeed">
            <summary>Min speed of particles</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.maxSpeed">
            <summary>Max speed of particles</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.minTTL">
            <summary>Initial time-to-live of particles (min)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.maxTTL">
            <summary>Initial time-to-live of particles (max)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.colorRangeStart">
            <summary>Initial color of particles (range start)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.colorRangeEnd">
            <summary>Initial color of particles (range end)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.isEnabled">
            <summary>Whether this emitter is currently enabled (defaults to true)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.startTime">
            <summary>Start time (in seconds from start of first call to ParticleSystem to update)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationMin">
            <summary>Minimum length of time emitter will run for (0 = forever)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationMax">
            <summary>Maximum length of time the emitter will run for (0 = forever)</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationRemain">
            <summary>Current duration remainder</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayMin">
            <summary>Time between each repeat</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayRemain">
            <summary>Repeat delay left</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GetEmissionCount(System.Single)">
            <summary>
            	Gets the number of particles which this emitter would like to emit based on the time elapsed.
             </summary>
             <remarks>
            	For efficiency the emitter does not actually create new Particle instances (these are reused
            	by the ParticleSystem as existing particles 'die'). The implementation for this method must
            	return the number of particles the emitter would like to emit given the number of seconds which
            	have elapsed (passed in as a parameter).
            	<p/>
            	Based on the return value from this method, the ParticleSystem class will call 
            	InitParticle once for each particle it chooses to allow to be emitted by this emitter.
            	The emitter should not track these InitParticle calls, it should assume all emissions
            	requested were made (even if they could not be because of particle quotas).
             </remarks>
            <param name="timeElapsed"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.InitParticle(Axiom.ParticleSystems.Particle)">
            <summary>
            	Initializes a particle based on the emitter's approach and parameters.
            </summary>
            <remarks>
            	See the GetEmissionCount method for details of why there is a separation between
            	'requested' emissions and actual initialized particles.
            </remarks>
            <param name="particle">Reference to a particle which must be initialized based on how this emitter starts particles</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionDirection(Axiom.MathLib.Vector3@)">
            <summary>
            	Utility method for generating particle exit direction
            </summary>
            <param name="dest">Normalized vector dictating new direction.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionVelocity(Axiom.MathLib.Vector3@)">
            <summary>
            	Utility method to applu velocity to a particle direction.
            </summary>
            <param name="dest">The normalized vector to scale by a randomly generated scale between min and max speed.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionTTL">
            <summary>
            	Utility method for generating a time-to-live for a particle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateConstantEmissionCount(System.Single)">
            <summary>
            	Utility method for generating an emission count based on a constant emission rate.
            </summary>
            <param name="timeElapsed"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionColor(Axiom.Core.ColorEx)">
            <summary>
            	Internal method for generating a color for a particle.
            </summary>
            <param name="color"></param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Position">
            <summary>
            	Gets/Sets the position of this emitter relative to the center of the particle system.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Direction">
            <summary>
            	Gets/Sets the direction of the emitter.
            </summary>
            <remarks>
            	Most emitters will have a base direction in which they emit particles (those which
            	emit in all directions will ignore this parameter). They may not emit exactly along this
            	vector for every particle, many will introduce a random scatter around this vector using 
            	the angle property.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Angle">
            <summary>
            	Gets/Sets the maximum angle away from the emitter direction which particle will be emitted.
            </summary>
            <remarks>
            	Whilst the direction property defines the general direction of emission for particles, 
            	this property defines how far the emission angle can deviate away from this base direction.
            	This allows you to create a scatter effect - if set to 0, all particles will be emitted
            	exactly along the emitters direction vector, wheras if you set it to 180 or more, particles
            	will be emitted in a sphere, i.e. in all directions.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ParticleVelocity">
            <summary>
            	Gets/Sets the initial velocity of particles emitted.
            </summary>
            <remarks>
            	This property sets the range of starting speeds for emitted particles. 
            	See the alternate Min/Max properties for velocities.  This emitter will randomly 
            	choose a speed between the minimum and maximum for each particle.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinParticleVelocity">
            <summary>
            	Gets/Sets the minimum velocity of particles emitted.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxParticleVelocity">
            <summary>
            	Gets/Sets the maximum velocity of particles emitted.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.EmissionRate">
            <summary>
            	Gets/Sets the emission rate for this emitter.
            </summary>
            <remarks>
            	This tells the emitter how many particles per second should be emitted. The emitter
            	subclass does not have to emit these in a continuous burst - this is a relative parameter
            	and the emitter may choose to emit all of the second's worth of particles every half-second
            	for example. This is controlled by the emitter's EmissionCount property.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.TimeToLive">
            <summary>
            	Gets/Sets the lifetime of all particles emitted.
            </summary>
            <remarks>
            	The emitter initializes particles with a time-to-live (TTL), the number of seconds a particle
            	will exist before being destroyed. This method sets a constant TTL for all particles emitted.
            	Note that affectors are able to modify the TTL of particles later.
            	<p/>
            	Also see the alternate Min/Max versions of this property which takes a min and max TTL in order to 
            	have the TTL vary per particle.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinTimeToLive">
            <summary>
            	Gets/Sets the minimum time each particle will live for.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxTimeToLive">
            <summary>
            	Gets/Sets the maximum time each particle will live for.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Color">
            <summary>
            	Gets/Sets the initial color of particles emitted.
            </summary>
            <remarks>
            	Particles have an initial color on emission which the emitter sets. This property sets
            	this color. See the alternate Start/End versions of this property which takes 2 colous in order to establish 
            	a range of colors to be assigned to particles.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ColorRangeStart">
            <summary>
            	Gets/Sets the color that a particle starts out when it is created.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ColorRangeEnd">
            <summary>
            	Gets/Sets the color that a particle ends at just before it's TTL expires.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Type">
            <summary>
            	Gets the name of the type of emitter. 
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.IsEnabled">
            <summary>
            	Gets/Sets the flag indicating if this emitter is enabled or not.
            </summary>
            <remarks>
            	Setting this property to false will turn the emitter off completely.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.StartTime">
            <summary>
            	Gets/Sets the start time of this emitter.
            </summary>
            <remarks>
            	By default an emitter starts straight away as soon as a ParticleSystem is first created,
            	or also just after it is re-enabled. This parameter allows you to set a time delay so
            	that the emitter does not 'kick in' until later.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Duration">
            <summary>
            	Gets/Sets the duration of time (in seconds) that the emitter should run.
            </summary>
            <remarks>
            	By default emitters run indefinitely (unless you manually disable them). By setting this
            	parameter, you can make an emitter turn off on it's own after a set number of seconds. It
            	will then remain disabled until either Enabled is set to true, or if the 'repeatAfter' parameter
            	has been set it will also repeat after a number of seconds.
            	<p/>
            	Also see the alternative Min/Max versions of this property which allows you to set a min and max duration for
            	a random variable duration.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinDuration">
            <summary>
            	Gets/Sets the minimum running time of this emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxDuration">
            <summary>
            	Gets/Sets the maximum running time of this emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.RepeatDelay">
            <summary>
            	Gets/Sets the time between repeats of the emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinRepeatDelay">
            <summary>
            	Gets/Sets the minimum repeat delay for the emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxRepeatDelay">
            <summary>
            	Gets/Sets the maximum repeat delay for the emitter.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.ParticleSystems.ParticleEmitterFactory" -->
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.Create">
            <summary>
            	Creates a new instance of an emitter.
            </summary>
            <remarks>
            	Subclasses must add newly created emitters to the emitterList.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.Destroy(Axiom.ParticleSystems.ParticleEmitter)">
            <summary>
            	Destroys the emitter referenced by the parameter.
            </summary>
            <param name="emitter"></param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitterFactory.Name">
            <summary>
            	Returns the name of the factory, which identifies which type of emitter this factory creates.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.ParticleSystems.ParticleSystem" -->
        <member name="F:Axiom.ParticleSystems.ParticleSystem.emitterList">
            <summary>List of emitters for this system.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.affectorList">
            <summary>List of affectors for this system.</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.#ctor(System.String)">
            <summary>
            	Creates a particle system with no emitters or affectors.
            </summary>
            <remarks>
            	You should use the ParticleSystemManager to create systems, rather than doing it directly.
            </remarks>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddEmitter(System.String)">
            <summary>
            	Adds an emitter to this particle system.
             </summary>
             <remarks>	
            	Particles are created in a particle system by emitters - see the ParticleEmitter
            	class for more details.
            </remarks>
            <param name="emitterType">
            	String identifying the emitter type to create. Emitter types are defined
            	by registering new factories with the manager - see ParticleEmitterFactory for more details.
            	Emitter types can be extended by plugin authors.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddAffector(System.String)">
            <summary>
            	Adds an affector to this particle system.
             </summary>
             <remarks>	
            	Particles are modified over time in a particle system by affectors - see the ParticleAffector
            	class for more details.
            </remarks>
            <param name="emitterType">
            	String identifying the affector type to create. Affector types are defined
            	by registering new factories with the manager - see ParticleAffectorFactory for more details.
            	Affector types can be extended by plugin authors.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.Update(System.Single)">
            <summary>
            	Updates the particles in the system based on time elapsed.
             </summary>
             <remarks>	
            	This is called automatically every frame by the engine.
            </remarks>
            <param name="timeElapsed">The amount of time (in seconds) since the last frame.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.FastForward(System.Single)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="time"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.ParticleSystems.ParticleSystem.FastForward(System.Single,System.Single)" -->
        <member name="M:Axiom.ParticleSystems.ParticleSystem.UpdateBounds">
            <summary>
            	Overriden.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.Expire(System.Single)">
            <summary>
            	Used to expire dead particles.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.TriggerEmitters(System.Single)">
            <summary>
            	Spawn new particles based on free quota and emitter requirements.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.ApplyMotion(System.Single)">
            <summary>
            	Updates existing particles based on their momentum.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.TriggerAffectors(System.Single)">
            <summary>
            	Applies the effects of particle affectors.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.IncreasePool(System.Int32)">
            <summary>
            	Overriden from BillboardSet to create Particles instead of Billboards.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddParticle">
            <summary>
            	Used internally for adding a new active particle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.GenerateBillboardAxes(Axiom.Core.Camera,Axiom.MathLib.Vector3@,Axiom.MathLib.Vector3@,Axiom.Core.Billboard)">
            <summary>
            	Overriden from BillboardSet.
            </summary>
            <param name="camera"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="billboard"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.CopyTo(Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Cloning will deep copy all particle emitters and effectors, but not particles. The
            	system's name is also not copied.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.WorldTransforms">
            <summary>
            	Overriden.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.ParticleCount">
            <summary>
            	Gets the count of active particles currently in the system.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.ParticleQuota">
            <summary>
            	Returns the maximum number of particles this system is allowed to have active at once.
            </summary>
            <remarks>
            	Particle systems all have a particle quota, i.e. a maximum number of particles they are 
            	allowed to have active at a time. This allows the application to set a keep particle systems
            	under control should they be affected by complex parameters which alter their emission rates
            	etc. If a particle system reaches it's particle quota, none of the emitters will be able to 
            	emit any more particles. As existing particles die, the spare capacity will be allocated
            	equally across all emitters to be as consistent to the origina particle system style as possible.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.Particles">
            <summary>
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.ParticleSystems.ParticleSystemManager" -->
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.systemTemplateList">
            <summary>Templates based on XML scripts.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.systemList">
            <summary>Actual instantiated particle systems (may be based on template, may be manual).</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.emitterFactoryList">
            <summary>Factories for named emitter type (can be extended using plugins).</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.affectorFactoryList">
            <summary>Factories for named affector types (can be extended using plugins).</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.timeFactor">
            <summary>Controls time. (1.0 is real time)</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddEmitterFactory(Axiom.ParticleSystems.ParticleEmitterFactory)">
            <summary>
            	Adds a new 'factory' object for emitters to the list of available emitter types.
             </summary>
             <remarks>
            	This method allows plugins etc to add new particle emitter types. Particle emitters
            	are sources of particles, and generate new particles with their start positions, colors and
            	momentums appropriately. Plugins would create new subclasses of ParticleEmitter which 
            	emit particles a certain way, and register a subclass of ParticleEmitterFactory to create them (since multiple 
            	emitters can be created for different particle systems).
            	<p/>
            	All particle emitter factories have an assigned name which is used to identify the emitter
            	type. This must be unique.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddAffectorFactory(Axiom.ParticleSystems.ParticleAffectorFactory)">
            <summary>
            	Adds a new 'factory' object for affectors to the list of available affector types.
             </summary>
              <remarks>
            	This method allows plugins etc to add new particle affector types. Particle
            	affectors modify the particles in a system a certain way such as affecting their direction
            	or changing their color, lifespan etc. Plugins would
            	create new subclasses of ParticleAffector which affect particles a certain way, and register
            	a subclass of ParticleAffectorFactory to create them.
            	<p/>
            	All particle affector factories have an assigned name which is used to identify the affector
            	type. This must be unique.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddTemplate(System.String,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Adds a new particle system template to the list of available templates. 
             </summary>
             <remarks>
            	Instances of particle systems in a scene are not normally unique - often you want to place the
            	same effect in many places. This method allows you to register a ParticleSystem as a named template,
            	which can subsequently be used to create instances using the CreateSystem method.
            	<p/>
            	Note that particle system templates can either be created programmatically by an application 
            	and registered using this method, or they can be defined in a XML script file which is
            	loaded by the engine at startup, very much like Shader scripts.
            </remarks>
            <param name="name">The name of the template. Must be unique across all templates.</param>
            <param name="system">A reference to a particle system to be used as a template.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateTemplate(System.String)">
            <summary>
            	Create a new particle system template.
            </summary>
            <remarks>
            	This method is similar to the AddTemplate method, except this just creates a new template
            	and returns a reference to it to be populated. Use this when you don't already have a system
            	to add as a template and just want to create a new template which you will build up at runtime.
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String,System.Int32)">
            <summary>
            	Basic method for creating a blank particle system.
             </summary>
             <remarks>
            	This method creates a new, blank ParticleSystem instance and returns a reference to it.
            	<p/>
            	The instance returned from this method won't actually do anything because on creation a
            	particle system has no emitters. The caller should manipulate the instance through it's 
            	ParticleSystem methods to actually create a real particle effect. 
            	<p/>
            	Creating a particle system does not make it a part of the scene. As with other SceneObject
            	subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
            </remarks>
            <param name="name">The name to give the ParticleSystem.</param>
            <param name="quota">The maximum number of particles to allow in this system.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String,System.String,System.Int32)">
            <summary>
            	Creates a particle system based on a template.
             </summary>
             <remarks>
            	This method creates a new ParticleSystem instance based on the named template and returns a 
            	reference to the caller. 
            	<p/>
            	Each system created from a template takes the template's settings at the time of creation, 
            	but is completely separate from the template from there on. 
            	<p/>
            	Creating a particle system does not make it a part of the scene. As with other SceneObject
            	subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
            	<p/>
            	This is probably the more useful particle system creation method since it does not require manual
            	setup of the system.
            </remarks>
            <param name="name">The name to give the new particle system instance.</param>
            <param name="templateName">The name of the template to base the new instance on.</param>
            <param name="quota">The maximum number of particles to allow in this system (can be changed later).</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateEmitter(System.String)">
            <summary>
            	Internal method for creating a new emitter from a factory.
            </summary>
            <remarks>
            	Used internally by the engine to create new ParticleEmitter instances from named
            	factories. Applications should use the ParticleSystem.AddEmitter method instead, 
            	which calls this method to create an instance.
            </remarks>
            <param name="emitterType">String name of the emitter type to be created. A factory of this type must have been registered.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateAffector(System.String)">
            <summary>
            	Internal method for creating a new affector from a factory.
            </summary>
            <remarks>
            	Used internally by the engine to create new ParticleAffector instances from named
            	factories. Applications should use the ParticleSystem.AddAffector method instead, 
            	which calls this method to create an instance.
            </remarks>
            <param name="emitterType">String name of the affector type to be created. A factory of this type must have been registered.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.Initialize">
            <summary>
            	Internal method to init the particle systems.
            </summary>
            <remarks>
            	Since this method is dependent on other engine systems being started, this method will be called by the
            	engine when the render system is initialized.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAllSources(System.String)">
            <summary>
            	Parses all particle system script files in resource folders and archives.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RenderSystem_FrameStarted(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	A listener that is added to the engine's render loop.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.TimeFactor">
            <summary>
            	Get/Set the relative speed of time as perceived by particle systems.
             </summary>
             <remarks>
            	Normally particle systems are updated automatically in line with the real 
            	passage of time. This method allows you to change that, so that 
            	particle systems are told that the time is passing slower or faster than it
            	actually is. Use this to globally speed up / slow down particle systems.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.ParticleSystems">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Affectors">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Emitters">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Patterns.IObjectFactory">
            <summary>
            	Interface that implements the Abstract Factory design pattern.
            </summary>
        </member>
        <member name="M:Axiom.Patterns.IObjectFactory.Create(System.String)">
            <summary>
            	Method to create an object based on the passed in name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Physics.DynamicsSystem">
            <summary>
            Summary description for DynamicsSystem.
            </summary>
        </member>
        <member name="M:Axiom.Physics.DynamicsSystem.CreateWorld">
            <summary>
            	
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Physics.DynamicsSystem.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Physics.IJoint">
            <summary>
            Summary description for Joint.
            </summary>
        </member>
        <member name="T:Axiom.Physics.IRigidBody">
            <summary>
            Summary description for RigidBody.
            </summary>
        </member>
        <member name="M:Axiom.Physics.IRigidBody.SetAABB(Axiom.Core.AxisAlignedBox)">
            <summary>
            
            </summary>
            <param name="aab"></param>
        </member>
        <member name="M:Axiom.Physics.IRigidBody.AddTorque(System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Axiom.Physics.IRigidBody.AddForce(System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="x"></param>
        </member>
        <member name="P:Axiom.Physics.IRigidBody.Position">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Physics.IRigidBody.Orientation">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Physics.IWorld">
            <summary>
            Summary description for IWorld.
            </summary>
        </member>
        <member name="M:Axiom.Physics.IWorld.CreateBody(Axiom.Scripting.GameObject,Axiom.Enumerations.DynamicsBodyType,System.Single)">
            <summary>
            
            </summary>
            <param name="gameObject"></param>
            <param name="bodyType"></param>
            <param name="position"></param>
            <param name="orientation"></param>
            <param name="aab"></param>
            <param name="massDensity"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Physics.IWorld.Step(System.Single)">
            <summary>
            
            </summary>
            <param name="stepsize"></param>
        </member>
        <member name="P:Axiom.Physics.IWorld.Gravity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Scripting.AutoAttribute">
            <summary>
            This attibute can be placed on one of an entitie's nested State classes to specifiy which
            state should be the default.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.GameObject">
            <summary>
            Summary description for GameObject.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.State">
            <summary>
            The state class is an abstract class that specifies abstract methods for all even methods that
            an entitie's nested state classes can implement.
            </summary>
        </member>
        <member name="P:Axiom.Scripting.State.Me">
            <summary>
            Returns the Entity object that own this state class.
            NOTE: Due to the .Net implementation of all "nested" classes as static, we must keep
            a local reference to our owner class in order to access it.
            </summary>
        </member>
        <member name="T:Axiom.Xml.OgreMeshReader">
            <summary>
            	Summary description for OgreMeshReader.
            </summary>
        </member>
        <member name="M:Axiom.Xml.OgreMeshReader.ReadGeometry(Axiom.SubSystems.Rendering.VertexData)">
            <summary>
            	Reads geometry data into the specified VertexData object.
            </summary>
            <param name="vertexData"></param>
        </member>
        <member name="M:Axiom.Xml.OgreMeshReader.Seek(System.Int64)">
            <summary>
            
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:Axiom.Xml.OgreMeshReader.ReadFloats(System.Int32,System.Single[])">
            <summary>
            
            </summary>
            <param name="count"></param>
            <param name="dest"></param>
        </member>
        <member name="M:Axiom.Xml.OgreMeshReader.ReadInts(System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="count"></param>
            <param name="dest"></param>
        </member>
        <member name="M:Axiom.Xml.OgreMeshReader.ReadShorts(System.Int32,System.Int16[])">
            <summary>
            
            </summary>
            <param name="count"></param>
            <param name="dest"></param>
        </member>
        <member name="T:Axiom.Xml.MeshChunkID">
            <summary>
            	Values that mark data chunks in the .mesh file.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.BufferLocking">
            <summary>
            	Describes how a vertex buffer should act when it is locked.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferLocking.Normal">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferLocking.Discard">
            <summary>
            	Discards the <em>entire</em> buffer while locking; this allows optimisation to be 
            	performed because synchronisation issues are relaxed. Only allowed on buffers 
            	created with the Dynamic flag. 
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferLocking.ReadOnly">
            <summary>
            	Lock the buffer for reading only. Not allowed in buffers which are created with WriteOnly. 
            	Mandatory on static buffers, ie those created without the Dynamic flag.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.BufferUsage">
            <summary>
            	Describes how a vertex buffer is to be used, and affects how it is created.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferUsage.Static">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferUsage.Dynamic">
            <summary>
            	Indicates the application would like to modify this buffer with the CPU
            	sometimes. Absence of this flag means the application will never modify. 
            	Buffers created with this flag will typically end up in AGP memory rather 
            	than video memory.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferUsage.WriteOnly">
            <summary>
            	Indicates the application will never read the contents of the buffer back, 
            	it will only ever write data. Locking a buffer with this flag will ALWAYS 
            	return a pointer to new, blank memory rather than the memory associated 
            	with the contents of the buffer; this avoids DMA stalls because you can 
            	write to a new memory area while the previous one is being used
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferUsage.StaticWriteOnly">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.BufferUsage.DynamicWriteOnly">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.Capabilities">
            <summary>
            	Various types of capabilities supported by hardware that must be checked.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.CompareFunction">
            <summary>
             Comparison functions, for things such as stencil buffer or depth comparisons.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.CullingMode">
            <summary>
            Options for deciding what geometry gets excluded from the rendering process.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.CullingMode.None">
            <summary>
            	Draw everything (2 sided geometry).
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.CullingMode.Clockwise">
            <summary>
            	Only draw geomtry where vertices were specified in clockwise order.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.CullingMode.CounterClockwise">
            <summary>
            	Only draw geomtry where vertices were specified in counterclockwise order.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.EnvironmentMap">
            <summary>
            	Specifes the type of environment mapping to use.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.EnvironmentMap.Curved">
            <summary>
            	Envmap based on vector from camera to vertex position, good for planar geometry.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.EnvironmentMap.Planar">
            <summary>
            	Envmap based on dot of vector from camera to vertex and vertex normal, good for curves.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.FogMode">
            <summary>
            Type of fog to use in the scene.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.FogMode.None">
            <summary>
            	No fog.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.FogMode.Exp">
            <summary>
            	Fog density increases exponentially from the camera (fog = 1/e^(distance * density)).
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.FogMode.Exp2">
            <summary>
            	Fog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2).
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.FogMode.Linear">
            <summary>
            	Fog density increases linearly between the start and end distances.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.IndexType">
            <summary>
            	Type of index buffer to use.
            </summary>
            <remarks>
            	No declarations can begin with a number, so Size prefix is used.
            </remarks>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.LayerBlendOperation">
            <summary>
            	Lists the texture layer operations that are available on both multipass and multitexture
            	hardware.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperation.Replace">
            <summary>
            	Replace all color with texture and no adjustment.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperation.Add">
            <summary>
            	Add color components together.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperation.Modulate">
            <summary>
            	Multiply the color components together.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperation.AlphaBlend">
            <summary>
            	Blend based on texture alpha.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.LayerBlendOperationEx">
            <summary>
            	Full and complete list of valid texture blending operations.  Fallbacks will be required on older hardware
            	that does not supports some of these multitexturing techniques.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.Source1">
            <summary>
            	Use source 1 as is.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.Source2">
            <summary>
            	Use source 2 as is.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.Modulate">
            <summary>
            	Multiply source 1 and source 2 together.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.ModulateX2">
            <summary>
            	Same as Modulate, but brightens as a result.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.ModulateX4">
            <summary>
            	Same as ModuleX2, but brightens even more as a result.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.Add">
            <summary>
            	Add source 1 and source 2 together.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.AddSigned">
            <summary>
            	Same as Add, but subtracts 0.5 from the result.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.AddSmooth">
            <summary>
            	Same as Add, but subtracts the product from the sum.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.Subtract">
            <summary>
            	Subtract source 2 from source 1.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.BlendDiffuseAlpha">
            <summary>
            	Use interpolated alpha value from vertices to scale source 1, then add source 2 scaled by 1 - alpha
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.BlendTextureAlpha">
            <summary>
            	Same as BlendDiffuseAlpha, but uses current alpha from the texture.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.BlendCurrentAlpha">
            <summary>
            	Same as BlendDiffuseAlpha, but uses current alpha from previous stages.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.BlendManual">
            <summary>
            	Sames as BlendDiffuseAlpha, but uses a constant manual blend value from [0.0,1.0]
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendOperationEx.DotProduct">
            <summary>
            	Takes the dot product of color 1 and color 2.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.LayerBlendSource">
            <summary>
            	Valid sources of values for texture layer blending operations.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendSource.Current">
            <summary>
            	The color as built up from previous stages.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendSource.Texture">
            <summary>
            	The color derived from the texture assigned to the current layer.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendSource.Diffuse">
            <summary>
            	The interpolated diffuse color from the vertices.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendSource.Specular">
            <summary>
            	The interpolated specular color from the vertices.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendSource.Manual">
            <summary>
            	A color supplied manually as a seperate argument.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.LayerBlendType">
            <summary>
            	Texture blending mode.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendType.Color">
            <summary>
            	Based on diffuse color of the texture.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LayerBlendType.Alpha">
            <summary>
            	Based on the alpha value of the texture.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.LightType">
            <summary>
            	Defines the types of lights that can be added to a scene.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LightType.Point">
            <summary>
            	Point light sources give off light equally in all directions, so require only position not direction.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LightType.Directional">
            <summary>
            	Directional lights simulate parallel light beams from a distant source, hence have direction but no position.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.LightType.Spotlight">
            <summary>
            	Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.ManualCullingMode">
            <summary>
            	Manual culling modes based on vertex normals.
            	This setting applies to how the software culls triangles before sending them to the 
            	hardware API. This culling mode is used by scene managers which choose to implement it -
            	normally those which deal with large amounts of fixed world geometry which is often 
            	planar (software culling movable variable geometry is expensive).
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.ManualCullingMode.None">
            <summary>
            	No culling so everything is sent to the hardware.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.ManualCullingMode.Back">
            <summary>
            	Cull triangles whose normal is pointing away from the camera (default).
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.ManualCullingMode.Front">
            <summary>
            	Cull triangles whose normal is pointing towards the camera.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.Projection">
            <summary>
            Type of projection used by the camera.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.Projection.Orthographic">
            <summary> Things stay the same size no matter where they are in terms of the camera.  Normally only used in 3D HUD elements. </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.Projection.Perspective">
            <summary> Things get smaller when they are furthur away from the camera. </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderMode">
            <summary>
            	Types for determining which render operation to do for a series of vertices.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderMode.PointList">
            <summary>
            	Render the vertices as individual points.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderMode.LineList">
            <summary>
            	Render the vertices as a series of individual lines.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderMode.LineStrip">
            <summary>
            	Render the vertices as a continuous line.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderMode.TriangleList">
            <summary>
            	Render the vertices as a series of individual triangles.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderMode.TriangleStrip">
            <summary>
            	Render the vertices as a continous set of triangles in a zigzag type fashion.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderMode.TriangleFan">
            <summary>
            	Render the vertices as a set of trinagles in a fan like formation.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.SceneBlendFactor">
            <summary>
            	Blending factors for manually blending objects with the scene. If there isn't a predefined
            	SceneBlendType that you like, then you can specify the blending factors directly to affect the
            	combination of object and the existing scene. See Shader.SceneBlending for more details.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.One">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.Zero">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.DestColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.SourceColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.OneMinusDestColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.OneMinusSourceColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.DestAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.SourceAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.OneMinusDestAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.OneMinusSourceAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendFactor.Dot3">
            <summary>
            	Blend pixels together by taking the dot product of the color values being blended.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.SceneBlendType">
            <summary>
            	Types of blending that you can specify between an object and the existing contents of the scene.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendType.TransparentAlpha">
            <summary>
            	Make the object transparent based on the final alpha values in the texture.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendType.TransparentColor">
            <summary>
            	Make the object transparent based on the color values in the texture (brighter = more opaque).
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneBlendType.Add">
            <summary>
            	Add the texture values to the existing scene content.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.SceneDetailLevel">
            <summary>
            The broad type of detail for rendering.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneDetailLevel.Points">
            <summary>
            	Render subsequent requests drawing only the vertices in the scene.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneDetailLevel.Wireframe">
            <summary>
            	Render subsequent requests drawing only objects using wireframe mode.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.SceneDetailLevel.Solid">
            <summary>
            	Render everything in the scene normally (textures, etc).
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.Shading">
            <summary>
            Types for deciding how to shade geometry primitives.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.Shading.Flat">
            <summary>
            	Draw with a single color.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.Shading.Gouraud">
            <summary>
            	Interpolate color across primitive vertices.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.Shading.Phong">
            <summary>
            	Draw everything (2 sided geometry).
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.StencilOperation">
            <summary>
            	Describes the various actions which can be taken on the stencil buffer.
            </summary> 
        </member>
        <member name="F:Axiom.SubSystems.Rendering.StencilOperation.Keep">
            <summary>
            	Leave the stencil buffer unchanged.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.StencilOperation.Zero">
            <summary>
            	Set the stencil value to zero.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.StencilOperation.Replace">
            <summary>
            	Set the stencil value to the reference value.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.StencilOperation.Increment">
            <summary>
            	Increase the stencil value by 1, clamping at the maximum value.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.StencilOperation.Decrement">
            <summary>
            	Decrease the stencil value by 1, clamping at 0.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.StencilOperation.Invert">
            <summary>
            	Invert the bits of the stencil buffer.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.TextureAddressing">
            <summary>
            Texture addressing modes - default is Wrap.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureAddressing.Wrap">
            <summary>
            	Texture wraps at values over 1.0 
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureAddressing.Mirror">
            <summary>
            	Texture mirrors (flips) at joins over 1.0.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureAddressing.Clamp">
            <summary>
            	Texture clamps at 1.0.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.TexCoordCalcMethod">
            <summary>
            	Describes the ways to generate texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TexCoordCalcMethod.None">
            <summary>
            	No calculated texture coordinates.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TexCoordCalcMethod.EnvironmentMap">
            <summary>
            	Environment map based on vertex normals.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TexCoordCalcMethod.EnvironmentMapPlanar">
            <summary>
            	Environment map based on vertex positions.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.TextureCubeFace">
            <summary>
            Enum identifying the frame indexes for faces of a cube map (not the composite 3D type.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.TextureEffect">
            <summary>
            Definition of the broad types of texture effect you can apply to a texture layer.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureEffect.BumpMap">
            <summary>
            	Bump mapping.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureEffect.EnvironmentMap">
            <summary>
            	Generate all texture coords based on angle between camera and vertex.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureEffect.Scroll">
            <summary>
            	Constant u/v scrolling effect.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureEffect.Rotate">
            <summary>
            	Constant rotation.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureEffect.Transform">
            <summary>
            	More complex transform.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.TextureFiltering">
            <summary>
            Modes for improving the visual quality of rendered textures.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureFiltering.None">
            <summary>
            	No filtering.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureFiltering.Bilinear">
            <summary>
            	Good lookin, slower than none.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureFiltering.Trilinear">
            <summary>
            	Even better looking, but even slower than bilinear.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.TextureTransform">
            <summary>
            Useful enumeration when dealing with procedural transforms.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.TextureUsage">
            <summary>
            	Specifies how a texture is to be used in the engine.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureUsage.Default">
            <summary>
            	Standard usage.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.TextureUsage.RenderTarget">
            <summary>
            	Target of rendering.  Example would be a billboard in a wrestling or sports game, or rendering a 
            	movie to a texture.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.VertexFlags">
            <summary>
            	Types for definings what information a vertex will hold.
            </summary>
            <remarks>
            	Implemented with the Flags attribute to treat this enum with bitwise addition
            	and comparisons.
            </remarks>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.VertexFlags.Position">
            <summary>
            	Specifies the 3D coordinates of the vertex.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.VertexFlags.BlendWeights">
            <summary>
            	When applying 1 or more world matrices to a vertex, the weight values of a vertex dictate how much
            	of an effect each matrix has in determining its final position.  
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.VertexFlags.Normals">
            <summary>
            	Normal vector, determines the logical direction the vertex is facing for use in
            	lighting calculations.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.VertexFlags.TextureCoords">
            <summary>
            	Texture coordinate for the vertex.
             </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.VertexFlags.Diffuse">
            <summary>
            	The primary color of the vertex.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.VertexFlags.Specular">
            <summary>
            	Specular color for this vertex.
             </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.VertexElementSemantic">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.VertexElementType">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.HardwareBuffer">
            <summary>
            Summary description for HardwareBuffer.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.Lock(System.Int32,System.Int32,Axiom.SubSystems.Rendering.BufferLocking)">
            <summary>
            	Used to lock a vertex buffer in hardware memory in order to make modifications.
            </summary>
            <param name="offset">Starting index in the buffer to lock.</param>
            <param name="length">Nunber of bytes to lock after the offset.</param>
            <param name="locking">Specifies how to lock the buffer.</param>
            <returns>An array of the <code>System.Type</code> associated with this VertexBuffer.</returns>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.LockImpl(System.Int32,System.Int32,Axiom.SubSystems.Rendering.BufferLocking)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="locking"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.Unlock">
            <summary>
            	Must be called after a call to <code>Lock</code>.  Unlocks the vertex buffer in the hardware
            	memory.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.UnlockImpl">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.UpdateFromShadow">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.ReadData(System.Int32,System.Int32,System.Array)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="dest"></param>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.WriteData(System.Int32,System.Int32,System.Array)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="src"></param>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.WriteData(System.Int32,System.Int32,System.Array,System.Boolean)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="src"></param>
            <param name="discardWholeBuffer"></param>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.CopyData(Axiom.SubSystems.Rendering.HardwareBuffer,System.Int32,System.Int32,System.Int32)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="srcBuffer"></param>
            <param name="srcOffset"></param>
            <param name="destOffset"></param>
            <param name="length"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBuffer.CopyData(Axiom.SubSystems.Rendering.HardwareBuffer,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="srcBuffer"></param>
            <param name="srcOffset"></param>
            <param name="destOffset"></param>
            <param name="length"></param>
            <param name="discardWholeBuffer"></param>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareBuffer.IsLocked">
            <summary>
            	Gets whether or not this buffer is currently locked.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareBuffer.IsSystemMemory">
            <summary>
            	Gets whether this buffer is held in system memory.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareBuffer.Size">
            <summary>
            	Gets the size (in bytes) for this buffer.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareBuffer.Usage">
            <summary>
            	Gets the usage 
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.HardwareBufferManager">
            <summary>
            	Abstract singleton class for managing hardware buffers, a concrete instance
            	of this will be created by the RenderSystem.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.SubSystems.Rendering.BufferUsage)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="vertexSize"></param>
            <param name="numVerts"></param>
            <param name="usage"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.SubSystems.Rendering.BufferUsage,System.Boolean)">
            <summary>
            	Create a hardware vertex buffer.
            </summary>
            <remarks>
            	This method creates a new vertex buffer; this will act as a source of geometry
            	data for rendering objects. Note that because the meaning of the contents of
            	the vertex buffer depends on the usage, this method does not specify a
            	vertex format; the user of this buffer can actually insert whatever data 
            	they wish, in any format. However, in order to use this with a RenderOperation,
            	the data in this vertex buffer will have to be associated with a semantic element
            	of the rendering pipeline, e.g. a position, or texture coordinates. This is done 
            	using the VertexDeclaration class, which itself contains VertexElement structures
            	referring to the source data.
            	<p/>
            	Note that because vertex buffers can be shared, they are reference
            	counted so you do not need to worry about destroying themm this will be done
            	automatically.
            </remarks>
            <param name="vertexSize">The size in bytes of each vertex in this buffer; you must calculate
            	this based on the kind of data you expect to populate this buffer with.</param>
            <param name="numVerts">The number of vertices in this buffer.</param>
            <param name="usage">One or more members of the BufferUsage enumeration; you are
            	strongly advised to use StaticWriteOnly wherever possible, if you need to 
            	update regularly, consider WriteOnly and useShadowBuffer=true.</param>
            <param name="useShadowBuffer"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBufferManager.CreateIndexBuffer(Axiom.SubSystems.Rendering.IndexType,System.Int32,Axiom.SubSystems.Rendering.BufferUsage)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBufferManager.CreateIndexBuffer(Axiom.SubSystems.Rendering.IndexType,System.Int32,Axiom.SubSystems.Rendering.BufferUsage,System.Boolean)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBufferManager.CreateVertexDeclaration">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareBufferManager.CreateVertexBufferBinding">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareBufferManager.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.HardwareCaps">
            <summary>
            	This serves as a way to query information about the capabilies of a 3D API and the
            	users hardware configuration.  A RenderSystem should create and initialize an instance
            	of this class during startup so that it will be available for use ASAP for checking caps.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.HardwareCaps.SetCap(Axiom.SubSystems.Rendering.Capabilities)">
            <summary>
            
            </summary>
            <param name="cap"></param>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareCaps.NumTextureUnits">
            <summary>
            	Reports on the number of texture units the graphics hardware has available.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareCaps.Vendor">
            <summary>
            	Gets/Sets the vendor of the current video card.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.HardwareIndexBuffer">
            <summary>
            Summary description for IIndexBuffer.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.HardwareVertexBuffer">
            <summary>
            	Describes the graphics API independent functionality required by a hardware
            	vertex buffer.  
            </summary>
            <remarks>
            	
            </remarks>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.HardwareVertexBuffer.VertexSize">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.IRenderSystem">
            <summary>
            	Defnines the methods and properties that should be implemented by any
            	particular graphics API.  
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.IRenderSystem.BeginFrame">
            <summary>
            	Defines what should be done at the beginning of any render loop.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.IRenderSystem.EndFrame">
            <summary>
            	Defines what needs to be done at the end of the render loop.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.IRenderSystem.Render(Axiom.SubSystems.Rendering.RenderOperation)">
            <summary>
            	Called to execute a rendering operation using the current API.
            </summary>
            <param name="renderOp">
            	An instance of a <see cref="T:Axiom.SubSystems.Rendering.RenderOperation"/> that
            	contains all information necesary for rendering a set of vertices.
            </param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.IRenderSystem.Shutdown">
            <summary>
            	Will be called during engine shutdown.  Any resource that need to be disposed of
            	should be done in this method.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.SubSystems.Rendering.IRenderSystem.AmbientLight" -->
        <member name="P:Axiom.SubSystems.Rendering.IRenderSystem.LightingEnabled">
            <summary>
            	Gets/Sets whether or not dynamic lighting is enabled.
            	<p/>
            	If true, dynamic lighting is performed on geometry with normals supplied, geometry without
            	normals will not be displayed. If false, no lighting is applied and all geometry will be full brightness.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderSystem.ShadingType">
            <summary>
            	Gets/Sets the type of light shading required.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderSystem.TextureFiltering">
            <summary>
            	Gets/Sets the type of texture filtering used when rendering
            </summary>
            <remarks>
            	This method sets the kind of texture filtering applied when rendering textures onto
            	primitives. Filtering covers how the effects of minification and magnification are
            	disguised by resampling.
            </remarks>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.IRenderWindow">
            <summary>
            	Represents an API independent interface for a rendering target, whether this be
            	a form, picturebox, or anything else that has an underlying HWND.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.IRenderWindow.SwapBuffers(System.Boolean)">
            <summary>
            	Updates the rendering target with all the rendering operations performed in
            	the render system during this frame.
            </summary>
            <param name="vsync"></param>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderWindow.IsActive">
            <summary>
            	Gets a boolean that specifies whether the current window is active or not.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.IRenderWindow.IsFullscreen">
            <summary>
            	Gets a boolean that specifies whether or not rendering target is taking up the entire
            	screen.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderOperation">
            <summary>
            	Contains all the information required to render a set of vertices.  This includes
            	a list of VertexBuffers. 
            </summary>
            <remarks>
            	This class contains
            </remarks>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderOperation.operationType">
            <summary>
            	Type of operation to perform.
            </summary>
            TODO: Rename the enum to OperationType
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderOperation.vertexData">
            <summary>
            	Contains a list of hardware vertex buffers for this complete render operation.
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderOperation.indexData">
            <summary>
            	When <code>useIndices</code> is set to true, this must hold a reference to an index
            	buffer containing indices into the vertices stored here. 
            </summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderOperation.useIndices">
            <summary>
            	Specifies whether or not a list of indices should be used when rendering the vertices in
            	the buffers.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderOperation.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderQueue">
            <summary>
            	Class to manage the scene object rendering queue.
            </summary>
            <remarks>
            	Objects are grouped by material to minimize rendering state changes. The map from
            	material to renderable object is wrapped in a class for ease of use.
            	<p/>
            	This class includes the concept of 'queue groups' which allows the application
            	adding the renderable to specifically schedule it so that it is included in 
            	a discrete group. Good for separating renderables into the main scene,
            	backgrounds and overlays, and also could be used in the future for more
            	complex multipass routines like stenciling.
            </remarks>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderQueue.DEFAULT_PRIORITY">
            <summary>Default priority of items added to the render queue.</summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderQueue.renderGroups">
            <summary>Cached list of render groups, indexed by RenderQueueGroupID</summary>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderQueue.defaultGroup">
            <summary>Default render group for this queue.</summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueue.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueue.AddRenderable(Axiom.SubSystems.Rendering.IRenderable,System.UInt16,Axiom.Enumerations.RenderQueueGroupID)">
            <summary>
            	Adds a renderable item to the queue.
            </summary>
            <param name="item">IRenderable object to add to the queue.</param>
            <param name="groupID">Group to add the item to.</param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueue.AddRenderable(Axiom.SubSystems.Rendering.IRenderable,System.UInt16)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="item"></param>
            <param name="groupID"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueue.AddRenderable(Axiom.SubSystems.Rendering.IRenderable)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueue.Clear">
            <summary>
            	Clears all 
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderQueue.DefaultRenderGroup">
            <summary>
            	Gets/Sets the default priority for rendering objects in the queue.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderQueue.QueueGroups">
            <summary>
            	
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderQueueGroup">
            <summary>
            	A grouping level underneath RenderQueue which groups renderables
            	to be issued at coarsely the same time to the renderer.	
            </summary>
            <remarks>
            	Each instance of this class itself hold RenderPriorityGroup instances, 
            	which are the groupings of renderables by priority for fine control
            	of ordering (not required for most instances).
            </remarks>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueueGroup.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueueGroup.AddRenderable(Axiom.SubSystems.Rendering.IRenderable,System.UInt16)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderQueueGroup.Clear">
            <summary>
            	Clears all the priority groups within this group.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderQueueGroup.PriorityGroups">
            <summary>
            	Gets an Enumerator that can be used to iterate through the priority groups.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderPriorityGroup">
            <summary>
            	IRenderables in the queue grouped by priority.
            </summary>
            <remarks>
            	This class simply groups renderables for rendering. All the 
            	renderables contained in this class are destined for the same
            	RenderQueueGroup (coarse groupings like those between the main
            	scene and overlays) and have the same priority (fine groupings
            	for detailed overlap control).
            </remarks>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderPriorityGroup.shaderGroups">
            <summary>List of renderable lists, indexed by shader.</summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderPriorityGroup.AddRenderable(Axiom.SubSystems.Rendering.IRenderable)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderPriorityGroup.Clear">
            <summary>
            	Clears all the internal lists.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderPriorityGroup.ShaderGroups">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderPriorityGroup.TransparentObjects">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderPriorityGroup.TransparencySort">
            <summary>
            	Nested class that implements IComparer for transparency sorting.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderSystem">
            <summary>
            Defines the functionality of a 3D API
            </summary>
            <remarks>
            	The RenderSystem class provides a base class
            	which abstracts the general functionality of the 3D API
            	e.g. Direct3D or OpenGL. Whilst a few of the general
            	methods have implementations, most of this class is
            	abstract, requiring a subclass based on a specific API
            	to be constructed to provide the full functionality.
            	<p/>
            	Note there are 2 levels to the interface - one which
            	will be used often by the caller of the engine library,
            	and one which is at a lower level and will be used by the
            	other classes provided by the engine. These lower level
            	methods are marked as internal, and are not accessible outside
            	of the Core library.
            </remarks>
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderSystem.worldMatrices">
            Saved set of world matrices
        </member>
        <member name="F:Axiom.SubSystems.Rendering.RenderSystem.tempVertexBlendBuffer">
            Temporary buffer for vertex blending in software
            TODO: Revisit this when software vertex blending gets implemented
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.Initialize(System.Boolean)">
            <summary>
            
            </summary>
            <param name="autoCreateWindow"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.Shutdown">
            <summary>
            	Shuts down the RenderSystem.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.CheckCaps">
            <summary>
            	Should be implemented by each subclass to interogate the caps of the hardware using
            	the specific API.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.CreateRenderWindow(System.String,System.Windows.Forms.Control,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.Boolean,Axiom.SubSystems.Rendering.RenderWindow)">
            <summary>
            Creates a new rendering window.
            </summary>
            <remarks>
            This method creates a new rendering window as specified
            by the paramteters. The rendering system could be
            responible for only a single window (e.g. in the case
            of a game), or could be in charge of multiple ones (in the
            case of a level editor). The option to create the window
            as a child of another is therefore given.
            This method will create an appropriate subclass of
            RenderWindow depending on the API and platform implementation.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.MakeProjectionMatrix(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Builds a perspective projection matrix suitable for this render system.
            </summary>
            <remarks>
            	Because different APIs have different requirements (some incompatible) for the
            	projection matrix, this method allows each to implement their own correctly and pass
            	back a generic Matrix3 for storage in the engine.
             </remarks>
            <param name="fov"></param>
            <param name="aspectRatio"></param>
            <param name="near"></param>
            <param name="far"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.AddLight(Axiom.Core.Light)">
            <summary>
            
            </summary>
            <param name="light"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.UpdateLight(Axiom.Core.Light)">
            <summary>
            
            </summary>
            <param name="light"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetFog(Axiom.SubSystems.Rendering.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the fog with the given params.
            </summary>
            <param name="mode"></param>
            <param name="color"></param>
            <param name="density"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.ConvertColor(Axiom.Core.ColorEx)">
            <summary>
            	Converts the System.Drawing.Color value to a uint.  Each API may need the 
            	bytes of the packed color data in different orders. i.e. OpenGL - ABGR, D3D - ARGB
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.SubSystems.Rendering.RenderSystem.SetSceneBlending(Axiom.SubSystems.Rendering.SceneBlendFactor,Axiom.SubSystems.Rendering.SceneBlendFactor)" -->
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetSurfaceParams(Axiom.Core.ColorEx,Axiom.Core.ColorEx,Axiom.Core.ColorEx,Axiom.Core.ColorEx,System.Single)">
            <summary>
            	Sets the surface parameters to be used during rendering an object.
            </summary>
            <param name="ambient"></param>
            <param name="diffuse"></param>
            <param name="specular"></param>
            <param name="emissive"></param>
            <param name="shininess"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetTextureAddressingMode(System.Int32,Axiom.SubSystems.Rendering.TextureAddressing)">
            <summary>
            	Tells the hardware how to treat texture coordinates.
            </summary>
            <param name="unit"></param>
            <param name="texAddressingMode"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SoftwareVertexBlend(Axiom.Core.VertexBuffer,Axiom.MathLib.Matrix4[])">
            <summary>
            	Performs a software vertex blend on the passed in operation. 
            </summary>
            <remarks>
            	This function is supplied to calculate a vertex blend when no hardware
            	support is available. The vertices contained in the passed in operation
            	will be modified by the matrices supplied according to the blending weights
            	also in the operation. To avoid accidentally modifying core vertex data, a
            	temporary vertex buffer is used for the result, which is then used in the
            	VertexBuffer instead of the original passed in vertex data.
            </remarks>
            TODO: Remove after VBO implementation
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SoftwareVertexBlend(Axiom.SubSystems.Rendering.RenderOperation,Axiom.MathLib.Matrix4[])">
            <summary>
            	Performs a software vertex blend on the passed in operation. 
            </summary>
            <remarks>
            	This function is supplied to calculate a vertex blend when no hardware
            	support is available. The vertices contained in the passed in operation
            	will be modified by the matrices supplied according to the blending weights
            	also in the operation. To avoid accidentally modifying core vertex data, a
            	temporary vertex buffer is used for the result, which is then used in the
            	VertexBuffer instead of the original passed in vertex data.
            </remarks>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.ToString">
            <summary>
            Returns the name of this RenderSystem.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.BeginFrame">
            <summary>
            	Signifies the beginning of a frame, ie the start of rendering on a single viewport. Will occur
            	several times per complete frame if multiple viewports exist.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.EndFrame">
            <summary>
            	Ends rendering of a frame to the current viewport.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetTexture(System.Int32,System.Boolean,System.String)">
            <param name="enabled">Boolean to turn the unit on/off</param>
            <param name="textureName">The name of the texture to use - this should have
            	already been loaded with TextureManager.Load.</param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetTextureCoordSet(System.Int32,System.Int32)">
            <summary>
            	Sets the index into the set of tex coords that will be currently used by the render system.
            </summary>
            <param name="unit"></param>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetTextureMatrix(System.Int32,Axiom.MathLib.Matrix4)">
            <summary>
            	Sets the texture matrix for the specified stage.  Used to apply rotations, translations,
            	and scaling to textures.
            </summary>
            <param name="stage"></param>
            <param name="xform"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetViewport(Axiom.Core.Viewport)">
            <summary>
            	Sets the current viewport that will be rendered to.
            </summary>
            <param name="viewport"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.Render(Axiom.SubSystems.Rendering.RenderOperation)">
            <summary>
            
            </summary>
            <param name="op"></param>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetTextureUnit(System.Int32,Axiom.Core.TextureLayer)">
            <summary>
            	Utility function for setting all the properties of a texture unit at once.
            	This method is also worth using over the individual texture unit settings because it
            	only sets those settings which are different from the current settings for this
            	unit, thus minimising render state changes.
            </summary>
            <param name="textureUnit">Index of the texture unit to configure</param>
            <param name="layer">Reference to a TextureLayer object which defines all the settings.</param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetTextureBlendMode(System.Int32,Axiom.Core.LayerBlendModeEx)">
            <summary>
            	Sets the texture blend modes from a TextureLayer record.
            	Meant for use internally only - apps should use the Material
            	and TextureLayer classes.
            </summary>
            <param name="unit">Texture unit.</param>
            <param name="blendMode">Details of the blending modes.</param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.DisableTextureUnit(System.Int32)">
            <summary>
            	Turns off a texture unit if not needed.
            </summary>
            <param name="textureUnit"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.SetWorldMatrices(Axiom.MathLib.Matrix4[],System.UInt16)">
            <summary>
            
            </summary>
            <param name="matrices"></param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderSystem.BeginGeometryCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.Name">
            <summary>
            Gets the name of this RenderSystem based on it's assembly attribute Title.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.IsVSync">
            <summary>
            Gets/Sets a value that determines whether or not to wait for the screen to finish refreshing
            before drawing the next frame.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.Caps">
            <summary>
            	Gets a set of hardware capabilities queryed by the current render system.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.ConfigOptions">
            <summary>
            Gets a dataset with the options set for the rendering system.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.RenderWindows">
            <summary>
            Gets a collection of the RenderSystems list of RenderWindows.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.FacesRendered">
            <summary>
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.SubSystems.Rendering.RenderSystem.AmbientLight" -->
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.ShadingType">
            <summary>
            	Sets the type of light shading required (default = Gouraud).
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.TextureFiltering">
            <summary>
            	Sets the type of texture filtering used when rendering
            </summary>
            <remarks>
            	This method sets the kind of texture filtering applied when rendering textures onto
            	primitives. Filtering covers how the effects of minification and magnification are
            	disguised by resampling.
            </remarks>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.LightingEnabled">
            <summary>
            	Sets whether or not dynamic lighting is enabled.
            	<p/>
            	If true, dynamic lighting is performed on geometry with normals supplied, geometry without
            	normals will not be displayed. If false, no lighting is applied and all geometry will be full brightness.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.StencilCheckEnabled">
            <summary>
            	Turns stencil buffer checking on or off. 
            </summary>
            <remarks>
            	Stencilling (masking off areas of the rendering target based on the stencil 
            	buffer) can be turned on or off using this method. By default, stencilling is
            	disabled.
            </remarks>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.StencilBufferBitDepth">
            <summary>
            	Determines the bit depth of the hardware accelerated stencil buffer, if supported.
            </summary>
            <remarks>
            	If hardware stencilling is not supported, the software will provide an 8-bit 
            	software stencil.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.SubSystems.Rendering.RenderSystem.StencilBufferFunction" -->
        <!-- Badly formed XML comment ignored for member "P:Axiom.SubSystems.Rendering.RenderSystem.StencilBufferReferenceValue" -->
        <!-- Badly formed XML comment ignored for member "P:Axiom.SubSystems.Rendering.RenderSystem.StencilBufferMask" -->
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.StencilBufferFailOperation">
            <summary>
            	Sets the action to perform if the stencil test fails.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.StencilBufferDepthFailOperation">
            <summary>
            	Sets the action to perform if the stencil test passes, but the depth
            	buffer test fails.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.StencilBufferPassOperation">
            <summary>
            	Sets the action to perform if both the stencil test and the depth buffer 
            	test passes.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.DepthWrite">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.DepthCheck">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.DepthFunction">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.DepthBias">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.ViewMatrix">
            <summary>Sets the current view matrix.</summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.WorldMatrix">
            <summary>Sets the current world matrix.</summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.ProjectionMatrix">
            <summary>Sets the current projection matrix.</summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderSystem.RasterizationMode">
            <summary>
            	Sets how to rasterise triangles, as points, wireframe or solid polys.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderTarget">
            <summary>
            	A 'canvas' which can receive the results of a rendering operation.
            </summary>
            <remarks>
            	This abstract class defines a common root to all targets of rendering operations. A
            	render target could be a window on a screen, or another
            	offscreen surface like a texture or bump map etc.
            </remarks>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderTarget.Update">
            <summary>
            	Tells the target to update it's contents.
            </summary>
            <remarks>
            	If the engine is not running in an automatic rendering loop
            	(started using RenderSystem.StartRendering()),
            	the user of the library is responsible for asking each render
            	target to refresh. This is the method used to do this. It automatically
            	re-renders the contents of the target using whatever cameras have been
            	pointed at it (using Camera.RenderTarget).
            
            	This allows the engine to be used in multi-windowed utilities
            	and for contents to be refreshed only when required, rather than
            	constantly as with the automatic rendering loop.
            </remarks>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderTarget.CreateViewport(Axiom.Core.Camera,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            	Used to create a viewport for this RenderTarget.
            </summary>
            <param name="camera"></param>
            <param name="top"></param>
            <param name="left"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="zOrder"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderTarget.OnPreUpdate">
            <summary>
            Called to fire the PreUpdate event.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderTarget.OnPostUpdate">
            <summary>
            Called to fire the PostUpdate event.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderTarget.Name">
            <summary>
            Gets/Sets the name of this render target.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderTarget.Width">
            <summary>
            Gets/Sets the width of this render target.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderTarget.Height">
            <summary>
            Gets/Sets the height of this render target.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderTarget.ColorDepth">
            <summary>
            Gets/Sets the color depth of this render target.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderTarget.Viewports">
            <summary>
            Allows access to the viewportList of this RenderTarget.
            </summary>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.RenderTarget.CustomAttributes">
            <summary>
            	Allows for stroring and retrieving custom attributes that can be leveraged by
            	any subclass.  For example, OpenGL and Direct3D windows may want to 
            	store certain objects that are only relevant to that particlular window.  This keeps
            	things generic.
            </summary>
        </member>
        <member name="E:Axiom.SubSystems.Rendering.RenderTarget.PreUpdate">
            <summary>
            
            </summary>
        </member>
        <member name="E:Axiom.SubSystems.Rendering.RenderTarget.PostUpdate">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.RenderWindow">
            <summary>
            	Manages the target rendering window.
            </summary>
            <remarks>
            	This class handles a window into which the contents
            	of a scene are rendered. There is a many-to-1 relationship
            	between instances of this class an instance of RenderSystem
            	which controls the rendering of the scene. There may be
            	more than one window in the case of level editor tools etc.
            	This class is abstract since there may be
            	different implementations for different windowing systems.
            
            	Instances are created and communicated with by the render system
            	although client programs can get a reference to it from
            	the render system if required for resizing or moving.
            	Note that you can have multiple viewpoints
            	in the window for effects like rear-view mirrors and
            	picture-in-picture views (see Viewport and Camera).
            </remarks>
            	
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.SubSystems.Rendering.RenderWindow.Create(System.String,System.Windows.Forms.Control,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.Boolean,System.Object[])" -->
        <member name="M:Axiom.SubSystems.Rendering.RenderWindow.Destroy">
            <summary>
            	Destroys the window.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderWindow.Resize(System.Int32,System.Int32)">
            <summary>
            	Alter the size of the window.
            </summary>
            <param name="pWidth"></param>
            <param name="pHeight"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderWindow.Reposition(System.Int32,System.Int32)">
            <summary>
            	Reposition the window.
            </summary>
            <param name="pLeft"></param>
            <param name="pRight"></param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderWindow.SwapBuffers(System.Boolean)">
             <summary>
            		Swaps the frame buffers to display the next frame.
             </summary>
             <remarks>
            		All render windows are float-buffered so that no
                 'in-progress' versions of the scene are displayed
                  during rendering. Once rendering has completed (to
            		an off-screen version of the window) the buffers
            		are swapped to display the new frame.
            	</remarks>
             <param name="pWaitForVSync">
            		If true, the system waits for the
            		next vertical blank period (when the CRT beam turns off
            		as it travels from bottom-right to top-left at the
            		end of the pass) before flipping. If false, flipping
            		occurs no matter what the beam position. Waiting for
            		a vertical blank can be slower (and limits the
            		framerate to the monitor refresh rate) but results
            		in a steadier image with no 'tearing' (a flicker
            		resulting from flipping buffers when the beam is
            		in the progress of drawing the last frame). 
            </param>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderWindow.SaveToFile(System.String)">
            <summary>
            	Saves window contents to file (i.e. screenshot);
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderWindow.Update">
            <summary>
            	Updates the window contents.
            </summary>
            <remarks>
            	The window is updated by telling each camera which is supposed
            	to render into this window to render it's view, and then
            	the window buffers are swapped via SwapBuffers()
            </remarks>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.RenderWindow.CreateDefaultForm(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a default window to use for a RenderWindow if none are provided.
            </summary>
            <param name="top"></param>
            <param name="left"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="fullScreen"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.SubSystems.Rendering.RenderWindow.IsActive" -->
        <member name="P:Axiom.SubSystems.Rendering.RenderWindow.IsFullScreen">
            <summary>
            Returns true if window is running in fullscreen mode.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.SoftwareBufferManager">
            <summary>
            	Summary description for SoftwareBufferManager.
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.SoftwareBufferManager.CreateIndexBuffer(Axiom.SubSystems.Rendering.IndexType,System.Int32,Axiom.SubSystems.Rendering.BufferUsage)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.SoftwareBufferManager.CreateIndexBuffer(Axiom.SubSystems.Rendering.IndexType,System.Int32,Axiom.SubSystems.Rendering.BufferUsage,System.Boolean)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.SoftwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.SubSystems.Rendering.BufferUsage)">
            <summary>
            
            </summary>
            <param name="vertexSize"></param>
            <param name="numVerts"></param>
            <param name="usage"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.SoftwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.SubSystems.Rendering.BufferUsage,System.Boolean)">
            <summary>
            
            </summary>
            <param name="vertexSize"></param>
            <param name="numVerts"></param>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            <returns></returns>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.SoftwareVertexBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.SoftwareVertexBuffer.#ctor(System.Int32,System.Int32,Axiom.SubSystems.Rendering.BufferUsage)">
            <summary>
            	
            </summary>
            <remarks>
            	This is already in system memory, so no need to use a shadow buffer.
            </remarks>
            <param name="vertexSize"></param>
            <param name="numVertices"></param>
            <param name="usage"></param>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.SoftwareIndexBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.SoftwareIndexBuffer.#ctor(Axiom.SubSystems.Rendering.IndexType,System.Int32,Axiom.SubSystems.Rendering.BufferUsage)">
            <summary>
            	
            </summary>
            <remarks>
            	This is already in system memory, so no need to use a shadow buffer.
            </remarks>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.VertexBufferBinding">
            <summary>
            	Records the state of all the vertex buffer bindings required to provide a vertex declaration
            	with the input data it needs for the vertex elements.
             </summary>
             <remarks>
            	Why do we have this binding list rather than just have VertexElement referring to the
            	vertex buffers direct? Well, in the underlying APIs, binding the vertex buffers to an
            	index (or 'stream') is the way that vertex data is linked, so this structure better
            	reflects the realities of that. In addition, by separating the vertex declaration from
            	the list of vertex buffer bindings, it becomes possible to reuse bindings between declarations
            	and vice versa, giving opportunities to reduce the state changes required to perform rendering.
            </remarks>
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexBufferBinding.SetBinding(System.UInt16,Axiom.SubSystems.Rendering.HardwareVertexBuffer)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="buffer"></param>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexBufferBinding.UnsetBinding(System.UInt16)">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexBufferBinding.UnsetAllBindings">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexBufferBinding.Bindings">
            <summary>
            
            </summary>
            DOC
            TODO: Change this to strongly typed later on
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexBufferBinding.NextIndex">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.VertexDeclaration">
            <summary>
            	Summary description for VertexDeclaration.
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexDeclaration.AddElement(Axiom.SubSystems.Rendering.VertexElement)">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexDeclaration.FindElementBySemantic(Axiom.SubSystems.Rendering.VertexElementSemantic,System.UInt16)">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexDeclaration.FindElementBySource(System.UInt16)">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexDeclaration.GetVertexSize(System.UInt16)">
            <summary>
            
            </summary>
            <param name="source"></param>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexDeclaration.Elements">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.VertexElement">
            <summary>
            	Summary description for VertexElement.
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexElement.GetTypeSize(Axiom.SubSystems.Rendering.VertexElementType)">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexElement.GetTypeCount(Axiom.SubSystems.Rendering.VertexElementType)">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="M:Axiom.SubSystems.Rendering.VertexElement.MultiplyTypeCount(Axiom.SubSystems.Rendering.VertexElementType,System.Int32)">
            <summary>
            	Returns proper enum for a base type multiplied by a value.  This is helpful
            	when working with tex coords especially since you might not know the number
            	of texture dimensions at runtime, and when creating the VertexBuffer you will
            	have to get a VertexElementType based on that amount to creating the VertexElement.
            </summary>
            <param name="type"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexElement.Source">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexElement.Offset">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexElement.Type">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexElement.Semantic">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexElement.Index">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.SubSystems.Rendering.VertexElement.Size">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="T:Axiom.SubSystems.Rendering.VertexData">
            <summary>
            	Summary description for VertexIndexData.
            </summary>
        </member>
        <member name="T:Axiom.SubSystems.Rendering.IndexData">
            <summary>
            	Summary description for VertexIndexData.
            </summary>
        </member>
        <member name="T:Axiom.Text.TextManager">
            <summary>
            Summary description for TextManager.
            </summary>
        </member>
        <member name="M:Axiom.Text.TextManager.GetString(System.String)">
            <summary>
            Used to retreive a text resource by passing a key.  
            </summary>
            <param name="keyName"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Utility.ConfigDialog">
            <summary>
            Summary description for ConfigDialog.
            </summary>
        </member>
        <member name="F:Axiom.Utility.ConfigDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Axiom.Utility.ConfigDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:Axiom.Utility.ConfigDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Axiom.Utility.DefaultForm">
            <summary>
            Summary description for DefaultForm.
            </summary>
        </member>
        <member name="M:Axiom.Utility.DefaultForm.DefaultForm_Deactivate(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="e"></param>
        </member>
        <member name="M:Axiom.Utility.DefaultForm.DefaultForm_Activated(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="e"></param>
        </member>
        <member name="M:Axiom.Utility.DefaultForm.DefaultForm_Close(System.Object,System.ComponentModel.CancelEventArgs)">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="e"></param>
        </member>
        <member name="P:Axiom.Utility.DefaultForm.RenderWindow">
            <summary>
            	Get/Set the Axiom RenderWindow associated with this form.
            </summary>
        </member>
        <member name="P:Axiom.Utility.DefaultForm.Target">
            <summary>
            	
            </summary>
        </member>
        <member name="T:Axiom.Utility.HighResolutionTimer">
            <summary>
            Encapsulates the functionality of the platform's highest resolution timer available.
            </summary>
            <remarks>
            On Windows this will be a QueryPerformanceCounter (if available), otherwise tt will be TimeGetTime().  
            On Linux this will be GetTimeOfDay (not currently implemented).
            </remarks>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.#cctor">
            <summary>
            This static constructor determines which platform timer to use
            and populates the timer's <see cref="P:Axiom.Utility.HighResolutionTimer.Frequency"/>
            and <see cref="T:Axiom.Utility.HighResolutionTimer.TimerType"/>.
            </summary>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.Dispose">
            <summary>
            Disposes of this class.  Implements IDisposable.
            </summary>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.Dispose(System.Boolean)">
            <summary>
            Cleans up either unmanaged resources or managed and unmanaged resources.
            </summary>
            <remarks>
            <para>
            If disposing equals true, the method has been called directly or indirectly by a user's 
            code.  Managed and unmanaged resources can be disposed.
            </para>
            <para>
            If disposing equals false, the method has been called by the runtime from inside the 
            finalizer and you should not reference other objects.  Only unmanaged resources can 
            be disposed.
            </para>
            </remarks>
            <param name="disposing">Was Dispose called manually?</param>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.Finalize">
            <summary>
            This destructor will run only if the Dispose method does not get called.  It gives 
            the class the opportunity to finalize.  Simply calls Dispose(false).
            </summary>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.GetCurrentCount">
            <summary>
            Gets the current tick count.
            </summary>
            <returns>
            Number Of Ticks (ulong).
            </returns>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.Start">
            <summary>
            Start this instance's timer.
            </summary>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.Stop">
            <summary>
            Stop this instance's timer.
            </summary>
        </member>
        <member name="M:Axiom.Utility.HighResolutionTimer.Reset">
            <summary>
            Reset this instance's timer.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.Count">
            <summary>
            Gets a <see cref="T:System.UInt64"/> representing the 
            current tick count of the timer.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.Difference">
            <summary>
            Gets a <see cref="T:System.UInt64"/> representing the 
            difference, in ticks, between the <see cref="P:Axiom.Utility.HighResolutionTimer.StartCount"/> 
            and <see cref="P:Axiom.Utility.HighResolutionTimer.EndCount"/>.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.Elapsed">
            <summary>
            Gets a <see cref="T:System.Double"/> representing the 
            elapsed time, in seconds, between the <see cref="P:Axiom.Utility.HighResolutionTimer.StartCount"/> 
            and <see cref="P:Axiom.Utility.HighResolutionTimer.EndCount"/>.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.EndCount">
            <summary>
            Gets a <see cref="T:System.UInt64"/> representing the 
            tick count at the end of the timer's run.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.Frequency">
            <summary>
            Gets a <see cref="T:System.UInt64"/> representing the 
            frequency of the counter in ticks-per-second.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.IsRunning">
            <summary>
            Gets a <see cref="T:System.Boolean"/> representing whether the 
            timer has been started and is currently running.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.Resolution">
            <summary>
            Gets a <see cref="T:System.Double"/> representing the 
            resolution of the timer in seconds.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.StartCount">
            <summary>
            Gets a <see cref="T:System.UInt64"/> representing the 
            tick count at the start of the timer's run.
            </summary>
        </member>
        <member name="P:Axiom.Utility.HighResolutionTimer.Type">
            <summary>
            Gets the <see cref="T:Axiom.Utility.HighResolutionTimer.TimerType"/> for this
            timer, which is based on what is supported by the underlying platform.
            </summary>
        </member>
        <member name="T:Axiom.Utility.HighResolutionTimer.TimerType">
            <summary>
            The type of timer supported by this platform.
            </summary>
        </member>
        <member name="F:Axiom.Utility.HighResolutionTimer.TimerType.None">
            <summary>
            No timer available.
            </summary>
        </member>
        <member name="F:Axiom.Utility.HighResolutionTimer.TimerType.QueryPerformanceCounter">
            <summary>
            The timer is a Query Performance Counter.
            </summary>
        </member>
        <member name="F:Axiom.Utility.HighResolutionTimer.TimerType.TimeGetTime">
            <summary>
            The timer will use TimeGetTime.
            </summary>
        </member>
        <member name="F:Axiom.Utility.HighResolutionTimer.TimerType.GetTimeOfDay">
            <summary>
            The timer will use GetTimeOfDay.
            </summary>
        </member>
        <member name="T:Axiom.Utility.TechDemo">
            <summary>
            A base class that can be used to get a head start on writing a game or technical demo using the engine.
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.Setup">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Utility.TechDemo.SetupResources">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.Configure">
            <summary>
            Configures the application 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Utility.TechDemo.ChooseSceneManager">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.CreateCamera">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.CreateViewports">
            <summary>
            	Called to create the default viewports.
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.CreateScene">
            <summary>
            Called to create the scene to be rendered each frame by the renderer.
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.OnFrameStarted(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	Used to set up the events for the RenderSystem.  Provides default camera movement behavior
            	and a few other basic functions, but can be overridden by base classes.  If overridden, the base class
            	method should be called first. 
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.OnFrameEnded(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            Used to set up the events for the RenderSystem.  Should be overridden by base classes.
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.TakeScreenshot">
            <summary>
            	Used to take a screenshot of the current camera view.
            </summary>
        </member>
        <member name="M:Axiom.Utility.TechDemo.GlobalErrorHandler(System.Object,System.Threading.ThreadExceptionEventArgs)">
            <summary>
            	Global error handler to trap any unhandled exceptions.  Exception will be displayed and logged.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
        </member>
        <member name="M:Axiom.Utility.TechDemo.Dispose">
            <summary>
            	Called to shutdown the engine and all of it's resources.
            </summary>
        </member>
        <member name="T:Axiom.Xml.AxiomValidatingReader">
            <summary>
            Summary description for AxiomXmlReader.
            </summary>
        </member>
        <member name="M:Axiom.Xml.AxiomValidatingReader.ReadColor4">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Xml.XmlParticleReader">
            <summary>
            Summary description for XmlParticleReader.
            </summary>
        </member>
        <member name="T:Axiom.Xml.XmlShaderReader">
            <summary>
            Summary description for XmlShaderReader.
            </summary>
        </member>
        <member name="M:Axiom.Xml.XmlShaderReader.ReadTextureLayer(Axiom.Core.TextureLayer)">
            <summary>
            
            </summary>
            <param name="layer"></param>
        </member>
    </members>
</doc>
