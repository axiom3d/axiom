<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Axiom</name>
    </assembly>
    <members>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRendererFactory.CreateInstance(System.String)">
            <summary>
            Creates a new object.
            </summary>
            <param name="name">Name of the object to create</param>
            <returns>
            An object created by the factory. The type of the object depends on the factory.
            </returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRendererFactory.DestroyInstance(Axiom.ParticleSystems.ParticleSystemRenderer)">
            <summary>
            Destroys an object which was created by this factory.
            </summary>
            <param name="instance">Pointer to the object to destroy</param>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanelFactory">
            <summary>
            	Summary description for BorderPanelFactory.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Overlays.IOverlayElementFactory" -->
        <member name="M:Axiom.Overlays.IOverlayElementFactory.Create(System.String)">
            <summary>
               Classes that implement this interface will return an instance of a OverlayElement of their designated
               type.
            </summary>
            <param name="name">Name of the element to create.</param>
            <returns>A new instance of a OverlayElement with the specified name.</returns>
        </member>
        <member name="P:Axiom.Overlays.IOverlayElementFactory.Type">
            <summary>
               Classes that implement this interface should return the name of the OverlayElement that it will be
               responsible for creating.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.PanelFactory">
            <summary>
            	Summary description for PanelFactory.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.TextAreaFactory">
            <summary>
            	Summary description for TextAreaFactory.
            </summary>
        </member>
        <member name="T:Axiom.Math.AxisAlignedBox">
            <summary>
            	A 3D box aligned with the x/y/z axes.
            </summary>
            <remarks>
            	This class represents a simple box which is aligned with the
                axes. Internally it only stores 2 points as the extremeties of
                the box, one which is the minima of all 3 axes, and the other
                which is the maxima of all 3 axes. This class is typically used
                for an axis-aligned bounding box (AABB) for collision and
                visibility determination.
            </remarks>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Transform(Axiom.Math.Matrix4)">
            <summary>
            
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.UpdateCorners">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.SetExtents(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Sets both Minimum and Maximum at once, so that UpdateCorners only
            	needs to be called once as well.
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Scale(Axiom.Math.Vector3)">
            <summary>
               Scales the size of the box by the supplied factor.
            </summary>
            <param name="factor">Factor of scaling to apply to the box.</param>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Returns whether or not this box intersects another.
            </summary>
            <param name="box2"></param>
            <returns>True if the 2 boxes intersect, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Tests whether this box intersects a sphere.
            </summary>
            <param name="sphere"></param>
            <returns>True if the sphere intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.Plane)">
            <summary>
            
            </summary>
            <param name="plane"></param>
            <returns>True if the plane intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Intersects(Axiom.Math.Vector3)">
            <summary>
            	Tests whether the vector point is within this box.
            </summary>
            <param name="vector"></param>
            <returns>True if the vector is within this box, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.AxisAlignedBox.Merge(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Allows for merging two boxes together (combining).
            </summary>
            <param name="box">Source box.</param>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Center">
            <summary>
               Gets the center point of this bounding box.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Maximum">
            <summary>
            	Gets/Sets the maximum corner of the box.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Minimum">
            <summary>
            	Gets/Sets the minimum corner of the box.
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Corners">
            <summary>
            	Returns an array of 8 corner points, useful for
            	collision vs. non-aligned objects.
             </summary>
             <remarks>
            	If the order of these corners is important, they are as
            	follows: The 4 points of the minimum Z face (note that
            	because we use right-handed coordinates, the minimum Z is
            	at the 'back' of the box) starting with the minimum point of
            	all, then anticlockwise around this face (if you are looking
            	onto the face from outside the box). Then the 4 points of the
            	maximum Z face, starting with maximum point of all, then
            	anticlockwise around this face (looking onto the face from
            	outside the box). Like this:
            	<pre>
            		 1-----2
            	    /|     /|
            	  /  |   /  |
            	5-----4   |
            	|   0-|--3
            	|  /   |  /
            	|/     |/
            	6-----7
            	</pre>
            </remarks>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.IsNull">
            <summary>
            	Gets/Sets the value of whether this box is null (i.e. not dimensions, etc).
            </summary>
        </member>
        <member name="P:Axiom.Math.AxisAlignedBox.Null">
            <summary>
            	Returns a null box
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderOperation">
            <summary>
            	Contains all the information required to render a set of vertices.  This includes
            	a list of VertexBuffers. 
            </summary>
            <remarks>
            	This class contains
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.operationType">
            <summary>
            	Type of operation to perform.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.vertexData">
            <summary>
            	Contains a list of hardware vertex buffers for this complete render operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.indexData">
            <summary>
            	When <code>useIndices</code> is set to true, this must hold a reference to an index
            	buffer containing indices into the vertices stored here. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderOperation.useIndices">
            <summary>
            	Specifies whether or not a list of indices should be used when rendering the vertices in
            	the buffers.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderOperation.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Pass">
            <summary>
            	Class defining a single pass of a Technique (of a Material), ie
               a single rendering call. 
            </summary>
            <remarks>
               Rendering can be repeated with many passes for more complex effects.
               Each pass is either a fixed-function pass (meaning it does not use
               a vertex or fragment program) or a programmable pass (meaning it does
               use either a vertex or a fragment program, or both). 
               <p/>
               Programmable passes are complex to define, because they require custom
               programs and you have to set all constant inputs to the programs (like
               the position of lights, any base material colors you wish to use etc), but
               they do give you much total flexibility over the algorithms used to render your
               pass, and you can create some effects which are impossible with a fixed-function pass.
               On the other hand, you can define a fixed-function pass in very little time, and
               you can use a range of fixed-function effects like environment mapping very
               easily, plus your pass will be more likely to be compatible with older hardware.
               There are pros and cons to both, just remember that if you use a programmable
               pass to create some great effects, allow more time for definition and testing.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.Pass.parent">
            <summary>
               A reference to the technique that owns this Pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.index">
            <summary>
               Index of this rendering pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.hashCode">
            <summary>
               Pass hash, used for sorting passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.ambient">
            <summary>
               Ambient color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.diffuse">
            <summary>
               Diffuse color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.specular">
            <summary>
               Specular color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.emissive">
            <summary>
               Emissive color in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.shininess">
            <summary>
               Shininess of the object's surface in fixed function passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.sourceBlendFactor">
            <summary>
               Source blend factor.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.destBlendFactor">
            <summary>
               Destination blend factor.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.depthCheck">
            <summary>
               Depth buffer checking setting for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.depthWrite">
            <summary>
               Depth write setting for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.depthFunc">
            <summary>
               Depth comparison function for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.depthBias">
            <summary>
               Depth bias for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.colorWrite">
            <summary>
               Color write setting for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.cullMode">
            <summary>
               Hardware culling mode for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.manualCullMode">
            <summary>
               Software culling mode for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.lightingEnabled">
            <summary>
               Is lighting enabled for this pass?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.maxLights">
            <summary>
               Max number of simultaneous lights that can be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.runOncePerLight">
            <summary>
               Run this pass once per light? 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.runOnlyForOneLightType">
            <summary>
                Should it only be run for a certain light type? 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.onlyLightType">
            <summary>
               Type of light for a programmable pass that supports only one particular type of light.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.shadeOptions">
            <summary>
               Shading options for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.maxAniso">
            <summary>
               Texture anisotropy level.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.fogOverride">
            <summary>
               Does this pass override global fog settings?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.fogMode">
            <summary>
               Fog mode to use for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.fogColor">
            <summary>
               Color of the fog used for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.fogStart">
            <summary>
               Starting point of the fog for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.fogEnd">
            <summary>
               Ending point of the fog for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.fogDensity">
            <summary>
               Density of the fog for this pass (if overriding).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.textureUnitStates">
            <summary>
               List of fixed function texture unit states for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.vertexProgramUsage">
            <summary>
               Details on the vertex program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.fragmentProgramUsage">
            <summary>
               Details on the fragment program to be used for this pass.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.queuedForDeletion">
            <summary>
            	Is this pass queued for deletion?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.dirtyHashList">
            <summary>
            	List of passes with dirty hashes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Pass.graveyardList">
            <summary>
            	List of passes queued for deletion.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.#ctor(Axiom.Graphics.Technique,System.Int32)">
            <summary>
               Default constructor.
            </summary>
            <param name="parent">Technique that owns this Pass.</param>
            <param name="index">Index of this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.AddTextureUnitState(Axiom.Graphics.TextureUnitState)">
            <summary>
               Adds the passed in TextureUnitState, to the existing Pass.
            </summary>
            <param name="state">TextureUnitState to add to this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.Clone(Axiom.Graphics.Technique,System.Int32)">
            <summary>
               Method for cloning a Pass object.
            </summary>
            <param name="parent">Parent technique that will own this cloned Pass.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.CopyTo(Axiom.Graphics.Pass)">
            <summary>
            	Copy the details of this pass to the target pass.
            </summary>
            <param name="target">Destination pass to copy this pass's attributes to.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.CreateTextureUnitState">
            <summary>
               Overloaded method.
            </summary>
            <param name="textureName">The basic name of the texture (i.e. brickwall.jpg)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.CreateTextureUnitState(System.String)">
            <summary>
               Overloaded method.
            </summary>
            <param name="textureName">The basic name of the texture (i.e. brickwall.jpg)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.CreateTextureUnitState(System.String,System.Int32)">
            <summary>
               Inserts a new TextureUnitState object into the Pass.
            </summary>
            <remarks>
               This unit is is added on top of all previous texture units.
               <p/>
               Applies to both fixed-function and programmable passes.
            </remarks>
            <param name="textureName">The basic name of the texture (i.e. brickwall.jpg)</param>
            <param name="texCoordSet">The index of the texture coordinate set to use.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.GetTextureUnitState(System.Int32)">
            <summary>
               Gets a reference to the TextureUnitState for this pass at the specified indx.
            </summary>
            <param name="index">Index of the state to retreive.</param>
            <returns>TextureUnitState at the specified index.</returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.Load">
            <summary>
               Internal method for loading this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.NotifyNeedsRecompile">
            <summary>
               Tells the pass that it needs recompilation.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.RecalculateHash">
            <summary>
               Internal method for recalculating the hash code used for sorting passes.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.RemoveAllTextureUnitStates">
            <summary>
               Removes all texture unit settings from this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.RemoveTextureUnitState(Axiom.Graphics.TextureUnitState)">
            <summary>
               Removes the specified TextureUnitState from this pass.
            </summary>
            <param name="state">A reference to the TextureUnitState to remove from this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.RemoveTextureUnitState(System.Int32)">
            <summary>
               Removes the specified TextureUnitState from this pass.
            </summary>
            <param name="state">Index of the TextureUnitState to remove from this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
               Sets the fogging mode applied to this pass.
            </summary>
            <remarks>
               Fogging is an effect that is applied as polys are rendered. Sometimes, you want
               fog to be applied to an entire scene. Other times, you want it to be applied to a few
               polygons only. This pass-level specification of fog parameters lets you easily manage
               both.
               <p/>
               The SceneManager class also has a SetFog method which applies scene-level fog. This method
               lets you change the fog behavior for this pass compared to the standard scene-level fog.
            </remarks>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref cref="!:overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
            <param name="color">
               The color of the fog. Either set this to the same as your viewport background color,
               or to blend in with a skydome or skybox.
            </param>
            <param name="density">
               The density of the fog in FogMode.Exp or FogMode.Exp2 mode, as a value between 0 and 1. 
               The default is 0.001.
            </param>
            <param name="start">
               Distance in world units at which linear fog starts to encroach. 
               Only applicable if mode is FogMode.Linear.
            </param>
            <param name="end">
               Distance in world units at which linear fog becomes completely opaque.
               Only applicable if mode is FogMode.Linear.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref cref="!:overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref cref="!:overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
            <param name="color">
               The color of the fog. Either set this to the same as your viewport background color,
               or to blend in with a skydome or skybox.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFog(System.Boolean,Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single)">
            <summary>
               Overloaded method.
            </summary>
            <param name="overrideScene">
               If true, you authorise this pass to override the scene's fog params with it's own settings.
               If you specify false, so other parameters are necessary, and this is the default behaviour for passs.
            </param>
            <param name="mode">
               Only applicable if <paramref cref="!:overrideScene"/> is true. You can disable fog which is turned on for the
               rest of the scene by specifying FogMode.None. Otherwise, set a pass-specific fog mode as
               defined in the enum FogMode.
            </param>
            <param name="color">
               The color of the fog. Either set this to the same as your viewport background color,
               or to blend in with a skydome or skybox.
            </param>
            <param name="density">
               The density of the fog in FogMode.Exp or FogMode.Exp2 mode, as a value between 0 and 1. 
               The default is 0.001.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetRunOncePerLight(System.Boolean,System.Boolean,Axiom.Graphics.LightType)">
            <summary>
               Sets whether or not this pass should be run once per light which 
               can affect the object being rendered.
            </summary>
            <remarks>
               The default behavior for a pass (when this option is 'false'), is 
               for a pass to be rendered only once, with all the lights which could 
               affect this object set at the same time (up to the maximum lights 
               allowed in the render system, which is typically 8). 
               <p/>
               Setting this option to 'true' changes this behavior, such that 
               instead of trying to issue render this pass once per object, it 
               is run once <b>per light</b> which can affect this object. In 
               this case, only light index 0 is ever used, and is a different light 
               every time the pass is issued, up to the total number of lights 
               which is affecting this object. This has 2 advantages: 
               <ul><li>There is no limit on the number of lights which can be 
               supported</li> 
               <li>It's easier to write vertex / fragment programs for this because 
               a single program can be used for any number of lights</li> 
               </ul> 
               However, this technique is a lot more expensive, and typically you 
               will want an additional ambient pass, because if no lights are 
               affecting the object it will not be rendered at all, which will look 
               odd even if ambient light is zero (imagine if there are lit objects 
               behind it - the objects silhouette would not show up). Therefore, 
               use this option with care, and you would be well advised to provide 
               a less expensive fallback technique for use in the distance. 
               <p/>
               Note: The number of times this pass runs is still limited by the maximum 
               number of lights allowed as set in MaxLights, so 
               you will never get more passes than this. 
            </remarks>
            <param name="enabled">Whether this feature is enabled.</param>
            <param name="onlyForOneLightType">
               If true, the pass will only be run for a single type of light, other light types will be ignored. 
            </param>
            <param name="lightType">The single light type which will be considered for this pass.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetSceneBlending(Axiom.Graphics.SceneBlendType)">
            <summary>
               Sets the kind of blending this pass has with the existing contents of the scene.
            </summary>
            <remarks>
               Whereas the texture blending operations seen in the TextureUnitState class are concerned with
               blending between texture layers, this blending is about combining the output of the Pass
               as a whole with the existing contents of the rendering target. This blending therefore allows
               object transparency and other special effects. If all passes in a technique have a scene
               blend, then the whole technique is considered to be transparent.
               <p/>
               This method allows you to select one of a number of predefined blending types. If you require more
               control than this, use the alternative version of this method which allows you to specify source and
               destination blend factors.
               <p/>
               This method is applicable for both the fixed-function and programmable pipelines.
            </remarks>
            <param name="type">One of the predefined SceneBlendType blending types.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetSceneBlending(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)">
            <summary>
               Allows very fine control of blending this Pass with the existing contents of the scene.
            </summary>
            <remarks>
               Wheras the texture blending operations seen in the TextureUnitState class are concerned with
               blending between texture layers, this blending is about combining the output of the material
               as a whole with the existing contents of the rendering target. This blending therefore allows
               object transparency and other special effects.
               <p/>
               This version of the method allows complete control over the blending operation, by specifying the
               source and destination blending factors. The result of the blending operation is:
               <span align="center">
               final = (texture * sourceFactor) + (pixel * destFactor)
               </span>
               <p/>
               Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor
               enumerated type.
               <p/>
               This method is applicable for both the fixed-function and programmable pipelines.
            </remarks>
            <param name="src">The source factor in the above calculation, i.e. multiplied by the texture color components.</param>
            <param name="dest">The destination factor in the above calculation, i.e. multiplied by the pixel color components.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFragmentProgram(System.String)">
            <summary>
            	
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetFragmentProgram(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="resetParams"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetVertexProgram(System.String)">
            <summary>
            	
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.SetVertexProgram(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="resetParams"></param>
        </member>
        <member name="M:Axiom.Graphics.Pass.Split(System.Int32)">
            <summary>
               Splits this Pass to one which can be handled in the number of
               texture units specified.
            </summary>
            <param name="numUnits">
               The target number of texture units.
            </param>
            <returns>
               A new Pass which contains the remaining units, and a scene_blend
               setting appropriate to approximate the multitexture. This Pass will be 
               attached to the parent Technique of this Pass.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.Pass.Unload">
            <summary>
               Internal method for unloaded this pass.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.UpdateAutoParamsLightsOnly(Axiom.Graphics.AutoParamDataSource)">
            <summary>
               Update any automatic light parameters on this pass.
            </summary>
            <param name="renderable">Current object being rendered.</param>
            <param name="camera">Current being being used for rendering.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.UpdateAutoParamsNoLights(Axiom.Graphics.AutoParamDataSource)">
            <summary>
               Update any automatic parameters (except lights) on this pass.
            </summary>
            <param name="renderable">Current object being rendered.</param>
            <param name="camera">Current being being used for rendering.</param>
        </member>
        <member name="M:Axiom.Graphics.Pass.DirtyHash">
            <summary>
            	Mark the hash for this pass as dirty.	
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.QueueForDeletion">
            <summary>
            	Queue this pass for deletion when appropriate.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.ProcessPendingUpdates">
            <summary>
            	Process all dirty and pending deletion passes.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Pass.GetHashCode">
            <summary>
               Gets the 'hash' of this pass, ie a precomputed number to use for sorting.
            </summary>
            <remarks>
               This hash is used to sort passes, and for this reason the pass is hashed
               using firstly its index (so that all passes are rendered in order), then
               by the textures which it's TextureUnitState instances are using.
            </remarks>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.Pass.Ambient">
            <summary>
               Sets the ambient color reflectance properties of this pass.
            </summary>
            <remarks>
               The base color of a pass is determined by how much red, green and blue light is reflects
               (provided texture layer #0 has a blend mode other than LayerBlendOperation.Replace). 
               This property determines how much ambient light (directionless global light) is reflected. 
               The default is full white, meaning objects are completely globally illuminated. Reduce this 
               if you want to see diffuse or specular light effects, or change the blend of colors to make 
               the object have a base color other than white.
               <p/>
               This setting has no effect if dynamic lighting is disabled (see <see cref="P:Axiom.Graphics.Pass.LightingEnabled"/>),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.ColorWrite">
            <summary>
               Sets whether or not color buffer writing is enabled for this Pass.
            </summary>
            <remarks>
               For some effects, you might wish to turn off the color write operation
               when rendering geometry; this means that only the depth buffer will be
               updated (provided you have depth buffer writing enabled, which you 
               probably will do, although you may wish to only update the stencil
               buffer for example - stencil buffer state is managed at the RenderSystem
               level only, not the Material since you are likely to want to manage it 
               at a higher level).
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.CullMode">
            <summary>
               Sets the culling mode for this pass based on the 'vertex winding'.
            </summary>
            <remarks>
               A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of
               triangles. Vertex winding refers to the direction in which the vertices are passed or indexed
               to in the rendering operation as viewed from the camera, and will wither be clockwise or
               counterclockwise. The default is Clockwise i.e. that only triangles whose vertices are passed/indexed in 
               counter-clockwise order are rendered - this is a common approach and is used in 3D studio models for example. 
               You can alter this culling mode if you wish but it is not advised unless you know what you are doing.
               <p/>
               You may wish to use the CullingMode.None option for mesh data that you cull yourself where the vertex
               winding is uncertain.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthBias">
            <summary>
               Sets the depth bias to be used for this Pass.
            </summary>
            <remarks>
               When polygons are coplanar, you can get problems with 'depth fighting' (or 'z fighting') where
               the pixels from the two polys compete for the same screen pixel. This is particularly
               a problem for decals (polys attached to another surface to represent details such as
               bulletholes etc.).
               <p/>
               A way to combat this problem is to use a depth bias to adjust the depth buffer value
               used for the decal such that it is slightly higher than the true value, ensuring that
               the decal appears on top.
            </remarks>
            <value>
               The bias value, should be between 0 and 16.
            </value>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthCheck">
            <summary>
               Gets/Sets whether or not this pass renders with depth-buffer checking on or not.
            </summary>
            <remarks>
               If depth-buffer checking is on, whenever a pixel is about to be written to the frame buffer
               the depth buffer is checked to see if the pixel is in front of all other pixels written at that
               point. If not, the pixel is not written.
               <p/>
               If depth checking is off, pixels are written no matter what has been rendered before.
               Also see <see cref="P:Axiom.Graphics.Pass.DepthFunction"/> for more advanced depth check configuration.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthFunction">
            <summary>
               Gets/Sets the function used to compare depth values when depth checking is on.
            </summary>
            <remarks>
               If depth checking is enabled (see <see cref="P:Axiom.Graphics.Pass.DepthCheck"/>) a comparison occurs between the depth
               value of the pixel to be written and the current contents of the buffer. This comparison is
               normally CompareFunction.LessEqual, i.e. the pixel is written if it is closer (or at the same distance)
               than the current contents. If you wish, you can change this comparison using this method.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DepthWrite">
            <summary>
               Gets/Sets whether or not this pass renders with depth-buffer writing on or not.
            </summary>
            <remarks>
               If depth-buffer writing is on, whenever a pixel is written to the frame buffer
               the depth buffer is updated with the depth value of that new pixel, thus affecting future
               rendering operations if future pixels are behind this one.
               <p/>
               If depth writing is off, pixels are written without updating the depth buffer. Depth writing should
               normally be on but can be turned off when rendering static backgrounds or when rendering a collection
               of transparent objects at the end of a scene so that they overlap each other correctly.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DestBlendFactor">
            <summary>
               Retrieves the destination blending factor for the material (as set using SetSceneBlending).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Diffuse">
            <summary>
               Sets the diffuse color reflectance properties of this pass.
            </summary>
            <remarks>
               The base color of a pass is determined by how much red, green and blue light is reflects
               (provided texture layer #0 has a blend mode other than LayerBlendOperation.Replace). This property determines how
               much diffuse light (light from instances of the Light class in the scene) is reflected. The default
               is full white, meaning objects reflect the maximum white light they can from Light objects.
               <p/>
               This setting has no effect if dynamic lighting is disabled (see <see cref="P:Axiom.Graphics.Pass.LightingEnabled"/>),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.Emissive">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogColor">
            <summary>
               Returns the fog color for the scene.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogDensity">
            <summary>
               Returns the fog density for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogEnd">
            <summary>
               Returns the fog end distance for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogMode">
            <summary>
               Returns the fog mode for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogOverride">
            <summary>
               Returns true if this pass is to override the scene fog settings.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.FogStart">
            <summary>
               Returns the fog start distance for this pass.
            </summary>
            <remarks>
               Only valid if FogOverride is true.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FragmentProgram">
            <summary>
               Gets the vertex program used by this pass.
            </summary>
            <remarks>
               Only available after Load() has been called.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FragmentProgramName">
            <summary>
               Gets/Sets the name of the fragment program to use.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level programs.
               <p/>
               This must have been created using GpuProgramManager by the time that 
               this Pass is loaded.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.FragmentProgramParameters">
            <summary>
               Gets/Sets the fragment program parameters used by this pass.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level program parameters.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasFragmentProgram">
            <summary>
               Returns true if this Pass uses the programmable fragment pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.HasVertexProgram">
            <summary>
               Returns true if this Pass uses the programmable vertex pipeline.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Index">
            <summary>
               Gets the index of this Pass in the parent Technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsAmbientOnly">
            <summary>
            	Gets a flag indicating whether this pass is ambient only.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsLoaded">
            <summary>
               Returns true if this pass is loaded.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsProgrammable">
            <summary>
               Returns true if this pass is programmable ie includes either a vertex or fragment program.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.IsTransparent">
            <summary>
               Returns true if this pass has some element of transparency.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.LightingEnabled">
            <summary>
               Sets whether or not dynamic lighting is enabled.
            </summary>
            <remarks>
               If true, dynamic lighting is performed on geometry with normals supplied, geometry without
               normals will not be displayed.
               If false, no lighting is applied and all geometry will be full brightness.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.ManualCullMode">
            <summary>
               Sets the manual culling mode, performed by CPU rather than hardware.
            </summary>
            <remarks>
               In some situations you want to use manual culling of triangles rather than sending the
               triangles to the hardware and letting it cull them. This setting only takes effect on SceneManager's
               that use it (since it is best used on large groups of planar world geometry rather than on movable
               geometry since this would be expensive), but if used can cull geometry before it is sent to the
               hardware.
            </remarks>
            <value>
               The default for this setting is ManualCullingMode.Back.
            </value>
        </member>
        <member name="P:Axiom.Graphics.Pass.MaxLights">
            <summary>
               Sets the maximum number of lights to be used by this pass. 
            </summary>
            <remarks>
               During rendering, if lighting is enabled (or if the pass uses an automatic
               program parameter based on a light) the engine will request the nearest lights 
               to the object being rendered in order to work out which ones to use. This
               parameter sets the limit on the number of lights which should apply to objects 
               rendered with this pass. 
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.NumTextureUnitStages">
            <summary>
               Gets the number of fixed function texture unit states for this Pass.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.OnlyLightType">
            <summary>
                Gets the single light type this pass runs for if RunOncePerLight and 
                RunOnlyForOneLightType are both true. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Parent">
            <summary>
               Gets a reference to the Technique that owns this pass.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.RunOncePerLight">
            <summary>
               Does this pass run once for every light in range?
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.RunOnlyOncePerLightType">
            <summary>
               Does this pass run only for a single light type (if RunOncePerLight is true). 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.ShadingMode">
            <summary>
               Sets the type of light shading required.
            </summary>
            <value>
               The default shading method is Gouraud shading.
            </value>
        </member>
        <member name="P:Axiom.Graphics.Pass.Shininess">
            <summary>
               Sets the shininess of the pass, affecting the size of specular highlights.
            </summary>
            <remarks>
               This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.SourceBlendFactor">
            <summary>
               Retrieves the source blending factor for the material (as set using SetSceneBlending).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.Specular">
            <summary>
               Sets the specular color reflectance properties of this pass.
            </summary>
            <remarks>
               The base color of a pass is determined by how much red, green and blue light is reflects
               (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how
               much specular light (highlights from instances of the Light class in the scene) is reflected.
               The default is to reflect no specular light.
               <p/>
               The size of the specular highlights is determined by the separate Shininess property.
               <p/>
               This setting has no effect if dynamic lighting is disabled (see <see cref="P:Axiom.Graphics.Pass.LightingEnabled"/>),
               or if this is a programmable pass.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.TextureAnisotropy">
            <summary>
               Sets the anisotropy level to be used for all textures.
            </summary>
            <remarks>
               This property has been moved to the TextureUnitState class, which is accessible via the 
               Technique and Pass. For simplicity, this method allows you to set these properties for 
               every current TeextureUnitState, If you need more precision, retrieve the Technique, 
               Pass and TextureUnitState instances and set the property there.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.TextureFiltering">
            <summary>
               Set texture filtering for every texture unit.
            </summary>
            <remarks>
               This property actually exists on the TextureUnitState class
               For simplicity, this method allows you to set these properties for 
               every current TeextureUnitState, If you need more precision, retrieve the  
               TextureUnitState instance and set the property there.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.VertexProgram">
            <summary>
               Gets the vertex program used by this pass.
            </summary>
            <remarks>
               Only available after Load() has been called.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.VertexProgramName">
            <summary>
               Gets/Sets the name of the vertex program to use.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level programs.
               <p/>
               This must have been created using GpuProgramManager by the time that 
               this Pass is loaded.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.VertexProgramParameters">
            <summary>
               Gets/Sets the vertex program parameters used by this pass.
            </summary>
            <remarks>
               Only applicable to programmable passes, and this particular call is
               designed for low-level programs; use the named parameter methods
               for setting high-level program parameters.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Pass.DirtyList">
            <summary>
            	Gets a list of dirty passes.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Pass.GraveyardList">
            <summary>
            	Gets a list of passes queued for deletion.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IlluminationPass">
            <summary>
            	Struct recording a pass which can be used for a specific illumination stage.
            </summary>
            <remarks>
            	This structure is used to record categorized passes which fit into a 
            	number of distinct illumination phases - ambient, diffuse / specular 
            	(per-light) and decal (post-lighting texturing).
            	An original pass may fit into one of these categories already, or it
            	may require splitting into its component parts in order to be categorized 
            	properly.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.Stage">
            <summary>
            	The stage at which this pass is relevant.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.Pass">
            <summary>
            	The pass to use in this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.DestroyOnShutdown">
            <summary>
            	Whether this pass is one which should be deleted itself.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationPass.OriginalPass">
            <summary>
            	The original pass which spawned this one.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.VertexElementList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.TextureEffectList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.RenderTargetList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.RenderTextureList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.PassList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.TechniqueList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.TextureUnitStateList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.AutoConstantEntryList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.FloatConstantEntryList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.IntConstantEntryList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.RenderableList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.TriangleList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.EdgeList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.EdgeGroupList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.VertexDataList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.IndexDataList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.ShadowRenderableList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.OperationTypeList" -->
        <member name="T:Axiom.Core.ITimer">
            <summary>
            	Describes the interface for a platform independent timer.
            </summary>
        </member>
        <member name="M:Axiom.Core.ITimer.Reset">
            <summary>
            	Resets this timer.
            </summary>
            <remarks>
            	This must be called first before using the timer.
            </remarks>
        </member>
        <member name="P:Axiom.Core.ITimer.Microseconds">
            <summary>
            	Returns microseconds since initialization or last reset.
            </summary>
        </member>
        <member name="P:Axiom.Core.ITimer.Milliseconds">
            <summary>
            	Returns milliseconds since initialization or last reset.
            </summary>
        </member>
        <member name="T:Axiom.Animating.TagPoint">
            <summary>
            	A tagged point on a skeleton, which can be used to attach entities to on specific
            	other entities.
            </summary>
            <remarks>
            	A Skeleton, like a Mesh, is shared between Entity objects and simply updated as required
            	when it comes to rendering. However there are times when you want to attach another object
            	to an animated entity, and make sure that attachment follows the parent entity's animation
            	(for example, a character holding a gun in his / her hand). This class simply identifies
            	attachment points on a skeleton which can be used to attach child objects. 
            	<p/>
            	The child objects themselves are not physically attached to this class; as it's name suggests
            	this class just 'tags' the area. The actual child objects are attached to the Entity using the
            	skeleton which has this tag point. Use <see cref="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject)"/> to attach
            	the objects, which creates a new TagPoint on demand.
            </remarks>
        </member>
        <member name="T:Axiom.Animating.Bone">
            <summary>
               A bone in a skeleton.
            </summary>
            <remarks>
               See Skeleton for more information about the principles behind skeletal animation.
               This class is a node in the joint hierarchy. Mesh vertices also have assignments
               to bones to define how they move in relation to the skeleton.
            </remarks>
        </member>
        <member name="T:Axiom.Core.Node">
            <summary>
            	Class representing a general-purpose node an articulated scene graph.
            </summary>
            <remarks>
            	A node in the scene graph is a node in a structured tree. A node contains
            	information about the transformation which will apply to
            	it and all of it's children. Child nodes can have transforms of their own, which
            	are combined with their parent's transformations.
            	
            	This is an abstract class - concrete classes are based on this for specific purposes,
            	e.g. SceneNode, Bone
            </remarks>
            <ogre headerVersion="1.39" sourceVersion="1.53" />
        </member>
        <member name="T:Axiom.Graphics.IRenderable">
            <summary>
            	Interface defining the interface all renderable objects must implement.
            </summary>
            <remarks>
            	This interface abstracts renderable discrete objects which will be queued in the render pipeline,
            	grouped by material. Classes implementing this interface must be based on a single material, a single
            	world matrix (or a collection of world matrices which are blended by weights), and must be 
            	renderable via a single render operation.
            	<p/>
            	Note that deciding whether to put these objects in the rendering pipeline is done from the more specific
            	classes e.g. entities. Only once it is decided that the specific class is to be rendered is the abstract version
            	created (could be more than one per visible object) and pushed onto the rendering queue.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
               Gets the render operation required to send this object to the frame buffer.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
               Gets the world transform matrix / matrices for this renderable object.
            </summary>
            <remarks>
               If the object has any derived transforms, these are expected to be up to date as long as
               all the SceneNode structures have been updated before this is called.
             <p/>
               This method will populate xform with 1 matrix if it does not use vertex blending. If it
               does use vertex blending it will fill the passed in pointer with an array of matrices,
               the length being the value returned from getNumWorldTransforms.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            	Returns the camera-relative squared depth of this renderable.
            </summary>
            <remarks>
            	Used to sort transparent objects. Squared depth is used rather than
            	actual depth to avoid having to perform a square root on the result.	
            </remarks>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.GetCustomParameter(System.Int32)">
            <summary>
            	Gets the custom value associated with this Renderable at the given index. 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.SetCustomParameter(System.Int32,Axiom.Math.Vector4)">
            <summary>
            	Sets a custom parameter for this Renderable, which may be used to 
            	drive calculations for this specific Renderable, like GPU program parameters.
            </summary>
            <remarks>
            	Calling this method simply associates a numeric index with a 4-dimensional
            	value for this specific Renderable. This is most useful if the material
            	which this Renderable uses a vertex or fragment program, and has an 
            	AutoConstant.Custom parameter entry. This parameter entry can refer to the
            	index you specify as part of this call, thereby mapping a custom
            	parameter for this renderable to a program parameter.
            </remarks>
            <param name="index">
            	The index with which to associate the value. Note that this
            	does not have to start at 0, and can include gaps. It also has no direct
            	correlation with a GPU program parameter index - the mapping between the
            	two is performed by the AutoConstant.Custom entry, if that is used.
            </param>
            <param name="val">The value to associate.</param>
        </member>
        <member name="M:Axiom.Graphics.IRenderable.UpdateCustomGpuParameter(Axiom.Graphics.GpuProgramParameters.AutoConstantEntry,Axiom.Graphics.GpuProgramParameters)">
            <summary>
            	Update a custom GpuProgramParameters constant which is derived from 
            	information only this Renderable knows.
            </summary>
            <remarks>
            	This method allows a Renderable to map in a custom GPU program parameter
            	based on it's own data. This is represented by a GPU auto parameter
            	of AutoConstants.Custom, and to allow there to be more than one of these per
            	Renderable, the 'data' field on the auto parameter will identify
            	which parameter is being updated. The implementation of this method
            	must identify the parameter being updated, and call a 'SetConstant' 
            	method on the passed in <see cref="T:Axiom.Graphics.GpuProgramParameters"/> object, using the details
            	provided in the incoming auto constant setting to identify the index
            	at which to set the parameter.
            </remarks>
            <param name="constant">The auto constant entry referring to the parameter being updated.</param>
            <param name="parameters">The parameters object which this method should call to set the updated parameters.</param>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.CastsShadows">
            <summary>
            	Gets whether this renderable would normally cast a shadow. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.Material">
            <summary>
               Get the material associated with this renderable object.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.Technique">
            <summary>
               Technique being used to render this object according to the current hardware.
            </summary>
            <remarks>
               This is to allow Renderables to use a chosen Technique if they wish, otherwise
               they will use the best Technique available for the Material they are using.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.Lights">
            <summary>
               Gets a list of lights, ordered relative to how close they are to this renderable.
            </summary>
            <remarks>
               Directional lights, which have no position, will always be first on this list.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.NormalizeNormals">
            <summary>
               Returns whether or not this Renderable wishes the hardware to normalize normals.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.NumWorldTransforms">
            <summary>
               Gets the number of world transformations that will be used for this object.
            </summary>
            <remarks>
               When a renderable uses vertex blending, it uses multiple world matrices instead of a single
               one. Each vertex sent to the pipeline can reference one or more matrices in this list
               with given weights.
               If a renderable does not use vertex blending this method returns 1, which is the default for 
               simplicity.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.UseIdentityProjection">
            <summary>
               Returns whether or not to use an 'identity' projection.
            </summary>
            <remarks>
               Usually IRenderable objects will use a projection matrix as determined
               by the active camera. However, if they want they can cancel this out
               and use an identity projection, which effectively projects in 2D using
               a {-1, 1} view space. Useful for overlay rendering. Normal renderables need
               not override this.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.UseIdentityView">
            <summary>
               Returns whether or not to use an 'identity' projection.
            </summary>
            <remarks>
               Usually IRenderable objects will use a view matrix as determined
               by the active camera. However, if they want they can cancel this out
               and use an identity matrix, which means all geometry is assumed
               to be relative to camera space already. Useful for overlay rendering. 
               Normal renderables need not override this.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.IRenderable.RenderDetail">
            <summary>
            	Will allow for setting per renderable scene detail levels.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Graphics.IRenderable.WorldOrientation" -->
        <!-- Badly formed XML comment ignored for member "P:Axiom.Graphics.IRenderable.WorldPosition" -->
        <member name="F:Axiom.Core.Node.name">
            <summary>Name of this node.</summary>
        </member>
        <member name="F:Axiom.Core.Node.parent">
            <summary>Parent node (if any)</summary>
        </member>
        <member name="F:Axiom.Core.Node.childNodes">
            <summary>Collection of this nodes child nodes.</summary>
        </member>
        <member name="F:Axiom.Core.Node.childrenToUpdate">
            <summary>Collection of this nodes child nodes.</summary>
        </member>
        <member name="F:Axiom.Core.Node.needParentUpdate">
            <summary>Flag to indicate own transform from parent is out of date.</summary>
        </member>
        <member name="F:Axiom.Core.Node.needChildUpdate">
            <summary>Flag to indicate all children need to be updated.</summary>
        </member>
        <member name="F:Axiom.Core.Node.isParentNotified">
            <summary>Flag indicating that parent has been notified about update request.</summary>
        </member>
        <member name="F:Axiom.Core.Node.orientation">
            <summary>Orientation of this node relative to it's parent.</summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedOrientation">
            <summary>World orientation of this node based on parents orientation.</summary>
        </member>
        <member name="F:Axiom.Core.Node.initialOrientation">
            <summary>Original orientation of this node, used for resetting to original.</summary>
        </member>
        <member name="F:Axiom.Core.Node.rotationFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.position">
            <summary>Position of this node relative to it's parent.</summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedPosition">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.initialPosition">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.translationFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.scale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.derivedScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.initialScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.scaleFromInitial">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.inheritsScale">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.accumAnimWeight">
            <summary>Weight of applied animations so far, used for blending.</summary>
        </member>
        <member name="F:Axiom.Core.Node.cachedTransform">
            <summary>Cached derived transform as a 4x4 matrix.</summary>
        </member>
        <member name="F:Axiom.Core.Node.cachedRelativeTransform">
            <summary>Cached relative transform as a 4x4 matrix.</summary>
        </member>
        <member name="F:Axiom.Core.Node.needTransformUpdate">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.needRelativeTransformUpdate">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Node.nodeMaterial">
            <summary>Material to be used is this node itself will be rendered (axes, or bones).</summary>
        </member>
        <member name="F:Axiom.Core.Node.nodeSubMesh">
            <summary>SubMesh to be used is this node itself will be rendered (axes, or bones).</summary>
        </member>
        <member name="F:Axiom.Core.Node.emptyLightList">
            <summary>
               Empty list of lights to return for IRenderable.Lights, since nodes are not lit.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Node.AddChild(Axiom.Core.Node)">
            <summary>
               Adds a node to the list of children of this node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Axiom.Core.Node.Clear">
            <summary>
               Removes all child nodes from this node.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.RemoveAllChildren">
            <summary>
            	Removes all child Nodes attached to this node.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.GetChild(System.Int32)">
            <summary>
               Gets a child node by index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.Core.Node.GetChild(System.String)">
            <summary>
               Gets a child node by name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.RemoveChild(Axiom.Core.Node)">
            <summary>
               Removes the specifed node as a child of this node.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.RemoveChild(System.String)">
            <summary>
                Removes the child node with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.RemoveChild(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.Scale(Axiom.Math.Vector3)">
             <summary>
             Scales the node, combining it's current scale with the passed in scaling factor. 
             </summary>
             <remarks>
            	This method applies an extra scaling factor to the node's existing scale, (unlike setScale
            	which overwrites it) combining it's current scale with the new one. E.g. calling this 
            	method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if
             the existing scale was 1.
             
            	Note that like rotations, scalings are oriented around the node's origin.
            </remarks>
             <param name="scale"></param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Vector3)">
             <summary>
             Moves the node along the cartesian axes.
            
            	This method moves the node by the supplied vector along the
            	world cartesian axes, i.e. along world x,y,z
             </summary>
             <param name="scale">Vector with x,y,z values representing the translation.</param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Vector3,Axiom.Core.TransformSpace)">
             <summary>
             Moves the node along the cartesian axes.
            
            	This method moves the node by the supplied vector along the
            	world cartesian axes, i.e. along world x,y,z
             </summary>
             <param name="scale">Vector with x,y,z values representing the translation.</param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Matrix3,Axiom.Math.Vector3)">
            <summary>
            Moves the node along arbitrary axes.
            </summary>
            <remarks>
            This method translates the node by a vector which is relative to
            a custom set of axes.
            </remarks>
            <param name="axes">3x3 Matrix containg 3 column vectors each representing the
            X, Y and Z axes respectively. In this format the standard cartesian axes would be expressed as:
            	1 0 0
            	0 1 0
            	0 0 1
            	i.e. The Identity matrix.
            </param>
            <param name="move">Vector relative to the supplied axes.</param>
        </member>
        <member name="M:Axiom.Core.Node.Translate(Axiom.Math.Matrix3,Axiom.Math.Vector3,Axiom.Core.TransformSpace)">
            <summary>
            Moves the node along arbitrary axes.
            </summary>
            <remarks>
            This method translates the node by a vector which is relative to
            a custom set of axes.
            </remarks>
            <param name="axes">3x3 Matrix containg 3 column vectors each representing the
            X, Y and Z axes respectively. In this format the standard cartesian axes would be expressed as:
            	1 0 0
            	0 1 0
            	0 0 1
            	i.e. The Identity matrix.
            </param>
            <param name="move">Vector relative to the supplied axes.</param>
        </member>
        <member name="M:Axiom.Core.Node.Pitch(System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around the X-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Pitch(System.Single)">
            <summary>
            Rotate the node around the X-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Roll(System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around the Z-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Roll(System.Single)">
            <summary>
            Rotate the node around the Z-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Yaw(System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around the Y-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Yaw(System.Single)">
            <summary>
            Rotate the node around the Y-axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Vector3,System.Single,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around an arbitrary axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Vector3,System.Single)">
            <summary>
            Rotate the node around an arbitrary axis.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Quaternion,Axiom.Core.TransformSpace)">
            <summary>
            Rotate the node around an arbitrary axis using a Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.Rotate(Axiom.Math.Quaternion)">
            <summary>
            Rotate the node around an arbitrary axis using a Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.ResetOrientation">
            <summary>
            Resets the nodes orientation (local axes as world axes, no rotation).
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.ResetToInitialState">
            <summary>
            Resets the position / orientation / scale of this node to it's initial state, see SetInitialState for more info.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.SetInitialState">
             <summary>
             Sets the current transform of this node to be the 'initial state' ie that
            	position / orientation / scale to be used as a basis for delta values used
             in keyframe animation.
             </summary>
             <remarks>
            	You never need to call this method unless you plan to animate this node. If you do
            	plan to animate it, call this method once you've loaded the node with it's base state,
            	ie the state on which all keyframes are based.
            
            	If you never call this method, the initial state is the identity transform, ie do nothing.
             </remarks>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String)">
            <summary>
               Creates a new name child node.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String,Axiom.Math.Vector3)">
            <summary>
               Creates a new named child node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(System.String,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new named child node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild">
            <summary>
               Creates a new Child node.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(Axiom.Math.Vector3)">
            <summary>
               Creates a new child node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChild(Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new child node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
               
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.Node.NeedUpdate">
            <summary>
            	To be called in the event of transform changes to this node that require it's recalculation.
            </summary>
            <remarks>
            	This not only tags the node state as being 'dirty', it also requests it's parent to 
            	know about it's dirtiness so it will get an update next time.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Node.RequestUpdate(Axiom.Core.Node)">
            <summary>
            	Called by children to notify their parent that they need an update.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.CancelUpdate(Axiom.Core.Node)">
            <summary>
            	Called by children to notify their parent that they no longer need an update.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Axiom.Core.Node.OnRename(System.String)">
            <summary>
            Can be overriden in derived classes to fire an event or rekey this node in the collections which contain it
            </summary>
            <param name="oldName"></param>
        </member>
        <member name="M:Axiom.Core.Node.UpdateFromParent">
             <summary>
            	Triggers the node to update it's combined transforms.
            
            	This method is called internally by the engine to ask the node
            	to update it's complete transformation based on it's parents
            	derived transform.
             </summary>
        </member>
        <member name="M:Axiom.Core.Node.MakeTransform(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Matrix4@)">
            <summary>
            Internal method for building a Matrix4 from orientation / scale / position. 
            </summary>
            <remarks>
            Transform is performed in the order rotate, scale, translation, i.e. translation is independent
            of orientation axes, scale does not affect size of translation, rotation and scaling are always
            centered on the origin.
            </remarks>
            <param name="position"></param>
            <param name="scale"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.MakeInverseTransform(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Matrix4@)">
            <summary>
            Internal method for building an inverse Matrix4 from orientation / scale / position. 
            </summary>
            <remarks>
            As makeTransform except it build the inverse given the same data as makeTransform, so
            performing -translation, 1/scale, -rotate in that order.
            </remarks>
            <param name="position"></param>
            <param name="scale"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Node.CreateChildImpl">
            <summary>
            Must be overridden in subclasses.  Specifies how a Node is created.  CreateChild uses this to create a new one and add it
            to the list of child nodes.  This allows subclasses to not have to override CreateChild and duplicate all its functionality.
            </summary>
        </member>
        <member name="M:Axiom.Core.Node.CreateChildImpl(System.String)">
            <summary>
            Must be overridden in subclasses.  Specifies how a Node is created.  CreateChild uses this to create a new one and add it
            to the list of child nodes.  This allows subclasses to not have to override CreateChild and duplicate all its functionality.
            </summary>
            <param name="name">The name of the node to add.</param>
        </member>
        <member name="M:Axiom.Core.Node.Update(System.Boolean,System.Boolean)">
            <summary>
            Internal method to update the Node.
            Updates this node and any relevant children to incorporate transforms etc.
            Don't call this yourself unless you are writing a SceneManager implementation.
            </summary>
            <param name="updateChildren">If true, the update cascades down to all children. Specify false if you wish to
            update children separately, e.g. because of a more selective SceneManager implementation.</param>
            <param name="hasParentChanged">if true then this will update its derived properties (scale, orientation, position) accoarding to the parent's</param>
        </member>
        <member name="M:Axiom.Core.Node.WeightedTransform(System.Single,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            This method transforms a Node by a weighted amount from it's
            initial state. If weighted transforms have already been applied, 
            the previous transforms and this one are blended together based
            on their relative weight. This method should not be used in
            combination with the unweighted rotate, translate etc methods.
            </summary>
            <param name="weight"></param>
            <param name="translate"></param>
            <param name="rotate"></param>
            <param name="scale"></param>
        </member>
        <member name="M:Axiom.Core.Node.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
            	This is only used if the SceneManager chooses to render the node. This option can be set
            	for SceneNodes at SceneManager.DisplaySceneNodes, and for entities based on skeletal 
            	models using Entity.DisplaySkeleton = true.
             </summary>
        </member>
        <member name="E:Axiom.Core.Node.UpdatedFromParent">
            <summary>
            Event which provides the newly-updated derived properties for syncronization in a physics engine for instance
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.ChildCount">
            <summary>
            	Gets the number of children attached to this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Name">
            <summary>
            Gets or sets the name of this Node object.
            </summary>
            <remarks>This is autogenerated initially, so setting it is optional.</remarks>
        </member>
        <member name="P:Axiom.Core.Node.Parent">
            <summary>
            Get the Parent Node of the current Node.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Orientation">
            <summary>
               A Quaternion representing the nodes orientation.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Position">
            <summary>
            The position of the node relative to its parent.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.ScaleFactor">
             <summary>
             The scaling factor applied to this node.
             </summary>
             <remarks>
            	Scaling factors, unlike other transforms, are not always inherited by child nodes. 
            	Whether or not scalings affect both the size and position of the child nodes depends on
            	the setInheritScale option of the child. In some cases you want a scaling factor of a parent node
            	to apply to a child node (e.g. where the child node is a part of the same object, so you
            	want it to be the same relative size and position based on the parent's size), but
            	not in other cases (e.g. where the child node is just for positioning another object,
            	you want it to maintain it's own size and relative position). The default is to inherit
            	as with other transforms.
            
            	Note that like rotations, scalings are oriented around the node's origin.
            	</remarks>
        </member>
        <member name="P:Axiom.Core.Node.InheritScale">
             <summary>
             Tells the node whether it should inherit scaling factors from it's parent node.
             </summary>
             <remarks>
            	Scaling factors, unlike other transforms, are not always inherited by child nodes. 
            	Whether or not scalings affect both the size and position of the child nodes depends on
            	the setInheritScale option of the child. In some cases you want a scaling factor of a parent node
            	to apply to a child node (e.g. where the child node is a part of the same object, so you
            	want it to be the same relative size and position based on the parent's size), but
            	not in other cases (e.g. where the child node is just for positioning another object,
            	you want it to maintain it's own size and relative position). The default is to inherit
            	as with other transforms.
            	If true, this node's scale and position will be affected by its parent's scale. If false,
            	it will not be affected.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.LocalAxes">
            <summary>
            Gets a matrix whose columns are the local axes based on
            the nodes orientation relative to it's parent.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedOrientation">
            <summary>
            Gets the orientation of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedPosition">
            <summary>
            Gets the position of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Axiom#Graphics#IRenderable#WorldOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Axiom#Graphics#IRenderable#WorldPosition">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.DerivedScale">
            <summary>
            Gets the scaling factor of the node as derived from all parents.
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.FullTransform">
            <summary>
            Gets the full transformation matrix for this node.
            </summary>
            <remarks>
            This method returns the full transformation matrix
            for this node, including the effect of any parent node
            transformations, provided they have been updated using the Node.Update() method.
            This should only be called by a SceneManager which knows the
            derived transforms have been updated before calling this method.
            Applications using the engine should just use the relative transforms.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.RelativeTransform">
            <summary>
            Gets the full transformation matrix for this node.
            </summary>
            <remarks>
            This method returns the full transformation matrix
            for this node, including the effect of any parent node
            transformations, provided they have been updated using the Node.Update() method.
            This should only be called by a SceneManager which knows the
            derived transforms have been updated before calling this method.
            Applications using the engine should just use the relative transforms.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.Material">
            <summary>
            	
            </summary>
            <remarks>
            	This is only used if the SceneManager chooses to render the node. This option can be set
            	for SceneNodes at SceneManager.DisplaySceneNodes, and for entities based on skeletal 
            	models using Entity.DisplaySkeleton = true.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Node.NumWorldTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.UseIdentityProjection">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.UseIdentityView">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.RenderDetail">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Node.Lights">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Animating.Bone.handle">
            <summary>Numeric handle of this bone.</summary>
        </member>
        <member name="F:Axiom.Animating.Bone.isManuallyControlled">
            <summary>Bones set as manuallyControlled are not reseted in Skeleton.Reset().</summary>
        </member>
        <member name="F:Axiom.Animating.Bone.creator">
            <summary>The skeleton that created this bone.</summary>
        </member>
        <member name="F:Axiom.Animating.Bone.bindDerivedInverseTransform">
            <summary>The inverse derived transform of the bone in the binding pose.</summary>
        </member>
        <member name="M:Axiom.Animating.Bone.#ctor(System.UInt16,Axiom.Animating.Skeleton)">
            <summary>
               Constructor, not to be used directly (use Bone.CreateChild or Skeleton.CreateBone)
            </summary>
        </member>
        <member name="M:Axiom.Animating.Bone.#ctor(System.String,System.UInt16,Axiom.Animating.Skeleton)">
            <summary>
               Constructor, not to be used directly (use Bone.CreateChild or Skeleton.CreateBone)
            </summary>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChildImpl">
            <summary>
               Creates a new Bone as a child of this bone.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChildImpl(System.String)">
            <summary>
               Creates a new Bone as a child of this bone.
            </summary>
            <param name="name">Name of the bone to create.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChild(System.UInt16)">
            <summary>
               Overloaded method.  Passes in Zero and Identity for the last 2 params.
            </summary>
            <param name="handle">The numeric handle to give the new bone; must be unique within the Skeleton.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.CreateChild(System.UInt16,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new Bone as a child of this bone.
            </summary>
            <param name="handle">The numeric handle to give the new bone; must be unique within the Skeleton.</param>
            <param name="translate">Initial translation offset of child relative to parent.</param>
            <param name="rotate">Initial rotation relative to parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Bone.Reset">
            <summary>
               Resets the position and orientation of this Bone to the original binding position.
            </summary>
            <remarks>
               Bones are bound to the mesh in a binding pose. They are then modified from this
               position during animation. This method returns the bone to it's original position and
               orientation.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Bone.SetBindingPose">
            <summary>
               Sets the current position / orientation to be the 'binding pose' ie the layout in which 
               bones were originally bound to a mesh.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Bone.IsManuallyControlled">
            <summary>
            	Determines whether this bone is controlled at runtime.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Bone.BindDerivedInverseTransform">
            <summary>
               Gets the inverse transform which takes bone space to origin from the binding pose. 
            </summary>
        </member>
        <member name="P:Axiom.Animating.Bone.Handle">
            <summary>
               Gets the numeric handle of this bone.
            </summary>
        </member>
        <member name="F:Axiom.Animating.TagPoint.parentEntity">
            <summary>
            	Reference to the entity that owns this tagpoint.
            </summary>
        </member>
        <member name="F:Axiom.Animating.TagPoint.childObject">
            <summary>
            	Object attached to this tagpoint.
            </summary>
        </member>
        <member name="F:Axiom.Animating.TagPoint.fullLocalTransform">
            <summary>
            	Combined full local transform of this tagpoint.
            </summary>
        </member>
        <member name="M:Axiom.Animating.TagPoint.#ctor(System.UInt16,Axiom.Animating.Skeleton)">
            <summary>
            	Constructor.
            </summary>
            <param name="handle">Handle to use.</param>
            <param name="creator">Skeleton who created this tagpoint.</param>
        </member>
        <member name="M:Axiom.Animating.TagPoint.NeedUpdate">
            <summary>
            	Overridden to update parent entity.
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.ChildObject">
            <summary>
            	Gets/Sets the object attached to this tagpoint.
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.ParentEntity">
            <summary>
            	Gets/Sets the parent Entity that is using this tagpoint.	
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.FullLocalTransform">
            <summary>
            	Gets the transform of this node just for the skeleton (not entity).
            </summary>
        </member>
        <member name="P:Axiom.Animating.TagPoint.ParentEntityTransform">
            <summary>
            	Transformation matrix of the parent entity.
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimationTrack">
            <summary>
            	A 'track' in an animation sequence, ie a sequence of keyframes which affect a
            	certain type of object that can be animated.
            </summary>
            <remarks>
            	This class is intended as a base for more complete classes which will actually
            	animate specific types of object, e.g. a bone in a skeleton to affect
            	skeletal animation. An animation will likely include multiple tracks each of which
            	can be made up of many KeyFrame instances. Note that the use of tracks allows each animatable
            	object to have it's own number of keyframes, i.e. you do not have to have the
            	maximum number of keyframes for all animable objects just to cope with the most
            	animated one.
            	<para/>
            	Since the most common animatable object is a Node, there are options in this class for associating
            	the track with a Node which will receive keyframe updates automatically when the <see cref="M:Axiom.Animating.AnimationTrack.Apply(System.Single,System.Single,System.Boolean,System.Single)"/> method
            	is called.
                <para/>
            	By default rotation is done using shortest-path algorithm. It is possible to change this behaviour using
                <see cref="!:setUseShortestRotationPath"/> method.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.handle">
            <summary>
            	Handle of this animation track.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.parent">
            <summary>
            	Animation that owns this track.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.targetNode">
            <summary>
            	Target node to be animated.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.maxKeyFrameTime">
            <summary>
            	Maximum keyframe time.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.keyFrameList">
            <summary>
            	Collection of key frames in this track.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.isSplineRebuildNeeded">
            <summary>
            	Flag indicating we need to rebuild the splines next time.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.positionSpline">
            <summary>
            	Spline for position interpolation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.scaleSpline">
            <summary>
            	Spline for scale interpolation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.rotationalSpline">
            <summary>
            	Spline for rotation interpolation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationTrack.useShortestRotationPath">
            <summary>
            	Defines if rotation is done using shortest path
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.#ctor(Axiom.Animating.Animation)">
            <summary>
            	Internal constructor, to prevent direction instantiation.  Should be created
            	via a call to the CreateTrack method of an Animation.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.#ctor(Axiom.Animating.Animation,Axiom.Core.Node)">
            <summary>
            	Internal constructor, to prevent direction instantiation.  Should be created
            	via a call to the CreateTrack method of an Animation.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)">
            <summary>
            	Creates a new KeyFrame and adds it to this animation at the given time index.
            </summary>
            <remarks>
            	It is better to create KeyFrames in time order. Creating them out of order can result 
            	in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created
            	for you, so you don't need to create this one, just access it using KeyFrames[0];
            </remarks>
            <param name="time">Time within the animation at which this keyframe will lie.</param>
            <returns>A new KeyFrame.</returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetKeyFrame(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetKeyFramesAtTime(System.Single,Axiom.Animating.KeyFrame@,Axiom.Animating.KeyFrame@,System.UInt16@)">
             <summary>
            		Gets the 2 KeyFrame objects which are active at the time given, and the blend value between them.
             </summary>
             <remarks>
            		At any point in time  in an animation, there are either 1 or 2 keyframes which are 'active',
            		1 if the time index is exactly on a keyframe, 2 at all other times i.e. the keyframe before
            		and the keyframe after.
             </remarks>
             <param name="time">The time index in seconds.</param>
             <param name="keyFrame1">Receive the keyframe just before or at this time index.</param>
             <param name="keyFrame2">Receive the keyframe just after this time index.</param>
             <param name="firstKeyIndex">If supplied, will receive the index of the 'from' keyframe incase the caller needs it.</param>
             <returns>
            		Parametric value indicating how far along the gap between the 2 keyframes the time
                value is, e.g. 0.0 for exactly at 1, 0.25 for a quarter etc. By definition the range of this 
                value is:  0.0 &lt;= returnValue &lt; 1.0 .
            </returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.GetInterpolatedKeyFrame(System.Single)">
            <summary>
            	Gets a KeyFrame object which contains the interpolated transforms at the time index specified.
            </summary>
            <remarks>
            	The KeyFrame objects held by this class are transformation snapshots at 
            	discrete points in time. Normally however, you want to interpolate between these
            	keyframes to produce smooth movement, and this method allows you to do this easily.
            	In animation terminology this is called 'tweening'. 
            </remarks>
            <param name="time">The time (in relation to the whole animation sequence).</param>
            <returns>
            	A new keyframe object containing the interpolated transforms. Note that the
            	position and scaling transforms are linearly interpolated (lerp), whilst the rotation is
            	spherically linearly interpolated (slerp) for the most natural result.
            </returns>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.Apply(System.Single)">
            <summary>
            	Overloaded Apply method.  
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.RemoveAllKeyFrames">
            <summary>
            	Removes all key frames from this animation track.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.RemoveKeyFrame(System.Int32)">
            <summary>
            	Removes the keyframe at the specified index.
            </summary>
            <param name="index">Index of the keyframe to remove from this track.</param>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.OnKeyFrameDataChanged">
            <summary>
            	Called internally when keyframes belonging to this track are changed, in order to
            	trigger a rebuild of the animation splines.
            </summary>
        </member>
        <member name="M:Axiom.Animating.AnimationTrack.BuildInterpolationSplines">
            <summary>Used to rebuild the internal interpolation splines for translations, rotations, and scaling.</summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.Handle">
            <summary>
            	The name of this animation track.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.KeyFrames">
            <summary>
            	Collection of the KeyFrames present in this AnimationTrack.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationTrack.AssociatedNode">
            <summary>
            	Gets/Sets the target node that this track is associated with.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.Particle">
            <summary>
            	An extension of Billboard that allows for each particle to have particle system specific info.
            </summary>
        </member>
        <member name="T:Axiom.Core.Billboard">
            <summary>
            	A billboard is a primitive which always faces the camera in every frame.
            </summary>
            <remarks>
            	Billboards can be used for special effects or some other trickery which requires the
            	triangles to always facing the camera no matter where it is. The engine groups billboards into
            	sets for efficiency, so you should never create a billboard on it's own (it's ok to have a
            	set of one if you need it).
            	<p/>
            	Billboards have their geometry generated every frame depending on where the camera is. It is most
            	beneficial for all billboards in a set to be identically sized since the engine can take advantage of this and
            	save some calculations - useful when you have sets of hundreds of billboards as is possible with special
            	effects. You can deviate from this if you wish (example: a smoke effect would probably have smoke puffs
            	expanding as they rise, so each billboard will legitimately have it's own size) but be aware the extra
            	overhead this brings and try to avoid it if you can.
            	<p/>
            	Billboards are just the mechanism for rendering a range of effects such as particles. It is other classes
            	which use billboards to create their individual effects, so the methods here are quite generic.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Billboard.rotationInRadians">
            <summary>
            	Needed for particle systems
            </summary>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor(Axiom.Math.Vector3,Axiom.Core.BillboardSet)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="owner"></param>
        </member>
        <member name="M:Axiom.Core.Billboard.#ctor(Axiom.Math.Vector3,Axiom.Core.BillboardSet,Axiom.Core.ColorEx)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="owner"></param>
            <param name="color"></param>
        </member>
        <member name="M:Axiom.Core.Billboard.ResetDimensions">
            <summary>
            	Resets this billboard to use the parent BillboardSet's dimensions instead of it's own.
            </summary>
        </member>
        <member name="M:Axiom.Core.Billboard.SetDimensions(System.Single,System.Single)">
            <summary>
            	Sets the width and height for this billboard.
            </summary>
            <param name="width">Width of the billboard.</param>
            <param name="height">Height of the billboard.</param>
        </member>
        <member name="M:Axiom.Core.Billboard.NotifyOwner(Axiom.Core.BillboardSet)">
            <summary>
            	Internal method for notifying a billboard of it's owner.
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:Axiom.Core.Billboard.Width">
            <summary>
            	Width and height of this billboard, if it has it's own.
            </summary>
        </member>
        <member name="P:Axiom.Core.Billboard.Height">
            <summary>
            	Width and height of this billboard, if it has it's own.
            </summary>
        </member>
        <member name="P:Axiom.Core.Billboard.HasOwnDimensions">
            <summary>
            	Sepcifies whether or not this billboard has different dimensions than the rest in the set.
            </summary>
        </member>
        <member name="P:Axiom.Core.Billboard.Rotation">
            <summary>
            	Gets/Sets the rotation in degrees.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.timeToLive">
            <summary>Time (in seconds) before this particle is destroyed.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.totalTimeToLive">
            <summary>Total Time to live, number of seconds of particles natural life</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.Particle.rotationSpeed">
            <summary>Speed of rotation in radians</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.Particle.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.VertexDeclaration" -->
        <member name="F:Axiom.Graphics.VertexDeclaration.elements">
            <summary>
                List of elements that make up this declaration.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.AddElement(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
                Adds a new VertexElement to this declaration.
            </summary>
            <remarks>
                This method adds a single element (positions, normals etc) to the
                vertex declaration. <b>Please read the information in <see cref="T:Axiom.Graphics.VertexDeclaration"/> about
                the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="source">
                The binding index of HardwareVertexBuffer which will provide the source for this element.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.AddElement(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
                Adds a new VertexElement to this declaration.
            </summary>
            <remarks>
                This method adds a single element (positions, normals etc) to the
                vertex declaration. <b>Please read the information in <see cref="T:Axiom.Graphics.VertexDeclaration"/> about
                the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="source">
                The binding index of HardwareVertexBuffer which will provide the source for this element.
            </param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <param name="index">Optional index for multi-input elements like texture coordinates.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.FindElementBySemantic(Axiom.Graphics.VertexElementSemantic)">
            <summary>
                Finds a <see cref="T:Axiom.Graphics.VertexElement"/> with the given semantic, and index if there is more than 
                one element with the same semantic. 
            </summary>
            <param name="semantic">Semantic to search for.</param>
            <returns>If the element is not found, this method returns null.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.FindElementBySemantic(Axiom.Graphics.VertexElementSemantic,System.Int16)">
            <summary>
                Finds a <see cref="T:Axiom.Graphics.VertexElement"/> with the given semantic, and index if there is more than 
                one element with the same semantic. 
            </summary>
            <param name="semantic">Semantic to search for.</param>
            <param name="index">Index of item to looks for using the supplied semantic (applicable to tex coords and colors).</param>
            <returns>If the element is not found, this method returns null.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.FindElementBySource(System.UInt16)">
            <summary>
                Gets a list of elements which use a given source.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.GetElement(System.Int32)">
            <summary>
            	Gets the <see cref="T:Axiom.Graphics.VertexElement"/> at the specified index.
            </summary>
            <param name="index">Index of the element to retrieve.</param>
            <returns>Element at the requested index.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.GetVertexSize(System.Int16)">
            <summary>
                Gets the vertex size defined by this declaration for a given source.
            </summary>
            <param name="source">The buffer binding index for which to get the vertex size.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.InsertElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
            	Inserts a new <see cref="T:Axiom.Graphics.VertexElement"/> at a given position in this declaration.
            </summary>
            <remarks>
            	This method adds a single element (positions, normals etc) at a given position in this
            	vertex declaration. <b>Please read the information in VertexDeclaration about
            	the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="position">Position to insert into.</param>
            <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element.</param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color, etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <returns>A reference to the newly created element.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.InsertElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
            	Inserts a new <see cref="T:Axiom.Graphics.VertexElement"/> at a given position in this declaration.
            </summary>
            <remarks>
            	This method adds a single element (positions, normals etc) at a given position in this
            	vertex declaration. <b>Please read the information in VertexDeclaration about
            	the importance of ordering and structure for compatibility with older D3D drivers</b>.
            </remarks>
            <param name="position">Position to insert into.</param>
            <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element.</param>
            <param name="offset">The offset in bytes where this element is located in the buffer.</param>
            <param name="type">The data format of the element (3 floats, a color, etc).</param>
            <param name="semantic">The meaning of the data (position, normal, diffuse color etc).</param>
            <param name="index">Optional index for multi-input elements like texture coordinates.</param>
            <returns>A reference to the newly created element.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.RemoveElement(System.Int32)">
            <summary>
            	Gets the <see cref="T:Axiom.Graphics.VertexElement"/> at the specified index.
            </summary>
            <param name="index">Index of the element to retrieve.</param>
            <returns>Element at the requested index.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.ModifyElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
            	Modifies the definition of a <see cref="T:Axiom.Graphics.VertexElement"/>.
            </summary>
            <param name="elemIndex">Index of the element to modify.</param>
            <param name="source">Source of the element.</param>
            <param name="offset">Offset of the element.</param>
            <param name="type">Type of the element.</param>
            <param name="semantic">Semantic of the element.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.ModifyElement(System.Int32,System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
            	Modifies the definition of a <see cref="T:Axiom.Graphics.VertexElement"/>.
            </summary>
            <param name="elemIndex">Index of the element to modify.</param>
            <param name="source">Source of the element.</param>
            <param name="offset">Offset of the element.</param>
            <param name="type">Type of the element.</param>
            <param name="semantic">Semantic of the element.</param>
            <param name="index">Usage index of the element.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.RemoveElement(Axiom.Graphics.VertexElementSemantic)">
            <summary>
            	Remove the element with the given semantic.
            </summary>
            <remarks>
            	For elements that have usage indexes, the default of 0 is used.
            </remarks>
            <param name="semantic">Semantic to remove.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.RemoveElement(Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
            	Remove the element with the given semantic and usage index.
            </summary>
            <param name="semantic">Semantic to remove.</param>
            <param name="index">Usage index to remove, typically only applies to tex coords.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.op_Equality(Axiom.Graphics.VertexDeclaration,Axiom.Graphics.VertexDeclaration)">
            <summary>
                Tests equality of 2 <see cref="T:Axiom.Graphics.VertexElement"/> objects.
            </summary>
            <param name="left">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <param name="right">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <returns>true if equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.op_Inequality(Axiom.Graphics.VertexDeclaration,Axiom.Graphics.VertexDeclaration)">
            <summary>
                Tests in-equality of 2 <see cref="T:Axiom.Graphics.VertexElement"/> objects.
            </summary>
            <param name="left">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <param name="right">A <see cref="T:Axiom.Graphics.VertexElement"/></param>
            <returns>true if not equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.Equals(System.Object)">
            <summary>
               Override to determine equality between 2 VertexDeclaration objects,
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.GetHashCode">
            <summary>
               Override GetHashCode.
            </summary>
            <remarks>
               Done mainly to quash warnings, no real need for it.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.VertexDeclaration.Clone">
            <summary>
                Clonses this declaration, including a copy of all <see cref="T:Axiom.Graphics.VertexElement"/> objects this declaration holds.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.VertexDeclaration.ElementCount">
            <summary>
                Gets the number of elements in the declaration.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTexture">
            <summary>
               Custom RenderTarget that allows for rendering a scene to a texture.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTarget">
            <summary>
            	A 'canvas' which can receive the results of a rendering operation.
            </summary>
            <remarks>
            	This abstract class defines a common root to all targets of rendering operations. A
            	render target could be a window on a screen, or another
            	offscreen surface like a render texture.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget._height">
            <summary>
               Height of this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget._width">
            <summary>
               Width of this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget._colorDepth">
            <summary>
                Color depth of this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget._priority">
            <summary>
               Indicates the priority of this render target.  Higher priority targets will get processed first.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget._name">
            <summary>
               Unique name assigned to this render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget._isActive">
            <summary>
               Flag that states whether this target is active or not.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget._isAutoUpdated">
            <summary>
                Is this render target updated automatically each frame?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetViewport(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.AddViewport(Axiom.Core.Camera)">
            <summary>
                Adds a viewport to the rendering target.
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.AddViewport(Axiom.Core.Camera,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            	Adds a viewport to the rendering target.
            </summary>
            <remarks>
            	A viewport is the rectangle into which rendering output is sent. This method adds
            	a viewport to the render target, rendering from the supplied camera. The
            	rest of the parameters are only required if you wish to add more than one viewport
            	to a single rendering target. Note that size information passed to this method is
            	passed as a parametric, i.e. it is relative rather than absolute. This is to allow
            	viewports to automatically resize along with the target.
            </remarks>
            <param name="camera">The camera from which the viewport contents will be rendered (mandatory)</param>
            <param name="left">The relative position of the left of the viewport on the target, as a value between 0 and 1.</param>
            <param name="top">The relative position of the top of the viewport on the target, as a value between 0 and 1.</param>
            <param name="width">The relative width of the viewport on the target, as a value between 0 and 1.</param>
            <param name="height">The relative height of the viewport on the target, as a value between 0 and 1.</param>
            <param name="zOrder">The relative order of the viewport with others on the target (allows overlapping
            	viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number
            	is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetStatistics(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Retieves details of current rendering performance.
            </summary>
            <param name="lastFPS">The number of frames per second (FPS) based on the last frame rendered.</param>
            <param name="avgFPS">
            The FPS rating based on an average of all the frames rendered 
            since rendering began (the call to Root.StartRendering).
            </param>
            <param name="bestFPS">The best FPS rating that has been achieved since rendering began.</param>
            <param name="worstFPS">The worst FPS rating seen so far</param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.ResetStatistics">
            <summary>
            Resets saved frame-rate statistices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTarget.customAttributes">
            <summary>
               Custom attributes that can be assigned to this target.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetCustomAttribute(System.String)">
            <summary>
            Gets a custom (maybe platform-specific) attribute.
            </summary>
            <remarks>
            This is a nasty way of satisfying any API's need to see platform-specific details.
            It horrid, but D3D needs this kind of info. At least it's abstracted.
            </remarks>
            <param name="attribute">The name of the attribute.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.Update">
            <summary>
            	Tells the target to update it's contents.
            </summary>
            <remarks>
            	If the engine is not running in an automatic rendering loop
            	(started using RenderSystem.StartRendering()),
            	the user of the library is responsible for asking each render
            	target to refresh. This is the method used to do this. It automatically
            	re-renders the contents of the target using whatever cameras have been
            	pointed at it (using Camera.RenderTarget).
            
            	This allows the engine to be used in multi-windowed utilities
            	and for contents to be refreshed only when required, rather than
            	constantly as with the automatic rendering loop.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.NotifyCameraRemoved(Axiom.Core.Camera)">
            <summary>
            	Utility method to notify a render target that a camera has been removed, 
            	incase it was referring to it as a viewer.
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.GetMetrics(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Retrieve information about the render target.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="colourDepth"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.Save(System.String)">
            <summary>
            	Saves window contents to file (i.e. screenshot);
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.Save(System.IO.Stream)">
            <summary>
            	Saves the contents of this render target to the specified stream.
            </summary>
            <param name="stream">Stream to write the contents of this render target to.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderTarget.dispose(System.Boolean)">
             <summary>
             Class level dispose method
             </summary>
             <remarks>
             When implementing this method in an inherited class the following template should be used;
             protected override void dispose( bool disposeManagedResources )
             {
             	if ( !isDisposed )
             	{
             		if ( disposeManagedResources )
             		{
             			// Dispose managed resources.
             		}
             
             		// There are no unmanaged resources to release, but
             		// if we add them, they need to be released here.
             	}
             	isDisposed = true;
            
             	// If it is available, make the call to the
             	// base class's Dispose(Boolean) method
             	base._dispose( disposeManagedResources );
             }
             </remarks>
             <param name="disposeManagedResources">True if Unmanaged resources should be released.</param>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Height">
            <summary>
            Gets/Sets the height of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Width">
            <summary>
            Gets/Sets the width of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.ColorDepth">
            <summary>
            Gets/Sets the color depth of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Priority">
            <summary>
               Gets/Sets the priority of this render target.  Higher priority targets will get processed first.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Name">
            <summary>
               Gets/Sets the name of this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.RequiresTextureFlipping">
            <summary>
                Signals whether textures should be flipping before this target
                is updated.  Required for render textures in some API's.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.IsActive">
            <summary>
               Gets/Sets whether this RenderTarget is active or not.  When inactive, it will be skipped
               during processing each frame.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.IsAutoUpdated">
            <summary>
               Gets/Sets whether this target should be automatically updated if Axiom's rendering
               loop or Root.UpdateAllRenderTargets is being used.
            </summary>
            <remarks>
            	By default, if you use Axiom's own rendering loop (Root.StartRendering)
            	or call Root.UpdateAllRenderTargets, all render targets are updated
            	automatically. This method allows you to control that behaviour, if 
            	for example you have a render target which you only want to update periodically.
            </remarks>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.BeforeUpdate">
            <summary>
               Gets fired before this RenderTarget is going to update.  Handling this event is ideal
               in situation, such as RenderTextures, where before rendering the scene to the texture,
               you would like to show/hide certain entities to avoid rendering more than was necessary
               to reduce processing time.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.AfterUpdate">
            <summary>
               Gets fired right after this RenderTarget has been updated each frame.  If the scene has been modified
               in the BeforeUpdate event (such as showing/hiding objects), this event can be handled to set everything 
               back to normal.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.BeforeViewportUpdate">
            <summary>
               Gets fired before rendering the contents of each viewport attached to this RenderTarget.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.AfterViewportUpdate">
            <summary>
               Gets fired after rendering the contents of each viewport attached to this RenderTarget.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.ViewportAdded">
            <summary>
            Gets fired when a Viewport has been added to this RenderTarget.
            </summary>
        </member>
        <member name="E:Axiom.Graphics.RenderTarget.ViewportRemoved">
            <summary>
            Gets fired when a Viewport has been removed from this RenderTarget.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.viewportList">
            <summary>
            The list of viewports
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.ViewportCount">
            <summary>
                Gets the number of viewports attached to this render target.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.Statistics">
            <summary>
            Retieves details of current rendering performance.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.LastFPS">
            <summary>
            The number of frames per second (FPS) based on the last frame rendered.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Graphics.RenderTarget.AverageFPS" -->
        <member name="P:Axiom.Graphics.RenderTarget.BestFPS">
            <summary>
            The best frames per second (FPS) since call to Root.StartRendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.WorstFPS">
            <summary>
            The worst frames per second (FPS) since call to Root.StartRendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.BestFrameTime">
            <summary>
            The best frame time
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.WorstFrameTime">
            <summary>
            The worst frame time
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.LastTriangleCount">
            <summary>
            The number of triangles rendered in the last Update() call. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.LastBatchCount">
            <summary>
            The number of triangles rendered in the last Update() call. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.isDisposed">
            <summary>
            Determines if this instance has been disposed of already.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTarget.FrameStatistics">
            <summary>
            Holds all the current statistics for a RenderTarget
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.LastFPS">
            <summary>
            The number of Frames per second.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.AvgerageFPS">
            <summary>
            The average number of Frames per second since Root.StartRendering was called.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.BestFPS">
            <summary>
            The highest number of Frames per second since Root.StartRendering was called.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.WorstFPS">
            <summary>
            The lowest number of Frames per second since Root.StartRendering was called.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.BestFrameTime">
            <summary>
            The best frame time recorded since Root.StartRendering was called.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.WorstFrameTime">
            <summary>
            The worst frame time recorded since Root.StartRendering was called.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.TriangleCount">
            <summary>
            The number of triangles processed in the last call to Update()
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderTarget.FrameStatistics.BatchCount">
            <summary>
            The number of batches procecssed in the last call to Update()
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTexture.texture">
            <summary>
               The texture object that will be accessed by the rest of the API.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTexture.CopyToTexture">
            <summary>
               
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderTexture.dispose(System.Boolean)">
            <summary>
            Ensures texture is destroyed.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IHardwareBufferLicensee">
            <summary>
                Interface representing a 'licensee' of a hardware buffer copy.
            </summary>
            <remarks>
                Often it's useful to have temporary buffers which are used for working
                but are not necessarily needed permanently. However, creating and 
                destroying buffers is expensive, so we need a way to share these 
                working areas, especially those based on existing fixed buffers. 
                Classes implementing this interface represent a licensee of one of those 
                temporary buffers, and must be implemented by any user of a temporary buffer 
                if they wish to be notified when the license is expired. 
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.IHardwareBufferLicensee.LicenseExpired(Axiom.Graphics.HardwareBuffer)">
            <summary>
                This method is called when the buffer license is expired and is about
                to be returned to the shared pool.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramUsage">
            <summary>
            	This class makes the usage of a vertex and fragment programs (low-level or high-level), 
            	with a given set of parameters, explicit.
            </summary>
            <remarks>
            	Using a vertex or fragment program can get fairly complex; besides the fairly rudimentary
            	process of binding a program to the GPU for rendering, managing usage has few
            	complications, such as:
            	<ul>
            	<li>Programs can be high level (e.g. Cg, GLSlang) or low level (assembler). Using
            	either should be relatively seamless, although high-level programs give you the advantage
            	of being able to use named parameters, instead of just indexed registers</li>
            	<li>Programs and parameters can be shared between multiple usages, in order to save
            	memory</li>
            	<li>When you define a user of a program, such as a material, you often want to be able to
            	set up the definition but not load / compile / assemble the program at that stage, because
            	it is not needed just yet. The program should be loaded when it is first needed, or
            	earlier if specifically requested. The program may not be defined at this time, you
            	may want to have scripts that can set up the definitions independent of the order in which
            	those scripts are loaded.</li>
            	</ul>
            	This class packages up those details so you don't have to worry about them. For example,
            	this class lets you define a high-level program and set up the parameters for it, without
            	having loaded the program (which you normally could not do). When the program is loaded and
            	compiled, this class will then validate the parameters you supplied earlier and turn them
            	into runtime parameters.
            	<p/>
            	Just incase it wasn't clear from the above, this class provides linkage to both 
            	GpuProgram and HighLevelGpuProgram, despite its name.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramUsage.type">
            <summary>
               Type of program (vertex or fragment) this usage is being specified for.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramUsage.program">
            <summary>
               Reference to the program whose usage is being specified within this class.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramUsage.parameters">
            <summary>
               Low level GPU program parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.#ctor(Axiom.Graphics.GpuProgramType)">
            <summary>
               Default constructor.
            </summary>
            <param name="type">Type of program to link to.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.Clone">
            <summary>
            	Creates and returns a copy of this GpuProgramUsage object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.Load">
            <summary>
               Load this usage (and ensure program is loaded).
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramUsage.Unload">
            <summary>
               Unload this usage.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.Params">
            <summary>
               Gets/Sets the program parameters that should be used; because parameters can be
               shared between multiple usages for efficiency, this method is here for you
               to register externally created parameter objects.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.Program">
            <summary>
               Gets the program this usage is linked to; only available after the usage has been
               validated either via enableValidation or by enabling validation on construction.
            </summary>
            <remarks>
               Note that this will create a fresh set of parameters from the
               new program being linked, so if you had previously set parameters
               you will have to set them again.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.ProgramName">
            <summary>
               Gets/Sets the name of the program we're trying to link to.
            </summary>
            <remarks>
               Note that this will create a fresh set of parameters from the 
               new program being linked, so if you had previously set parameters 
               you will have to set them again. 
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramUsage.Type">
            <summary>
               Gets the type of program we're trying to link to.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.AutoParamDataSource">
            <summary>
            	This utility class is used to hold the information used to generate the matrices
            	and other information required to automatically populate GpuProgramParameters.
            </summary>
            <remarks>
               This class exercises a lazy-update scheme in order to avoid having to update all
            	the information a GpuProgramParameters class could possibly want all the time. 
            	It relies on the SceneManager to update it when the base data has changed, and
            	will calculate concatenated matrices etc only when required, passing back precalculated
            	matrices when they are requested more than once when the underlying information has
            	not altered.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.renderable">
            <summary>
               Current target renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.camera">
            <summary>
               Current camera being used for rendering.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.currentTextureProjector">
            <summary>
            	Current frustum used for texture projection.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.currentRenderTarget">
            <summary>
            	Current active render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.viewMatrix">
            <summary>
               Current view matrix;
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.projectionMatrix">
            <summary>
               Current projection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.viewProjMatrix">
            <summary>
               Current view and projection matrices concatenated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldMatrix">
            <summary>
               Array of world matrices for the current renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldMatrixCount">
            <summary>
            	Current count of matrices in the world matrix array.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldViewMatrix">
            <summary>
               Current concatenated world and view matrices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.worldViewProjMatrix">
            <summary>
               Current concatenated world, view, and projection matrices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.inverseWorldMatrix">
            <summary>
               Inverse of current world matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.inverseWorldViewMatrix">
            <summary>
               Inverse of current concatenated world and view matrices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.inverseViewMatrix">
            <summary>
               Inverse of the current view matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.textureViewProjMatrix">
            <summary>
            	Current texture view projection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.dirLightExtrusionDistance">
            <summary>
            	Distance to extrude shadow volume vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.cameraPositionObjectSpace">
            <summary>
               Position of the current camera in object space relative to the current renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.ambientLight">
            <summary>
               Current global ambient light color.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.currentLightList">
            <summary>
               List of lights that are in the scene and near the current renderable.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoParamDataSource.blankLight">
            <summary>
               Blank light to use when a higher index light is requested than is available.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.GetLight(System.Int32)">
            <summary>
               Get the light which is 'index'th closest to the current object 
            </summary>
            <param name="index">Ordinal value signifying the light to retreive, with 0 being closest, 1 being next closest, etc.</param>
            <returns>A light located near the current renderable.</returns>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.SetCurrentLightList(Axiom.Collections.LightList)">
            <summary>
               
            </summary>
        </member>
        <member name="M:Axiom.Graphics.AutoParamDataSource.SetShadowDirLightExtrusionDistance(System.Single)">
            <summary>
            	Sets the constant extrusion distance for directional lights.
            </summary>
            <param name="distance"></param>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.Renderable">
            <summary>
               Gets/Sets the current renderable object.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.Camera">
            <summary>
               Gets/Sets the current camera being used for rendering.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.TextureProjector">
            <summary>
            	Get/Set the current frustum used for texture projection.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.RenderTarget">
            <summary>
            	Get/Set the current active render target in use.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.AmbientLight">
            <summary>
               Gets/Sets the current global ambient light color.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldMatrix">
            <summary>
               Gets the current world matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldMatrixCount">
            <summary>
               Gets the number of current world matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldMatrixArray">
            <summary>
            	Gets an array with all the current world matrix transforms.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldViewMatrix">
            <summary>
               Gets/Sets the current concatenated world and view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.WorldViewProjMatrix">
            <summary>
               Gets/Sets the current concatenated world, view, and projection matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseWorldMatrix">
            <summary>
               Gets/Sets the inverse of current world matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseWorldViewMatrix">
            <summary>
               Gets/Sets the inverse of current concatenated world and view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.InverseViewMatrix">
            <summary>
               Gets/Sets the inverse of current concatenated view matrices.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.CameraPositionObjectSpace">
            <summary>
               Gets/Sets the position of the current camera in object space relative to the current renderable.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ProjectionMatrix">
            <summary>
               Gets/Sets the current projection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ViewMatrix">
            <summary>
               Gets/Sets the current view matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ViewProjectionMatrix">
            <summary>
            	Gets the projection and view matrices concatenated.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.TextureViewProjectionMatrix">
            <summary>
            	Gets the current texture * view * projection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.AutoParamDataSource.ShadowExtrusionDistance">
            <summary>
            	Get the extrusion distance for shadow volume vertices.
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FontType">
            <summary>
            	Possible font sources for use in the engine.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FontType.TrueType">
            <summary>System truetype fonts, as well as supplementary .ttf files.</summary>
        </member>
        <member name="F:Axiom.Fonts.FontType.Image">
            <summary>Character image map created by an artist.</summary>
        </member>
        <member name="T:Axiom.FileSystem.ArchiveManager">
            <summary>
                ResourceManager specialization to handle Archive plug-ins.
            </summary>
        </member>
        <member name="F:Axiom.FileSystem.ArchiveManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.FileSystem.ArchiveManager.factories">
            <summary>
            The list of factories
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.AddArchiveFactory(Axiom.FileSystem.IArchiveFactory)">
            <summary>
            Add an archive factory to the list
            </summary>
            <param name="type">The type of the factory (zip, file, etc.)</param>
            <param name="factory">The factory itself</param>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.GetArchiveFactory(System.String)">
            <summary>
            Get the archive factory
            </summary>
            <param name="type">The type of factory to get</param>
            <returns>The corresponding factory, or null if no factory</returns>
        </member>
        <member name="M:Axiom.FileSystem.ArchiveManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.FileSystem.ArchiveManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.SimpleRenderable">
            <summary>
            Summary description for SimpleRenderable.
            </summary>
        </member>
        <member name="T:Axiom.Core.MovableObject">
            <summary>
            	Abstract class definining a movable object in a scene.
            </summary>
            <remarks>
            	Instances of this class are discrete, relatively small, movable objects
            	which are attached to SceneNode objects to define their position.						  
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.ShadowCaster">
            <summary>
            	This class defines the interface that must be implemented by shadow casters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetDarkCapBounds(Axiom.Core.Light,System.Single)">
            <summary>
            	Gets the world space bounding box of the dark cap, as extruded using the light provided.
            </summary>
            <param name="light"></param>
            <param name="dirLightExtrusionDist"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetEdgeList">
            <summary>
            	Gets details of the edges which might be used to determine a silhouette.
            </summary>
            <remarks>Defaults to LOD index 0.</remarks>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetEdgeList(System.Int32)">
            <summary>
            	Gets details of the edges which might be used to determine a silhouette.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetLightCapBounds">
            <summary>
            	Gets the world space bounding box of the light cap.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetWorldBoundingBox(System.Boolean)">
            <summary>
            	Get the world bounding box of the caster.
            </summary>
            <param name="derive"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetShadowVolumeRenderableEnumerator(Axiom.Graphics.ShadowTechnique,Axiom.Core.Light,Axiom.Graphics.HardwareIndexBuffer,System.Boolean,System.Single,System.Int32)">
            <summary>
            	Gets an iterator over the renderables required to render the shadow volume.
            </summary>
            <remarks>
            	Shadowable geometry should ideally be designed such that there is only one
            	ShadowRenderable required to render the the shadow; however this is not a necessary
            	limitation and it can be exceeded if required.
            </remarks>
            <param name="technique">The technique being used to generate the shadow.</param>
            <param name="light">The light to generate the shadow from.</param>
            <param name="indexBuffer">The index buffer to build the renderables into, 
            the current contents are assumed to be disposable.</param>
            <param name="extrudeVertices">If true, this means this class should extrude
            the vertices of the back of the volume in software. If false, it
            will not be done (a vertex program is assumed).</param>
            <param name="flags">Technique-specific flags, see <see cref="T:Axiom.Graphics.ShadowRenderableFlags"/></param>
            <returns>An iterator that will allow iteration over all renderables for the full shadow volume.</returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetLastShadowVolumeRenderableEnumerator">
            <summary>
            	Return the last calculated shadow renderables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.ExtrudeVertices(Axiom.Graphics.HardwareVertexBuffer,System.Int32,Axiom.Math.Vector4,System.Single)">
            <summary>
            	Utility method for extruding vertices based on a light.
            </summary>
            <remarks>
            	Unfortunately, because D3D cannot handle homogenous (4D) position
            	coordinates in the fixed-function pipeline (GL can, but we have to
            	be cross-API), when we extrude in software we cannot extrude to 
            	infinity the way we do in the vertex program (by setting w to
            	0.0f). Therefore we extrude by a fixed distance, which may cause 
            	some problems with larger scenes. Luckily better hardware (ie
            	vertex programs) can fix this.
            </remarks>
            <param name="vertexBuffer">The vertex buffer containing ONLY xyz position
            values, which must be originalVertexCount * 2 * 3 floats long.</param>
            <param name="originalVertexCount">The count of the original number of
            vertices, ie the number in the mesh, not counting the doubling
            which has already been done (by <see cref="M:Axiom.Graphics.VertexData.PrepareForShadowVolume"/>)
            to provide the extruded area of the buffer.</param>
            <param name="lightPosition"> 4D light position in object space, when w=0.0f this
            represents a directional light</param>
            <param name="extrudeDistance">The distance to extrude.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.UpdateEdgeListLightFacing(Axiom.Graphics.EdgeData,Axiom.Math.Vector4)">
            <summary>
            	Tells the caster to perform the tasks necessary to update the 
            	edge data's light listing. Can be overridden if the subclass needs 
            	to do additional things.
            </summary>
            <param name="edgeData">The edge information to update.</param>
            <param name="lightPosition">4D vector representing the light, a directional light has w=0.0.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GenerateShadowVolume(Axiom.Graphics.EdgeData,Axiom.Graphics.HardwareIndexBuffer,Axiom.Core.Light,Axiom.Graphics.ShadowRenderableList,System.Int32)">
            <summary>
            	Generates the indexes required to render a shadow volume into the 
            	index buffer which is passed in, and updates shadow renderables to use it.
            </summary>
            <param name="edgeData">The edge information to use.</param>
            <param name="indexBuffer">The buffer into which to write data into; current 
            contents are assumed to be discardable.</param>
            <param name="light">The light, mainly for type info as silhouette calculations
            should already have been done in <see cref="M:Axiom.Graphics.ShadowCaster.UpdateEdgeListLightFacing(Axiom.Graphics.EdgeData,Axiom.Math.Vector4)"/></param>
            <param name="shadowRenderables">A list of shadow renderables which has 
            already been constructed but will need populating with details of
            the index ranges to be used.</param>
            <param name="flags">Additional controller flags, see <see cref="T:Axiom.Graphics.ShadowRenderableFlags"/>.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.ExtrudeBounds(Axiom.Math.AxisAlignedBox,Axiom.Math.Vector4,System.Single)">
            <summary>
            	Utility method for extruding a bounding box.
            </summary>
            <param name="box">Original bounding box, will be updated in-place.</param>
            <param name="lightPosition">4D light position in object space, when w=0.0f this
            represents a directional light</param>
            <param name="extrudeDistance">The distance to extrude.</param>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetExtrusionDistance(Axiom.Math.Vector3,Axiom.Core.Light)">
            <summary>
            	Helper method for calculating extrusion distance.
            </summary>
            <param name="objectPos"></param>
            <param name="light"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowCaster.GetPointExtrusionDistance(Axiom.Core.Light)">
            <summary>
            	Get the distance to extrude for a point/spot light.
            </summary>
            <param name="light"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.ShadowCaster.CastShadows">
            <summary>
            	Gets/Sets whether or not this object currently casts a shadow.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.parentNode">
            <summary>
               Node that this node is attached to.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.isVisible">
            <summary>
               Is this object visible?
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.name">
            <summary>
               Name of this object.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.renderQueueID">
            <summary>
               The render queue to use when rendering this object.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.renderQueueIDSet">
            <summary>
               Flags whether the RenderQueue's default should be used.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.queryFlags">
            <summary>
               Flags determining whether this object is included/excluded from scene queries.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.worldAABB">
            <summary>
               Cached world bounding box of this object.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.worldBoundingSphere">
            <summary>
               Cached world bounding spehere.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.userData">
            <summary>
               A link back to a GameObject (or subclass thereof) that may be associated with this SceneObject.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.parentIsTagPoint">
            <summary>
            	Flag which indicates whether this objects parent is a <see cref="T:Axiom.Animating.TagPoint"/>.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.worldDarkCapBounds">
            <summary>
            	World space AABB of this object's dark cap.
            </summary>
        </member>
        <member name="F:Axiom.Core.MovableObject.castShadows">
            <summary>
            	Does this object cast shadows?
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.AddQueryFlags(System.UInt64)">
            <summary>
            	Appends the specified flags to the current flags for this object.
            </summary>
            <param name="flags"></param>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetWorldBoundingBox(System.Boolean)">
            <summary>
               Retrieves the axis-aligned bounding box for this object in world coordinates.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetWorldBoundingSphere">
            <summary>
               Overloaded method.  Calls the overload with a default of not deriving the transform.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetWorldBoundingSphere(System.Boolean)">
            <summary>
               Retrieves the worldspace bounding sphere for this object.
            </summary>
            <param name="derive">Whether or not to derive from parent transforms.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.RemoveQueryFlags(System.UInt64)">
            <summary>
            	Removes the specified flags from the current flags for this object.
            </summary>
            <param name="flags"></param>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetDarkCapBounds(Axiom.Core.Light,System.Single)">
            <summary>
            	
            </summary>
            <param name="light"></param>
            <param name="extrusionDistance"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetEdgeList(System.Int32)">
            <summary>
            	Overridden.  Returns null by default.
            </summary>
        </member>
        <member name="M:Axiom.Core.MovableObject.GetPointExtrusionDistance(Axiom.Core.Light)">
            <summary>
            	Get the distance to extrude for a point/spot light
            </summary>
            <param name="light"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MovableObject.NotifyAttached(Axiom.Core.Node)">
            <summary>
            	Internal method called to notify the object that it has been attached to a node.
            </summary>
            <param name="node">Scene node to notify.</param>
        </member>
        <member name="M:Axiom.Core.MovableObject.NotifyAttached(Axiom.Core.Node,System.Boolean)">
            <summary>
            	Internal method called to notify the object that it has been attached to a node.
            </summary>
            <param name="node">Scene node to notify.</param>
        </member>
        <member name="M:Axiom.Core.MovableObject.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            	Internal method to notify the object of the camera to be used for the next rendering operation.
            </summary>
            <remarks>
            	Certain objects may want to do specific processing based on the camera position. This method notifies
            	them incase they wish to do this.
            </remarks>
            <param name="camera">Reference to the Camera being used for the current rendering operation.</param>
        </member>
        <member name="M:Axiom.Core.MovableObject.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            	An abstract method that causes the specified RenderQueue to update itself.  
            </summary>
            <remarks>This is an internal method used by the engine assembly only.</remarks>
            <param name="queue">The render queue that this object should be updated in.</param>
        </member>
        <member name="P:Axiom.Core.MovableObject.BoundingBox">
            <summary>
            	An abstract method required by subclasses to return the bounding box of this object in local coordinates.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.BoundingRadius">
            <summary>
            	An abstract method required by subclasses to return the bounding box of this object in local coordinates.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.UserData">
            <summary>
                Get/Sets a link back to a GameObject (or subclass thereof, such as Entity) that may be associated with this SceneObject.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.ParentNode">
            <summary>
            	Gets the parent node that this object is attached to.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.IsAttached">
            <summary>
            	See if this object is attached to another node.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.IsVisible">
            <summary>
            	States whether or not this object should be visible.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.Name">
            <summary>
            	Name of this SceneObject.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.ParentFullTransform">
            <summary>
               		Returns the full transformation of the parent SceneNode or the attachingPoint node
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.ParentNodeFullTransform">
            <summary>
            	Gets the full transformation of the parent SceneNode or TagPoint.
            </summary>
        </member>
        <member name="P:Axiom.Core.MovableObject.QueryFlags">
            <summary>
            	Gets/Sets the query flags for this object.
            </summary>
            <remarks>
            	When performing a scene query, this object will be included or excluded according
            	to flags on the object and flags on the query. This is a bitwise value, so only when
            	a bit on these flags is set, will it be included in a query asking for that flag. The
            	meaning of the bits is application-specific.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.ShowBoundingBox">
            <summary>
               Allows showing the bounding box of an invidual SceneObject.
            </summary>
            <remarks>
               This shows the bounding box of the SceneNode that the SceneObject is currently attached to.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.RenderQueueGroup">
            <summary>
            	Gets/Sets the render queue group this entity will be rendered through.
            </summary>
            <remarks>
            	Render queues are grouped to allow you to more tightly control the ordering
            	of rendered objects. If you do not call this method, all Entity objects default
            	to <see cref="F:Axiom.Core.RenderQueueGroupID.Main"/> which is fine for most objects. You may want to alter this
            	if you want this entity to always appear in front of other objects, e.g. for
            	a 3D menu system or such.
            </remarks>
        </member>
        <member name="P:Axiom.Core.MovableObject.CastShadows">
            <summary>
            	Overridden.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SimpleRenderable.dummyLightList">
            <summary>
               Empty light list to use when there is no parent for this renderable.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
            
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
            
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Graphics.SimpleRenderable.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.BoundingBox">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.Material">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.NumWorldTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.UseIdentityProjection">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.UseIdentityView">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.RenderDetail">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.WorldOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.SimpleRenderable.WorldPosition">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Collections.ConfigOptionCollection">
            <summary>
            Summary description for EntityCollection.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AxiomCollection">
            <summary>
            	Serves as a basis for strongly typed collections in the engine.
            </summary>
            <remarks>
            	Can't wait for Generics in .Net Framework 2.0!   
            </remarks>
        </member>
        <member name="F:Axiom.Collections.AxiomCollection.objectList">
            <summary></summary>
        </member>
        <member name="F:Axiom.Collections.AxiomCollection.parent">
            <summary></summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.#ctor">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.#ctor(System.Object)">
            <summary>
            	
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Add(System.Object)">
            <summary>
            	Accepts an unnamed object and names it manually.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Add(System.Object,System.Object)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="key"></param>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Clear">
            <summary>
            	Clears all objects from the collection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Remove(System.Object)">
            <summary>
            	Removes the item from the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.RemoveAt(System.Int32)">
            <summary>
            	Removes an item at the specified index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.ContainsKey(System.Object)">
            <summary>
            	Tests if there is a dupe entry in here.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Collections.AxiomCollection.Item(System.Int32)">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Collections.AxiomCollection.Item(System.Object)">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Enumerator.Reset">
            <summary>
            	Resets the in progress enumerator.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AxiomCollection.Enumerator.MoveNext">
            <summary>
            	Moves to the next item in the enumeration if there is one.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Collections.AxiomCollection.Enumerator.Current">
            <summary>
            	Returns the current object in the enumeration.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ConfigOptionCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ConfigOptionCollection.Add(Axiom.Configuration.ConfigOption)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.ConfigOptionCollection.Add(System.UInt16,Axiom.Configuration.ConfigOption)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.ConfigOptionCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.ConfigOptionCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AnimationTrackCollection">
            <summary>
            Summary description for AnimationTrackCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationTrackCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationTrackCollection.Add(Axiom.Animating.AnimationTrack)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AnimationTrackCollection.Add(System.Int16,Axiom.Animating.AnimationTrack)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="key"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.AnimationTrackCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.AnimationTrackCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Animating.AnimationState">
            <summary>
            	Represents the state of an animation and the weight of it's influence. 
            </summary>
            <remarks>
            	Other classes can hold instances of this class to store the state of any animations
            	they are using.
            	This class implements the IControllerValue interface to enable automatic update of
            	animation state through controllers.
            </remarks>
        </member>
        <member name="T:Axiom.Controllers.IControllerValue">
            <summary>
            	Classes that will be controlled by any type of Controller should implement
            	this interface to define how the controller will modifiy it's local data.
            </summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.animationName">
            <summary>Name of this animation track.</summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.time">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.length">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.inverseLength">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.weight">
            <summary></summary>
        </member>
        <member name="F:Axiom.Animating.AnimationState.isEnabled">
            <summary></summary>
        </member>
        <member name="M:Axiom.Animating.AnimationState.#ctor(System.String,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            	
            </summary>
            <param name="animationName"></param>
            <param name="time"></param>
            <param name="length"></param>
            <param name="weight"></param>
            <param name="isEnabled"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.#ctor(System.String,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="animationName"></param>
            <param name="time"></param>
            <param name="length"></param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.AddTime(System.Single)">
            <summary>
            	Modifies the time position, adjusting for animation length.
            </summary>
            <param name="offset">Offset from the current time position.</param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.CopyTo(Axiom.Animating.AnimationState)">
            <summary>
                Copies the details of this AnimationState instance to another instance.
            </summary>
            <param name="target">Target instance to copy our details to.</param>
        </member>
        <member name="M:Axiom.Animating.AnimationState.GetHashCode">
            <summary>
               Override GetHashCode.
            </summary>
            <remarks>
               Done mainly to quash warnings, no real need for it.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.AnimationState.CompareTo(System.Object)">
            <summary>
               
            </summary>
            <param name="obj"></param>
            <returns>0 if they are the same, -1 otherwise.</returns>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Name">
            <summary>
            	Gets the name of the animation to which this state applies
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Time">
            <summary>
            	Gets/Sets the time position for this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Length">
            <summary>
            	Gets/Sets the total length of this animation (may be shorter than whole animation)
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Weight">
            <summary>
            Gets/Sets the weight (influence) of this animation
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.IsEnabled">
            <summary>
            	Gets/Sets whether this animation is enabled or not.
            </summary>
        </member>
        <member name="P:Axiom.Animating.AnimationState.Value">
            <summary>
            	Gets/Sets the value to be used in a ControllerFunction.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.OverlayElementContainer">
            <summary>
            	A 2D element which contains other OverlayElement instances.
            </summary>
            <remarks>
            	This is a specialization of OverlayElement for 2D elements that contain other
            	elements. These are also the smallest elements that can be attached directly
            	to an Overlay.
            	<p/>
            	OverlayElementContainers should be managed using GuiManager. This class is responsible for
            	instantiating elements, and also for accepting new types of element
            	from plugins etc.
            </remarks>
        </member>
        <member name="T:Axiom.Overlays.OverlayElement">
            <summary>
            	Abstract definition of a 2D element to be displayed in an Overlay.
            </summary>
            <remarks>
            	This class abstracts all the details of a 2D element which will appear in
            	an overlay. In fact, not all OverlayElement instances can be directly added to an
            	Overlay, only those which are OverlayElementContainer instances (derived from this class) are able to be added,
            	however they can contain any OverlayElement however. This is done to enforce some level of grouping of widgets.
            	<br/>
            	OverlayElements should be managed using OverlayElementManager. This class is responsible for
            	instantiating / deleting elements, and also for accepting new types of element
            	from plugins etc.
            	<br/>
            	Note that positions / dimensions of 2D screen elements are expressed as parametric
            	values (0.0 - 1.0) because this makes them resolution-independent. However, most
            	screen resolutions have an aspect ratio of 1.3333:1 (width : height) so note that
            	in physical pixels 0.5 is wider than it is tall, so a 0.5x0.5 panel will not be
            	square on the screen (but it will take up exactly half the screen in both dimensions).
            </remarks>
        </member>
        <member name="F:Axiom.Overlays.OverlayElement.attribParsers">
            <summary>Parser method lookup for script parameters.</summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.CopyFromTemplate(Axiom.Overlays.OverlayElement)">
            <summary>
               Copys data from the template element to this element to clone it.
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Hide">
            <summary>
               Hides an element if it is currently visible.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Initialize">
            <summary>
               Initialize the OverlayElement.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.NotifyParent(Axiom.Overlays.OverlayElementContainer,Axiom.Overlays.Overlay)">
            <summary>
               Internal method for notifying the gui element of it's parent and ultimate overlay.
            </summary>
            <param name="parent">Parent of this element.</param>
            <param name="overlay">Overlay this element belongs to.</param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.NotifyZOrder(System.Int32)">
            <summary>
               Internal method to notify the element when Zorder of parent overlay
               has changed.
            </summary>
            <remarks>
               Overlays have explicit Z orders. OverlayElements do not, they inherit the 
               ZOrder of the overlay, and the Zorder is incremented for every container
               nested within this to ensure that containers are displayed behind contained
               items. This method is used internally to notify the element of a change in
               final zorder which is used to render the element.
            </remarks>
            <param name="zOrder"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.PositionsOutOfDate">
            <summary>
               Tells this element to recaculate it's position.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.RegisterParsers">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to 
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.SetDimensions(System.Single,System.Single)">
            <summary>
               
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.SetParam(System.String,System.String)">
            <summary>
               Sets param values from script values.  Subclasses can define their own params in addition to what
               this base class already defines.
            </summary>
            <param name="param"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.SetPosition(System.Single,System.Single)">
            <summary>
               Sets the position of this element.
            </summary>
            <param name="left"></param>
            <param name="top"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Show">
            <summary>
               Shows this element if it was previously hidden.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Update">
            <summary>
               Internal method to update the element based on transforms applied.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.Contains(System.Single,System.Single)">
            <summary>
            Returns true if xy is within the constraints of the component 
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.FindElementAt(System.Single,System.Single)">
            <summary>
             Returns true if xy is within the constraints of the component
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdateFromParent">
            <summary>
               Updates this elements transform based on it's parent.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenLeft(System.Single)">
            <summary>
            Sets the left of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="left"></param>
            <ogreequivilent>_setLeft</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenTop(System.Single)">
            <summary>
            Sets the top of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="top"></param>
            <ogreequivilent>_setTop</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenWidth(System.Single)">
            <summary>
            Sets the width of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="width"></param>
            <ogreequivilent>_setWidth</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenHeight(System.Single)">
            <summary>
            Sets the height of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="height"></param>
            <ogreequivilent>_setHeight</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenPosition(System.Single,System.Single)">
            <summary>
            Sets the left and top of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <ogreequivilent>_setPosition</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.ScreenDimensions(System.Single,System.Single)">
            <summary>
            Sets the width and height of this element in relation to the screen (where 1.0 = screen width)
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <ogreequivilent>_setDimensions</ogreequivilent>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdatePositionGeometry">
            <summary>
               Internal method which is triggered when the positions of the element get updated,
               meaning the element should be rebuilding it's mesh positions. Abstract since
               subclasses must implement this.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdateTextureGeometry">
            <summary>
            Internal method which is triggered when the UVs of the element get updated,
            meaning the element should be rebuilding it's mesh UVs. Abstract since
            subclasses must implement this.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
               Internal method to put the contents onto the render queue.
            </summary>
            <param name="queue">Current render queue.</param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
               Abstract.  Force subclasses to implement this.
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
            
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.GetWorldOrientation">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElement.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
               Implementation of IRenderable.
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.SourceTemplate">
            <summary>
            Gets the SourceTemplate for this element
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Color">
            <summary>
               Sets the color on elements that support it.
            </summary>
            <remarks>
               Note that not all elements support this, but it is still a relevant base class property.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.DerivedLeft">
            <summary>
               Gets the 'left' position as derived from own left and that of parents.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.DerivedTop">
            <summary>
               Gets the 'top' position as derived from own top and that of parents.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Enabled">
            <summary>
               Gets/Sets whether or not this element is enabled.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Height">
            <summary>
               Gets/Sets the height of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.HorizontalAlignment">
            <summary>
               Gets/Sets the horizontal origin for this element.
            </summary>
            <remarks>
               By default, the horizontal origin for a OverlayElement is the left edge of the parent container
               (or the screen if this is a root element). You can alter this by using this property, which is
               especially useful when you want to use pixel-based metrics (see MetricsMode) since in this
               mode you can't use relative positioning.
               <p/>
               For example, if you were using Pixels metrics mode, and you wanted to place a 30x30 pixel
               crosshair in the center of the screen, you would use Center with a 'left' property of -15.
               <p/>
               Note that neither Center nor Right alter the position of the element based
               on it's width, you have to alter the 'left' to a negative number to do that; all this
               does is establish the origin. This is because this way you can align multiple things
               in the center and right with different 'left' offsets for maximum flexibility.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.IsContainer">
            <summary>
               Gets whether or not this element is a container type.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.IsCloneable">
            <summary>
               Gets/Sets whether or not this element can be cloned.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.IsVisible">
            <summary>
               Returns whether or not this element is currently visible.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Left">
            <summary>
               Gets/Sets the left position of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.MaterialName">
            <summary>
               Gets/Sets the name of the material in use by this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.MetricsMode">
            <summary>
               Tells this element how to interpret the position and dimension values it is given.
            </summary>
            <remarks>
               By default, OverlayElements are positioned and sized according to relative dimensions
               of the screen. This is to ensure portability between different resolutions when you
               want things to be positioned and sized the same way across all resolutions. However, 
               sometimes you want things to be sized according to fixed pixels. In order to do this,
               you can call this method with the parameter Pixels. Note that if you then want
               to place your element relative to the center, right or bottom of it's parent, you will
               need to use the HorizontalAlignment and VerticalAlignment properties.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Name">
            <summary>
               Gets the name of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.ClippingRegion">
            <summary>
            Gets the clipping region of the element
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Parent">
            <summary>
               Gets the parent container of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Text">
             <summary>
                Sets the caption on elements that support it. 
             </summary>
             <remarks>
                Not all elements support this, but it is still a relevant base class property.
             </remarks>
            <ogreequivilent>getCaption</ogreequivilent>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Top">
            <summary>
               Gets/Sets the top position of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.VerticalAlignment">
            <summary>
               Sets the vertical origin for this element.
            </summary>
            <remarks>
               By default, the vertical origin for a OverlayElement is the top edge of the parent container
               (or the screen if this is a root element). You can alter this by using this property, which is
               especially useful when you want to use pixel-based metrics (see MetricsMode) since in this
               mode you can't use relative positioning.
               <p/>
               For example, if you were using Pixels metrics mode, and you wanted to place a 30x30 pixel
               crosshair in the center of the screen, you would use Center with a 'top' property of -15.
               <p/>
               Note that neither Center or Bottom alter the position of the element based
               on it's height, you have to alter the 'top' to a negative number to do that; all this
               does is establish the origin. This is because this way you can align multiple things
               in the center and bottom with different 'top' offsets for maximum flexibility.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.Width">
            <summary>
               Gets/Sets the width of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.ZOrder">
            <summary>
               Gets the z ordering of this element.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.NumWorldTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.UseIdentityProjection">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.UseIdentityView">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.RenderDetail">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.WorldOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElement.WorldPosition">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.#ctor(System.String)">
            <summary>
               Don't use directly, create through GuiManager.CreateElement.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.AddChild(Axiom.Overlays.OverlayElement)">
            <summary>
               Adds another OverlayElement to this container.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.AddChildImpl(Axiom.Overlays.OverlayElement)">
            <summary>
               Adds another OverlayElement to this container.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.AddChildImpl(Axiom.Overlays.OverlayElementContainer)">
            <summary>
               Add a nested container to this container.
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.GetChild(System.String)">
            <summary>
               Gets the named child of this container.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementContainer.PositionsOutOfDate">
            <summary>
               Tell the object and its children to recalculate their positions.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementContainer.IsContainer">
            <summary>
               This is most certainly a container.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementContainer.IsChildrenProcessEvents">
            <summary>
              Should this container pass events to their children 
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.BaseCollection">
            <summary>
            	Serves as a basis for strongly typed collections in the math lib.
            </summary>
            <remarks>
            	Can't wait for Generics in .Net Framework 2.0!   
            </remarks>
        </member>
        <member name="F:Axiom.Math.Collections.BaseCollection.objectList">
            <summary></summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.#ctor">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Add(System.Object)">
            <summary>
            	Adds an item to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Clear">
            <summary>
            	Clears all objects from the collection.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Remove(System.Object)">
            <summary>
            	Removes the item from the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.Reset">
            <summary>
            	Resets the in progress enumerator.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.BaseCollection.MoveNext">
            <summary>
            	Moves to the next item in the enumeration if there is one.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.Item(System.Int32)">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.IsSynchronized">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.SyncRoot">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.BaseCollection.Current">
            <summary>
            	Returns the current object in the enumeration.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.MovablePlane">
            <summary>
            	Definition of a Plane that may be attached to a node, and the derived
            	details of it retrieved simply.
            </summary>
            <remarks>
            	This plane is not here for rendering purposes, it's to allow you to attach
            	planes to the scene in order to have them move and follow nodes on their
            	own, which is useful if you're using the plane for some kind of calculation,
            	e.g. reflection.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.derivedPlane">
            <summary>
            	Plane as transformed by it's parent node.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.lastTranslate">
            <summary>
            	Cached translation vector.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.lastRotate">
            <summary>
            	Cached rotation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.nullBB">
            <summary>
            	Bounding box.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.isDirty">
            <summary>
            	Flag for whether changes have been made to this planes position/rotation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MovablePlane.containedPlane">
            <summary>
            	Underlying plane representation.
            </summary>
            <remarks>
            	Ogre uses multiple inheritance for this purpose - bah! ;)
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.MovablePlane.#ctor(System.String)">
            <summary>
            	Constructor.
            </summary>
            <param name="name">Name of this plane.</param>
        </member>
        <member name="P:Axiom.Graphics.MovablePlane.D">
            <summary>
            	The plane's distance from the origin.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.MovablePlane.Normal">
            <summary>
            	The direction the plane is facing.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.MovablePlane.DerivedPlane">
            <summary>
            	Get the derived plane as transformed by its parent node.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeData">
            <summary>
                This class contains the information required to describe the edge connectivity of a
                given set of vertices and indexes. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.triangles">
            <summary>
                List of triangles.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.edgeGroups">
            <summary>
                List of edge groups.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.UpdateTriangleLightFacing(Axiom.Math.Vector4)">
            <summary>
                Calculate the light facing state of the triangles in this edge list.
            </summary>
            <remarks>
                This is normally the first stage of calculating a silhouette, ie
                establishing which tris are facing the light and which are facing
                away. This state is stored in the 'lightFacing' flag in each 
                Triangle.
            </remarks>
            <param name="lightPos">
                4D position of the light in object space, note that 
                for directional lights (which have no position), the w component
                is 0 and the x/y/z position are the direction.
            </param>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.UpdateFaceNormals(System.Int32,Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
            	Updates the face normals for this edge list based on (changed)
            	position information, useful for animated objects. 
            </summary>
            <param name="vertexSet">The vertex set we are updating.</param>
            <param name="positionBuffer">The updated position buffer, must contain ONLY xyz.</param>
        </member>
        <member name="T:Axiom.Graphics.EdgeData.Triangle">
            <summary>
                Basic triangle structure.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.indexSet">
            <summary>
                The set of indexes this triangle came from (NB it is possible that the triangles on 
                one side of an edge are using a different vertex buffer from those on the other side.)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.vertexSet">
            <summary>
                The vertex set these vertices came from.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.vertIndex">
            <summary>
                Vertex indexes, relative to the original buffer.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Graphics.EdgeData.Triangle.sharedVertIndex" -->
        <member name="F:Axiom.Graphics.EdgeData.Triangle.normal">
            <summary>
                 Unit vector othogonal to this face, plus distance from origin.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Triangle.lightFacing">
            <summary>
                Working vector used when calculating the silhouette.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.Triangle.#ctor">
            <summary>
            	Default contructor.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeData.Edge">
            <summary>
                Edge data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.triIndex">
            <summary>
                The indexes of the 2 tris attached, note that tri 0 is the one where the 
                indexes run *counter* clockwise along the edge. Indexes must be
                reversed for tri 1.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.vertIndex">
            <summary>
                The vertex indices for this edge. Note that both vertices will be in the vertex
                set as specified in 'vertexSet', which will also be the same as tri 0.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.sharedVertIndex">
            <summary>
                Vertex indices as used in the shared vertex list, not exposed.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.Edge.isDegenerate">
            <summary>
            	Indicates if this is a degenerate edge, ie it does not have 2 triangles.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeData.Edge.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.EdgeData.EdgeGroup">
            <summary>
                A group of edges sharing the same vertex data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.EdgeGroup.vertexSet">
            <summary>
                The vertex set index that contains the vertices for this edge group.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.EdgeGroup.vertexData">
            <summary>
                Reference to vertex data used by this edge group.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeData.EdgeGroup.edges">
            <summary>
                The edges themselves.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneNode">
            <summary>
            	Represents a node in a scene graph.
            </summary>
            <remarks>
            	A SceneNode is a type of Node which is used to organize objects in a scene.
            	It has the same hierarchical transformation properties of the generic Node class,
            	but also adds the ability to attach world objects to the node, and stores hierarchical
            	bounding volumes of the nodes in the tree.
            	Child nodes are contained within the bounds of the parent, and so on down the
            	tree, allowing for fast culling.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneNode.objectList">
            <summary>
            	A collection of all objects attached to this scene node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.creator">
            <summary>
            	Reference to the scene manager who created me.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.wireBox">
            <summary>
            	Renderable bounding box for this node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.showBoundingBox">
            <summary>
            	Whether or not to display this node's bounding box.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.worldAABB">
            <summary>
            	Bounding box. Updated through Update.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.worldBoundingSphere">
            <summary>
            	Word bounding sphere surrounding this node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.lightList">
            <summary>
               List of lights within range of this node.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.lightListDirty">
            <summary>
               Keeps track of whether the list of lights located near this node needs updating.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.isYawFixed">
            <summary>
            	Where to yaw around a fixed axis.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.yawFixedAxis">
            <summary>
            	Fixed axis to yaw around.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.autoTrackTarget">
            <summary>
            	Auto tracking target.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.autoTrackOffset">
            <summary>
            	Tracking offset for fine tuning.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.autoTrackLocalDirection">
            <summary>
            	Local 'normal' direction vector.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneNode.visible">
            <summary>
            	Determines whether node and children are visible or not.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Basic constructor.  Takes a scene manager reference to record the creator.
            </summary>
            <remarks>
            	Can be created manually, but should be left the Create* Methods.
            </remarks>
            <param name="creator"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.#ctor(Axiom.Core.SceneManager,System.String)">
            <summary>
            	Overloaded constructor.  Takes a scene manager reference to record the creator, and a name for the node.
            </summary>
            <param name="creator"></param>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.AttachObject(Axiom.Core.MovableObject)">
            <summary>
               Attaches a MovableObject to this scene node.
            </summary>
            <remarks>
               A MovableObject will not show up in the scene until it is attached to a SceneNode.
            </remarks>
            <param name="obj"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.Clear">
            <summary>
            	Need to clear list of child objects in addition to base class functionality.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(System.String)">
            <summary>
               Creates a new name child node.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(System.String,Axiom.Math.Vector3)">
            <summary>
               Creates a new named child scene node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(System.String,Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new named child scene node.
            </summary>
            <param name="name">Name of the node.</param>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode">
            <summary>
               Creates a new child scene node.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(Axiom.Math.Vector3)">
            <summary>
               Creates a new child scene node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildSceneNode(Axiom.Math.Vector3,Axiom.Math.Quaternion)">
            <summary>
               Creates a new child scene node.
            </summary>
            <param name="translate">A vector to specify the position relative to the parent.</param>
            <param name="rotate">A quaternion to specify the orientation relative to the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.DetachAllObjects">
            <summary>
               Removes all currently attached SceneObjects from this SceneNode.
            </summary>
            <remarks>
               Bounds for this SceneNode are also updated.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneNode.DetachObject(System.Int32)">
            <summary>
               Removes the specifed object from this scene node.
            </summary>
            <remarks>
               Bounds for this SceneNode are also updated.
            </remarks>
            <param name="index">Index of the object to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneNode.NotifyAttachedObjectNameChanged(Axiom.Core.MovableObject)">
            <summary>
            Rekeys the scene object using its new Name
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.DetachObject(Axiom.Core.MovableObject)">
            <summary>
               Removes the specifed object from this scene node.
            </summary>
            <remarks>
               Bounds for this SceneNode are also updated.
            </remarks>
            <param name="obj">Reference to the object to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneNode.GetObject(System.String)">
            <summary>
            Returns a movable object attached to this node by name. Node that this method
            is O(n), whereas the integer overload of this method is O(1). Use the integer
            version of this method if speed is important.
            </summary>
            <param name="name">The name of the object to return.</param>
            <returns>MovableObject if found. Throws exception of not found.</returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.Update(System.Boolean,System.Boolean)">
            <summary>
            	Internal method to update the Node.
            </summary>
            <remarks>
            	Updates this scene node and any relevant children to incorporate transforms etc.
            	Don't call this yourself unless you are writing a SceneManager implementation.
            </remarks>
            <param name="updateChildren"></param>
            <param name="hasParentChanged"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue,System.Boolean,System.Boolean)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
            <param name="includeChildren"></param>
            <param name="displayNodes"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Internal method which locates any visible objects attached to this node and adds them to the passed in queue.
            </summary>
            <param name="camera">Active camera.</param>
            <param name="queue">Queue to which these objects should be added.</param>
            <param name="includeChildren">If true, cascades down to all children.</param>
            <param name="displayNodes">Renders the local axes for the node.</param>
            <param name="onlyShadowCasters"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.AddBoundingBoxToQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            	Adds this nodes bounding box (wireframe) to the RenderQueue.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.UpdateBounds">
            <summary>
            	Tell the SceneNode to update the world bound info it stores.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetFixedYawAxis(System.Boolean,Axiom.Math.Vector3)">
            <summary>
            	Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice.
            </summary>
            <remarks>
            	This method allows you to change the yaw behavior of the node - by default, it
            	yaws around it's own local Y axis when told to yaw with <see cref="F:Axiom.Core.TransformSpace.Local"/>, 
            	this makes it yaw around a fixed axis. 
            	You only really need this when you're using auto tracking (<see cref="M:Axiom.Core.SceneNode.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode,Axiom.Math.Vector3,Axiom.Math.Vector3)"/>,
            	because when you're manually rotating a node you can specify the <see cref="T:Axiom.Core.TransformSpace"/>
            	in which you wish to work anyway.
            </remarks>
            <param name="useFixed">
            	If true, the axis passed in the second parameter will always be the yaw axis no
            	matter what the node orientation. If false, the node returns to it's default behavior.
            </param>
            <param name="fixedAxis">The axis to use if the first parameter is true.</param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetFixedYawAxis(System.Boolean)">
            <summary>
            	Sets a default fixed yaw axis of Y.
            </summary>
            <param name="useFixed"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.Yaw(System.Single)">
            <summary>
            	Overridden to apply fixed yaw axis behavior.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.SceneNode.LookAt(Axiom.Math.Vector3,Axiom.Core.TransformSpace,Axiom.Math.Vector3)">
            <summary>
            	Points the local Z direction of this node at a point in space.
            </summary>
            <param name="target">A vector specifying the look at point.</param>
            <param name="relativeTo">The space in which the point resides.</param>
            <param name="localDirection">
            	The vector which normally describes the natural direction of the node, usually -Z.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Enables / disables automatic tracking of another SceneNode.
            </summary>
            <remarks>
            	If you enable auto-tracking, this SceneNode will automatically rotate to
            	point it's -Z at the target SceneNode every frame, no matter how 
            	it or the other SceneNode move. Note that by default the -Z points at the 
            	origin of the target SceneNode, if you want to tweak this, provide a 
            	vector in the 'offset' parameter and the target point will be adjusted.
            </remarks>
            <param name="enabled">
            	If true, tracking will be enabled and the 'target' cannot be null. 
            	If false tracking will be disabled and the current orientation will be maintained.
            </param>
            <param name="target">
            	Reference to the SceneNode to track. Can be null if and only if the enabled param is false.
            </param>
            <param name="localDirection">
            	The local vector considered to be the usual 'direction'
            	of the node; normally the local -Z but can be another direction.
            </param>
            <param name="offset">
            	If supplied, this is the target point in local space of the target node
            	instead of the origin of the target node. Good for fine tuning the look at point.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneNode.SetDirection(Axiom.Math.Vector3,Axiom.Core.TransformSpace,Axiom.Math.Vector3)">
            <summary>
            	Sets the node's direction vector ie it's local -z.
            </summary>
            <remarks>
            	Note that the 'up' vector for the orientation will automatically be 
            	recalculated based on the current 'up' vector (i.e. the roll will 
            	remain the same). If you need more control, use the <see cref="!:Orientation"/>
            	property.
            </remarks>
            <param name="vec">The direction vector.</param>
            <param name="relativeTo">The space in which this direction vector is expressed.</param>
            <param name="localDirection">The vector which normally describes the natural direction 
            	of the node, usually -Z.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneNode.FindLights(System.Single)">
            <summary>
               Allows retrieval of the nearest lights to the center of this SceneNode.
            </summary>
            <remarks>
               This method allows a list of lights, ordered by proximity to the center of
               this SceneNode, to be retrieved. Multiple access to this method when neither 
               the node nor the lights have moved will result in the same list being returned
               without recalculation. Can be useful when implementing IRenderable.Lights.
            </remarks>
            <param name="radius">Parameter to specify lights intersecting a given radius of
            	this SceneNode's centre</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.AutoTrack">
            <summary>
            	Internal method used to update auto-tracking scene nodes.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildImpl">
            <summary>
            	
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneNode.CreateChildImpl(System.String)">
            <summary>
            	
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.SceneNode.ObjectCount">
            <summary>
               Gets the number of SceneObjects currently attached to this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.Objects">
            <summary>
            Gets the list of scene objects attached to this scene node
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.ShowBoundingBox">
            <summary>
            	Gets/Sets whether or not to display the bounding box for this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.Creator">
            <summary>
            	Gets a reference to the SceneManager that created this node.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.WorldAABB">
            <summary>
            	Gets the axis-aligned bounding box of this node (and hence all child nodes).
            </summary>
            <remarks>
            	Usage not recommended unless you are extending a SceneManager, because the bounding box returned
            	from this method is only up to date after the SceneManager has called Update.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneNode.AutoTrackOffset">
            <summary>
            	Gets the offset at which this node is tracking another node, if the node is auto tracking..
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.AutoTrackLocalDirection">
            <summary>
            	Get the auto tracking local direction for this node, if it is auto tracking.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.AutoTrackTarget">
            <summary>
            	Gets the SceneNode that this node is currently tracking, if any.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.Visible">
            <summary>
            	Sets visibility for this node. If invisible, child nodes will be invisible, too.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneNode.Lights">
            <summary>
               Allows retrieval of the nearest lights to the center of this SceneNode.
            </summary>
            <remarks>
               This method allows a list of lights, ordered by proximity to the center of
               this SceneNode, to be retrieved. Multiple access to this method when neither 
               the node nor the lights have moved will result in the same list being returned
               without recalculation. Can be useful when implementing IRenderable.Lights.
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.PluginException">
            <summary>
            Summary description for PluginException.
            </summary>
        </member>
        <member name="T:Axiom.Core.AxiomException">
            <summary>
            Summary description for AxiomException.
            </summary>
        </member>
        <member name="T:Axiom.Core.ColorEx">
            <summary>
            	This class is necessary so we can store the color components as floating 
            	point values in the range [0,1].  It serves as an intermediary to System.Drawing.Color, which
            	stores them as byte values.  This doesn't allow for slow color component
            	interpolation, because with the values always being cast back to a byte would lose
            	any small interpolated values (i.e. 223 - .25 as a byte is 223).
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.a">
            <summary>
            	Alpha value [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.r">
            <summary>
            	Red color component [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.g">
            <summary>
            	Green color component [0,1].
            </summary>
        </member>
        <member name="F:Axiom.Core.ColorEx.b">
            <summary>
            	Blue color component [0,1].
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.ColorEx.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Constructor taking all component values.
            </summary>
            <param name="a">Alpha value.</param>
            <param name="r">Red color component.</param>
            <param name="g">Green color component.</param>
            <param name="b">Blue color component.</param>
        </member>
        <member name="M:Axiom.Core.ColorEx.Clone">
            <summary>
            	Returns a copy of this ColorEx instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToColor">
            <summary>
            	Converts this instance to a <see cref="T:System.Drawing.Color"/> structure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToABGR">
            <summary>
            	Converts this color value to packed ABGR format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToARGB">
            <summary>
            	Converts this color value to packed ARBG format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.ToArrayRGBA(System.Single[])">
            <summary>
            	Populates the color components in a 4 elements array in RGBA order.
            </summary>
            <remarks>
            	Primarily used to help in OpenGL.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.FromColor(System.Drawing.Color)">
            <summary>
            	Static method used to create a new <code>ColorEx</code> instance based
            	on an existing <see cref="T:System.Drawing.Color"/> structure.
            </summary>
            <param name="color">.Net color structure to use as a basis.</param>
            <returns>A new <code>ColorEx instance.</code></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.GetHashCode">
            <summary>
               Override GetHashCode.
            </summary>
            <remarks>
               Done mainly to quash warnings, no real need for it.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ColorEx.CompareTo(System.Object)">
            <summary>
               Used to compare 2 ColorEx objects for equality.
            </summary>
            <param name="obj">An instance of a ColorEx object to compare to this instance.</param>
            <returns>0 if they are equal, 1 if they are not.</returns>
        </member>
        <member name="P:Axiom.Core.ColorEx.Transparent">
            <summary>
            	The color Transparent.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.AliceBlue">
            <summary>
            	The color AliceBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.AntiqueWhite">
            <summary>
            	The color AntiqueWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Aqua">
            <summary>
            	The color Aqua.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Aquamarine">
            <summary>
            	The color Aquamarine.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Azure">
            <summary>
            	The color Azure.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Beige">
            <summary>
            	The color Beige.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Bisque">
            <summary>
            	The color Bisque.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Black">
            <summary>
            	The color Black.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.BlanchedAlmond">
            <summary>
            	The color BlanchedAlmond.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Blue">
            <summary>
            	The color Blue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.BlueViolet">
            <summary>
            	The color BlueViolet.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Brown">
            <summary>
            	The color Brown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.BurlyWood">
            <summary>
            	The color BurlyWood.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.CadetBlue">
            <summary>
            	The color CadetBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Chartreuse">
            <summary>
            	The color Chartreuse.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Chocolate">
            <summary>
            	The color Chocolate.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Coral">
            <summary>
            	The color Coral.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.CornflowerBlue">
            <summary>
            	The color CornflowerBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Cornsilk">
            <summary>
            	The color Cornsilk.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Crimson">
            <summary>
            	The color Crimson.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Cyan">
            <summary>
            	The color Cyan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkBlue">
            <summary>
            	The color DarkBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkCyan">
            <summary>
            	The color DarkCyan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkGoldenrod">
            <summary>
            	The color DarkGoldenrod.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkGray">
            <summary>
            	The color DarkGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkGreen">
            <summary>
            	The color DarkGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkKhaki">
            <summary>
            	The color DarkKhaki.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkMagenta">
            <summary>
            	The color DarkMagenta.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkOliveGreen">
            <summary>
            	The color DarkOliveGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkOrange">
            <summary>
            	The color DarkOrange.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkOrchid">
            <summary>
            	The color DarkOrchid.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkRed">
            <summary>
            	The color DarkRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSalmon">
            <summary>
            	The color DarkSalmon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSeaGreen">
            <summary>
            	The color DarkSeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSlateBlue">
            <summary>
            	The color DarkSlateBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkSlateGray">
            <summary>
            	The color DarkSlateGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkTurquoise">
            <summary>
            	The color DarkTurquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DarkViolet">
            <summary>
            	The color DarkViolet.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DeepPink">
            <summary>
            	The color DeepPink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DeepSkyBlue">
            <summary>
            	The color DeepSkyBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DimGray">
            <summary>
            	The color DimGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.DodgerBlue">
            <summary>
            	The color DodgerBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Firebrick">
            <summary>
            	The color Firebrick.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.FloralWhite">
            <summary>
            	The color FloralWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.ForestGreen">
            <summary>
            	The color ForestGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Fuchsia">
            <summary>
            	The color Fuchsia.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Gainsboro">
            <summary>
            	The color Gainsboro.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.GhostWhite">
            <summary>
            	The color GhostWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Gold">
            <summary>
            	The color Gold.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Goldenrod">
            <summary>
            	The color Goldenrod.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Gray">
            <summary>
            	The color Gray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Green">
            <summary>
            	The color Green.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.GreenYellow">
            <summary>
            	The color GreenYellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Honeydew">
            <summary>
            	The color Honeydew.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.HotPink">
            <summary>
            	The color HotPink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.IndianRed">
            <summary>
            	The color IndianRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Indigo">
            <summary>
            	The color Indigo.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Ivory">
            <summary>
            	The color Ivory.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Khaki">
            <summary>
            	The color Khaki.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Lavender">
            <summary>
            	The color Lavender.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LavenderBlush">
            <summary>
            	The color LavenderBlush.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LawnGreen">
            <summary>
            	The color LawnGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LemonChiffon">
            <summary>
            	The color LemonChiffon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightBlue">
            <summary>
            	The color LightBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightCoral">
            <summary>
            	The color LightCoral.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightCyan">
            <summary>
            	The color LightCyan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightGoldenrodYellow">
            <summary>
            	The color LightGoldenrodYellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightGreen">
            <summary>
            	The color LightGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightGray">
            <summary>
            	The color LightGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightPink">
            <summary>
            	The color LightPink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSalmon">
            <summary>
            	The color LightSalmon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSeaGreen">
            <summary>
            	The color LightSeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSkyBlue">
            <summary>
            	The color LightSkyBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSlateGray">
            <summary>
            	The color LightSlateGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightSteelBlue">
            <summary>
            	The color LightSteelBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LightYellow">
            <summary>
            	The color LightYellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Lime">
            <summary>
            	The color Lime.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.LimeGreen">
            <summary>
            	The color LimeGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Linen">
            <summary>
            	The color Linen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Magenta">
            <summary>
            	The color Magenta.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Maroon">
            <summary>
            	The color Maroon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumAquamarine">
            <summary>
            	The color MediumAquamarine.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumBlue">
            <summary>
            	The color MediumBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumOrchid">
            <summary>
            	The color MediumOrchid.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumPurple">
            <summary>
            	The color MediumPurple.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumSeaGreen">
            <summary>
            	The color MediumSeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumSlateBlue">
            <summary>
            	The color MediumSlateBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumSpringGreen">
            <summary>
            	The color MediumSpringGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumTurquoise">
            <summary>
            	The color MediumTurquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MediumVioletRed">
            <summary>
            	The color MediumVioletRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MidnightBlue">
            <summary>
            	The color MidnightBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MintCream">
            <summary>
            	The color MintCream.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.MistyRose">
            <summary>
            	The color MistyRose.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Moccasin">
            <summary>
            	The color Moccasin.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.NavajoWhite">
            <summary>
            	The color NavajoWhite.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Navy">
            <summary>
            	The color Navy.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.OldLace">
            <summary>
            	The color OldLace.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Olive">
            <summary>
            	The color Olive.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.OliveDrab">
            <summary>
            	The color OliveDrab.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Orange">
            <summary>
            	The color Orange.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.OrangeRed">
            <summary>
            	The color OrangeRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Orchid">
            <summary>
            	The color Orchid.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleGoldenrod">
            <summary>
            	The color PaleGoldenrod.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleGreen">
            <summary>
            	The color PaleGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleTurquoise">
            <summary>
            	The color PaleTurquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PaleVioletRed">
            <summary>
            	The color PaleVioletRed.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PapayaWhip">
            <summary>
            	The color PapayaWhip.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PeachPuff">
            <summary>
            	The color PeachPuff.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Peru">
            <summary>
            	The color Peru.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Pink">
            <summary>
            	The color Pink.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Plum">
            <summary>
            	The color Plum.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.PowderBlue">
            <summary>
            	The color PowderBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Purple">
            <summary>
            	The color Purple.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Red">
            <summary>
            	The color Red.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.RosyBrown">
            <summary>
            	The color RosyBrown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.RoyalBlue">
            <summary>
            	The color RoyalBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SaddleBrown">
            <summary>
            	The color SaddleBrown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Salmon">
            <summary>
            	The color Salmon.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SandyBrown">
            <summary>
            	The color SandyBrown.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SeaGreen">
            <summary>
            	The color SeaGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SeaShell">
            <summary>
            	The color SeaShell.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Sienna">
            <summary>
            	The color Sienna.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Silver">
            <summary>
            	The color Silver.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SkyBlue">
            <summary>
            	The color SkyBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SlateBlue">
            <summary>
            	The color SlateBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SlateGray">
            <summary>
            	The color SlateGray.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Snow">
            <summary>
            	The color Snow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SpringGreen">
            <summary>
            	The color SpringGreen.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.SteelBlue">
            <summary>
            	The color SteelBlue.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Tan">
            <summary>
            	The color Tan.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Teal">
            <summary>
            	The color Teal.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Thistle">
            <summary>
            	The color Thistle.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Tomato">
            <summary>
            	The color Tomato.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Turquoise">
            <summary>
            	The color Turquoise.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Violet">
            <summary>
            	The color Violet.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Wheat">
            <summary>
            	The color Wheat.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.White">
            <summary>
            	The color White.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.WhiteSmoke">
            <summary>
            	The color WhiteSmoke.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.Yellow">
            <summary>
            	The color Yellow.
            </summary>
        </member>
        <member name="P:Axiom.Core.ColorEx.YellowGreen">
            <summary>
            	The color YellowGreen.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.NodeRotationControllerValue">
            <summary>
            Summary description for NodeRotationControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.FrameTimeControllerValue">
            <summary>
            Summary description for FrameTimeControllerValue.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.FrameTimeControllerValue.frameTime">
            <summary>
            	Stores the value of the time elapsed since the last frame.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.FrameTimeControllerValue.timeFactor">
            <summary>
            	Float value that should be used to scale controller time.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.FrameTimeControllerValue.RenderSystem_FrameStarted(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	Event handler to the Frame Started event so that we can capture the
            	time since last frame to use for controller functions.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Controllers.FrameTimeControllerValue.Axiom#Controllers#IControllerValue#Value">
            <summary>
            	Gets a time scaled value to use for controller functions.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.FrameTimeControllerValue.TimeFactor">
            <summary>
            	Float value that should be used to scale controller time.  This could be used
            	to either speed up or slow down controller functions independent of slowing
            	down the render loop.
            </summary>
        </member>
        <member name="T:Axiom.Animating.SkeletalAnimBlendMode">
            <summary>
            	Used to specify how animations are applied to a skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletalAnimBlendMode.Average">
            <summary>
            	Animations are applied by calculating a weighted average of all animations.
             </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletalAnimBlendMode.Cumulative">
            <summary>
            	Animations are applied by calculating a weighted cumulative total.
            </summary>
        </member>
        <member name="T:Axiom.Math.PlaneBoundedVolume">
            <summary>
            	Represents a convex volume bounded by planes.
            </summary>
        </member>
        <member name="F:Axiom.Math.PlaneBoundedVolume.planes">
            <summary>
            	Publicly accessible plane list, you can modify this direct.
            </summary>
        </member>
        <member name="F:Axiom.Math.PlaneBoundedVolume.outside">
            <summary>
            	Side of the plane to be considered 'outside'.
            </summary>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.#ctor(Axiom.Math.PlaneSide)">
            <summary>
            	Constructor.
            </summary>
            <param name="outside">Side of the plane to be considered 'outside'.</param>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Intersection test with an <see cref="T:Axiom.Math.AxisAlignedBox"/>.
            </summary>
            <remarks>
            	May return false positives but will never miss an intersection.
            </remarks>
            <param name="box">Box to test.</param>
            <returns>True if interesecting, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.PlaneBoundedVolume.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Intersection test with <see cref="T:Axiom.Math.Sphere"/>.
            </summary>
            <param name="sphere">Sphere to test.</param>
            <returns>True if the sphere intersects this volume, and false otherwise.</returns>
        </member>
        <member name="T:Axiom.Graphics.TextureUnitState">
            <summary>
            	Class representing the state of a single texture unit during a Pass of a
            	Technique, of a Material.
            </summary>
            <remarks> 	
            	Texture units are pipelines for retrieving texture data for rendering onto
            	your objects in the world. Using them is common to both the fixed-function and 
            	the programmable (vertex and fragment program) pipeline, but some of the 
            	settings will only have an effect in the fixed-function pipeline (for example, 
            	setting a texture rotation will have no effect if you use the programmable
            	pipeline, because this is overridden by the fragment program). The effect
            	of each setting as regards the 2 pipelines is commented in each setting.
            	<p/>
            	When I use the term 'fixed-function pipeline' I mean traditional rendering
            	where you do not use vertex or fragment programs (shaders). Programmable 
            	pipeline means that for this pass you are using vertex or fragment programs.
            </remarks>
            TODO: Destroy controllers
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.MaxAnimationFrames">
            <summary>
               Maximum amount of animation frames allowed.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.parent">
            <summary>
               The parent Pass that owns this TextureUnitState.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.texCoordSet">
            <summary>
               Index of the texture coordinate set to use for texture mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.texAddressingMode">
            <summary>
               Addressing mode to use for texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorBlendMode">
            <summary>
               Reference to a class containing the color blending operation params for this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.alphaBlendMode">
            <summary>
               Reference to a class containing the alpha blending operation params for this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorBlendFallbackSrc">
            <summary>
               Fallback source blending mode, for use if the desired mode is not available.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorBlendFallbackDest">
            <summary>
               Fallback destination blending mode, for use if the desired mode is not available.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.colorOp">
            <summary>
               Operation to use (add, modulate, etc.) for color blending between stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isBlank">
            <summary>
               Is this a blank layer (i.e. no textures, or texture failed to load)?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isCubic">
            <summary>
               Is this a series of 6 2D textures to make up a cube?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.numFrames">
            <summary>
               Number of frames for this layer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.animDuration">
            <summary>
               Duration (in seconds) of the animated texture (if any).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.currentFrame">
            <summary>
               Index of the current frame of animation (always 0 for single texture stages).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.frames">
            <summary>
               Store names of textures for animation frames.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.recalcTexMatrix">
            <summary>
               Flag the determines if a recalc of the texture matrix is required, usually set after a rotate or
               other transformations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.transU">
            <summary>
               U coord of the texture transformation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.transV">
            <summary>
               V coord of the texture transformation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.scrollU">
            <summary>
               U coord of the texture scroll animation
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.scrollV">
            <summary>
               V coord of the texture scroll animation
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.scaleU">
            <summary>
               U scale value of the texture transformation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.scaleV">
            <summary>
               V scale value of the texture transformation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.rotate">
            <summary>
               Rotation value of the texture transformation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.texMatrix">
            <summary>
               4x4 texture matrix which gets updated based on various transformations made to this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.effectList">
            <summary>
               List of effects to apply during this texture stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.textureType">
            <summary>
               Type of texture this is.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.minFilter">
            <summary>
               Texture filtering - minification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.magFilter">
            <summary>
               Texture filtering - magnification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.mipFilter">
            <summary>
               Texture filtering - mipmapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.maxAnisotropy">
            <summary>
               Anisotropy setting for this stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isDefaultFiltering">
            <summary>
               Is the filtering level the default?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.isDefaultAniso">
            <summary>
               Is anisotropy the default?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.alphaRejectFunction">
            <summary>
               Function used to reject pixels based on alpha value.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.alphaRejectValue">
            <summary>
               Value against which alpha values will be tested.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.animController">
            <summary>
                Reference to an animation controller for this texture unit.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUnitState.environMap">
            <summary>
                Reference to the environment mapping type for this texunit.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.#ctor(Axiom.Graphics.Pass)">
            <summary>
            	Default constructor.
            </summary>
            <param name="parent">Parent Pass of this TextureUnitState.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.#ctor(Axiom.Graphics.Pass,System.String)">
            <summary>
            	Name based constructor.
            </summary>
            <param name="parent">Parent Pass of this texture stage.</param>
            <param name="textureName">Name of the texture for this texture stage.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.#ctor(Axiom.Graphics.Pass,System.String,System.Int32)">
            <summary>
            	Constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetProjectiveTexturing(System.Boolean,Axiom.Core.Frustum)">
            <summary>
               Enables or disables projective texturing on this texture unit.
            </summary>
            <remarks>
               <p>
               Projective texturing allows you to generate texture coordinates 
               based on a Frustum, which gives the impression that a texture is
               being projected onto the surface. Note that once you have called
               this method, the texture unit continues to monitor the Frustum you 
               passed in and the projection will change if you can alter it. It also
               means that the Frustum object you pass remains in existence for as long
               as this TextureUnitState does.
               </p>
               <p>
               This effect cannot be combined with other texture generation effects, 
               such as environment mapping. It also has no effect on passes which 
               have a vertex program enabled - projective texturing has to be done
               in the vertex program instead.
               </p>
            </remarks>
            <param name="enable">
               Whether to enable / disable
            </param>
            <param name="projectionSettings">
               The Frustum which will be used to derive the projection parameters.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.GetEffect(System.Int32)">
            <summary>
               Gets the texture effect at the specified index.
            </summary>
            <param name="index">Index of the texture effect to retrieve.</param>
            <returns>The TextureEffect at the specified index.</returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RemoveAllEffects">
            <summary>
               Removes all effects from this texture stage.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RemoveEffect(Axiom.Graphics.TextureEffect)">
            <summary>
               Removes the specified effect from the list of effects being applied during this
               texture stage.
            </summary>
            <param name="effect">Effect to remove.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOpMultipassFallback(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)">
            <summary>
               Sets the multipass fallback operation for this layer, if you used TextureUnitState.SetColorOperationEx
               and not enough multitexturing hardware is available.
            </summary>
            <remarks>
               Because some effects exposed using TextureUnitState.SetColorOperationEx are only supported under
               multitexturing hardware, if the hardware is lacking the system must fallback on multipass rendering,
               which unfortunately doesn't support as many effects. This method is for you to specify the fallback
               operation which most suits you.
               <p/>
               You'll notice that the interface is the same as the Material.SetSceneBlending method; this is
               because multipass rendering IS effectively scene blending, since each layer is rendered on top
               of the last using the same mechanism as making an object transparent, it's just being rendered
               in the same place repeatedly to get the multitexture effect.
               <p/>
               If you use the simpler (and hence less flexible) TextureUnitState.SetColorOperation method you
               don't need to call this as the system sets up the fallback for you.
               <p/>
               This option has no effect in the programmable pipeline, because there is no multipass fallback
               and multitexture blending is handled by the fragment shader.
            </remarks>
            <param name="src">How to apply the source color during blending.</param>
            <param name="dest">How to affect the destination color during blending.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Graphics.TextureUnitState.SetCubicTexture(System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Axiom.Graphics.TextureUnitState.SetCubicTexture(System.String[],System.Boolean)" -->
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperation(Axiom.Graphics.LayerBlendOperation)">
            <summary>
            	Determines how this texture layer is combined with the one below it (or the diffuse color of
            	the geometry if this is layer 0).
            </summary>
            <remarks>
               This method is the simplest way to blend tetxure layers, because it requires only one parameter,
               gives you the most common blending types, and automatically sets up 2 blending methods: one for
               if single-pass multitexturing hardware is available, and another for if it is not and the blending must
               be achieved through multiple rendering passes. It is, however, quite limited and does not expose
               the more flexible multitexturing operations, simply because these can't be automatically supported in
               multipass fallback mode. If want to use the fancier options, use <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,Axiom.Core.ColorEx,Axiom.Core.ColorEx,System.Single)"/>,
               but you'll either have to be sure that enough multitexturing units will be available, or you should
               explicitly set a fallback using <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOpMultipassFallback(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)"/>.
               <p/>
               The default method is LayerBlendOperation.Modulate for all layers.
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="operation">One of the LayerBlendOperation enumerated blending types.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,Axiom.Core.ColorEx,Axiom.Core.ColorEx,System.Single)">
            <summary>
               For setting advanced blending options.
            </summary>
            <remarks>
               This is an extended version of the <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOperation(Axiom.Graphics.LayerBlendOperation)"/> method which allows
               extremely detailed control over the blending applied between this and earlier layers.
               See the IMPORTANT note below about the issues between mulitpass and multitexturing that
               using this method can create.
               <p/>
               Texture color operations determine how the final color of the surface appears when
               rendered. Texture units are used to combine color values from various sources (ie. the
               diffuse color of the surface from lighting calculations, combined with the color of
               the texture). This method allows you to specify the 'operation' to be used, ie. the
               calculation such as adds or multiplies, and which values to use as arguments, such as
               a fixed value or a value from a previous calculation.
               <p/>
               The defaults for each layer are:
               <ul>
               <li>op = Modulate</li>
               <li>source1 = Texture</li>
               <li>source2 = Current</li>
               </ul>
               ie. each layer takes the color results of the previous layer, and multiplies them
               with the new texture being applied. Bear in mind that colors are RGB values from
               0.0 - 1.0 so multiplying them together will result in values in the same range,
               'tinted' by the multiply. Note however that a straight multiply normally has the
               effect of darkening the textures - for this reason there are brightening operations
               like ModulateX2. See the LayerBlendOperation and LayerBlendSource enumerated
               types for full details.
               <p/>
               Because of the limitations on some underlying APIs (Direct3D included)
               the Texture argument can only be used as the first argument, not the second.
               <p/>
               The final 3 parameters are only required if you decide to pass values manually
               into the operation, i.e. you want one or more of the inputs to the color calculation
               to come from a fixed value that you supply. Hence you only need to fill these in if
               you supply <code>Manual</code> to the corresponding source, or use the 
               <code>BlendManual</code> operation.
               <p/>
               The engine tries to use multitexturing hardware to blend texture layers
               together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a
               GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object
               multiple times with different textures. This is both less efficient and there is a smaller
               range of blending operations which can be performed. For this reason, if you use this method
               you MUST also call <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOpMultipassFallback(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)"/> to specify which effect you
               want to fall back on if sufficient hardware is not available.
               <p/>
               If you wish to avoid having to do this, use the simpler <see cref="M:Axiom.Graphics.TextureUnitState.SetColorOperation(Axiom.Graphics.LayerBlendOperation)"/> method
               which allows less flexible blending options but sets up the multipass fallback automatically,
               since it only allows operations which have direct multipass equivalents.
               <p/>
               This has no effect in the programmable pipeline.
            </remarks>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first color to the operation e.g. texture color.</param>
            <param name="source2">The source of the second color to the operation e.g. current surface color.</param>
            <param name="arg1">Manually supplied color value (only required if source1 = Manual).</param>
            <param name="arg2">Manually supplied color value (only required if source2 = Manual)</param>
            <param name="blendFactor">
               Manually supplied 'blend' value - only required for operations
               which require manual blend e.g. LayerBlendOperationEx.BlendManual
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first color to the operation e.g. texture color.</param>
            <param name="source2">The source of the second color to the operation e.g. current surface color.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetColorOperationEx(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,Axiom.Core.ColorEx)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first color to the operation e.g. texture color.</param>
            <param name="source2">The source of the second color to the operation e.g. current surface color.</param>
            <param name="arg1">Manually supplied color value (only required if source1 = Manual).</param>		
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAlphaOperation(Axiom.Graphics.LayerBlendOperationEx,Axiom.Graphics.LayerBlendSource,Axiom.Graphics.LayerBlendSource,System.Single,System.Single,System.Single)">
            <summary>
               Sets the alpha operation to be applied to this texture.
            </summary>
            <remarks>
               This works in exactly the same way as SetColorOperation, except
               that the effect is applied to the level of alpha (i.e. transparency)
               of the texture rather than its color. When the alpha of a texel (a pixel
               on a texture) is 1.0, it is opaque, wheras it is fully transparent if the
               alpha is 0.0. Please refer to the SetColorOperation method for more info.
            </remarks>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
            <param name="source1">The source of the first alpha value to the operation e.g. texture alpha.</param>
            <param name="source2">The source of the second alpha value to the operation e.g. current surface alpha.</param>
            <param name="arg1">Manually supplied alpha value (only required if source1 = LayerBlendSource.Manual).</param>
            <param name="arg2">Manually supplied alpha value (only required if source2 = LayerBlendSource.Manual).</param>
            <param name="blendFactor">Manually supplied 'blend' value - only required for operations
               which require manual blend e.g. LayerBlendOperationEx.BlendManual.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAlphaOperation(Axiom.Graphics.LayerBlendOperationEx)">
            <summary>
               Overloaded method.
            </summary>
            <param name="operation">The operation to be used, e.g. modulate (multiply), add, subtract.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetEnvironmentMap(System.Boolean)">
            <summary>
               Overloaded method.
            </summary>
            <param name="enable"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetEnvironmentMap(System.Boolean,Axiom.Graphics.EnvironmentMap)">
            <summary>
               Turns on/off texture coordinate effect that makes this layer an environment map.
            </summary>
            <remarks>
               Environment maps make an object look reflective by using the object's vertex normals relative
               to the camera view to generate texture coordinates.
               <p/>
               The vectors generated can either be used to address a single 2D texture which
               is a 'fish-eye' lens view of a scene, or a 3D cubic environment map which requires 6 textures
               for each side of the inside of a cube. The type depends on what texture you set up - if you use the
               setTextureName method then a 2D fisheye lens texture is required, whereas if you used setCubicTextureName
               then a cubic environemnt map will be used.
               <p/>
               This effect works best if the object has lots of gradually changing normals. The texture also
               has to be designed for this effect - see the example spheremap.png included with the sample
               application for a 2D environment map; a cubic map can be generated by rendering 6 views of a
               scene to each of the cube faces with orthoganal views.
               <p/>
               Enabling this disables any other texture coordinate generation effects.
               However it can be combined with texture coordinate modification functions, which then operate on the
               generated coordinates rather than static model texture coordinates.
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="enable">True to enable, false to disable.</param>
            <param name="envMap">
               If set to true, instead of being based on normals the environment effect is based on
               vertex positions. This is good for planar surfaces.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.GetFrameTextureName(System.Int32)">
            <summary>
               Gets the name of the texture associated with a frame.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="frame">Index of the frame to retreive the texture name for.</param>
            <returns>The name of the texture at the specified frame index.</returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.GetTextureFiltering(Axiom.Graphics.FilterType)">
            <summary>
               Gets the texture filtering for the given type.
            </summary>
            <param name="type">Type of filtering options to retreive.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAlphaRejectSettings(Axiom.Graphics.CompareFunction,System.Byte)">
            <summary>
               Sets the way the layer will have use alpha to totally reject pixels from the pipeline.
            </summary>
            <remarks>
               This option applies in both the fixed function and the programmable pipeline.
            </remarks>
            <param name="func">The comparison which must pass for the pixel to be written.</param>
            <param name="val">1 byte value against which alpha values will be tested(0-255).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAnimatedTextureName(System.String,System.Int32,System.Single)">
            <summary>
                Sets the names of the texture images for an animated texture.
            </summary>
            <remarks>
                Animated textures are just a series of images making up the frames of the animation. All the images
                must be the same size, and their names must have a frame number appended before the extension, e.g.
                if you specify a name of "wall.jpg" with 3 frames, the image names must be "wall_1.jpg" and "wall_2.jpg".
                <p/>
                You can change the active frame on a texture layer by setting the CurrentFrame property.
                <p/>
                Note: If you can't make your texture images conform to the naming standard layed out here, you
                can call the alternative SetAnimatedTextureName method which takes an array of names instead.
            </remarks>
            <param name="name">The base name of the series of textures to use.</param>
            <param name="numFrames">Number of frames to be used for this animation.</param>
            <param name="duration">
                Total length of the animation sequence.  When set to 0, automatic animation does not occur.
                In that scenario, the values can be changed manually by setting the CurrentFrame property.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetAnimatedTextureName(System.String[],System.Int32,System.Single)">
            <summary>
                Sets the names of the texture images for an animated texture.
            </summary>
            <remarks>
                Animated textures are just a series of images making up the frames of the animation. All the images
                must be the same size, and their names must have a frame number appended before the extension, e.g.
                if you specify a name of "wall.jpg" with 3 frames, the image names must be "wall_1.jpg" and "wall_2.jpg".
                <p/>
                You can change the active frame on a texture layer by setting the CurrentFrame property.
            </remarks>
            <param name="names">An array containing the array names to use for the animation.</param>
            <param name="numFrames">Number of frames to be used for this animation.</param>
            <param name="duration">
                Total length of the animation sequence.  When set to 0, automatic animation does not occur.
                In that scenario, the values can be changed manually by setting the CurrentFrame property.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScroll(System.Single,System.Single)">
            <summary>
               Sets the translation offset of the texture, ie scrolls the texture.
            </summary>
            <remarks>
               This method sets the translation element of the texture transformation, and is easier to use than setTextureTransform if
               you are combining translation, scaling and rotation in your texture transformation. Again if you want
               to animate these values you need to use a Controller
               <p/>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The amount the texture should be moved horizontally (u direction).</param>
            <param name="v">The amount the texture should be moved vertically (v direction).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScrollU(System.Single)">
            <summary>
               Same as in SetTextureScroll, but sets only U value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The amount the texture should be moved horizontally (u direction).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScrollV(System.Single)">
            <summary>
               Same as in SetTextureScroll, but sets only V value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="v">The amount the texture should be moved vertically (v direction).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetScrollAnimation(System.Single,System.Single)">
            <summary>
            	Sets up an animated scroll for the texture layer.
            </summary>
            <remarks>
               Useful for creating constant scrolling effects on a texture layer (for varying scrolls, <see cref="M:Axiom.Graphics.TextureUnitState.SetTransformAnimation(Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)"/>).
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="uSpeed">The number of horizontal loops per second (+ve=moving right, -ve = moving left).</param>
            <param name="vSpeed">The number of vertical loops per second (+ve=moving up, -ve= moving down).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetRotateAnimation(System.Single)">
            <summary>
            	Sets up an animated texture rotation for this layer.
            </summary>
            <remarks>
               Useful for constant rotations (for varying rotations, <see cref="!:setTransformAnimation"/>).
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="speed">The number of complete counter-clockwise revolutions per second (use -ve for clockwise)</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTransformAnimation(Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Sets up a general time-relative texture modification effect.
            </summary>
            <remarks>
               This can be called multiple times for different values of <paramref cref="!:transType"/>, but only the latest effect
               applies if called multiple time for the same <paramref cref="!:transType"/>.
               <p/>
               This option has no effect in the programmable pipeline.
            </remarks>
            <param name="transType">The type of transform, either translate (scroll), scale (stretch) or rotate (spin).</param>
            <param name="waveType">The shape of the wave, see <see cref="T:Axiom.Controllers.WaveformType"/> enum for details</param>
            <param name="baseVal">The base value for the function (range of output = {base, base + amplitude}).</param>
            <param name="frequency">The speed of the wave in cycles per second.</param>
            <param name="phase">The offset of the start of the wave, e.g. 0.5 to start half-way through the wave.</param>
            <param name="amplitude">Scales the output so that instead of lying within [0..1] it lies within [0..(1 * amplitude)] for exaggerated effects.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScale(System.Single,System.Single)">
            <summary>
               Sets the scaling factor of the texture.
            </summary>
            <remarks>
               This method sets the scale element of the texture transformation, and is easier to use than
               setTextureTransform if you are combining translation, scaling and rotation in your texture transformation. Again if you want
               to animate these values you need to use a Controller (see ControllerManager and it's methods for
               more information).
               <p/>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The value by which the texture is to be scaled horizontally.</param>
            <param name="v">The value by which the texture is to be scaled vertically.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScaleU(System.Single)">
            <summary>
               Same as in SetTextureScale, but sets only U value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="u">The value by which the texture is to be scaled horizontally.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureScaleV(System.Single)">
            <summary>
               Same as in SetTextureScale, but sets only V value.
            </summary>
            <remarks>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="v">The value by which the texture is to be scaled vertically.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureFiltering(Axiom.Graphics.TextureFiltering)">
            <summary>
               Set the texture filtering for this unit, using the simplified interface.
            </summary>
            <remarks>
               You also have the option of specifying the minification, magnification 
               and mip filter individually if you want more control over filtering 
               options. See the SetTextureFiltering overloads for details. 
               <p/>
               Note: This option applies in both the fixed function and programmable pipeline.
            </remarks>
            <param name="filter">
               The high-level filter type to use.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureFiltering(Axiom.Graphics.FilterType,Axiom.Graphics.FilterOptions)">
            <summary>
               Set a single filtering option on this texture unit.
            </summary>
            <param name="type">
               The filtering type to set.
            </param>
            <param name="options">
               The filtering options to set.
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureFiltering(Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions)">
            <summary>
               Set a the detailed filtering options on this texture unit.
            </summary>
            <param name="minFilter">
               The filtering to use when reducing the size of the texture. Can be Point, Linear or Anisotropic.
            </param>
            <param name="magFilter">
               The filtering to use when increasing the size of the texture. Can be Point, Linear or Anisotropic.
            </param>
            <param name="mipFilter">
               The filtering to use between mipmap levels. Can be None (no mipmap), Point or Linear (trilinear).
            </param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureName(System.String,Axiom.Graphics.TextureType)">
            <summary>
               Sets this texture layer to use a single texture, given the name of the texture to use on this layer.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="name">Name of the texture.</param>
            <param name="type">Type of texture this is.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureName(System.String)">
            <summary>
               Sets this texture layer to use a single texture, given the name of the texture to use on this layer.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
            <param name="name">Name of the texture.</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.SetTextureRotate(System.Single)">
            <summary>
               Sets the counter-clockwise rotation factor applied to texture coordinates.
            </summary>
            <remarks>
               This sets a fixed rotation angle - if you wish to animate this, see the
               <see cref="!:ControllerManager.CreateTextureRotater"/> method.
               <p/>
               Has no effect in the programmable pipeline.
            </remarks>
            <param name="degrees">The angle of rotation in degrees (counter-clockwise).</param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RecalcTextureMatrix">
            <summary>
            	Used to update the texture matrix if need be.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.AddEffect(Axiom.Graphics.TextureEffect)">
            <summary>
            	Generic method for setting up texture effects.
            </summary>
            <remarks>
               Allows you to specify effects directly by using the TextureEffectType enumeration. The
               arguments that go with it depend on the effect type. Only one effect of
               each type can be applied to a texture layer.
               <p/>
               This method is used internally, but it is better generally for applications to use the
               more intuitive specialized methods such as SetEnvironmentMap and SetScroll.
            </remarks>
            <param name="effect"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.RemoveEffect(Axiom.Graphics.TextureEffectType)">
            <summary>
            	Removes effects of the specified type from this layers effect list.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.CreateAnimationController">
            <summary>
                Creates an animation controller if needed for this texture unit.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.CreateEffectController(Axiom.Graphics.TextureEffect)">
            <summary>
            	Used internally to create a new controller for this layer given the requested effect.
            </summary>
            <param name="effect"></param>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.Load">
            <summary>
               Internal method for loading this texture stage as part of Material.Load.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.Unload">
            <summary>
               Internal method for unloading this object as part of Material.Unload.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.NotifyNeedsRecompile">
            <summary>
               Notifies the parent that it needs recompilation.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.CopyTo(Axiom.Graphics.TextureUnitState)">
            <summary>
            	Used to clone a texture layer.  Mainly used during a call to Clone on a Material.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.TextureUnitState.Clone(Axiom.Graphics.Pass)">
            <summary>
            	Used to clone a texture layer.  Mainly used during a call to Clone on a Material or Pass.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.AlphaBlendMode">
            <summary>
            	Gets a structure that describes the layer blending mode parameters.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.AlphaRejectFunction">
            <summary>
               Gets the alpha reject function. See <see cref="M:Axiom.Graphics.TextureUnitState.SetAlphaRejectSettings(Axiom.Graphics.CompareFunction,System.Byte)"/> for more information.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.AlphaRejectValue">
            <summary>
               Gets the alpha reject value. See <see cref="M:Axiom.Graphics.TextureUnitState.SetAlphaRejectSettings(Axiom.Graphics.CompareFunction,System.Byte)"/> for more information.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureAnisotropy">
            <summary>
               Gets/Sets the anisotropy level to be used for this texture stage.
            </summary>
            <remarks>
               This option applies in both the fixed function and the programmable pipeline.
            </remarks>
            <value>
               The maximal anisotropy level, should be between 2 and the maximum supported by hardware (1 is the default, ie. no anisotropy)
            </value>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ColorBlendMode">
            <summary>
            	Gets a structure that describes the layer blending mode parameters.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.HasViewRelativeTexCoordGen">
            <summary>
               Returns true if this texture unit requires an updated view matrix
               to allow for proper texture matrix generation.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureName">
            <summary>
            	Gets/Sets the name of the texture for this texture pass.
            </summary>
            <remarks>
               This will either always be a single name for this layer,
               or will be the name of the current frame for an animated
               or otherwise multi-frame texture.
               <p/>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureType">
            <summary>
               Gets the type of texture this unit has.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureCoordSet">
            <summary>
            	Gets/Sets the texture coordinate set to be used by this texture layer.
            </summary>
            <remarks>
            	Default is 0 for all layers. Only change this if you have provided multiple texture coords per
            	vertex.
            	<p/>
            	Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.TextureAddressing">
            <summary>
            	Gets/Sets the texture addressing mode, i.e. what happens at uv values above 1.0.
            </summary>
            <remarks>
               The default is <code>TextureAddressing.Wrap</code> i.e. the texture repeats over values of 1.0.
               This applies for both the fixed-function and programmable pipelines.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ColorBlendFallbackSource">
            <summary>
               Gets/Sets the multipass fallback for color blending operation source factor.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ColorBlendFallbackDest">
            <summary>
               Gets/Sets the multipass fallback for color blending operation destination factor.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.ColorOperation">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.Blank">
            <summary>
            	Gets/Sets whether this layer is blank or not.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.CurrentFrame">
            <summary>
            	Gets/Sets the active frame in an animated or multi-image texture.
            </summary>
            <remarks>
            	An animated texture (or a cubic texture where the images are not combined for 3D use) is made up of
            	a number of frames. This method sets the active frame.
            	<p/>
            	Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsBlank">
            <summary>
               Gets/Sets wether this texture layer is currently blank.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsCubic">
            <summary>
               Returns true if this texture unit is either a series of 6 2D textures, each 
               in it's own frame, or is a full 3D cube map. You can tell which by checking 
               TextureType. 
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.Is3D">
            <summary>
               Returns true if this texture layer uses a composite 3D cubic texture.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.IsLoaded">
            <summary>
               Returns true if the resource for this texture layer have been loaded.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.NumEffects">
            <summary>
               Gets the number of effects currently tied to this texture stage.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.NumFrames">
            <summary>
            	Gets the number of frames for a texture.
            </summary>
            <remarks>
               Applies to both fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.TextureUnitState.Parent">
            <summary>
               Gets a reference to the Pass that owns this TextureUnitState.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Graphics.TextureUnitState.TextureMatrix" -->
        <member name="T:Axiom.Graphics.LayerBlendModeEx">
            <summary>
            	Utility class for handling texture layer blending parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.op_Equality(Axiom.Graphics.LayerBlendModeEx,Axiom.Graphics.LayerBlendModeEx)">
            <summary>
            	Compares to blending modes for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.op_Inequality(Axiom.Graphics.LayerBlendModeEx,Axiom.Graphics.LayerBlendModeEx)">
            <summary>
            	Compares to blending modes for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.Clone">
            <summary>
            	Creates and returns a clone of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.Equals(System.Object)">
            <summary>
               Overide to use custom equality check.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.LayerBlendModeEx.GetHashCode">
            <summary>
               Override.
            </summary>
            <remarks>
               Overriden to quash warnings, not necessarily needed right now.
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.TextureEffect">
            <summary>
            	Class used to define parameters for a texture effect.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TextureEffect.Clone">
            <summary>
            	Returns a clone of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.SpotShadowFadePng">
            <summary>
            	This exists so we don't have to be dependent on an external .png file
            	for this core feature (PNG used to fade out the edges of spotlight shadows)
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetUpdateEventHandler">
            <summary>
               Delegate for RenderTarget update events.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ViewportUpdateEventHandler">
            <summary>
               Delegate for Viewport update events.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetUpdateEventArgs">
            <summary>
               Event arguments for render target updates.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ViewportUpdateEventArgs">
            <summary>
               Event arguments for viewport updates while processing a RenderTarget.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Rectangle2D">
            <summary>
            	Allows the rendering of a simple 2D rectangle
            	This class renders a simple 2D rectangle; this rectangle has no depth and
            	therefore is best used with specific render queue and depth settings,
            	like <see cref="F:Axiom.Core.RenderQueueGroupID.Background"/> and 'depth_write off' for backdrops, and 
            	<see cref="F:Axiom.Core.RenderQueueGroupID.Overlay"/> and 'depth_check off' for fullscreen quads.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Rectangle2D.SetCorners(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the corners of the rectangle, in relative coordinates.
            </summary>
            <param name="left">Left position in screen relative coordinates, -1 = left edge, 1.0 = right edge.</param>
            <param name="top">Top position in screen relative coordinates, 1 = top edge, -1 = bottom edge.</param>
            <param name="right">Position in screen relative coordinates.</param>
            <param name="bottom">Position in screen relative coordinates.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.MaterialManager" -->
        <member name="T:Axiom.Core.ResourceManager">
            <summary>
            	Defines a generic resource handler.
            </summary>
            <remarks>
            	A resource manager is responsible for managing a pool of
            	resources of a particular type. It must index them, look
            	them up, load and destroy them. It may also need to stay within
            	a defined memory budget, and temporaily unload some resources
            	if it needs to to stay within this budget.
            	<p/>
            	Resource managers use a priority system to determine what can
            	be unloaded, and a Least Recently Used (LRU) policy within
            	resources of the same priority.
            </remarks>
        </member>
        <member name="F:Axiom.Core.ResourceManager.resourceList">
            <summary>
            	A cached list of all resources in memory.
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.filePaths">
            <summary>
            	A lookup table used to find a common archive associated with a filename.
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.archives">
            <summary>
            	A cached list of archives specific to a resource type.
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.commonFilePaths">
            <summary>
            	A lookup table used to find a archive associated with a filename.
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.commonArchives">
            <summary>
            	A cached list of archives common to all resource types.
            </summary>
        </member>
        <member name="F:Axiom.Core.ResourceManager.nextHandle">
            <summary>
            	Next available handle to assign to a new resource.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Add(Axiom.Core.Resource)">
            <summary>
            	Add a resource to this manager; normally only done by subclasses.
            </summary>
            <param name="resource">Resource to add.</param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Create(System.String)">
            <summary>
            	Creates a new blank resource, compatible with this manager.
            </summary>
            <remarks>
            	Resource managers handle disparate types of resources. This method returns a pointer to a
            	valid new instance of the kind of resource managed here. The caller should  complete the
            	details of the returned resource and call ResourceManager.Load to load the resource. Note
            	that it is the CALLERS responsibility to destroy this object when it is no longer required
            	(after calling ResourceManager.Unload if it had been loaded).
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.GetNextHandle">
            <summary>
                Gets the next available unique resource handle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Load(Axiom.Core.Resource,System.Int32)">
            <summary>
            	Loads a resource.  Resource will be subclasses of Resource.
            </summary>
            <param name="resource">Resource to load.</param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Unload(Axiom.Core.Resource)">
            <summary>
            	Unloads a Resource from the managed resources list, calling it's Unload() method.
            </summary>
            <remarks>
            	This method removes a resource from the list maintained by this manager, and unloads it from
            	memory. It does NOT destroy the resource itself, although the memory used by it will be largely
            	freed up. This would allow you to reload the resource again if you wished. 
            </remarks>
            <param name="resource"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.UnloadAndDestroyAll">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddSearchPath(System.String)">
            <summary>
            	Adds a relative path to search for resources of this type.
            </summary>
            <remarks>
            	This method adds the supplied path to the list of relative locations that that will be searched for
            	a single type of resource only. Each subclass of ResourceManager will maintain it's own list of
            	specific subpaths, which it will append to the current path as it searches for matching files.
            </remarks>
            <param name="path"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddCommonSearchPath(System.String)">
            <summary>
            	Adds a relative search path for resources of ALL types.
            </summary>
            <remarks>
            	This method has the same effect as ResourceManager.AddSearchPath, except that the path added
            	applies to ALL resources, not just the one managed by the subclass in question.
            </remarks>
            <param name="path"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddArchive(System.String,System.String)">
            <summary>
            	Adds an archive to 
            </summary>
            <param name="name"></param>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.AddCommonArchive(System.String,System.String)">
            <summary>
            	Adds an archive to 
            </summary>
            <param name="name"></param>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Core.ResourceManager.GetByHandle(System.Int32)">
            <summary>
            	Gets a resource with the given handle.
            </summary>
            <param name="handle">Handle of the resource to retrieve.</param>
            <returns>A reference to a Resource with the given handle.</returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.GetByName(System.String)">
            <summary>
               Gets a reference to the specified named resource.
            </summary>
            <param name="name">Name of the resource to retreive.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.CheckUsage">
            <summary>
            	Makes sure we are still within budget.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceManager.FindResourceData(System.String)">
            <summary>
            	Locates resource data within the archives known to the ResourceManager.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.FindCommonResourceData(System.String)">
            <summary>
            	Locates resource data within the archives known to the ResourceManager.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ResourceManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Core.ResourceManager.MemoryBudget">
            <summary>
            	Sets a limit on the amount of memory this resource handler may use.	
            </summary>
            <remarks>
            	If, when asked to load a new resource, the manager believes it will exceed this memory
            	budget, it will temporarily unload a resource to make room for the new one. This unloading
            	is not permanent and the Resource is not destroyed; it simply needs to be reloaded when
            	next used.
            </remarks>
        </member>
        <member name="P:Axiom.Core.ResourceManager.MemoryUsage">
            <summary>
            	Gets/Sets the current memory usages by all resource managers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager.defaultMinFilter">
            <summary>
                Default Texture filtering - minification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager.defaultMagFilter">
            <summary>
                Default Texture filtering - magnification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager.defaultMipFilter">
            <summary>
                Default Texture filtering - mipmapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager.defaultMaxAniso">
            <summary>
                Default Texture anisotropy.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.MaterialManager.serializer">
            <summary>
            	Used for parsing material scripts.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.Initialize">
            <summary>
                Sets up default materials and parses all material scripts.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.SetDefaultTextureFiltering(Axiom.Graphics.TextureFiltering)">
            <summary>
                Sets the default texture filtering to be used for loaded textures, for when textures are
                loaded automatically (e.g. by Material class) or when 'load' is called with the default
                parameters by the application.
            </summary>
            <param name="options">Default options to use.</param>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.SetDefaultTextureFiltering(Axiom.Graphics.FilterType,Axiom.Graphics.FilterOptions)">
            <summary>
                Sets the default texture filtering to be used for loaded textures, for when textures are
                loaded automatically (e.g. by Material class) or when 'load' is called with the default
                parameters by the application.
            </summary>
            <param name="type">Type to configure.</param>
            <param name="options">Options to set for the specified type.</param>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.SetDefaultTextureFiltering(Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions)">
            <summary>
                Sets the default texture filtering to be used for loaded textures, for when textures are
                loaded automatically (e.g. by Material class) or when 'load' is called with the default
                parameters by the application.
            </summary>
            <param name="minFilter">Minification filter.</param>
            <param name="magFilter">Magnification filter.</param>
            <param name="mipFilter">Map filter.</param>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.GetDefaultTextureFiltering(Axiom.Graphics.FilterType)">
            <summary>
                Gets the default texture filtering options for the specified filter type.
            </summary>
            <param name="type">Filter type to get options for.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.ParseAllSources(System.String)">
            <summary>
            	Look for material scripts in all known sources and parse them.
            </summary>
            <param name="extension">Extension to parse (i.e. ".material").</param>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.GetByName(System.String)">
            <summary>
            	Gets a material with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.Create(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.Load(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.MaterialManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.MaterialManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.MaterialManager.DefaultAnisotropy">
            <summary>
               Sets the default anisotropy level to be used for loaded textures, for when textures are
               loaded automatically (e.g. by Material class) or when 'Load' is called with the default
               parameters by the application.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferStream">
            <summary>
                This class is intended to allow a clean stream interface for writing to hardware buffers.
                An instance of this would be returned by one of the HardwareBuffer.Lock methods, which would
                allow easily and safely writing to a hardware buffer without having to use unsafe code.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.position">
            <summary>
            	Current position (as a byte offset) into the stream.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.data">
            <summary>
                Pointer to the raw data we will be writing to.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.owner">
            <summary>
                Reference to the hardware buffer who owns this stream.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferStream.tmp">
            <summary>
                Temp array.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.#ctor(Axiom.Graphics.HardwareBuffer,System.IntPtr)">
            <summary>
                Constructor.
            </summary>
            <param name="owner">Reference to the hardware buffer who owns this stream.</param>
            <param name="data">Pointer to the raw data we will be writing to.</param>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Write(System.Array,System.Int32,System.Int32)">
            <summary>
                
            </summary>
            <param name="val"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Seek(System.Int64)">
            <summary>
                Moves the "cursor" position within the buffer.
            </summary>
            <param name="offset">Offset (in bytes) to move from the current position.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.BufferStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
                Moves the "cursor" position within the buffer.
            </summary>
            <param name="offset">Number of bytes to move.</param>
            <param name="origin">How to treat the offset amount.</param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.BufferStream.Length">
            <summary>
                Length (in bytes) of this stream.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.BufferStream.Position">
            <summary>
                Current position of the stream.
            </summary>
        </member>
        <member name="T:Axiom.Core.LogManager">
            <summary>
            Summary description for LogManager.
            </summary>
        </member>
        <member name="F:Axiom.Core.LogManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.LogManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Core.LogManager.logList">
            <summary>
                List of logs created by the log manager.
            </summary>
        </member>
        <member name="F:Axiom.Core.LogManager.defaultLog">
            <summary>
                The default log to which output is done.
            </summary>
        </member>
        <member name="M:Axiom.Core.LogManager.CreateLog(System.String)">
            <summary>
                Creates a new log with the given name.
            </summary>
            <param name="name">Name to give to the log, i.e. "Axiom.log"</param>
            <returns>A newly created Log object, opened and ready to go.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.CreateLog(System.String,System.Boolean)">
            <summary>
                Creates a new log with the given name.
            </summary>
            <param name="name">Name to give to the log, i.e. "Axiom.log"</param>
            <param name="defaultLog">
                If true, this is the default log output will be
                sent to if the generic logging methods on this class are
                used. The first log created is always the default log unless
                this parameter is set.
            </param>
            <returns>A newly created Log object, opened and ready to go.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.CreateLog(System.String,System.Boolean,System.Boolean)">
            <summary>
                Creates a new log with the given name.
            </summary>
            <param name="name">Name to give to the log, i.e. "Axiom.log"</param>
            <param name="defaultLog">
                If true, this is the default log output will be
                sent to if the generic logging methods on this class are
                used. The first log created is always the default log unless
                this parameter is set.
            </param>
            <param name="debuggerOutput">
                If true, output to this log will also be routed to <see cref="T:System.Diagnostics.Debug"/>
                Not only will this show the messages into the debugger, but also allows you to hook into
                it using a custom TraceListener to receive message notification wherever you want.
            </param>
            <returns>A newly created Log object, opened and ready to go.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.GetLog(System.String)">
            <summary>
                Retrieves a log managed by this class.
            </summary>
            <param name="name">Name of the log to retrieve.</param>
            <returns>Log with the specified name.</returns>
        </member>
        <member name="M:Axiom.Core.LogManager.Write(System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to 
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.LogManager.Write(System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to 
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.LogManager.Write(Axiom.Core.LogMessageLevel,System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <param name="level">Importance of this logged message.</param>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to 
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.LogManager.Dispose">
            <summary>
                Destroys all the logs owned by the log manager.
            </summary>
        </member>
        <member name="P:Axiom.Core.LogManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Core.LogManager.DefaultLog">
            <summary>
                Gets/Sets the default log to use for writing.
            </summary>
            <value></value>
        </member>
        <member name="P:Axiom.Core.LogManager.LogDetail">
            <summary>
                Sets the level of detail of the default log.
            </summary>
        </member>
        <member name="T:Axiom.Collections.BoneCollection">
            <summary>
            Summary description for AnimationCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.BoneCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.BoneCollection.Add(Axiom.Animating.Bone)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.BoneCollection.Add(System.UInt16,Axiom.Animating.Bone)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.BoneCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.BoneCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializer">
            <summary>
            	Class for serialising mesh data to/from an OGRE .mesh file.
            </summary>
            <remarks>
            	This class allows exporters to write OGRE .mesh files easily, and allows the
            	OGRE engine to import .mesh files into instatiated OGRE Meshes.
            	<p/>
            	It's important to realize that this exporter uses OGRE terminology. In this context,
            	'Mesh' means a top-level mesh structure which can actually contain many SubMeshes, each
            	of which has only one Material. Modelling packages may refer to these differently, for
            	example in Milkshape, it says 'Model' instead of 'Mesh' and 'Mesh' instead of 'SubMesh', 
            	but the theory is the same.
            </remarks>
        </member>
        <member name="T:Axiom.Serialization.Serializer">
            <summary>
            Summary description for Serializer.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Serializer.ChunkOverheadSize">
            <summary>
            	Chunk ID + size (short + long).
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Serializer.version">
            <summary>
            	Version string of this serializer.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.Serializer.currentChunkLength">
            <summary>
            	Length of the chunk that is currently being processed.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.IgnoreCurrentChunk(System.IO.BinaryReader)">
            <summary>
            	Skips past a particular chunk.
            </summary>
            <remarks>
            	Only really used during development, when logic for handling particular chunks is not yet complete.
            </remarks>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadBytes(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of floats and copies them into the destination pointer.
            </summary>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadFloats(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of floats and copies them into the destination pointer.
            </summary>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadFloats(System.IO.BinaryReader,System.Int32,System.IntPtr,System.Single[])">
            <summary>
            	Reads a specified number of shorts and copies them into the destination pointer.
            </summary>
            <remarks>This overload will also copy the values into the specified destination array.</remarks>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
            <param name="destArray">A float array that is to have the values copied into it at the same time as 'dest'.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadInts(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of integers and copies them into the destination pointer.
            </summary>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadShorts(System.IO.BinaryReader,System.Int32,System.IntPtr)">
            <summary>
            	Reads a specified number of shorts and copies them into the destination pointer.
            </summary>
            <param name="count">Number of values to read.</param>
            <param name="dest">Pointer to copy the values into.</param>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadString(System.IO.BinaryReader)">
            <summary>
            	Reads from the stream up to the first endline character.
            </summary>
            <returns>A string formed from characters up to the first '\n' character.</returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadString(System.IO.BinaryReader,System.Char)">
            <summary>
            	Reads from the stream up to the specified delimiter character.
            </summary>
            <param name="delimiter">The character that signals the end of the string.</param>
            <returns>A string formed from characters up to the first instance of the specified delimeter.</returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadQuat(System.IO.BinaryReader)">
            <summary>
               Reads and returns a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadVector3(System.IO.BinaryReader)">
            <summary>
               Reads and returns a Vector3 structure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadVector4(System.IO.BinaryReader)">
            <summary>
               Reads and returns a Vector4 structure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadChunk(System.IO.BinaryReader)">
            <summary>
            	Reads a chunk ID and chunk size.
            </summary>
            <returns>The chunk ID at the current location.</returns>
        </member>
        <member name="M:Axiom.Serialization.Serializer.ReadFileHeader(System.IO.BinaryReader)">
            <summary>
            	Reads a file header and checks the version string.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.Serializer.Seek(System.IO.BinaryReader,System.Int64,System.IO.SeekOrigin)">
            <summary>
            	Skips to a particular part of the binary stream.
            </summary>
            <param name="length">Number of bytes to skip.</param>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializer.implementations">
            <summary>
            	Lookup table holding the various mesh serializer versions.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializer.currentVersion">
            <summary>
            	Current version string.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializer.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializer.ExportMesh(Axiom.Core.Mesh,System.String)">
            <summary>
            	Exports a mesh to the file specified.
            </summary>
            <param name="mesh">Reference to the mesh to export.</param>
            <param name="fileName">The destination filename.</param>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializer.ImportMesh(System.IO.Stream,Axiom.Core.Mesh)">
            <summary>
            	Imports mesh data from a .mesh file.
            </summary>
            <param name="stream">The stream holding the .mesh data. Must be initialised (pos at the start of the buffer).</param>
            <param name="mesh">Reference to the Mesh object which will receive the data. Should be blank already.</param>
        </member>
        <member name="T:Axiom.Scripting.CommandAttribute">
            <summary>
            	Summary description for CommandAttribute.
            </summary>
        </member>
        <member name="F:Axiom.Scripting.CommandAttribute.name">
            <summary>
               Name of the command the target class will be registered to handle.
            </summary>
        </member>
        <member name="F:Axiom.Scripting.CommandAttribute.description">
            <summary>
               Description of what this command does.
            </summary>
        </member>
        <member name="F:Axiom.Scripting.CommandAttribute.target">
            <summary>
               Target type this class is meant to handle commands for.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.CommandAttribute.#ctor(System.String,System.String,System.Type)">
            <summary>
               Constructor.
            </summary>
            <param name="name"></param>
            <param name="description"></param>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Scripting.CommandAttribute.#ctor(System.String,System.String)">
            <summary>
               Constructor.
            </summary>
            <param name="name"></param>
            <param name="description"></param>
        </member>
        <member name="M:Axiom.Scripting.CommandAttribute.#ctor(System.String)">
            <summary>
               Constructor.
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:Axiom.Scripting.CommandAttribute.Name">
            <summary>
               Name of this command.
            </summary>
        </member>
        <member name="P:Axiom.Scripting.CommandAttribute.Description">
            <summary>
               Optional description of what this command does.
            </summary>
        </member>
        <member name="P:Axiom.Scripting.CommandAttribute.Target">
            <summary>
               Optional target to specify what object type this command affects.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Overlay">
            <summary>
               Represents a layer which is rendered on top of the 'normal' scene contents.
            </summary>
            <remarks>
               An overlay is a container for visual components (2D and 3D) which will be 
               rendered after the main scene in order to composite heads-up-displays, menus
               or other layers on top of the contents of the scene.
               <p/>
               An overlay always takes up the entire size of the viewport, although the 
               components attached to it do not have to. An overlay has no visual element
               in itself, it it merely a container for visual elements.
               <p/>
               Overlays are created by calling SceneManager.CreateOverlay, or by defining them
               in special text scripts (.overlay files). As many overlays
               as you like can be defined; after creation an overlay is hidden i.e. not
               visible until you specifically enable it by calling Show(). This allows you to have multiple
               overlays predefined (menus etc) which you make visible only when you want.
               It is possible to have multiple overlays enabled at once; in this case the
               relative ZOrder parameter of the overlays determine which one is displayed
               on top.
               <p/>
               By default overlays are rendered into all viewports. This is fine when you only
               have fullscreen viewports, but if you have picture-in-picture views, you probably
               don't want the overlay displayed in the smaller viewports. You turn this off for 
               a specific viewport by calling the Viewport.DisplayOverlays property.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.Resource" -->
        <member name="F:Axiom.Core.Resource.name">
            <summary>
            	Name of this resource.
            </summary>
        </member>
        <member name="F:Axiom.Core.Resource.isLoaded">
            <summary>
            	Has this resource been loaded yet?
            </summary>
        </member>
        <member name="F:Axiom.Core.Resource.size">
            <summary>
            	 Size (in bytes) that this resource takes up in memory.
            </summary>
        </member>
        <member name="F:Axiom.Core.Resource.lastAccessed">
            <summary>
            	Timestamp of the last time this resource was accessed.
            </summary>
        </member>
        <member name="F:Axiom.Core.Resource.handle">
            <summary>
            	Unique handle of this resource.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.#ctor">
            <summary>
            	Default constructor.
            </summary>
            <remarks>Subclasses must initialize name and size.</remarks>
        </member>
        <member name="M:Axiom.Core.Resource.Load">
            <summary>
            	Loads the resource, if not loaded already.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.Unload">
            <summary>
            	Unloads the resource data, but retains enough info. to be able to recreate it
            	on demand.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.Touch">
            <summary>
            	Indicates this resource has been used.
            </summary>
        </member>
        <member name="M:Axiom.Core.Resource.Dispose">
            <summary>
            	Dispose method.  Made virtual to allow subclasses to destroy resources their own way.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Size">
            <summary>
            	Size of this resource.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Name">
            <summary>
            	Name of this resource.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.IsLoaded">
            <summary>
            	Is this resource loaded?
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.LastAccessed">
            <summary>
            	The time the resource was last touched.
            </summary>
        </member>
        <member name="P:Axiom.Core.Resource.Handle">
            <summary>
            	Gets/Sets the unique handle of this resource.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.rootNode">
            <summary>
            Internal root node, used as parent for 3D objects
            </summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.elementList">
            <summary>2D element list.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.rotate">
            <summary>Degrees of rotation around center.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scrollX">
            <summary>Scroll values, offsets.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scrollY">
            <summary>Scroll values, offsets.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scaleX">
            <summary>Scale values.</summary>
        </member>
        <member name="F:Axiom.Overlays.Overlay.scaleY">
            <summary>Scale values.</summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.#ctor(System.String)">
            <summary>
               Constructor: do not call direct, use SceneManager.CreateOverlay
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.AddElement(Axiom.Overlays.OverlayElementContainer)">
            <summary>
               Adds a 2d element to this overlay.
            </summary>
            <remarks>
               Containers are created and managed using the GuiManager. A container
               could be as simple as a square panel, or something more complex like
               a grid or tree view. Containers group collections of other elements,
               giving them a relative coordinate space and a common z-order.
               If you want to attach a gui widget to an overlay, you have to do it via
               a container.
            </remarks>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.AddElement(Axiom.Core.SceneNode)">
            <summary>
               Adds a node capable of holding 3D objects to the overlay.
            </summary>
            <remarks>
               Although overlays are traditionally associated with 2D elements, there 
               are reasons why you might want to attach 3D elements to the overlay too.
               For example, if you wanted to have a 3D cockpit, which was overlaid with a
               HUD, then you would create 2 overlays, one with a 3D object attached for the
               cockpit, and one with the HUD elements attached (the zorder of the HUD 
               overlay would be higher than the cockpit to ensure it was always on top).
               <p/>
               A SceneNode can have any number of 3D objects attached to it. SceneNodes
               are created using SceneManager.CreateSceneNode, and are normally attached 
               (directly or indirectly) to the root node of the scene. By attaching them
               to an overlay, you indicate that:<OL>
               <LI>You want the contents of this node to only appear when the overlay is active</LI>
               <LI>You want the node to inherit a coordinate space relative to the camera,
               rather than relative to the root scene node</LI>
               <LI>You want these objects to be rendered after the contents of the main scene
               to ensure they are rendered on top</LI>
               </OL>
               One major consideration when using 3D objects in overlays is the behavior of 
               the depth buffer. Overlays are rendered with depth checking off, to ensure
               that their contents are always displayed on top of the main scene (to do 
               otherwise would result in objects 'poking through' the overlay). The problem
               with using 3D objects is that if they are concave, or self-overlap, then you
               can get artifacts because of the lack of depth buffer checking. So you should 
               ensure that any 3D objects you us in the overlay are convex and don't overlap
               each other. If they must overlap, split them up and put them in 2 overlays.
            </remarks>
            <param name="node"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Clear">
            <summary>
               Clears the overlay of all attached items.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.FindVisibleObjects(Axiom.Core.Camera,Axiom.Graphics.RenderQueue)">
            <summary>
               Internal method to put the overlay contents onto the render queue.
            </summary>
            <param name="camera">Current camera being used in the render loop.</param>
            <param name="queue">Current render queue.</param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.FindElementAt(System.Single,System.Single)">
            <summary>
            This returns a OverlayElement at position x,y.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Overlay.GetChild(System.String)">
            <summary>
               Gets a child container of this overlay by name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.Overlay.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
               Used to transform the overlay when scrolling, scaling etc.
            </summary>
            <param name="xform">Array of Matrix4s to populate with the world 
               transforms of this overlay.
            </param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Hide">
            <summary>
               Hides this overlay if it is currently being displayed.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Rotate(System.Single)">
            <summary>
               Adds the passed in angle to the rotation applied to this overlay.
            </summary>
            <param name="degress"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Scroll(System.Single,System.Single)">
            <summary>
               Scrolls the overlay by the offsets provided.
            </summary>
            <remarks>
               This method moves the overlay by the amounts provided. As with
               other methods on this object, a full screen width / height is represented
               by the value 1.0.
            </remarks>
            <param name="xOffset"></param>
            <param name="yOffset"></param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.SetScale(System.Single,System.Single)">
            <summary>
               Sets the scaling factor of this overlay.
            </summary>
            <remarks>
               You can use this to set an scale factor to be used to zoom an overlay.
            </remarks>
            <param name="x">Horizontal scale value, where 1.0 = normal, 0.5 = half size etc</param>
            <param name="y">Vertical scale value, where 1.0 = normal, 0.5 = half size etc</param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.SetScroll(System.Single,System.Single)">
            <summary>
               Sets the scrolling factor of this overlay.
            </summary>
            <remarks>
               You can use this to set an offset to be used to scroll an 
               overlay around the screen.
            </remarks>
            <param name="x">
               Horizontal scroll value, where 0 = normal, -0.5 = scroll so that only
               the right half the screen is visible etc
            </param>
            <param name="y">
               Vertical scroll value, where 0 = normal, 0.5 = scroll down by half 
               a screen etc.
            </param>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Show">
            <summary>
               Shows this overlay if it is not already visible.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.UpdateTransforms">
            <summary>
               Internal lazy update method.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Load">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Unload">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Overlay.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.IsVisible">
            <summary>
               Gets whether this overlay is being displayed or not.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.Origin">
             <summary>
             Get the origin of this overlay, e.g. a script file name.
             </summary>
             <remarks>
             This property will only contain something if the creator of
             this overlay chose to populate it. Script loaders are advised
             to populate it.
            </remarks>
        </member>
        <member name="P:Axiom.Overlays.Overlay.Rotation">
            <summary>
               Gets/Sets the rotation applied to this overlay, in degrees.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScaleX">
            <summary>
               Gets the current x scale value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScaleY">
            <summary>
               Gets the current y scale value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScrollX">
            <summary>
               Gets the current x scroll value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ScrollY">
            <summary>
               Gets the  current y scroll value.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Overlay.ZOrder">
            <summary>
               Z ordering of this overlay. Valid values are between 0 and 600.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.MetricsMode">
            <summary>
            	Describes how the position / size of an element is to be treated. 
            </summary>
        </member>
        <member name="F:Axiom.Overlays.MetricsMode.Relative">
            <summary>'left', 'top', 'height' and 'width' are parametrics from 0.0 to 1.0</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Overlays.MetricsMode.Pixels" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Overlays.MetricsMode.Relative_Aspect_Adjusted" -->
        <member name="T:Axiom.Overlays.HorizontalAlignment">
            <summary>
            	Describes where '0' is in relation to the parent in the horizontal dimension.  Affects how 'left' is interpreted.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.HorizontalAlignment.Left">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.HorizontalAlignment.Center">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.HorizontalAlignment.Right">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Overlays.VerticalAlignment">
            <summary>
            	Describes where '0' is in relation to the parent in the vertical dimension.  Affects how 'top' is interpreted.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.VerticalAlignment.Top">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.VerticalAlignment.Center">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Overlays.VerticalAlignment.Bottom">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Media.CodecManager">
            <summary>
               Manages registering/fulfilling requests for codecs that handle various types of media.
            </summary>
        </member>
        <member name="F:Axiom.Media.CodecManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Media.CodecManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Media.CodecManager.codecs">
            <summary>
               List of registered media codecs.
            </summary>
        </member>
        <member name="M:Axiom.Media.CodecManager.RegisterCodecs">
            <summary>
                Register all default IL image codecs.
            </summary>
        </member>
        <member name="M:Axiom.Media.CodecManager.RegisterCodec(Axiom.Media.ICodec)">
            <summary>
               Registers a new codec that can handle a particular type of media files.
            </summary>
            <param name="codec"></param>
        </member>
        <member name="M:Axiom.Media.CodecManager.GetCodec(System.String)">
            <summary>
               Gets the codec registered for the passed in file extension.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Media.CodecManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.PatchSurface">
            <summary>
                A surface which is defined by curves of some kind to form a patch, e.g. a Bezier patch.
            </summary>
            <remarks>
                This object will take a list of control points with various assorted data, and will
                subdivide it into a patch mesh. Currently only Bezier curves are supported for defining
                the surface, but other techniques such as NURBS would follow the same basic approach.
            </remarks>
        </member>
        <member name="F:Axiom.Core.PatchSurface.AUTO_LEVEL">
            <summary>
                Constant for indicating automatic determination of subdivision level for patches.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.declaration">
            <summary>
                Vertex declaration describing the control point buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlPointBuffer">
            <summary>
                Buffer containing the system-memory control points.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.type">
            <summary>
                Type of surface.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlWidth">
            <summary>
                Width in control points.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlHeight">
            <summary>
                Height in control points.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlCount">
            <summary>
                Total number of control level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.uLevel">
            <summary>
                U-direction subdivision level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.vLevel">
            <summary>
               V-direction subdivision level. 
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.maxULevel">
            <summary>
                Max U subdivision level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.maxVLevel">
            <summary>
                Max V subdivision level.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.meshWidth">
            <summary>
                Width of the subdivided mesh (big enough for max level).
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.meshHeight">
            <summary>
                Height of the subdivided mesh (big enough for max level).
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.side">
            <summary>
                Which side is visible.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.subdivisionFactor">
            <summary>
                Mesh subdivision factor.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchSurface.controlPoints">
            <summary>
                List of control points.
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.#ctor">
            <summary>
                Default contructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)">
            <summary>
                Sets up the surface by defining it's control points, type and initial subdivision level.
            </summary>
            <remarks>
                This method initialises the surface by passing it a set of control points. The type of curves to be used
                are also defined here, although the only supported option currently is a bezier patch. You can also
                specify a global subdivision level here if you like, although it is recommended that the parameter
                is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the
                curvature of the surface).
            </remarks>
            <param name="controlPoints">
                A pointer to a buffer containing the vertex data which defines control points 
                of the curves rather than actual vertices. Note that you are expected to provide not
                just position information, but potentially normals and texture coordinates too. The
                format of the buffer is defined in the VertexDeclaration parameter.
            </param>
            <param name="decl">
                VertexDeclaration describing the contents of the buffer. 
                Note this declaration must _only_ draw on buffer source 0!
            </param>
            <param name="width">Specifies the width of the patch in control points.</param>
            <param name="height">Specifies the height of the patch in control points.</param>
            <param name="type">The type of surface.</param>
            <param name="uMaxSubdivisionLevel">
                If you want to manually set the top level of subdivision, 
                do it here, otherwise let the system decide.
            </param>
            <param name="vMaxSubdivisionLevel">
                If you want to manually set the top level of subdivision, 
                do it here, otherwise let the system decide.
            </param>
            <param name="side">Determines which side of the patch (or both) triangles are generated for.</param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32)">
            <summary>
                Sets up the surface by defining it's control points, type and initial subdivision level.
            </summary>
            <remarks>
                This method initialises the surface by passing it a set of control points. The type of curves to be used
                are also defined here, although the only supported option currently is a bezier patch. You can also
                specify a global subdivision level here if you like, although it is recommended that the parameter
                is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the
                curvature of the surface).
            </remarks>
            <param name="controlPoints">
                A pointer to a buffer containing the vertex data which defines control points 
                of the curves rather than actual vertices. Note that you are expected to provide not
                just position information, but potentially normals and texture coordinates too. The
                format of the buffer is defined in the VertexDeclaration parameter.
            </param>
            <param name="decl">
                VertexDeclaration describing the contents of the buffer. 
                Note this declaration must _only_ draw on buffer source 0!
            </param>
            <param name="width">Specifies the width of the patch in control points.</param>
            <param name="height">Specifies the height of the patch in control points.</param>
            <param name="type">The type of surface.</param>
            <param name="uMaxSubdivision">
                If you want to manually set the top level of subdivision, 
                do it here, otherwise let the system decide.
            </param>
            <param name="vMaxSubdivision">
                If you want to manually set the top level of subdivision, 
                do it here, otherwise let the system decide.
            </param>
            <param name="side">Determines which side of the patch (or both) triangles are generated for.</param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.Build(Axiom.Graphics.HardwareVertexBuffer,System.Int32,Axiom.Graphics.HardwareIndexBuffer,System.Int32)">
            <summary>
                Tells the system to build the mesh relating to the surface into externally created buffers.
            </summary>
            <remarks>
                The VertexDeclaration of the vertex buffer must be identical to the one passed into
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)"/>.  In addition, there must be enough space in the buffer to 
                accommodate the patch at full detail level; you should check <see cref="P:Axiom.Core.PatchSurface.RequiredVertexCount"/>
                and <see cref="P:Axiom.Core.PatchSurface.RequiredIndexCount"/> to determine this. This method does not create an internal
                mesh for this patch and so GetMesh will return null if you call it after building the
                patch this way.
            </remarks>
            <param name="destVertexBuffer">The destination vertex buffer in which to build the patch.</param>
            <param name="vertexStart">The offset at which to start writing vertices for this patch.</param>
            <param name="destIndexBuffer">The destination index buffer in which to build the patch.</param>
            <param name="indexStart">The offset at which to start writing indexes for this patch.</param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.FindLevel(Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Math.Vector3@)">
            <summary>
                Internal method for finding the subdivision level given 3 control points.
            </summary>
            <param name="a">First control point.</param>
            <param name="b">Second control point.</param>
            <param name="c">Third control point.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.PatchSurface.DistributeControlPoints(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="lockedBuffer"></param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.SubdivideCurve(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="lockedBuffer"></param>
            <param name="startIdx"></param>
            <param name="stepSize"></param>
            <param name="numSteps"></param>
            <param name="iterations"></param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.InterpolateVertexData(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
                
            </summary>
            <param name="lockedBuffer"></param>
            <param name="leftIndex"></param>
            <param name="rightIndex"></param>
            <param name="destIndex"></param>
        </member>
        <member name="M:Axiom.Core.PatchSurface.MakeTriangles">
            <summary>
                
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoULevel">
            <summary>
            
            </summary>
            <param name="forMax"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoULevel(System.Boolean)">
            <summary>
            
            </summary>
            <param name="forMax"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoVLevel">
            <summary>
            
            </summary>
            <param name="forMax"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.PatchSurface.GetAutoVLevel(System.Boolean)">
            <summary>
            
            </summary>
            <param name="forMax"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.PatchSurface.RequiredVertexCount">
            <summary>
                Based on a previous call to <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)"/>, establishes the number of vertices required
                to hold this patch at the maximum detail level. 
            </summary>
            <remarks>
                This is useful when you wish to build the patch into external vertex / index buffers.
            </remarks>
        </member>
        <member name="P:Axiom.Core.PatchSurface.RequiredIndexCount">
            <summary>
                Based on a previous call to <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)"/>, establishes the number of indexes required
                to hold this patch at the maximum detail level. 
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.CurrentIndexCount">
            <summary>
                Gets the current index count based on the current subdivision level.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.IndexOffset">
            <summary>
                Returns the index offset used by this buffer to write data into the buffer.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.VertexOffset">
            <summary>
                Returns the vertex offset used by this buffer to write data into the buffer.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.Bounds">
            <summary>
                Gets the bounds of this patch, only valid after calling <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)"/>.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.BoundingSphereRadius">
            <summary>
                Gets the radius of the bounding sphere for this patch, only valid after <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)"/> 
                has been called.
            </summary>
        </member>
        <member name="P:Axiom.Core.PatchSurface.SubdivisionFactor">
            <summary>
                Gets/Sets the level of subdivision for this surface.
            </summary>
            <remarks>
                This method changes the proportionate detail level of the patch; since
                the U and V directions can have different subdivision levels, this property
                takes a single float value where 0 is the minimum detail (the control points)
                and 1 is the maximum detail level as supplied to the original call to 
                <see cref="M:Axiom.Core.PatchSurface.DefineSurface(System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,Axiom.Core.PatchSurfaceType,System.Int32,System.Int32,Axiom.Core.VisibleSide)"/>.
            </remarks>
        </member>
        <member name="P:Axiom.Core.PatchSurface.ControlPointBuffer">
            <summary>
                Gets the control point buffer being used for this patch surface.
            </summary>
        </member>
        <member name="T:Axiom.Core.VisibleSide">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Core.VisibleSide.Front">
            <summary>
                The side from which u goes right and v goes up (as in texture coords).
            </summary>
        </member>
        <member name="F:Axiom.Core.VisibleSide.Back">
            <summary>
                The side from which u goes right and v goes down (reverse of texture coords).
            </summary>
        </member>
        <member name="F:Axiom.Core.VisibleSide.Both">
            <summary>
                Both sides are visible - warning this creates 2x the number of triangles and adds 
                extra overhead for calculating normals.
            </summary>
        </member>
        <member name="T:Axiom.Core.PatchSurfaceType">
            <summary>
                A patch defined by a set of bezier curves.
            </summary>
        </member>
        <member name="T:Axiom.Core.Memory">
            <summary>
            	Utility class for dealing with memory.
            </summary>
        </member>
        <member name="M:Axiom.Core.Memory.#ctor">
            <summary>
                Don't want instances of this created.
            </summary>
        </member>
        <member name="M:Axiom.Core.Memory.Copy(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            	Method for copying data from one IntPtr to another.
            </summary>
            <param name="src">Source pointer.</param>
            <param name="dest">Destination pointer.</param>
            <param name="length">Length of data (in bytes) to copy.</param>
        </member>
        <member name="M:Axiom.Core.Memory.Copy(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            	Method for copying data from one IntPtr to another.
            </summary>
            <param name="src">Source pointer.</param>
            <param name="dest">Destination pointer.</param>
            <param name="srcOffset">Offset at which to copy from the source pointer.</param>
            <param name="destOffset">Offset at which to begin copying to the destination pointer.</param>
            <param name="length">Length of data (in bytes) to copy.</param>
        </member>
        <member name="M:Axiom.Core.Memory.Set(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Sets the memory to 0 starting at the specified offset for the specified byte length.
            </summary>
            <param name="dest">Destination pointer.</param>
            <param name="offset">Byte offset to start.</param>
            <param name="length">Number of bytes to set.</param>
        </member>
        <member name="T:Axiom.Core.Log">
            <summary>
                Log class for writing debug/log data to files.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.LogThreshold">
            <summary>
                LogMessageLevel + LoggingLevel > LOG_THRESHOLD = message logged.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.log">
            <summary>
                File stream used for kepping the log file open.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.writer">
            <summary>
                Writer used for writing to the log file.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.logLevel">
            <summary>
                Level of detail for this log.
            </summary>
        </member>
        <member name="F:Axiom.Core.Log.debugOutput">
            <summary>
                Debug output enabled?
            </summary>
        </member>
        <member name="M:Axiom.Core.Log.#ctor(System.String)">
            <summary>
                Constructor.  Creates a log file that also logs debug output.
            </summary>
            <param name="fileName">Name of the log file to open.</param>
        </member>
        <member name="M:Axiom.Core.Log.#ctor(System.String,System.Boolean)">
            <summary>
                Constructor.
            </summary>
            <param name="fileName">Name of the log file to open.</param>
            <param name="debugOutput">Write log messages to the debug output?</param>
        </member>
        <member name="M:Axiom.Core.Log.Write(System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to 
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.Log.Write(System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <remarks>
                Message is written with a LogMessageLevel of Normal, and debug output is not written.
            </remarks>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to 
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.Log.Write(Axiom.Core.LogMessageLevel,System.Boolean,System.String,System.Object[])">
            <summary>
                Write a message to the log.
            </summary>
            <param name="level">Importance of this logged message.</param>
            <param name="maskDebug">If true, debug output will not be written.</param>
            <param name="message">Message to write, which can include string formatting tokens.</param>
            <param name="substitutions">
                When message includes string formatting tokens, these are the values to 
                inject into the formatted string.
            </param>
        </member>
        <member name="M:Axiom.Core.Log.Dispose">
            <summary>
                Called to dispose of this objects resources.
            </summary>
            <remarks>
                For the log, closes any open file streams and file writers.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Log.LogDetail">
            <summary>
                Gets/Sets the level of the detail for this log.
            </summary>
            <value></value>
        </member>
        <member name="T:Axiom.Core.Frustum">
            <summary>
                A frustum represents a pyramid, capped at the near and far end which is
                used to represent either a visible area or a projection area. Can be used
                for a number of applications.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.InfiniteFarPlaneAdjust">
            <summary>
            	Small constant used to reduce far plane projection to avoid inaccuracies.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.InfiniteFarPlaneDistance">
            <summary>
            	Arbitrary large distance to use for the far plane when set to 0 (infinite far plane).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.projectionType">
            <summary>
            	Perspective or Orthographic?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.fieldOfView">
            <summary>
                y-direction field-of-view (default 45).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.farDistance">
            <summary>
                Far clip distance - default 10000.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.nearDistance">
            <summary>
                Near clip distance - default 100.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.aspectRatio">
            <summary>
                x/y viewport ratio - default 1.3333
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.planes">
            <summary>
                The 6 main clipping planes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.lastParentOrientation">
            <summary>
                Stored versions of parent orientation.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.lastParentPosition">
            <summary>
                Stored versions of parent position.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.projectionMatrix">
            <summary>
                Pre-calced projection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.standardProjMatrix">
            <summary>
                Pre-calced standard projection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.viewMatrix">
            <summary>
                Pre-calced view matrix.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.recalculateFrustum">
            <summary>
                Something's changed in the frustum shape?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.recalculateView">
            <summary>
                Something in the view pos has changed?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.boundingBox">
            <summary>
                Bounding box of this frustum.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.vertexData">
            <summary>
                Vertex info for rendering this frustum.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.material">
            <summary>
                Material to use when rendering this frustum.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.worldSpaceCorners">
            <summary>
            	Frustum corners in world space.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.coeffL">
            Temp coefficient values calculated from a frustum change,
                        used when establishing the frustum planes when the view changes. 
        </member>
        <member name="F:Axiom.Core.Frustum.isReflected">
            <summary>
            	Is this frustum to act as a reflection of itself?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.reflectionMatrix">
            <summary>
            	Derive reflection matrix.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.reflectionPlane">
            <summary>
            	Fixed reflection.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.linkedReflectionPlane">
            <summary>
            	Reference of a reflection plane (automatically updated).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.lastLinkedReflectionPlane">
            <summary>
            	Record of the last world-space reflection plane info used.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.useObliqueDepthProjection">
            <summary>
            	Is this frustum using an oblique depth projection?
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.obliqueProjPlane">
            <summary>
            	Fixed oblique projection plane.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.linkedObliqueProjPlane">
            <summary>
            	Reference to oblique projection plane (automatically updated).
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.lastLinkedObliqueProjPlane">
            <summary>
            	Record of the last world-space oblique depth projection plane info used.
            </summary>
        </member>
        <member name="F:Axiom.Core.Frustum.dummyLightList">
            <summary>
                Dummy list for IRenderable.Lights since we wont be lit.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.DisableCustomNearClipPlane">
            <summary>
            	Disables any custom near clip plane.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.DisableReflection">
            <summary>
                Disables reflection modification previously turned on with <see cref="M:Axiom.Core.Frustum.EnableReflection(Axiom.Math.Plane)"/>.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableCustomNearClipPlane(Axiom.Graphics.MovablePlane)">
            <summary>
            	Links the frustum to a custom near clip plane, which can be used
            	to clip geometry in a custom manner without using user clip planes.
            </summary>
            <remarks>
            	<p>
            	There are several applications for clipping a scene arbitrarily by
            	a single plane; the most common is when rendering a reflection to 
            	a texture, and you only want to render geometry that is above the 
            	water plane (to do otherwise results in artefacts). Whilst it is
            	possible to use user clip planes, they are not supported on all
            	cards, and sometimes are not hardware accelerated when they are
            	available. Instead, where a single clip plane is involved, this
            	technique uses a 'fudging' of the near clip plane, which is 
            	available and fast on all hardware, to perform as the arbitrary
            	clip plane. This does change the shape of the frustum, leading 
            	to some depth buffer loss of precision, but for many of the uses of
            	this technique that is not an issue.</p>
            	<p>
            	This version of the method links to a plane, rather than requiring
            	a by-value plane definition, and therefore you can 
            	make changes to the plane (e.g. by moving / rotating the node it is
            	attached to) and they will automatically affect this object.
            	</p>
            	<p>This technique only works for perspective projection.</p>
            </remarks>
            <param name="plane">The plane to link to to perform the clipping.</param>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableCustomNearClipPlane(Axiom.Math.Plane)">
            <summary>
            	Links the frustum to a custom near clip plane, which can be used
            	to clip geometry in a custom manner without using user clip planes.
            </summary>
            <remarks>
            	<p>
            	There are several applications for clipping a scene arbitrarily by
            	a single plane; the most common is when rendering a reflection to 
            	a texture, and you only want to render geometry that is above the 
            	water plane (to do otherwise results in artefacts). Whilst it is
            	possible to use user clip planes, they are not supported on all
            	cards, and sometimes are not hardware accelerated when they are
            	available. Instead, where a single clip plane is involved, this
            	technique uses a 'fudging' of the near clip plane, which is 
            	available and fast on all hardware, to perform as the arbitrary
            	clip plane. This does change the shape of the frustum, leading 
            	to some depth buffer loss of precision, but for many of the uses of
            	this technique that is not an issue.</p>
            	<p>
            	This version of the method links to a plane, rather than requiring
            	a by-value plane definition, and therefore you can 
            	make changes to the plane (e.g. by moving / rotating the node it is
            	attached to) and they will automatically affect this object.
            	</p>
            	<p>This technique only works for perspective projection.</p>
            </remarks>
            <param name="plane">The plane to link to to perform the clipping.</param>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableReflection(Axiom.Math.Plane)">
            <summary>
                Modifies this camera so it always renders from the reflection of itself through the
                plane specified.
            </summary>
            <remarks>
                This is obviously useful for rendering planar reflections.
            </remarks>
            <param name="plane"></param>
        </member>
        <member name="M:Axiom.Core.Frustum.EnableReflection(Axiom.Graphics.MovablePlane)">
            <summary>
            	Modifies this frustum so it always renders from the reflection of itself through the
            	plane specified. Note that this version of the method links to a plane
            	so that changes to it are picked up automatically.
            </summary>
            <remarks>This is obviously useful for performing planar reflections.</remarks>
            <param name="plane"></param>
        </member>
        <member name="M:Axiom.Core.Frustum.GetPositionForViewUpdate">
            <summary>
            	Get the derived position of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.GetOrientationForViewUpdate">
            <summary>
            	Get the derived orientation of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.AxisAlignedBox,Axiom.Core.FrustumPlane@)">
            <summary>
            	Tests whether the given box is visible in the Frustum.
             </summary>
            <param name="box"> Bounding box to be checked.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Sphere)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Sphere,Axiom.Core.FrustumPlane@)">
            <summary>
            	Tests whether the given sphere is in the viewing frustum.
            </summary>
            <param name="sphere">Bounding sphere to be checked.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Vector3)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Frustum.IsObjectVisible(Axiom.Math.Vector3,Axiom.Core.FrustumPlane@)">
            <summary>
            	Tests whether the given 3D point is in the viewing frustum.
            </summary>
            <param name="vector">3D point to check for frustum visibility.</param>
            <param name="culledBy">
            	Optional FrustrumPlane params which will be filled by the plane which culled
            	the box if the result was false.
            </param>
            <returns>True if the box is visible, otherwise false.</returns>
        </member>
        <member name="M:Axiom.Core.Frustum.InvalidateFrustum">
            <summary>
                Signal to update frustum information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.InvalidateView">
            <summary>
                Signal to update view information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.UpdateFrustum">
            <summary>
            	Updates the frustum data.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.UpdateView">
            <summary>
            	Updates the view matrix.
            </summary>
        </member>
        <member name="M:Axiom.Core.Frustum.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.Frustum.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
                Implemented to add outself to the rendering queue.
            </summary>
            <param name="queue"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Core.Frustum.FOV" -->
        <member name="P:Axiom.Core.Frustum.Near">
            <summary>
            	Gets/Sets the position of the near clipping plane.
            </summary>
            <remarks>
            	The position of the near clipping plane is the distance from the cameras position to the screen
            	on which the world is projected. The near plane distance, combined with the field-of-view and the
            	aspect ratio, determines the size of the viewport through which the world is viewed (in world
            	co-ordinates). Note that this world viewport is different to a screen viewport, which has it's
            	dimensions expressed in pixels. The cameras viewport should have the same aspect ratio as the
            	screen viewport it renders into to avoid distortion.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.Far">
            <summary>
            	Gets/Sets the distance to the far clipping plane.
             </summary>
             <remarks>
            	The view frustrum is a pyramid created from the camera position and the edges of the viewport.
            	This frustrum does not extend to infinity - it is cropped near to the camera and there is a far
            	plane beyond which nothing is displayed. This method sets the distance for the far plane. Different
            	applications need different values: e.g. a flight sim needs a much further far clipping plane than
            	a first-person shooter. An important point here is that the larger the gap between near and far
            	clipping planes, the lower the accuracy of the Z-buffer used to depth-cue pixels. This is because the
            	Z-range is limited to the size of the Z buffer (16 or 32-bit) and the max values must be spread over
            	the gap between near and far clip planes. The bigger the range, the more the Z values will
            	be approximated which can cause artifacts when lots of objects are close together in the Z-plane. So
            	make sure you clip as close to the camera as you can - don't set a huge value for the sake of
            	it.
            </remarks>
            <value>
            	The distance to the far clipping plane from the frustum in 
            	world coordinates.  If you specify 0, this means an infinite view
            	distance which is useful especially when projecting shadows; but
            	be careful not to use a near distance too close.
            </value>
        </member>
        <member name="P:Axiom.Core.Frustum.AspectRatio">
            <summary>
            	Gets/Sets the aspect ratio to use for the camera viewport.
            </summary>
            <remarks>
            	The ratio between the x and y dimensions of the rectangular area visible through the camera
            	is known as aspect ratio: aspect = width / height .
            	<p/>
            	The default for most fullscreen windows is 1.3333f - this is also assumed unless you
            	use this property to state otherwise.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.ProjectionMatrix">
            <summary>
            Gets the projection matrix for this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ViewMatrix">
            <summary>
                Gets the view matrix for this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ProjectionType">
            <summary>
               Gets/Sets the type of projection to use (orthographic or perspective). Default is perspective.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.IsFrustumOutOfDate">
            <summary>
            	Evaluates whether or not the view frustum is out of date.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.IsReflected">
            <summary>
                Gets a flag that specifies whether this camera is being reflected or not.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.IsViewOutOfDate">
            <summary>
            	Gets whether or not the view matrix is out of date.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ReflectionMatrix">
            <summary>
                Returns the reflection matrix of the camera if appropriate.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.ReflectionPlane">
            <summary>
                Returns the reflection plane of the camera if appropriate.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.StandardProjectionMatrix">
            <summary>
               Gets the 'standard' projection matrix for this camera, ie the 
               projection matrix which conforms to standard right-handed rules.
            </summary>
            <remarks>
               This differs from the rendering-API dependent ProjectionMatrix
               in that it always returns a right-handed projection matrix result 
               no matter what rendering API is being used - this is required for
               vertex and fragment programs for example. However, the resulting depth
               range may still vary between render systems since D3D uses [0,1] and 
               GL uses [-1,1], and the range must be kept the same between programmable
               and fixed-function pipelines.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Frustum.Item(Axiom.Core.FrustumPlane)">
            <summary>
            	An indexer that accepts a FrustumPlane enum value and return the appropriate plane side of the Frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.BoundingRadius">
            <summary>
               Local bounding radius of this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.BoundingBox">
            <summary>
                Returns the bounding box for this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.Material">
            <summary>
                Returns the material to use when rendering this frustum.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.Technique">
            <summary>
                Just returns the best technique for our material.
            </summary>
        </member>
        <member name="P:Axiom.Core.Frustum.Lights">
            <summary>
                Returns a dummy list since we won't be lit.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.TexCoordModifierControllerValue">
            <summary>
            Summary description for TexCoordModifierControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Collections.SubEntityCollection">
            <summary>
            Summary description for SubEntityCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SubEntityCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SubEntityCollection.Add(Axiom.Core.SubEntity)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.SubEntityCollection.Add(System.String,Axiom.Core.SubEntity)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.SubEntityCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.SubEntityCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.EntityList">
            <summary>
            Summary description for EntityCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.EntityList.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.EntityList.Add(Axiom.Core.Entity)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.EntityList.Add(System.String,Axiom.Core.Entity)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.EntityList.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.EntityList.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.OgreSkeletonReader">
            <summary>
            	Summary description for OgreSkeletonReader.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadAnimation">
            <summary>
               Reads animation information from the file.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadAnimationTrack(Axiom.Animating.Animation)">
            <summary>
               Reads an animation track.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadBone">
            <summary>
               Reads bone information from the file.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadBoneParent">
            <summary>
               Reads bone information from the file.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadChunk">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadFileHeader">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadKeyFrame(Axiom.Animating.AnimationTrack)">
            <summary>
               Reads an animation track section.
            </summary>
            <param name="track"></param>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadQuat">
            <summary>
               Reads and returns a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.ReadVector3">
            <summary>
               Reads and returns a Vector3 structure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Serialization.OgreSkeletonReader.Seek(System.Int64)">
            <summary>
               Moves forward (or backward if negative length is supplied) in the file.
            </summary>
            <param name="length"></param>
        </member>
        <member name="T:Axiom.Serialization.SkeletonChunkID">
            <summary>
               Chunk ID's that can be found within the Ogre .skeleton format.
            </summary>
        </member>
        <member name="T:Axiom.Math.Ray">
            <summary>
            	Representation of a ray in space, ie a line with an origin and direction.
            </summary>
        </member>
        <member name="M:Axiom.Math.Ray.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Math.Ray.#ctor(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
               Constructor.
            </summary>
            <param name="origin">Starting point of the ray.</param>
            <param name="direction">Direction the ray is pointing.</param>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
               Tests whether this ray intersects the given box.
            </summary>
            <param name="box"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.Plane)">
            <summary>
            	Tests whether this ray intersects the given plane. 
            </summary>
            <param name="plane"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Tests whether this ray intersects the given sphere. 
            </summary>
            <param name="sphere"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.Intersects(Axiom.Math.PlaneBoundedVolume)">
            <summary>
            	Tests whether this ray intersects the given PlaneBoundedVolume. 
            </summary>
            <param name="volume"></param>
            <returns>
            	Struct containing info on whether there was a hit, and the distance from the 
            	origin of this ray where the intersect happened.
            </returns>
        </member>
        <member name="M:Axiom.Math.Ray.op_Multiply(Axiom.Math.Ray,System.Single)">
            <summary>
               Gets the position of a point t units along the ray.
            </summary>
            <param name="ray"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Ray.Origin">
            <summary>
               Gets/Sets the origin of the ray.
            </summary>
        </member>
        <member name="P:Axiom.Math.Ray.Direction">
            <summary>
               Gets/Sets the direction this ray is pointing.
            </summary>
            <remarks>
               A ray has no length, so the direction goes to infinity.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.RenderPriorityGroup">
            <summary>
            	IRenderables in the queue grouped by priority.
            </summary>
            <remarks>
            	This class simply groups renderables for rendering. All the 
            	renderables contained in this class are destined for the same
            	RenderQueueGroup (coarse groupings like those between the main
            	scene and overlays) and have the same priority (fine groupings
            	for detailed overlap control).
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPasses">
            <summary>
            	Solid pass list, used when no shadows, modulative shadows, or ambient passes for additive.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPassesDiffuseSpecular">
            <summary>
            	Solid per-light pass list, used with additive shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPassesDecal">
            <summary>
            	Solid decal (texture) pass list, used with additive shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.solidPassesNoShadow">
            <summary>
            	Solid pass list, used when shadows are enabled but shadow receive is turned off for these passes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderPriorityGroup.splitPassesByLightingType">
            <summary>
            	Should passes be split by their lighting stage?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.#ctor(System.Boolean,System.Boolean)">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddRenderable(Axiom.Graphics.IRenderable)">
            <summary>
            	Add a renderable to this group.
            </summary>
            <param name="renderable">Renderable to add to the queue.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddSolidRenderable(Axiom.Graphics.Technique,Axiom.Graphics.IRenderable,System.Boolean)">
            <summary>
            	Internal method for adding a solid renderable
            </summary>
            <param name="technique">Technique to use for this renderable.</param>
            <param name="renderable">Renderable to add to the queue.</param>
            <param name="noShadows">True to add to the no shadow group, false otherwise.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddSolidRenderableSplitByLightType(Axiom.Graphics.Technique,Axiom.Graphics.IRenderable)">
            <summary>
            	Internal method for adding a solid renderable ot the group based on lighting stage.
            </summary>
            <param name="technique">Technique to use for this renderable.</param>
            <param name="renderable">Renderable to add to the queue.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.AddTransparentRenderable(Axiom.Graphics.Technique,Axiom.Graphics.IRenderable)">
            <summary>
            	Internal method for adding a transparent renderable.
            </summary>
            <param name="technique">Technique to use for this renderable.</param>
            <param name="renderable">Renderable to add to the queue.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.Clear">
            <summary>
            	Clears all the internal lists.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.GetSolidPass(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.GetSolidPassRenderables(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.GetTransparentPass(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.Sort(Axiom.Core.Camera)">
            <summary>
               Sorts the objects which have been added to the queue; transparent objects by their 
               depth in relation to the passed in Camera, solid objects in order to minimize
               render state changes.
            </summary>
            <remarks>
               Solid passes are already stored in a sorted structure, so nothing extra needed here.
            </remarks>
            <param name="camera">Current camera to use for depth sorting.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderPriorityGroup.RemoveSolidPassEntry(Axiom.Graphics.Pass)">
            <summary>
            	Remove a pass entry from all solid pass maps
            </summary>
            <param name="pass">Reference to the pass to remove.</param>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.NumSolidPasses">
            <summary>
               Gets the number of non-transparent passes for this priority group.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.NumTransparentPasses">
            <summary>
               Gets the number of transparent passes for this priority group.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.SplitPassesByLightingType">
            <summary>
            	Gets/Sets whether or not the queue will split passes by their lighting type,
            	ie ambient, per-light and decal. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderPriorityGroup.SplitNoShadowPasses">
            <summary>
            	Gets/Sets whether or not the queue will split passes which have shadow receive
            	turned off (in their parent material), which is needed when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderPriorityGroup.SolidSort">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderPriorityGroup.TransparencySort">
            <summary>
            	Nested class that implements IComparer for transparency sorting.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HighLevelGpuProgram">
            <summary>
            	Abstract base class representing a high-level program (a vertex or
            	fragment program).
            </summary>
            <remarks>
               High-level programs are vertex and fragment programs written in a high-level
               language such as Cg or HLSL, and as such do not require you to write assembler code
               like GpuProgram does. However, the high-level program does eventually 
               get converted (compiled) into assembler and then eventually microcode which is
               what runs on the GPU. As well as the convenience, some high-level languages like Cg allow
               you to write a program which will operate under both Direct3D and OpenGL, something
               which you cannot do with just GpuProgram (which requires you to write 2 programs and
               use each in a Technique to provide cross-API compatibility). The engine will be creating
               a GpuProgram for you based on the high-level program, which is compiled specifically 
               for the API being used at the time, but this process is transparent.
               <p/>
               You cannot create high-level programs direct - use HighLevelGpuProgramManager instead.
               Plugins can register new implementations of HighLevelGpuProgramFactory in order to add
               support for new languages without requiring changes to the core engine API. To allow 
               custom parameters to be set, this class implement IConfigurable - the application
               can query on the available custom parameters and get/set them without having to 
               link specifically with it.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.GpuProgram">
            <summary>
            	Defines a program which runs on the GPU such as a vertex or fragment program.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.fileName">
            <summary>
               The name of the file to load from source (may be blank).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.source">
            <summary>
               The assembler source of this program.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.loadFromFile">
            <summary>
               Whether this source is being loaded from file or not.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.syntaxCode">
            <summary>
               Syntax code (i.e. arbvp1, vs_2_0, etc.)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.type">
            <summary>
               Type of program this represents (vertex or fragment).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.isSkeletalAnimationSupported">
            <summary>
            	Flag indicating whether this program is being used for hardware skinning.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.defaultParams">
            <summary>
            	List of default parameters, as gathered from the program definition.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgram.passSurfaceAndLightStates">
            <summary>
            	Does this program want light states passed through fixed pipeline?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.#ctor(System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Constructor for creating
            </summary>
            <param name="name"></param>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.CreateParameters">
            <summary>
               Creates a new parameters object compatible with this program definition.
            </summary>
            <remarks>
               It is recommended that you use this method of creating parameters objects
               rather than going direct to GpuProgramManager, because this method will
               populate any implementation-specific extras (like named parameters) where
               they are appropriate.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.Load">
            <summary>
               Loads this Gpu Program.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgram.LoadFromSource">
            <summary>
               Method which must be implemented by subclasses, loads the program from source.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.BindingDelegate">
            <summary>
               Returns the GpuProgram which should be bound to the pipeline.
            </summary>
            <remarks>
               This method is simply to allow some subclasses of GpuProgram to delegate
               the program which is bound to the pipeline to a delegate, if required.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsSkeletalAnimationIncluded">
            <summary>
            	Gets/Sets whether a vertex program includes the required instructions
            	to perform skeletal animation. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.IsSupported">
            <summary>
               Returns whether this program can be supported on the current renderer and hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.PassSurfaceAndLightStates">
            <summary>
            	Sets whether a vertex program requires light and material states to be passed
            	to through fixed pipeline low level API rendering calls.
            </summary>
            <remarks>
            	If this is set to true, Axiom will pass all active light states to the fixed function
            	pipeline.  This is useful for high level shaders like GLSL that can read the OpenGL
            	light and material states.  This way the user does not have to use autoparameters to 
            	pass light position, color etc.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.Source">
            <summary>
               Gets/Sets the source assembler code for this program.
            </summary>
            <remarks>
               Setting this will have no effect until you (re)load the program.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.SourceFile">
            <summary>
               Gets/Sets the source file for this program.
            </summary>
            <remarks>
               Setting this will have no effect until you (re)load the program.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.SyntaxCode">
            <summary>
               Gets the syntax code of this program (i.e. arbvp1, vs_1_1, etc).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgram.Type">
            <summary>
               Gets the type of GPU program this represents (vertex or fragment).
            </summary>
        </member>
        <member name="T:Axiom.Core.IConfigurable">
            <summary>
            	Describes behaviors required by objects that can be configured, whether through script
            	parameters or programatically.
            </summary>
        </member>
        <member name="M:Axiom.Core.IConfigurable.SetParam(System.String,System.String)">
            <summary>
               Will be called by script parsers that run across extended properties, and will pass them
               along expecting the target object to handle them.
            </summary>
            <param name="name">
               Name of the parameter.
            </param>
            <param name="val">
               Value of the parameter.
            </param>
            <returns>
               False if the param was not dealt with, True if it was.
            </returns>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgram.isHighLevelLoaded">
            <summary>
               Whether the high-level program (and it's parameter defs) is loaded.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgram.assemblerProgram">
            <summary>
               The underlying assembler program.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.#ctor(System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Default constructor.
            </summary>
            <param name="name">Name of the high level program.</param>
            <param name="type">Type of program, vertex or fragment.</param>
            <param name="language">HLSL language this program is written in.</param>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.Load">
            <summary>
               Implementation of Resource.Load.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.LoadHighLevelImpl">
            <summary>
               Internal load implementation, loads just the high-level portion, enough to 
               get parameters.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.CreateLowLevelImpl">
            <summary>
               Internal method for creating an appropriate low-level program from this
               high-level program, must be implemented by subclasses.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.Unload">
            <summary>
               Implementation of Resource.Unload.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.UnloadImpl">
            <summary>
               Internal unload implementation, must be implemented by subclasses.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.PopulateParameterNames(Axiom.Graphics.GpuProgramParameters)">
            <summary>
               Populate the passed parameters with name->index map, must be overridden.
            </summary>
            <param name="parms"></param>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.CreateParameters">
            <summary>
               Creates a new parameters object compatible with this program definition.
            </summary>
            <remarks>
               Unlike low-level assembly programs, parameters objects are specific to the
               program and therefore must be created from it rather than by the 
               HighLevelGpuProgramManager. This method creates a new instance of a parameters
               object containing the definition of the parameters this program understands.
            </remarks>
            <returns>A new set of program parameters.</returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgram.SetParam(System.String,System.String)">
            <summary>
               Must be implemented by subclasses.
            </summary>
            <param name="name"></param>
            <param name="val"></param>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgram.BindingDelegate">
            <summary>
               Gets the lowlevel assembler program based on this HighLevel program.
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.Zip">
            <summary>
               Implementation of Archive that allows for reading resources from a .zip file.
            </summary>
            <remarks>
               This would also be suitable for reading other .zip like formats, including
               .pk3.
            </remarks>
        </member>
        <member name="T:Axiom.FileSystem.Archive">
            <summary>
               Summary description for Archive.
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.Archive.ReadFile(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.FileSystem.Zip.ReadFile(System.String)">
            <summary>
               Reads a file with the specified name in the .zip file and returns the
               file as a MemoryStream.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.FileSystem.Zip.GetFileNamesLike(System.String,System.String)">
            <summary>
               Returns a list of files matching the specified pattern (usually extension) located
               within this .zip file.
            </summary>
            <param name="startPath"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.Timer">
            <summary>
            	Encapsulates the functionality of the platform's highest resolution timer available.
            </summary>
            <remarks>
            based on an vb.net implementation by createdbyx as posted in SourceForge Tracker #: [1612705]
            </remarks>
        </member>
        <member name="M:Axiom.Core.Timer.Start">
            <summary>
            Start this instance's timer.
            </summary>
        </member>
        <member name="M:Axiom.Core.Timer.Reset">
            <summary>
            	Reset this instance's timer.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.Count">
            <summary>
            Gets a <see cref="T:System.Int64"/> representing the 
            current tick count of the timer.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.Frequency">
            <summary>
            Gets a <see cref="T:System.Int64"/> representing the 
            frequency of the counter in ticks-per-second.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.IsRunning">
            <summary>
            Gets a <see cref="T:System.Boolean"/> representing whether the 
            timer has been started and is currently running.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.Resolution">
            <summary>
            Gets a <see cref="T:System.Double"/> representing the 
            resolution of the timer in seconds.
            </summary>
        </member>
        <member name="P:Axiom.Core.Timer.StartCount">
            <summary>
            Gets a <see cref="T:System.Int64"/> representing the 
            tick count at the start of the timer's run.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.TextureFrameControllerValue">
            <summary>
                Predefined controller value for getting/setting the frame number of a texture unit.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.TextureFrameControllerValue.texUnit">
            <summary>
                Reference to the texture unit state to target for the animation.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Canned.TextureFrameControllerValue.#ctor(Axiom.Graphics.TextureUnitState)">
            <summary>
                Constructor.
            </summary>
            <param name="textureUnit">Reference to the texture unit state to target for the animation.</param>
        </member>
        <member name="P:Axiom.Controllers.Canned.TextureFrameControllerValue.Value">
            <summary>
                Gets/Sets the frame of animation for a texture unit.
            </summary>
            <remarks>
                Value is a parametric value in the range [0,1].
            </remarks>
        </member>
        <member name="T:Axiom.Collections.LightList">
            <summary>
            Summary description for LightList.
            </summary>
        </member>
        <member name="M:Axiom.Collections.LightList.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.LightList.Add(Axiom.Core.Light)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.LightList.Add(System.String,Axiom.Core.Light)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.LightList.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.LightList.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.CameraList">
            <summary>
            Summary description for CameraCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.CameraList.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.CameraList.Add(Axiom.Core.Camera)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.CameraList.Add(System.String,Axiom.Core.Camera)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.CameraList.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.CameraList.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.AnimationStateCollection">
            <summary>
            Summary description for AnimationStateCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationStateCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationStateCollection.Add(Axiom.Animating.AnimationState)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AnimationStateCollection.Add(System.String,Axiom.Animating.AnimationState)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.AnimationStateCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.AnimationStateCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Animating.KeyFrame">
            <summary>
            	A key frame in an animation sequence defined by an AnimationTrack.
            </summary>
            <remarks>
            	This class can be used as a basis for all kinds of key frames. 
            	The unifying principle is that multiple KeyFrames define an 
            	animation sequence, with the exact state of the animation being an 
            	interpolation between these key frames.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.KeyFrame.time">
            <summary>
            	Time of this keyframe.
            </summary>
        </member>
        <member name="F:Axiom.Animating.KeyFrame.translate">
            <summary>
            	Translation at this keyframe.
            </summary>
        </member>
        <member name="F:Axiom.Animating.KeyFrame.scale">
            <summary>
            	Scale factor at this keyframe.
            </summary>
        </member>
        <member name="F:Axiom.Animating.KeyFrame.rotation">
            <summary>
            	Rotation at this keyframe.
            </summary>
        </member>
        <member name="F:Axiom.Animating.KeyFrame.parentTrack">
            <summary>
            	Animation track that this key frame belongs to.
            </summary>
        </member>
        <member name="M:Axiom.Animating.KeyFrame.#ctor(Axiom.Animating.AnimationTrack,System.Single)">
            <summary>
            	Creates a new keyframe with the specified time.  
            	Should really be created by <see cref="M:Axiom.Animating.AnimationTrack.CreateKeyFrame(System.Single)"/> instead.
            </summary>
            <param name="parent">Animation track that this keyframe belongs to.</param>
            <param name="time">Time at which this keyframe begins.</param>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Rotation">
            <summary>
            	Sets the rotation applied by this keyframe.
            	Use Quaternion methods to convert from angle/axis or Matrix3 if
            	you don't like using Quaternions directly.
            </summary>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Scale">
            <summary>
            	Sets the scaling factor applied by this keyframe to the animable
            	object at it's time index.
            	beware of supplying zero values for any component of this
            	vector, it will scale the object to zero dimensions.
            </summary>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Translate">
            <summary>
            	Sets the translation associated with this keyframe. 
            </summary>
            <remarks>
            	The translation factor affects how much the keyframe translates (moves) it's animable
            	object at it's time index.
            </remarks>
        </member>
        <member name="P:Axiom.Animating.KeyFrame.Time">
            <summary>
            	Gets the time of this keyframe in the animation sequence.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.ParticleSystems.ParticleSystemManager" -->
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.DefaultQuota">
            <summary>
                Default param constants.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.PARTICLE">
            <summary>
                Script parsing constants.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.systemTemplateList">
            <summary>
                List of template particle systems.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.systemList">
            <summary>
                Actual instantiated particle systems (may be based on template, may be manual).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.emitterFactoryList">
            <summary>
                Factories for named emitter type (can be extended using plugins).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.affectorFactoryList">
            <summary>
                Factories for named affector types (can be extended using plugins).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.rendererFactoryList">
            <summary>
                Map of renderer types to factories
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.attribParsers">
            <summary>
                List of available attibute parsers for script attributes.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystemManager.timeFactor">
            <summary>
                Controls time. (1.0 is real time)
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddEmitterFactory(Axiom.ParticleSystems.ParticleEmitterFactory)">
            <summary>
            	Adds a new 'factory' object for emitters to the list of available emitter types.
             </summary>
             <remarks>
            	This method allows plugins etc to add new particle emitter types. Particle emitters
            	are sources of particles, and generate new particles with their start positions, colors and
            	momentums appropriately. Plugins would create new subclasses of ParticleEmitter which 
            	emit particles a certain way, and register a subclass of ParticleEmitterFactory to create them (since multiple 
            	emitters can be created for different particle systems).
            	<p/>
            	All particle emitter factories have an assigned name which is used to identify the emitter
            	type. This must be unique.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddAffectorFactory(Axiom.ParticleSystems.ParticleAffectorFactory)">
            <summary>
            	Adds a new 'factory' object for affectors to the list of available affector types.
             </summary>
              <remarks>
            	This method allows plugins etc to add new particle affector types. Particle
            	affectors modify the particles in a system a certain way such as affecting their direction
            	or changing their color, lifespan etc. Plugins would
            	create new subclasses of ParticleAffector which affect particles a certain way, and register
            	a subclass of ParticleAffectorFactory to create them.
            	<p/>
            	All particle affector factories have an assigned name which is used to identify the affector
            	type. This must be unique.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddRendererFactory(Axiom.ParticleSystems.ParticleSystemRendererFactory)">
            <summary>
            Registers a factory class for creating ParticleSystemRenderer instances.
            </summary>
            <param name="factory">
            factory Pointer to a ParticleSystemRendererFactory subclass created by the plugin or application code.
            </param>
            <remarks>
            Note that the object passed to this function will not be destroyed by the ParticleSystemManager,
            since it may have been allocted on a different heap in the case of plugins. The caller must
            destroy the object later on, probably on plugin shutdown.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.AddTemplate(System.String,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Adds a new particle system template to the list of available templates. 
             </summary>
             <remarks>
            	Instances of particle systems in a scene are not normally unique - often you want to place the
            	same effect in many places. This method allows you to register a ParticleSystem as a named template,
            	which can subsequently be used to create instances using the CreateSystem method.
            	<p/>
            	Note that particle system templates can either be created programmatically by an application 
            	and registered using this method, or they can be defined in a XML script file which is
            	loaded by the engine at startup, very much like Material scripts.
            </remarks>
            <param name="name">The name of the template. Must be unique across all templates.</param>
            <param name="system">A reference to a particle system to be used as a template.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateTemplate(System.String)">
            <summary>
            	Create a new particle system template.
            </summary>
            <remarks>
            	This method is similar to the AddTemplate method, except this just creates a new template
            	and returns a reference to it to be populated. Use this when you don't already have a system
            	to add as a template and just want to create a new template which you will build up at runtime.
            </remarks>
            <param name="name"></param>
            <param name="resourceGroup">The name of the resource group which will be used to load any dependent resources.</param>
            <returns>returns a reference to a ParticleSystem template to be populated</returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RemoveTemplate(System.String)">
            <summary>
            
            </summary>
            <param name="name">Name of the particle system to remove</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String,System.Int32)">
            <summary>
            	Basic method for creating a blank particle system.
             </summary>
             <remarks>
            	This method creates a new, blank ParticleSystem instance and returns a reference to it.
                The caller should not delete this object, it will be freed at system shutdown, or can
                be released earlier using the destroySystem method.
            	<p/>
            	The instance returned from this method won't actually do anything because on creation a
            	particle system has no emitters. The caller should manipulate the instance through it's 
            	ParticleSystem methods to actually create a real particle effect. 
            	<p/>
            	Creating a particle system does not make it a part of the scene. As with other SceneObject
            	subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
            </remarks>
            <param name="name">The name to give the ParticleSystem.</param>
            <param name="quota">The maximum number of particles to allow in this system.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String,System.Int32,System.String)">
            <summary>
            	Basic method for creating a blank particle system.
             </summary>
             <remarks>
            	This method creates a new, blank ParticleSystem instance and returns a reference to it.
                The caller should not delete this object, it will be freed at system shutdown, or can
                be released earlier using the destroySystem method.
            	<p/>
            	The instance returned from this method won't actually do anything because on creation a
            	particle system has no emitters. The caller should manipulate the instance through it's 
            	ParticleSystem methods to actually create a real particle effect. 
            	<p/>
            	Creating a particle system does not make it a part of the scene. As with other SceneObject
            	subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
            </remarks>
            <param name="name">The name to give the ParticleSystem.</param>
            <param name="quota">The maximum number of particles to allow in this system.</param>
            <param name="resourceGroup">The resource group which will be used to load dependent resources</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateSystem(System.String,System.String)">
            <summary>
            	Creates a particle system based on a template.
             </summary>
             <remarks>
            	This method creates a new ParticleSystem instance based on the named template and returns a 
            	reference to the caller. The caller should not delete this object, it will be freed at system shutdown, 
               or can be released earlier using the destroySystem method.
            	<p/>
            	Each system created from a template takes the template's settings at the time of creation, 
            	but is completely separate from the template from there on. 
            	<p/>
            	Creating a particle system does not make it a part of the scene. As with other SceneObject
            	subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. 
            	<p/>
            	This is probably the more useful particle system creation method since it does not require manual
            	setup of the system.
            </remarks>
            <param name="name">The name to give the new particle system instance.</param>
            <param name="templateName">The name of the template to base the new instance on.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RemoveSystem(System.String)">
            <summary>
            Destroys a particle system, freeing it's memory and removing references to it in this class.
            </summary>
            <remarks>
            You should ensure that before calling this method, the particle system has been detached from 
            any SceneNode objects, and that no other objects are referencing it.
            </remarks>
            <param name="name">The name of the ParticleSystem to remove.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RemoveSystem(Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            Destroys a particle system, freeing it's memory and removing references to it in this class.
            </summary>
            <remarks>
            You should ensure that before calling this method, the particle system has been detached from 
            any SceneNode objects, and that no other objects are referencing it.
            </remarks>
            <param name="sys">Reference to the ParticleSystem to be removed.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateEmitter(System.String)">
            <summary>
            	Internal method for creating a new emitter from a factory.
            </summary>
            <remarks>
            	Used internally by the engine to create new ParticleEmitter instances from named
            	factories. Applications should use the ParticleSystem.AddEmitter method instead, 
            	which calls this method to create an instance.
            </remarks>
            <param name="emitterType">string name of the emitter type to be created. A factory of this type must have been registered.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RemoveEmitter(Axiom.ParticleSystems.ParticleEmitter)">
            <summary>
            Internal method for removing an emitter.
            </summary>
            <remarks>
            This method is used to ask the factory to remove the instance passed in as a reference.
            </remarks>
            <param name="emitter">Reference to emitter to be removed. On return this reference will be null.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateAffector(System.String)">
            <summary>
            	Internal method for creating a new affector from a factory.
            </summary>
            <remarks>
            	Used internally by the engine to create new ParticleAffector instances from named
            	factories. Applications should use the ParticleSystem.AddAffector method instead, 
            	which calls this method to create an instance.
            </remarks>
            <param name="emitterType">string name of the affector type to be created. A factory of this type must have been registered.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RemoveAffector(Axiom.ParticleSystems.ParticleAffector)">
            <summary>
            Internal method for removing an affector.
            </summary>
            <remarks>
            This method is used to ask the factory to remove the instance passed in as a reference.
            </remarks>
            <param name="affector">Reference to affector to be removed. On return this reference will be null.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.CreateRenderer(System.String)">
            <summary>
            Internal method for creating a new renderer from a factory.
            </summary>
            <param name="rendererType">rendererType String name of the renderer type to be created. A factory of this type must have been registered.</param>
            <returns>new ParticleSystemRenderer</returns>
            <remarks>
               Used internally by the engine to create new ParticleSystemRenderer instances from named
               factories. Applications should use the ParticleSystem.Renderer Property instead, 
               which calls this method to create an instance.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RemoveRenderer(Axiom.ParticleSystems.ParticleAffector)">
            <summary>
            Internal method for removing an renderer.
            </summary>
            <remarks>
            This method is used to ask the factory to remove the instance passed in as a reference.
            </remarks>
            <param name="renderer">Reference to renderer to be removed. On return this reference will be null.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.Initialize">
            <summary>
            	Internal method to init the particle systems.
            </summary>
            <remarks>
            	Since this method is dependent on other engine systems being started, this method will be called by the
            	engine when the render system is initialized.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAllSources">
            <summary>
            	Parses all particle system script files in resource folders and archives.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseScript(System.IO.TextReader)">
            <summary>
            	Starts parsing an individual script file.
            </summary>
            <param name="data">Stream containing the script data.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAttrib(System.String,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Parses an attribute intended for the particle system itself.
            </summary>
            <param name="line"></param>
            <param name="system"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseEmitter(System.String,System.IO.TextReader,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <param name="system"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAffector(System.String,System.IO.TextReader,Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <param name="system"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseEmitterAttrib(System.String,Axiom.ParticleSystems.ParticleEmitter)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <param name="emitter"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.ParseAffectorAttrib(System.String,Axiom.ParticleSystems.ParticleAffector)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <param name="affector"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RegisterParsers">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to 
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RenderSystem_FrameStarted(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	A listener that is added to the engine's render loop.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.RenderSystem_FrameEnded(System.Object,Axiom.Core.FrameEventArgs)">
            <summary>
            	A listener that is added to the engine's render loop.
            </summary>
            <param name="source"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.TimeFactor">
            <summary>
            	Get/Set the relative speed of time as perceived by particle systems.
             </summary>
             <remarks>
            	Normally particle systems are updated automatically in line with the real 
            	passage of time. This method allows you to change that, so that 
            	particle systems are told that the time is passing slower or faster than it
            	actually is. Use this to globally speed up / slow down particle systems.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.ParticleSystems">
            <summary>
            	List of available particle systems.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Affectors">
            <summary>
                List of available affector factories.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Emitters">
            <summary>
                List of available emitter factories.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.Renderers">
            <summary>
                List of available renderer factories.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.ScriptPatterns">
            <summary>
                List of script patterns to load.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemManager.LoadingOrder">
            <summary>
                Loading Order
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleSystemManager.ParticleSystemAttributeParser">
            <summary>
                Particle system attribute method definition.
            </summary>
            <param name="values">Attribute values.</param>
            <param name="system">Target particle system.</param>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter">
            <summary>
            	Abstract class defining the interface to be implemented by particle emitters.
            </summary>
            <remarks>
            	Particle emitters are the sources of particles in a particle system. 
            	This class defines the ParticleEmitter interface, and provides a basic implementation 
            	for tasks which most emitters will do (these are of course overridable).
            	Particle emitters can be  grouped into types, e.g. 'point' emitters, 'box' emitters etc; each type will 
            	create particles with a different starting point, direction and velocity (although
            	within the types you can configure the ranges of these parameters). 
            	<p/>
            	Because there are so many types of emitters you could use, the engine chooses not to dictate
            	the available types. It comes with some in-built, but allows plugins or games to extend the emitter types available.
            	This is done by subclassing ParticleEmitter to have the appropriate emission behavior you want,
            	and also creating a subclass of ParticleEmitterFactory which is responsible for creating instances 
            	of your new emitter type. You register this factory with the ParticleSystemManager using
            	AddEmitterFactory, and from then on emitters of this type can be created either from code or through
            	XML particle scripts by naming the type.
            	<p/>
            	This same approach is used for ParticleAffectors (which modify existing particles per frame).
            	This means that the engine is particularly flexible when it comes to creating particle system effects,
            	with literally infinite combinations of emitter and affector types, and parameters within those
            	types.
            </remarks>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.position">
            <summary>
               Position relative to the center of the ParticleSystem.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.emissionRate">
            <summary>
                Rate in particles per second at which this emitter wishes to emit particles.
             </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.type">
            <summary>
               Name of the type of emitter, MUST be initialized by subclasses.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.direction">
            <summary>
               Base direction of the emitter, may not be used by some emitters.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.up">
            <summary>
               Notional up vector, just used to speed up generation of variant directions.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.angle">
            <summary>
               Angle around direction which particles may be emitted, internally radians but degrees for interface.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.minSpeed">
            <summary>
               Min speed of particles.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.maxSpeed">
            <summary>
               Max speed of particles.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.minTTL">
            <summary>
               Initial time-to-live of particles (min).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.maxTTL">
            <summary>
               Initial time-to-live of particles (max).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.colorRangeStart">
            <summary>
               Initial color of particles (range start).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.colorRangeEnd">
            <summary>
               Initial color of particles (range end).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.isEnabled">
            <summary>
               Whether this emitter is currently enabled (defaults to true).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.startTime">
            <summary>
               Start time (in seconds from start of first call to ParticleSystem to update).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationMin">
            <summary>
               Minimum length of time emitter will run for (0 = forever).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationMax">
            <summary>
               Maximum length of time the emitter will run for (0 = forever).
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.durationRemain">
            <summary>
               Current duration remainder.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayMin">
            <summary>
               Minimum time between each repeat.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayMax">
            <summary>
               Maximum time between each repeat.
            </summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleEmitter.repeatDelayRemain">
            <summary>
               Repeat delay left.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GetEmissionCount(System.Single)">
            <summary>
            	Gets the number of particles which this emitter would like to emit based on the time elapsed.
             </summary>
             <remarks>
            	For efficiency the emitter does not actually create new Particle instances (these are reused
            	by the ParticleSystem as existing particles 'die'). The implementation for this method must
            	return the number of particles the emitter would like to emit given the number of seconds which
            	have elapsed (passed in as a parameter).
            	<p/>
            	Based on the return value from this method, the ParticleSystem class will call 
            	InitParticle once for each particle it chooses to allow to be emitted by this emitter.
            	The emitter should not track these InitParticle calls, it should assume all emissions
            	requested were made (even if they could not be because of particle quotas).
             </remarks>
            <param name="timeElapsed"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.InitParticle(Axiom.ParticleSystems.Particle)">
            <summary>
            	Initializes a particle based on the emitter's approach and parameters.
            </summary>
            <remarks>
            	See the GetEmissionCount method for details of why there is a separation between
            	'requested' emissions and actual initialized particles.
            </remarks>
            <param name="particle">Reference to a particle which must be initialized based on how this emitter starts particles</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionDirection(Axiom.Math.Vector3@)">
            <summary>
            	Utility method for generating particle exit direction
            </summary>
            <param name="dest">Normalized vector dictating new direction.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionVelocity(Axiom.Math.Vector3@)">
            <summary>
            	Utility method to apply velocity to a particle direction.
            </summary>
            <param name="dest">The normalized vector to scale by a randomly generated scale between min and max speed.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionTTL">
            <summary>
            	Utility method for generating a time-to-live for a particle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateConstantEmissionCount(System.Single)">
            <summary>
            	Utility method for generating an emission count based on a constant emission rate.
            </summary>
            <param name="timeElapsed"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.GenerateEmissionColor(Axiom.Core.ColorEx)">
            <summary>
            	Internal method for generating a color for a particle.
            </summary>
            <param name="color">
               The color object that will be altered depending on the method of generating the particle color.
            </param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.InitDurationRepeat">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.SetDuration(System.Single,System.Single)">
            <summary>
               Sets the min/max duration range for this emitter.
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.CopyTo(Axiom.ParticleSystems.ParticleEmitter)">
            <summary>
            
            </summary>
            <param name="emitter"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.SetParam(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitter.RegisterCommands">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to 
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Position">
            <summary>
            	Gets/Sets the position of this emitter relative to the center of the particle system.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Direction">
            <summary>
            	Gets/Sets the direction of the emitter.
            </summary>
            <remarks>
            	Most emitters will have a base direction in which they emit particles (those which
            	emit in all directions will ignore this parameter). They may not emit exactly along this
            	vector for every particle, many will introduce a random scatter around this vector using 
            	the angle property.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Angle">
            <summary>
            	Gets/Sets the maximum angle away from the emitter direction which particle will be emitted.
            </summary>
            <remarks>
            	Whilst the direction property defines the general direction of emission for particles, 
            	this property defines how far the emission angle can deviate away from this base direction.
            	This allows you to create a scatter effect - if set to 0, all particles will be emitted
            	exactly along the emitters direction vector, wheras if you set it to 180 or more, particles
            	will be emitted in a sphere, i.e. in all directions.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ParticleVelocity">
            <summary>
            	Gets/Sets the initial velocity of particles emitted.
            </summary>
            <remarks>
            	This property sets the range of starting speeds for emitted particles. 
            	See the alternate Min/Max properties for velocities.  This emitter will randomly 
            	choose a speed between the minimum and maximum for each particle.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinParticleVelocity">
            <summary>
            	Gets/Sets the minimum velocity of particles emitted.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxParticleVelocity">
            <summary>
            	Gets/Sets the maximum velocity of particles emitted.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.EmissionRate">
            <summary>
            	Gets/Sets the emission rate for this emitter.
            </summary>
            <remarks>
            	This tells the emitter how many particles per second should be emitted. The emitter
            	subclass does not have to emit these in a continuous burst - this is a relative parameter
            	and the emitter may choose to emit all of the second's worth of particles every half-second
            	for example. This is controlled by the emitter's EmissionCount property.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.TimeToLive">
            <summary>
            	Gets/Sets the lifetime of all particles emitted.
            </summary>
            <remarks>
            	The emitter initializes particles with a time-to-live (TTL), the number of seconds a particle
            	will exist before being destroyed. This method sets a constant TTL for all particles emitted.
            	Note that affectors are able to modify the TTL of particles later.
            	<p/>
            	Also see the alternate Min/Max versions of this property which takes a min and max TTL in order to 
            	have the TTL vary per particle.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinTimeToLive">
            <summary>
            	Gets/Sets the minimum time each particle will live for.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxTimeToLive">
            <summary>
            	Gets/Sets the maximum time each particle will live for.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Color">
            <summary>
            	Gets/Sets the initial color of particles emitted.
            </summary>
            <remarks>
            	Particles have an initial color on emission which the emitter sets. This property sets
            	this color. See the alternate Start/End versions of this property which takes 2 colous in order to establish 
            	a range of colors to be assigned to particles.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ColorRangeStart">
            <summary>
            	Gets/Sets the color that a particle starts out when it is created.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.ColorRangeEnd">
            <summary>
            	Gets/Sets the color that a particle ends at just before it's TTL expires.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Type">
            <summary>
            	Gets the name of the type of emitter. 
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.IsEnabled">
            <summary>
            	Gets/Sets the flag indicating if this emitter is enabled or not.
            </summary>
            <remarks>
            	Setting this property to false will turn the emitter off completely.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.StartTime">
            <summary>
            	Gets/Sets the start time of this emitter.
            </summary>
            <remarks>
            	By default an emitter starts straight away as soon as a ParticleSystem is first created,
            	or also just after it is re-enabled. This parameter allows you to set a time delay so
            	that the emitter does not 'kick in' until later.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.Duration">
            <summary>
            	Gets/Sets the duration of time (in seconds) that the emitter should run.
            </summary>
            <remarks>
            	By default emitters run indefinitely (unless you manually disable them). By setting this
            	parameter, you can make an emitter turn off on it's own after a set number of seconds. It
            	will then remain disabled until either Enabled is set to true, or if the 'repeatAfter' parameter
            	has been set it will also repeat after a number of seconds.
            	<p/>
            	Also see the alternative Min/Max versions of this property which allows you to set a min and max duration for
            	a random variable duration.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinDuration">
            <summary>
            	Gets/Sets the minimum running time of this emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxDuration">
            <summary>
            	Gets/Sets the maximum running time of this emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MaxRepeatDelay">
            <summary>
            	Gets/Sets the maximum repeat delay for the emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.MinRepeatDelay">
            <summary>
            	Gets/Sets the minimum repeat delay for the emitter.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitter.RepeatDelay">
            <summary>
            	Gets/Sets the time between repeats of the emitter.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.AngleCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.Scripting.ICommand">
            <summary>
            	Summary description for ICommand.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.ICommand.Get(System.Object)">
            <summary>
               Gets the value for this command from the target object.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.ICommand.Set(System.Object,System.String)">
            <summary>
               Sets the value for this command on the target object.
            </summary>
            <param name="target"></param>
            <param name="val"></param>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.PositionCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.EmissionRateCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.TtlCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.TtlMinCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.TtlMaxCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.DirectionCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.DurationCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.MinDurationCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.MaxDurationCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.RepeatDelayCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.RepeatDelayMinCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.RepeatDelayMaxCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.VelocityCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.VelocityMinCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.VelocityMaxCommand">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.ColorRangeStartCommand">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleEmitter.ColorRangeEndCommand">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Media.BMPCodec">
            <summary>
               BMP image file codec.
            </summary>
        </member>
        <member name="T:Axiom.Media.ILImageCodec">
            <summary>
               Base DevIL (OpenIL) implementation for loading images.
            </summary>
        </member>
        <member name="T:Axiom.Media.ImageCodec">
            <summary>
            Summary description for ImageCodec.
            </summary>
        </member>
        <member name="T:Axiom.Media.ICodec">
            <summary>
               Interface describing an object that can handle a form of media, be it
               a image, sound, video, etc.
            </summary>
        </member>
        <member name="M:Axiom.Media.ICodec.Decode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
               Codes the data from the input chunk into the output chunk.
            </summary>
            <param name="input">Input stream (encoded data).</param>
            <param name="output">Output stream (decoded data).</param>
            <param name="args">Variable number of extra arguments.</param>
            <returns>
               An object that holds data specific to the media format which this codec deal with.
               For example, an image coded might return a structure that has image related details,
               such as height, width, etc.
            </returns>
        </member>
        <member name="M:Axiom.Media.ICodec.Encode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
               Encodes the data in the input stream and saves the result in the output stream.
            </summary>
            <param name="input">Input stream (decoded data).</param>
            <param name="output">Output stream (encoded data).</param>
            <param name="args">Variable number of extra arguments.</param>
        </member>
        <member name="M:Axiom.Media.ICodec.EncodeToFile(System.IO.Stream,System.String,System.Object)">
            <summary>
                Encodes data to a file.
            </summary>
            <param name="input">Stream containing data to write.</param>
            <param name="fileName">Filename to output to.</param>
            <param name="codecData">Extra data to use in order to describe the codec data.</param>
        </member>
        <member name="P:Axiom.Media.ICodec.Type">
            <summary>
               Gets the type of data that this codec is meant to handle, typically a file extension.
            </summary>
        </member>
        <member name="F:Axiom.Media.ILImageCodec.isInitialized">
            <summary>
               Flag used to ensure DevIL gets initialized once.
            </summary>
        </member>
        <member name="M:Axiom.Media.ILImageCodec.InitializeIL">
            <summary>
               One time DevIL initialization.
            </summary>
        </member>
        <member name="M:Axiom.Media.ILImageCodec.ConvertToILFormat(Axiom.Media.PixelFormat)">
            <summary>
               Converts a PixelFormat enum to a pair with DevIL format enum and bytesPerPixel.
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Media.ILImageCodec.ConvertFromILFormat(System.Int32,System.Int32)">
            <summary>
               Converts a DevIL format enum to a PixelFormat enum.
            </summary>
            <param name="format"></param>
            <param name="bytesPerPixel"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Media.ILImageCodec.ILType">
            <summary>
               Implemented by subclasses to return the IL type enum value for this
               images file type.
            </summary>
        </member>
        <member name="M:Axiom.Media.BMPCodec.Encode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="args"></param>
        </member>
        <member name="P:Axiom.Media.BMPCodec.Type">
            <summary>
               Returns the BMP file extension.
            </summary>
        </member>
        <member name="P:Axiom.Media.BMPCodec.ILType">
            <summary>
               Returns BMP enum.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.#cctor">
            <summary>
            Empty static constructor
            DO NOT DELETE.  It needs to be here because:
            
                # The presence of a static constructor suppresses beforeFieldInit.
                # Static field variables are initialized before the static constructor is called.
                # Having a static constructor is the only way to ensure that all resources are 
                  initialized before other static functions are called.
            
            (from "Static Constructors Demystified" by Satya Komatineni
             http://www.ondotnet.com/pub/a/dotnet/2003/07/07/staticxtor.html)
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.DegreesToRadians(System.Single)">
            <summary>
            	Converts degrees to radians.
            </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.RadiansToDegrees(System.Single)">
            <summary>
            	Converts radians to degrees.
            </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.FloatEqual(System.Single,System.Single,System.Single)">
            <summary>
                Compares float values for equality, taking into consideration
                that floating point values should never be directly compared using
                ==.  2 floats could be conceptually equal, but vary by a 
                .000001 which would fail in a direct comparison.  To circumvent that,
                a tolerance value is used to see if the difference between the 2 floats
                is less than the desired amount of accuracy.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.FloatEqual(System.Single,System.Single)">
            <summary>
                Compares float values for equality, taking into consideration
                that floating point values should never be directly compared using
                ==.  2 floats could be conceptually equal, but vary by a 
                .000001 which would fail in a direct comparison.  To circumvent that,
                a tolerance value is used to see if the difference between the 2 floats
                is less than the desired amount of accuracy.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Sin(System.Single)">
            <summary>
            Returns the sine of the specified angle.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.ASin(System.Single)">
            <summary>
            Returns the angle whose cosine is the specified number.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.Cos(System.Single)">
            <summary>
            Returns the cosine of the specified angle.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.ACos(System.Single)">
            <summary>
            Returns the angle whose cosine is the specified number.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.Tan(System.Single)">
            <summary>
            Returns the tangent of the specified angle.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.ATan(System.Single)">
            <summary>
            Return the angle whos tangent is the specified number.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.ATan(System.Single,System.Single)">
            <summary>
            Returns the angle whose tangent is the quotient of the two specified numbers.
            </summary>
        </member>
        <member name="M:Axiom.Math.Utility.Sqrt(System.Single)">
            <summary>
            	Returns the square root of a number.
            </summary>
            <remarks>This is one of the more expensive math operations.  Avoid when possible.</remarks>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.InvSqrt(System.Single)">
            <summary>
               Inverse square root.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Abs(System.Single)">
            <summary>
            	Returns the absolute value of the supplied number.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Max(System.Single,System.Single)">
            <summary>
            Returns the maximum of the two supplied values.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.Min(System.Single,System.Single)">
            <summary>
            Returns the minumum of the two supplied values.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.RangeRandom(System.Single,System.Single)">
            <summary>
               Returns a random value between the specified min and max values.
            </summary>
            <param name="min">Minimum value.</param>
            <param name="max">Maximum value.</param>
            <returns>A random value in the range [min,max].</returns>
        </member>
        <member name="M:Axiom.Math.Utility.UnitRandom">
            <summary>
               
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.SymmetricRandom">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.BuildReflectionMatrix(Axiom.Math.Plane)">
            <summary>
                Builds a reflection matrix for the specified plane.
            </summary>
            <param name="plane"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.CalculateFaceNormal(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Calculate a face normal, including the w component which is the offset from the origin.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.CalculateBasicFaceNormal(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Calculate a face normal, no w-information.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.CalculateTangentSpaceVector(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Calculates the tangent space vector for a given set of positions / texture coords.
            </summary>
            <remarks>
               Adapted from bump mapping tutorials at:
               http://www.paulsprojects.net/tutorials/simplebump/simplebump.html
               author : paul.baker@univ.ox.ac.uk
            </remarks>
            <param name="position1"></param>
            <param name="position2"></param>
            <param name="position3"></param>
            <param name="u1"></param>
            <param name="v1"></param>
            <param name="u2"></param>
            <param name="v2"></param>
            <param name="u3"></param>
            <param name="v3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Utility.PointInTri2D(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Checks wether a given point is inside a triangle, in a
            	2-dimensional (Cartesian) space.
            </summary>
            <remarks>
            	The vertices of the triangle must be given in either
            	trigonometrical (anticlockwise) or inverse trigonometrical
            	(clockwise) order.
            </remarks>
            <param name="px">
               The X-coordinate of the point.
            </param>
            <param name="py">
               The Y-coordinate of the point.
            </param>
            <param name="ax">
               The X-coordinate of the triangle's first vertex.
            </param>
            <param name="ay">
               The Y-coordinate of the triangle's first vertex.
            </param>
            <param name="bx">
               The X-coordinate of the triangle's second vertex.
            </param>
            <param name="by">
               The Y-coordinate of the triangle's second vertex.
            </param>
            <param name="cx">
               The X-coordinate of the triangle's third vertex.
            </param>
            <param name="cy">
               The Y-coordinate of the triangle's third vertex.
            </param>
            <returns>
               <list type="bullet">
                   <item>
                       <description><b>true</b> - the point resides in the triangle.</description>
                   </item>
                   <item>
                       <description><b>false</b> - the point is outside the triangle</description>
                    </item>
                </list>
            </returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.AxisAlignedBox)">
            <summary>
               Tests an intersection between a ray and a box.
            </summary>
            <param name="ray"></param>
            <param name="box"></param>
            <returns>A Pair object containing whether the intersection occurred, and the distance between the 2 objects.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.AxisAlignedBox,Axiom.Math.AxisAlignedBox)">
            <summary>
               Tests an intersection between two boxes.
            </summary>
            <param name="boxA">
               The primary box.
            </param>
            <param name="boxB">
               The box to test intersection with boxA.
            </param>
            <returns>
               <list type="bullet">
                   <item>
                       <description>None - There was no intersection between the 2 boxes.</description>
                   </item>
                   <item>
                       <description>Contained - boxA is fully within boxB.</description>
                    </item>
                   <item>
                       <description>Contains - boxB is fully within boxA.</description>
                    </item>
                   <item>
                       <description>Partial - boxA is partially intersecting with boxB.</description>
                    </item>
                </list>
            </returns>
            Submitted by: romout
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.Sphere,System.Boolean)">
            <summary>
            	Ray/Sphere intersection test.
            </summary>
            <param name="ray"></param>
            <param name="sphere"></param>
            <param name="discardInside"></param>
            <returns>Struct that contains a bool (hit?) and distance.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.Plane)">
            <summary>
            	Ray/Plane intersection test.
            </summary>
            <param name="ray"></param>
            <param name="plane"></param>
            <returns>Struct that contains a bool (hit?) and distance.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Sphere,Axiom.Math.AxisAlignedBox)">
            <summary>
            	Sphere/Box intersection test.
            </summary>
            <param name="sphere"></param>
            <param name="box"></param>
            <returns>True if there was an intersection, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Plane,Axiom.Math.AxisAlignedBox)">
            <summary>
            	Plane/Box intersection test.
            </summary>
            <param name="plane"></param>
            <param name="box"></param>
            <returns>True if there was an intersection, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Sphere,Axiom.Math.Plane)">
            <summary>
            	Sphere/Plane intersection test.
            </summary>
            <param name="sphere"></param>
            <param name="plane"></param>
            <returns>True if there was an intersection, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Utility.Intersects(Axiom.Math.Ray,Axiom.Math.PlaneBoundedVolume)">
            <summary>
               Ray/PlaneBoundedVolume intersection test.
            </summary>
            <param name="ray"></param>
            <param name="volume"></param>
            <returns>Struct that contains a bool (hit?) and distance.</returns>
        </member>
        <member name="T:Axiom.Math.IntersectResult">
            <summary>
            	Simple struct to allow returning a complex intersection result.
            </summary>
        </member>
        <member name="F:Axiom.Math.IntersectResult.Hit">
            <summary>
            	Did the intersection test result in a hit?
            </summary>
        </member>
        <member name="F:Axiom.Math.IntersectResult.Distance">
            <summary>
            	If Hit was true, this will hold a query specific distance value.
            	i.e. for a Ray-Box test, the distance will be the distance from the start point
            	of the ray to the point of intersection.
            </summary>
        </member>
        <member name="M:Axiom.Math.IntersectResult.#ctor(System.Boolean,System.Single)">
            <summary>
            	Constructor.
            </summary>
            <param name="hit"></param>
            <param name="distance"></param>
        </member>
        <member name="T:Axiom.Math.Matrix4">
            <summary>
            	Class encapsulating a standard 4x4 homogenous matrix.
            </summary>
            <remarks>
            	The engine uses column vectors when applying matrix multiplications,
            	This means a vector is represented as a single column, 4-row
            	matrix. This has the effect that the tranformations implemented
            	by the matrices happens right-to-left e.g. if vector V is to be
            	transformed by M1 then M2 then M3, the calculation would be
            	M3 * M2 * M1 * V. The order that matrices are concatenated is
            	vital since matrix multiplication is not cummatative, i.e. you
            	can get a different result if you concatenate in the wrong order.
            		<p/>
            	The use of column vectors and right-to-left ordering is the
            	standard in most mathematical texts, and is the same as used in
            	OpenGL. It is, however, the opposite of Direct3D, which has
            	inexplicably chosen to differ from the accepted standard and uses
            	row vectors and left-to-right matrix multiplication.
            	<p/>
            	The engine deals with the differences between D3D and OpenGL etc.
            	internally when operating through different render systems. The engine
            	users only need to conform to standard maths conventions, i.e.
            	right-to-left matrix multiplication, (The engine transposes matrices it
            	passes to D3D to compensate).
            	<p/>
            	The generic form M * V which shows the layout of the matrix 
            	entries is shown below:
            	<p/>
            	| m[0][0]  m[0][1]  m[0][2]  m[0][3] |   {x}
            	| m[1][0]  m[1][1]  m[1][2]  m[1][3] |   {y}
            	| m[2][0]  m[2][1]  m[2][2]  m[2][3] |   {z}
            	| m[3][0]  m[3][1]  m[3][2]  m[3][3] |   {1}
            </remarks>
            <ogre headerVersion="1.18" sourceVersion="1.8" />
        </member>
        <member name="M:Axiom.Math.Matrix4.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Creates a new Matrix4 with all the specified parameters.
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix4.GetMatrix3">
            <summary>
               Returns a 3x3 portion of this 4x4 matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Inverse">
            <summary>
               Returns an inverted 4d matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Transpose">
            <summary>
               Swap the rows of the matrix with the columns.
            </summary>
            <returns>A transposed Matrix.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Multiply(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to multiply (concatenate) two 4x4 Matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to multiply (concatenate) two 4x4 Matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Multiply(Axiom.Math.Matrix4,Axiom.Math.Vector3)">
            <summary>
            	Transforms the given 3-D vector by the matrix, projecting the 
            	result back into <i>w</i> = 1.
            	<p/>
            	This means that the initial <i>w</i> is considered to be 1.0,
            	and then all the tree elements of the resulting 3-D vector are
            	divided by the resulting <i>w</i>.
            </summary>
            <param name="matrix">A Matrix4.</param>
            <param name="vector">A Vector3.</param>
            <returns>A new vector.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Multiply(Axiom.Math.Matrix4,Axiom.Math.Plane)">
            <summary>
            	Transforms a plane using the specified transform.
            </summary>
            <param name="matrix">Transformation matrix.</param>
            <param name="plane">Plane to transform.</param>
            <returns>A transformed plane.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Vector3)">
            <summary>
            	Transforms the given 3-D vector by the matrix, projecting the 
            	result back into <i>w</i> = 1.
            	<p/>
            	This means that the initial <i>w</i> is considered to be 1.0,
            	and then all the tree elements of the resulting 3-D vector are
            	divided by the resulting <i>w</i>.
            </summary>
            <param name="matrix">A Matrix4.</param>
            <param name="vector">A Vector3.</param>
            <returns>A new vector.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,System.Single)">
            <summary>
            	Used to multiply a Matrix4 object by a scalar value..
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Plane)">
            <summary>
            	Used to multiply a transformation to a Plane.
            </summary>
            <param name="left"></param>
            <param name="plane"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Add(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Addition(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Subtract(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Subtraction(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Equality(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            Compares two Matrix4 instances for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true if the Matrix 4 instances are equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Inequality(Axiom.Math.Matrix4,Axiom.Math.Matrix4)">
            <summary>
            Compares two Matrix4 instances for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true if the Matrix 4 instances are not equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.FromMatrix3(Axiom.Math.Matrix3)">
            <summary>
            	Used to allow assignment from a Matrix3 to a Matrix4 object.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.op_Implicit(Axiom.Math.Matrix3)~Axiom.Math.Matrix4">
            <summary>
            	Used to allow assignment from a Matrix3 to a Matrix4 object.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.MakeFloatArray(System.Single[])">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Adjoint">
            <summary>
               Used to generate the adjoint of this matrix.  Used internally for <see cref="M:Axiom.Math.Matrix4.Inverse"/>.
            </summary>
            <returns>The adjoint matrix of the current instance.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Matrix4.
            </summary>
            <returns>A string representation of a vector3.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix4.Equals(System.Object)">
            <summary>
            	Compares this Matrix to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Matrix4.Identity">
            <summary>
               Returns a matrix with the following form:
               | 1,0,0,0 |
               | 0,1,0,0 |
               | 0,0,1,0 |
               | 0,0,0,1 |
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Zero">
            <summary>
               Returns a matrix with all elements set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Translation">
            <summary>
            	Gets/Sets the Translation portion of the matrix.
            	| 0 0 0 Tx|
            	| 0 0 0 Ty|
            	| 0 0 0 Tz|
            	| 0 0 0  1 |
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Scale">
            <summary>
            	Gets/Sets the Translation portion of the matrix.
            	|Sx 0  0  0 |
            	| 0 Sy 0  0 |
            	| 0  0 Sz 0 |
            	| 0  0  0  0 |
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix4.Item(System.Int32,System.Int32)">
            <summary>
               Allows the Matrix to be accessed like a 2d array (i.e. matrix[2,3])
            </summary>
            <remarks>
               This indexer is only provided as a convenience, and is <b>not</b> recommended for use in
               intensive applications.  
            </remarks>
        </member>
        <member name="P:Axiom.Math.Matrix4.Item(System.Int32)">
            <summary>
            	Allows the Matrix to be accessed linearly (m[0] -> m[15]).  
            </summary>
            <remarks>
               This indexer is only provided as a convenience, and is <b>not</b> recommended for use in
               intensive applications.  
            </remarks>
        </member>
        <member name="P:Axiom.Math.Matrix4.Determinant">
            <summary>
               Gets the determinant of this matrix.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.Material" -->
        <member name="F:Axiom.Graphics.Material.techniques">
            <summary>
               A list of techniques that exist within this Material.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.supportedTechniques">
            <summary>
               A list of the techniques of this material that are supported by the current hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.compilationRequired">
            <summary>
               Flag noting whether or not this Material needs to be re-compiled.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.receiveShadows">
            <summary>
            	Should objects using this material receive shadows?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.transparencyCastsShadows">
            <summary>
            	Do transparent objects casts shadows?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.lodDistances">
            <summary>
            	List of LOD distances specified for this material.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.bestTechniqueList">
            <summary>
            	
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.defaultSettings">
            <summary>
               A reference to a precreated Material that contains all the default settings.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Material.autoNumber">
            <summary>
               Auto incrementing number for creating unique names.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.#ctor">
            <summary>
               Constructor.  Creates an auto generated name for the material.
            </summary>
            <remarks>
               Normally you create materials by calling the relevant SceneManager since that is responsible for
               managing all scene state including materials.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Material.#ctor(System.String)">
            <summary>
               Contructor, taking the name of the material.
            </summary>
            <remarks>
               Normally you create materials by calling the relevant SceneManager since that is responsible for
               managing all scene state including materials.
            </remarks>
            <param name="name">Unique name of this material.</param>
        </member>
        <member name="M:Axiom.Graphics.Material.CompareTo(System.Object)">
            <summary>
            	Used for comparing 2 Material objects.
            </summary>
            <remarks>
            	This comparison will be used in RenderQueue group sorting of Materials materials.
            	If this object is transparent and the object being compared is not, this is greater that obj.
            	If this object is not transparent and the object being compared is, obj is greater than this.
            </remarks>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.Load">
            <summary>
            	Overridden from Resource.
            </summary>
            <remarks>
            	By default, Materials are not loaded, and adding additional textures etc do not cause those
            	textures to be loaded. When the <code>Load</code> method is called, all textures are loaded (if they
            	are not already), GPU programs are created if applicable, and Controllers are instantiated.
            	Once a material has been loaded, all changes made to it are immediately loaded too
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Material.Unload">
            <summary>
            	Unloads the material, frees resources etc.
            	<see cref="T:Axiom.Core.Resource"/>
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.Dispose">
            <summary>
                Disposes of any resources used by this object.	
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.Touch">
            <summary>
               Overridden to ensure a recompile occurs if needed before use.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.SetName(System.String)">
            <summary>
            	Only to be used by MaterialManager.Init.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Graphics.Material.Compile">
            <summary>
               'Compiles' this Material.
            </summary>
            <remarks>
               Compiling a material involves determining which Techniques are supported on the
               card on which the engine is currently running, and for fixed-function Passes within those
               Techniques, splitting the passes down where they contain more TextureUnitState 
               instances than the curren card has texture units.
               <p/>
               This process is automatically done when the Material is loaded, but may be
               repeated if you make some procedural changes.
               <p/>
               By default, the engine will automatically split texture unit operations into multiple
               passes when the target hardware does not have enough texture units.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Material.Compile(System.Boolean)">
            <summary>
               'Compiles' this Material.
            </summary>
            <remarks>
               Compiling a material involves determining which Techniques are supported on the
               card on which the engine is currently running, and for fixed-function Passes within those
               Techniques, splitting the passes down where they contain more TextureUnitState 
               instances than the curren card has texture units.
               <p/>
               This process is automatically done when the Material is loaded, but may be
               repeated if you make some procedural changes.
            </remarks>
            <param name="autoManageTextureUnits">
               If true, when a fixed function pass has too many TextureUnitState
               entries than the card has texture units, the Pass in question will be split into
               more than one Pass in order to emulate the Pass. If you set this to false and
               this situation arises, an Exception will be thrown.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Material.CreateTechnique">
            <summary>
               Creates a new Technique for this Material.
            </summary>
            <remarks>
               A Technique is a single way of rendering geometry in order to achieve the effect
               you are intending in a material. There are many reason why you would want more than
               one - the main one being to handle variable graphics card abilities; you might have
               one technique which is impressive but only runs on 4th-generation graphics cards, 
               for example. In this case you will want to create at least one fallback Technique.
               The engine will work out which Techniques a card can support and pick the best one.
               <p/>    
               If multiple Techniques are available, the order in which they are created is 
               important - the engine will consider lower-indexed Techniques to be preferable
               to higher-indexed Techniques, ie when asked for the 'best' technique it will
               return the first one in the technique list which is supported by the hardware.
            </remarks>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Graphics.Material.GetBestTechnique(System.Int32)" -->
        <member name="M:Axiom.Graphics.Material.GetLodIndex(System.Single)">
            <summary>
            	Gets the LOD index to use at the given distance.
            </summary>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.GetLodIndexSquaredDepth(System.Single)">
            <summary>
            	Gets the LOD index to use at the given squared distance.
            </summary>
            <param name="squaredDistance"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.GetTechnique(System.Int32)">
            <summary>
               Gets the technique at the specified index.
            </summary>
            <param name="index">Index of the technique to return.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.NotifyNeedsRecompile">
            <summary>
               Tells the material that it needs recompilation.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.RemoveTechnique(Axiom.Graphics.Technique)">
            <summary>
               Removes the specified Technique from this material.
            </summary>
            <param name="t">A reference to the technique to remove</param>
        </member>
        <member name="M:Axiom.Graphics.Material.RemoveAllTechniques">
            <summary>
            	Removes all techniques from this material.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Material.SetLodLevels(Axiom.Core.FloatList)">
            <summary>
            	Sets the distance at which level-of-detail (LOD) levels come into effect.
            </summary>
            <remarks>
            	You should only use this if you have assigned LOD indexes to the Technique
            	instances attached to this Material. If you have done so, you should call this
            	method to determine the distance at which the lowe levels of detail kick in.
            	The decision about what distance is actually used is a combination of this
            	and the LOD bias applied to both the current Camera and the current Entity.
            </remarks>
            <param name="lodDistances">
            	A list of floats which indicate the distance at which to 
            	switch to lower details. They are listed in LOD index order, starting at index
            	1 (ie the first level down from the highest level 0, which automatically applies
            	from a distance of 0).
            </param>
        </member>
        <member name="M:Axiom.Graphics.Material.Clone(System.String)">
            <summary>
               Creates a copy of this Material with the specified name (must be unique).
            </summary>
            <param name="newName">The name that the cloned material will be known as.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.CopyTo(Axiom.Graphics.Material)">
            <summary>
            	Copies the details of this material into another, preserving the target's handle and name
            	(unlike operator=) but copying everything else.
            </summary>
            <param name="target">Material which will receive this material's settings.</param>
        </member>
        <member name="M:Axiom.Graphics.Material.CopyTo(Axiom.Graphics.Material,System.Boolean)">
            <summary>
            	Copies the details of this material into another, preserving the target's handle and name
            	(unlike operator=) but copying everything else.
            </summary>
            <param name="target">Material which will receive this material's settings.</param>
        </member>
        <member name="M:Axiom.Graphics.Material.GetHashCode">
            <summary>
               Overridden to give Materials a meaningful hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Material.ToString">
            <summary>
               Overridden.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.Material.Ambient">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.CullingMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.DepthCheck">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.DepthWrite">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.IsTransparent">
            <summary>
            	Determines if the material has any transparency with the rest of the scene (derived from 
               whether any Techniques say they involve transparency).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.Lighting">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.ManualCullMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.NumTechniques">
            <summary>
               Gets the number of techniques within this Material.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.NumLodLevels">
            <summary>
            	Gets the number of levels-of-detail this material has.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Material.ReceiveShadows">
            <summary>
            	Sets whether objects using this material will receive shadows.
            </summary>
            <remarks>
            	This method allows a material to opt out of receiving shadows, if
            	it would otherwise do so. Shadows will not be cast on any objects
            	unless the scene is set up to support shadows and not all techniques 
            	cast shadows on all objects. In any case, if you have a need to prevent
            	shadows being received by material, this is the method you call to do it.
            	Note: Transparent materials never receive shadows despite this setting. 
            	The default is to receive shadows.
            	<seealso cref="P:Axiom.Core.SceneManager.ShadowTechnique"/>
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Material.TransparencyCastsShadows">
            <summary>
            	Gets/Sets whether objects using this material be classified as opaque to the shadow caster system.
            </summary>
            <remarks>
            	This method allows a material to cast a shadow, even if it is transparent.
            	By default, transparent materials neither cast nor receive shadows. Shadows
            	will not be cast on any objects unless the scene is set up to support shadows 
            	<seealso cref="P:Axiom.Core.SceneManager.ShadowTechnique"/>, and not all techniques cast
            	shadows on all objects.
            </remarks>
        </member>
        <member name="T:Axiom.FileSystem.IArchiveFactory">
            <summary>
            	Interface for plugin developers to override to create new types of archive to load
            	resources from.
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.IArchiveFactory.CreateArchive(System.String)">
            <summary>
            	Create an archive object based on the name.
            </summary>
            <param name="name">the name identifying the archive to the factory
            (usually a zip or directory name)</param>
            <returns>An Archive matching the name</returns>
        </member>
        <member name="P:Axiom.FileSystem.IArchiveFactory.Type">
            <summary>
            	Name of the archive supported by this factory.
            </summary>
        </member>
        <member name="T:Axiom.Core.Viewport">
            <summary>
            	Summary description for Viewport.
            	An abstraction of a viewport, i.e. a rendering region on a render
            	target.
            </summary>
            <remarks>
            	A viewport is the meeting of a camera and a rendering surface -
            	the camera renders the scene from a viewpoint, and places its
            	results into some subset of a rendering target, which may be the
            	whole surface or just a part of the surface. Each viewport has a
            	single camera as source and a single target as destination. A
            	camera only has 1 viewport, but a render target may have several.
            	A viewport also has a Z-order, i.e. if there is more than one
            	viewport on a single render target and they overlap, one must
            	obscure the other in some predetermined way.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Viewport._clearEveryFrame">
            <summary>
            	Should this viewport be cleared very frame?
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._clearBuffers">
            <summary>
            	Which buffers to clear every frame
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._camera">
            <summary>
            	Camera that this viewport is attached to.
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._target">
            <summary>
            	Render target that is using this viewport.
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._relativeTop">
            <summary>
            	Relative top [0.0, 1.0].
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._relativeLeft">
            <summary>
            	Relative left [0.0, 1.0].
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._relativeWidth">
            <summary>
            	Relative width [0.0, 1.0].
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._relativeHeight">
            <summary>
            	Relative height [0.0, 1.0].
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._actualTop">
            <summary>
            	Absolute top edge of the viewport (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._actualLeft">
            <summary>
            	Absolute left edge of the viewport (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._actualWidth">
            <summary>
            	Absolute width of the viewport (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._actualHeight">
            <summary>
            	Absolute height of the viewport (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._zOrder">
            <summary>
            	Depth order of the viewport, for sorting.
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._backColor">
            <summary>
            	Background color of the viewport.
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._isUpdated">
            <summary>
            	Has this viewport been updated?
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._showOverlays">
            <summary>
            	Should we show overlays on this viewport?
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._showSkies">
            <summary>
            	Should we show skies on this viewport?
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._showShadows">
            <summary>
            	Should we show shadows on this viewport?
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._materialScheme">
            <summary>
                Which material scheme should this viewport use?
            </summary>
        </member>
        <member name="F:Axiom.Core.Viewport._visibilityMask">
            <summary>
            the per-viewport visibility mask
            </summary>
        </member>
        <member name="M:Axiom.Core.Viewport.#ctor(Axiom.Core.Camera,Axiom.Graphics.RenderTarget,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            	The constructor. Dimensions of the viewport are expressed as a pecentage between
            	0 and 100. This allows the dimensions to apply irrespective of
            	changes in the target's size: e.g. to fill the whole area,
            	values of 0,0,100,100 are appropriate.
            </summary>
            <param name="camera">Reference to the camera to be the source for the image.</param>
            <param name="target">Reference to the render target to be the destination for the rendering.</param>
            <param name="left">Left</param>
            <param name="top">Top</param>
            <param name="width">Width</param>
            <param name="height">Height</param>
            <param name="zOrder">Relative Z-order on the target. Lower = further to the front.</param>
        </member>
        <member name="M:Axiom.Core.Viewport.UpdateDimensions">
            <summary>
            	Notifies the viewport of a possible change in dimensions.
            </summary>
            <remarks>
            	Used by the target to update the viewport's dimensions
            	(usually the result of a change in target size).
            </remarks>
        </member>
        <member name="M:Axiom.Core.Viewport.SetClearEveryFrame(System.Boolean)">
            <summary>
            	Determines whether to clear the viewport before rendering.
            </summary>
            <remarks>
            	If you expecting every pixel on the viewport to be redrawn
            	every frame, you can save a little time by not clearing the
            	viewport before every frame. Do so by passing 'false' to this
            	method (the default is to clear every frame).
            </remarks>
        </member>
        <member name="M:Axiom.Core.Viewport.SetClearEveryFrame(System.Boolean,Axiom.Graphics.FrameBuffer)">
            <summary>
            	Determines whether to clear the viewport before rendering.
            </summary>
            <remarks>
            	If you expecting every pixel on the viewport to be redrawn
            	every frame, you can save a little time by not clearing the
            	viewport before every frame. Do so by passing 'false' to this
            	method (the default is to clear every frame).
            </remarks>
        </member>
        <member name="M:Axiom.Core.Viewport.GetClearEveryFrame">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Viewport.GetClearBuffers">
            <summary>
            Gets the buffers to clear every frame
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Viewport.Update">
            <summary>
            	Instructs the viewport to updates its contents from the viewpoint of
            	the current camera.
            </summary>
        </member>
        <member name="M:Axiom.Core.Viewport.SetDimensions(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Allows setting the dimensions of the viewport (after creation).
            </summary>
            <remarks>
            	Dimensions relative to the size of the target,
            	represented as real values between 0 and 1. i.e. the full
            	target area is 0, 0, 1, 1.
            </remarks>
            <param name="left">Left edge of the viewport ([0.0, 1.0]).</param>
            <param name="top">Top edge of the viewport ([0.0, 1.0]).</param>
            <param name="width">Width of the viewport ([0.0, 1.0]).</param>
            <param name="height">Height of the viewport ([0.0, 1.0]).</param>
        </member>
        <member name="M:Axiom.Core.Viewport.GetActualDimensions(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            	Access to actual dimensions (based on target size).
            </summary>
            <param name="left">Left edge of the viewport (in pixels).</param>
            <param name="top">Top edge of the viewport (in pixels).</param>
            <param name="width">Width of the viewport (in pixels).</param>
            <param name="height">Height of the viewport (in pixels).</param>
        </member>
        <member name="P:Axiom.Core.Viewport.Camera">
            <summary>
            	Retrieves a reference to the camera for this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Target">
            <summary>
            	Retrieves a reference to the render target for this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Top">
            <summary>
            	Gets the relative top edge of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Left">
            <summary>
            	Gets the relative left edge of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Width">
            <summary>
            	Gets the relative width of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.Height">
            <summary>
            	Gets the relative height of the viewport, a value between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualTop">
            <summary>
            	Gets the actual top edge of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualLeft">
            <summary>
            	Gets the actual left edge of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualWidth">
            <summary>
            	Gets the actual width of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ActualHeight">
            <summary>
            	Gets the actual height of the viewport, a value in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.ZOrder">
            <summary>
            	Gets the ZOrder of this viewport.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.BackgroundColor">
            <summary>
            	Gets/Sets the background color which will be used to clear the screen every frame.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.IsUpdated">
            <summary>
            	Gets/Sets the IsUpdated value.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Core.Viewport.ShowOverlays" -->
        <member name="P:Axiom.Core.Viewport.ShowSkies">
            <summary>
            Tells this viewport whether it should display skies.
            </summary>
            <remarks>
            Skies are layers which appear on background of the scene. They are created via
            SceneManager.SetSkyBox, SceneManager.SetSkyPlane and SceneManager.SetSkyDome and
            every viewport displays these by default. However, you probably don't want this if
            you're using multiple viewports, because one of them is probably a picture-in-picture
            which is not supposed to have skies of it's own. In this case you can turn off skies
            on this viewport by calling this method.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.ShowShadows">
            <summary>
            Tells this viewport whether it should display shadows.
            </summary>
            <remarks>
            This setting enables you to disable shadow rendering for a given viewport. The global
            shadow technique set on SceneManager still controls the type and nature of shadows,
            but this flag can override the setting so that no shadows are rendered for a given
            viewport to save processing time where they are not required.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.MaterialScheme">
            <summary>
            the material scheme which the viewport should use.
            </summary>
            <remarks>
            This allows you to tell the system to use a particular
            material scheme when rendering this viewport, which can 
            involve using different techniques to render your materials.
            <see>Technique.SchemeName</see>
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.VisibilityMask">
            <summary>
            a per-viewport visibility mask.
            </summary>
            <remarks>
            The visibility mask is a way to exclude objects from rendering for
            a given viewport. For each object in the frustum, a check is made
            between this mask and the objects visibility flags 
            (MovableObject.VisibilityFlags), and if a binary 'and'
            returns zero, the object will not be rendered.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.RenderedFaceCount">
            <summary>
            	Returns the number of faces rendered to this viewport during the last frame.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.RenderedBatchCount">
            <summary>
            Gets the number of rendered batches in the last update.
            </summary>
        </member>
        <member name="P:Axiom.Core.Viewport.RenderQueueInvocationSequenceName">
            <summary>
            The name of the render queue invocation sequence for this target.
            </summary>
            <remarks>
            RenderQueueInvocationSequence instances are managed through Root. By
            setting this, you are indicating that you wish this RenderTarget to
            be updated using a custom sequence of render queue invocations, with
            potentially customised ordering and render state options. You should
            create the named sequence through Root first, then set the name here.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Viewport.RenderQueueInvocationSequence">
            <summary>
            the invocation sequence - will return null if using standard
            </summary>
        </member>
        <member name="T:Axiom.Core.Texture">
            <summary>
            	Abstract class representing a Texture resource.
            </summary>
            <remarks>
            	The actual concrete subclass which will exist for a texture
            	is dependent on the rendering system in use (Direct3D, OpenGL etc).
            	This class represents the commonalities, and is the one 'used'
            	by programmers even though the real implementation could be
            	different in reality. Texture objects are created through
            	the 'Create' method of the TextureManager concrete subclass.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Texture.width">
            <summary>Width of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.height">
            <summary>Height of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.depth">
            <summary>Depth of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.finalBpp">
            <summary>Bits per pixel in this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.srcWidth">
            <summary>Original source width if this texture had been modified.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.srcHeight">
            <summary>Original source height if this texture had been modified.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.srcBpp">
            <summary>Original source bits per pixel if this texture had been modified.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.hasAlpha">
            <summary>Does this texture have an alpha component?</summary>
        </member>
        <member name="F:Axiom.Core.Texture.format">
            <summary>Pixel format of this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.usage">
            <summary>Specifies how this texture will be used.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.textureType">
            <summary>Type of texture, i.e. 1D, 2D, Cube, Volume.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.numMipMaps">
            <summary>Number of mipmaps present in this texture.</summary>
        </member>
        <member name="F:Axiom.Core.Texture.gamma">
            <summary>Gamma setting for this texture.</summary>
        </member>
        <member name="M:Axiom.Core.Texture.Enable32Bit(System.Boolean)">
            <summary>
               Specifies whether this texture should use 32 bit color or not.
            </summary>
            <param name="enable">true if this should be treated as 32-bit, false if it should be 16-bit.</param>
        </member>
        <member name="M:Axiom.Core.Texture.LoadImage(Axiom.Media.Image)">
            <summary>
               Loads data from an Image directly into this texture.
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:Axiom.Core.Texture.LoadRawData(System.IO.Stream,System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from the stream into this texture.
            </summary>
            <param name="data">The raw, decoded image data.</param>
            <param name="width">Width of the texture data.</param>
            <param name="height">Height of the texture data.</param>
            <param name="format">Format of the supplied image data.</param>
        </member>
        <member name="M:Axiom.Core.Texture.Dispose">
            <summary>
            	Implementation of IDisposable to determine how resources are disposed of.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.Width">
            <summary>
               Gets the width (in pixels) of this texture.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.Height">
            <summary>
               Gets the height (in pixels) of this texture.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.Depth">
            <summary>
               Gets the depth of this texture (for volume textures).
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.Bpp">
            <summary>
               Gets the bits per pixel found within this texture data.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.HasAlpha">
            <summary>
               Gets whether or not the PixelFormat of this texture contains an alpha component.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.Gamma">
            <summary>
               Gets/Sets the gamma adjustment factor for this texture.
            </summary>
            <remarks>
               Must be called before any variation of Load.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Texture.Format">
            <summary>
               Gets the PixelFormat of this texture.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.NumMipMaps">
            <summary>
               Number of mipmaps present in this texture.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.TextureType">
            <summary>
               Type of texture, i.e. 2d, 3d, cubemap.
            </summary>
        </member>
        <member name="P:Axiom.Core.Texture.Usage">
            <summary>
                Gets the intended usage of this texture, whether for standard usage
                or as a render target.
            </summary>
        </member>
        <member name="T:Axiom.Collections.UnsortedCollection`1">
            <summary>
            Summary description for DriverCollection.
            </summary>
        </member>
        <member name="T:Axiom.Collections.NodeCollection">
            <summary>
            	A strongly-typed collection of <see cref="T:Axiom.Core.Node"/> objects.
            </summary>
        </member>
        <member name="M:Axiom.Collections.NodeCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.NodeCollection.Add(Axiom.Core.Node)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.NodeCollection.Add(System.String,Axiom.Core.Node)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.NodeCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.NodeCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.ControllerList">
            <summary>
            Summary description for AnimationCollection.
            </summary>
        </member>
        <member name="T:Axiom.Animating.SkeletonManager">
            <summary>
            Summary description for SkeletonManager.
            </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletonManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonManager.Create(System.String)">
            <summary>
               Creates a new skeleton object.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.SkeletonManager.Load(System.String)">
            <summary>
               Overloaded method.  Call overload with default of priority 1.
            </summary>
            <param name="fileName">Name of the skeleton file to load.</param>
        </member>
        <member name="M:Axiom.Animating.SkeletonManager.Load(System.String,System.Int32)">
            <summary>
               Load a skeleton.  Creates one if it doesn't exists, else return the cached version.
            </summary>
            <remarks>
               Creates one if it doesn't exists, else return the cached version.
            </remarks>
            <param name="fileName"></param>
            <param name="priority"></param>
        </member>
        <member name="P:Axiom.Animating.SkeletonManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshChunkID">
            <summary>
            	Values that mark data chunks in the .mesh file.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Header">
            <summary>
            	string vesion;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Mesh">
            <summary>
            	bool skeletallyAnimated: Important flag which affects h/w buffer policies
            	Optional Geometry chunk.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMesh">
            <summary>
            	string materialName;
            	bool useSharedVertices;
            	uint indexCount;
            	bool indexes32Bit;
            	uint[indexCount]/ushort[indexCount] faceVertexIndices;
            	M_GEOMETRY chunk (Optional: present only if useSharedVertices = false)
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMeshOperation">
            <summary>
            	ushort operationType: Optional - TriangleList assumed if missing.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.SubMeshBoneAssignment">
            <summary>
            	Optional bone weights (repeating section)
            	uint vertexIndex;
            	ushort boneIndex;
            	float weight;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.Geometry">
            <summary>
            	This chunk is embedded within Mesh and SubMesh.
            	uint vertexCount;
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryVertexDeclaration">
            <summary>
            	Beginning of a vertex delcaraion section.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryNormals">
            <summary>
            	Optional (pre 1.30).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.GeometryVertexElement" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.GeometryVertexBuffer" -->
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryColors">
            <summary>
            	Optional (pre 1.30).
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryVertexBufferData">
            <summary>
            	Raw buffer data.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.GeometryTexCoords">
            <summary>
            	Optional, REPEATABLE, each one adds an extra set.  (pre 1.30).
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshChunkID.MeshSkeletonLink">
            <summary>
            	Optional link to skeleton.
            	string skeletonName:	name of .skeleton to use
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.MeshBoneAssignment" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.MeshLOD" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.MeshLODUsage" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.MeshLODManual" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.MeshLODGenerated" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.MeshBounds" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.SubMeshNameTable" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.SubMeshNameTableElement" -->
        <member name="F:Axiom.Serialization.MeshChunkID.EdgeLists">
            <summary>
            	Optional chunk which stores precomputed edge data.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.EdgeListLOD" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Serialization.MeshChunkID.EdgeListGroup" -->
        <member name="T:Axiom.Scripting.ScriptEnumAttribute">
            <summary>
            	This attribute is intended to be used on enum fields for enums that can be used
            	in script files (.material, .overlay, etc).  Placing this attribute on the field will
            	allow the script parsers to look up a real enum value based on the value as it is
            	used in the script.
            </summary>
            <remarks>
            	For example, texturing addressing mode can base used in .material scripts, and
            	the values in the script are 'wrap', 'clamp', and 'mirror'.
            	<p/>
            	The TextureAddress enum fields are defined with attributes to create the mapping
            	between the scriptable values and their real enum values.
            	<p/>
            	...
            	[ScriptEnum("wrap")]
            	Wrap
            	...
            </remarks>
        </member>
        <member name="M:Axiom.Scripting.ScriptEnumAttribute.#ctor(System.String)">
            <summary>
            	
            </summary>
            <param name="val">The value as it will appear when used in script files (.material, .overlay, etc).</param>
        </member>
        <member name="M:Axiom.Scripting.ScriptEnumAttribute.Lookup(System.String,System.Type)">
            <summary>
            	Returns an actual enum value for a enum that can be used in script files.
            </summary>
            <param name="val"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.ScriptEnumAttribute.GetLegalValues(System.Type)">
            <summary>
            	Returns a string describing the legal values for a particular enum.
            </summary>
            <param name="type"></param>
            <returns>
            	A string containing legal values for script file.  
            	i.e. "'none', 'clockwise', 'anticlockwise'"
            </returns>
        </member>
        <member name="T:Axiom.Scripting.AttributeParserAttribute">
            <summary>
            	Custom attribute to mark methods as handling the parsing for a material script attribute.
            </summary>
        </member>
        <member name="T:Axiom.Math.Matrix3">
            <summary>
            A 3x3 matrix which can represent rotations around axes.
            </summary>
        </member>
        <member name="F:Axiom.Math.Matrix3.m00">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Math.Matrix3.m01">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Math.Matrix3.m02">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix3.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Creates a new Matrix3 with all the specified parameters.
            </summary>
        </member>
        <member name="M:Axiom.Math.Matrix3.#ctor(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            Create a new Matrix from 3 Vertex3 objects.
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Matrix3.Transpose">
            <summary>
            Swap the rows of the matrix with the columns.
            </summary>
            <returns>A transposed Matrix.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.GetColumn(System.Int32)">
            <summary>
            	Gets a matrix column by index.
            </summary>
            <param name="col"></param>
            <returns>A Vector3 representing one of the Matrix columns.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.SetColumn(System.Int32,Axiom.Math.Vector3)">
            <summary>
            	Sets one of the columns of the Matrix with a Vector3.
            </summary>
            <param name="col"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.FromAxes(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Creates a Matrix3 from 3 axes.
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Matrix3.FromEulerAnglesXYZ(System.Single,System.Single,System.Single)">
            <summary>
               Constructs this Matrix from 3 euler angles, in degrees.
            </summary>
            <param name="yaw"></param>
            <param name="pitch"></param>
            <param name="roll"></param>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            Multiply (concatenate) two Matrix3 instances together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            Multiply (concatenate) two Matrix3 instances together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Vector3,Axiom.Math.Matrix3)">
            <summary>
            	vector * matrix [1x3 * 3x3 = 1x3]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Vector3,Axiom.Math.Matrix3)">
            <summary>
            	vector * matrix [1x3 * 3x3 = 1x3]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Matrix3,Axiom.Math.Vector3)">
            <summary>
            	matrix * vector [3x3 * 3x1 = 3x1]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Matrix3,Axiom.Math.Vector3)">
            <summary>
            	matrix * vector [3x3 * 3x1 = 3x1]
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(Axiom.Math.Matrix3,System.Single)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(Axiom.Math.Matrix3,System.Single)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Multiply(System.Single,Axiom.Math.Matrix3)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Multiply(System.Single,Axiom.Math.Matrix3)">
            <summary>
            Multiplies all the items in the Matrix3 by a scalar value.
            </summary>
            <param name="matrix"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Add(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Addition(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to add two matrices together.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Subtract(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Subtraction(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Used to subtract two matrices.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Negate(Axiom.Math.Matrix3)">
            <summary>
            Negates all the items in the Matrix.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_UnaryNegation(Axiom.Math.Matrix3)">
            <summary>
            Negates all the items in the Matrix.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.op_Equality(Axiom.Math.Matrix3,Axiom.Math.Matrix3)">
            <summary>
            	Test two matrices for (value) equality
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Matrix4.
            </summary>
            <returns>A string representation of a vector3.</returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Matrix3.Equals(System.Object)">
            <summary>
            	Compares this Matrix to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Matrix3.Identity">
            <summary>
            Identity Matrix
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix3.Zero">
            <summary>
            Zero matrix.
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix3.Item(System.Int32,System.Int32)">
            <summary>
            Indexer for accessing the matrix like a 2d array (i.e. matrix[2,3]).
            </summary>
        </member>
        <member name="P:Axiom.Math.Matrix3.Item(System.Int32)">
            <summary>
            	Allows the Matrix to be accessed linearly (m[0] -> m[8]).  
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HighLevelGpuProgramManager">
            <summary>
            	This ResourceManager manages high-level vertex and fragment programs. 
            </summary>
            <remarks>
               High-level vertex and fragment programs can be used instead of assembler programs
               as managed by <see cref="T:Axiom.Graphics.GpuProgramManager"/>; however they typically result in a 
               <see cref="T:Axiom.Graphics.GpuProgram"/> being created as a derivative of the high-level program. 
               High-level programs are easier to write, and can often be API-independent, 
               unlike assembler programs. 
               <p/>
               This class not only manages the programs themselves, it also manages the factory
               classes which allow the creation of high-level programs using a variety of high-level
               syntaxes. Plugins can be created which register themselves as high-level program
               factories and as such the engine can be extended to accept virtually any kind of
               program provided a plugin is written.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgramManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HighLevelGpuProgramManager.factories">
            <summary>
               Lookup table for list of registered factories.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.AddFactory(Axiom.Graphics.IHighLevelGpuProgramFactory)">
            <summary>
               Add a new factory object for high-level programs of a given language.
            </summary>
            <param name="factory">
               The factory instance to register.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.CreateProgram(System.String,System.String,Axiom.Graphics.GpuProgramType)">
            <summary>
               Creates a new, unloaded HighLevelGpuProgram instance.
            </summary>
            <remarks>
               This method creates a new program of the type specified as the second and third parameters.
               You will have to call further methods on the returned program in order to 
               define the program fully before you can load it.
            </remarks>
            <param name="name">Name of the program to create.</param>
            <param name="language">HLSL language to use.</param>
            <param name="type">Type of program, i.e. vertex or fragment.</param>
            <returns>An unloaded instance of HighLevelGpuProgram.</returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.GetFactory(System.String)">
            <summary>
               Retreives a factory instance capable of producing HighLevelGpuPrograms of the
               specified language.
            </summary>
            <param name="language">HLSL language.</param>
            <returns>A factory capable of creating a HighLevelGpuProgram of the specified language.</returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.Create(System.String)">
            <summary>
               Overridden to throw an exception since this Create method isn't sufficient enough
               for creating HighLevelGpuPrograms, since more info is required.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.GetByName(System.String)">
            <summary>
                Gets a HighLevelGpuProgram with the specified name.
            </summary>
            <param name="name">Name of the program to retrieve.</param>
            <returns>The high level gpu program with the specified name.</returns>
        </member>
        <member name="M:Axiom.Graphics.HighLevelGpuProgramManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HighLevelGpuProgramManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IHighLevelGpuProgramFactory">
            <summary>
               Interface definition for factories that create instances of HighLevelGpuProgram.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.IHighLevelGpuProgramFactory.Create(System.String,Axiom.Graphics.GpuProgramType)">
            <summary>
               Create method which needs to be implemented to return an
               instance of a HighLevelGpuProgram.
            </summary>
            <param name="name">
               Name of the program to create.
            </param>
            <param name="type">
               Type of program to create, i.e. vertex or fragment.
            </param>
            <returns>
               A newly created instance of HighLevelGpuProgram.
            </returns>
        </member>
        <member name="P:Axiom.Graphics.IHighLevelGpuProgramFactory.Language">
            <summary>
               Gets the name of the HLSL language that this factory creates programs for.
            </summary>
        </member>
        <member name="T:Axiom.Core.MeshManager">
            <summary>
            	Handles the management of mesh resources.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshManager.prepAllMeshesForShadowVolumes">
            <summary>
            	Flag indicating whether newly loaded meshes should also be prepared for 
            	shadow volumes.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.Initialize">
            <summary>
            	Called internally to initialize this manager.
            </summary>
        </member>
        <member name="M:Axiom.Core.MeshManager.Create(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateManual(System.String)">
            <summary>
            	Creates a barebones Mesh object that can be used to manually define geometry later on.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreatePlane(System.String,Axiom.Math.Plane,System.Int32,System.Int32)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name">Name of the plane mesh.</param>
            <param name="plane">Plane to use for distance and orientation of the mesh.</param>
            <param name="width">Width in world coordinates.</param>
            <param name="height">Height in world coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreatePlane(System.String,Axiom.Math.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name">Name of the plane mesh.</param>
            <param name="plane">Plane to use for distance and orientation of the mesh.</param>
            <param name="width">Width in world coordinates.</param>
            <param name="height">Height in world coordinates.</param>
            <param name="xSegments">Number of x segments for tesselation.</param>
            <param name="ySegments">Number of y segments for tesselation.</param>
            <param name="normals">If true, plane normals are created.</param>
            <param name="numTexCoordSets">Number of 2d texture coord sets to use.</param>
            <param name="uTile">Number of times the texture should be repeated in the u direction.</param>
            <param name="vTile">Number of times the texture should be repeated in the v direction.</param>
            <param name="upVec">The up direction of the plane.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateBezierPatch(System.String,System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Core.VisibleSide,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
                Creates a Bezier patch based on an array of control vertices.
            </summary>
            <param name="name"></param>
            <param name="controlPointBuffer"></param>
            <param name="declaration"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="uMaxSubdivisionLevel"></param>
            <param name="uMaxSubdivisionLevel"></param>
            <param name="visibleSide"></param>
            <param name="vbUsage"></param>
            <param name="ibUsage"></param>
            <param name="vbUseShadow"></param>
            <param name="ibUseShadow"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedIllusionPlane(System.String,Axiom.Math.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="plane"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="curvature"></param>
            <param name="xSegments"></param>
            <param name="ySegments"></param>
            <param name="normals"></param>
            <param name="numberOfTexCoordSets"></param>
            <param name="uTiles"></param>
            <param name="vTiles"></param>
            <param name="upVector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.CreateCurvedIllusionPlane(System.String,Axiom.Math.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,Axiom.Math.Vector3,Axiom.Math.Quaternion,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="plane"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="curvature"></param>
            <param name="xSegments"></param>
            <param name="ySegments"></param>
            <param name="normals"></param>
            <param name="numberOfTexCoordSets"></param>
            <param name="uTiles"></param>
            <param name="vTiles"></param>
            <param name="upVector"></param>
            <param name="orientation"></param>
            <param name="vertexBufferUsage"></param>
            <param name="indexBufferUsage"></param>
            <param name="vertexShadowBuffer"></param>
            <param name="indexShadowBuffer"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.MeshManager.Load(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Core.MeshManager.Load(System.String,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Core.MeshManager.Tesselate2DMesh(Axiom.Core.SubMesh,System.Int32,System.Int32,System.Boolean,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Used to generate a face list based on vertices.
            </summary>
            <param name="subMesh"></param>
            <param name="xSegments"></param>
            <param name="ySegments"></param>
            <param name="doubleSided"></param>
        </member>
        <member name="P:Axiom.Core.MeshManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Core.MeshManager.PrepareAllMeshesForShadowVolumes">
            <summary>
            	Tells the mesh manager that all future meshes should prepare themselves for
            	shadow volumes on loading.
            </summary>
        </member>
        <member name="T:Axiom.Core.IPlugin">
            <summary>
            	Any class that wants to entend the functionality of the engine can implement this
            	interface.  Classes implementing this interface will automatically be loaded and
            	started by the engine during the initialization phase.  Examples of plugins would be
            	RenderSystems, SceneManagers, etc, which can register themself using the 
            	singleton instance of the Engine class.
            </summary>
        </member>
        <member name="M:Axiom.Core.IPlugin.Start">
            <summary>
            Called to start the plugin.
            </summary>
        </member>
        <member name="M:Axiom.Core.IPlugin.Stop">
            <summary>
            Called while the engine is shutting down.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.WaveformControllerFunction">
            <summary>
            	Summary description for WaveformControllerFunction.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.BaseControllerFunction">
            <summary>
            	Subclasses of this class are responsible for performing a function on an input value for a Controller.
             </summary>
             <remarks>
            	This abstract class provides the interface that needs to be supported for a custom function which
            	can be 'plugged in' to a Controller instance, which controls some object value based on an input value.
            	For example, the WaveControllerFunction class provided by Ogre allows you to use various waveforms to
            	translate an input value to an output value.
            	<p/>
            	This base class implements IControllerFunction, but leaves the implementation up to the subclasses.
            </remarks>
        </member>
        <member name="T:Axiom.Controllers.IControllerFunction">
            <summary>
            	Interface describing the required methods of a Controller Function.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.IControllerFunction.Execute(System.Single)">
            <summary>
            	Called by a controller every frame to have this function run and return on the supplied
            	source value and return the result.
            </summary>
            <param name="sourceValue"></param>
        </member>
        <member name="F:Axiom.Controllers.BaseControllerFunction.useDeltaInput">
            <summary>
            	If true, function will add input values together and wrap at 1.0 before evaluating.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.BaseControllerFunction.deltaCount">
            <summary>
            	Value to be added during evaluation.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.BaseControllerFunction.AdjustInput(System.Single)">
            <summary>
            	Adjusts the input value by a delta.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Controllers.Canned.AnimationControllerFunction">
            <summary>
                Predefined controller function for dealing with animation.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.AnimationControllerFunction.sequenceTime">
            <summary>
                The amount of time in seconds it takes to loop through the whole animation sequence.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.AnimationControllerFunction.time">
            <summary>
                The offset in seconds at which to start (default is start at 0).
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Canned.AnimationControllerFunction.#ctor(System.Single)">
            <summary>
                Constructor.
            </summary>
            <param name="sequenceTime">The amount of time in seconds it takes to loop through the whole animation sequence.</param>
        </member>
        <member name="M:Axiom.Controllers.Canned.AnimationControllerFunction.#ctor(System.Single,System.Single)">
            <summary>
                Constructor.
            </summary>
            <param name="sequenceTime">The amount of time in seconds it takes to loop through the whole animation sequence.</param>
            <param name="timeOffset">The offset in seconds at which to start.</param>
        </member>
        <member name="M:Axiom.Controllers.Canned.AnimationControllerFunction.Execute(System.Single)">
            <summary>
            
            </summary>
            <param name="sourceValue"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Collections.ViewportCollection">
            <summary>
            Summary description for ViewportCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.ViewportCollection.Add(Axiom.Core.Viewport)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:Axiom.Collections.SceneNodeCollection">
            <summary>
            Summary description for SceneNodeCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneNodeCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneNodeCollection.Add(Axiom.Core.SceneNode)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.SceneNodeCollection.Add(System.String,Axiom.Core.SceneNode)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.SceneNodeCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.SceneNodeCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.RenderSystemCollection">
            <summary>
            Summary description for RenderSystemCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderSystemCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderSystemCollection.Add(Axiom.Graphics.RenderSystem)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.RenderSystemCollection.Add(System.String,Axiom.Graphics.RenderSystem)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.RenderSystemCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.RenderSystemCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Animating.VertexBoneAssignment">
            <summary>
            	Records the assignment of a single vertex to a single bone with the corresponding weight.
             </summary>
             <remarks>
            	This simple struct simply holds a vertex index, bone index and weight representing the
            	assignment of a vertex to a bone for skeletal animation. There may be many of these
            	per vertex if blended vertex assignments are allowed.
            	This is a class because we need it as a reference type to allow for modification
            	in places where we would only have a copy of the data if it were a struct. 
            </remarks>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleAffector">
            <summary>
            	Abstract class defining the interface to be implemented by particle affectors.
            </summary>
            <remarks>
            	Particle affectors modify particles in a particle system over their lifetime. They can be
            	grouped into types, e.g. 'vector force' affectors, 'fader' affectors etc; each type will 
            	modify particles in a different way, using different parameters.
            	<para/>
            	Because there are so many types of affectors you could use, the engine chooses not to dictate
            	the available types. It comes with some in-built, but allows plugins or applications to extend the affector types available.
            	This is done by subclassing ParticleAffector to have the appropriate emission behavior you want,
            	and also creating a subclass of ParticleAffectorFactory which is responsible for creating instances 
            	of your new affector type. You register this factory with the ParticleSystemManager using
            	AddAffectorFactory, and from then on affectors of this type can be created either from code or through
            	.particle scripts by naming the type.
            	<para/>
            	This same approach is used for ParticleEmitters (which are the source of particles in a system).
            	This means that the engine is particularly flexible when it comes to creating particle system effects,
            	with literally infinite combinations of affector and affector types, and parameters within those
            	types.
            </remarks>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleAffector.type">
            <summary>Name of the affector type.  Must be initialized by subclasses.</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.AffectParticles(Axiom.ParticleSystems.ParticleSystem,System.Single)">
            <summary>
            	Method called to allow the affector to 'do it's stuff' on all active particles in the system.
            </summary>
            <remarks>
            	This is where the affector gets the chance to apply it's effects to the particles of a system.
            	The affector is expected to apply it's effect to some or all of the particles in the system
            	passed to it, depending on the affector's approach.
            </remarks>
            <param name="system">Reference to a ParticleSystem to affect.</param>
            <param name="timeElapsed">The number of seconds which have elapsed since the last call.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.CopyTo(Axiom.ParticleSystems.ParticleAffector)">
            <summary>
            
            </summary>
            <param name="emitter"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.InitParticle(Axiom.ParticleSystems.Particle@)">
            <summary>
            	Method called to allow the affector to 'do it's stuff' on all active particles in the system.
            </summary>
            <remarks>
            	This is where the affector gets the chance to apply it's effects to the particles of a system.
            	The affector is expected to apply it's effect to some or all of the particles in the system
            	passed to it, depending on the affector's approach.
            </remarks>
            <param name="system">Reference to a ParticleSystem to affect.</param>
            <param name="timeElapsed">The number of seconds which have elapsed since the last call.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.SetParam(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffector.RegisterCommands">
            <summary>
            	Registers all attribute names with their respective parser.
            </summary>
            <remarks>
            	Methods meant to serve as attribute parsers should use a method attribute to 
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleAffector.Type">
            <summary>
            	Gets the type name of this affector.
            </summary>
        </member>
        <member name="T:Axiom.Media.JPGCodec">
            <summary>
               JPG image file codec.
            </summary>
        </member>
        <member name="M:Axiom.Media.JPGCodec.Decode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
               Passthrough implementation, no special code needed.
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Media.JPGCodec.Encode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="args"></param>
        </member>
        <member name="P:Axiom.Media.JPGCodec.Type">
            <summary>
               Returns the JPG file extension.
            </summary>
        </member>
        <member name="P:Axiom.Media.JPGCodec.ILType">
            <summary>
               Returns JPG enum.
            </summary>
        </member>
        <member name="T:Axiom.Media.DDSCodec">
            <summary>
               Microsoft's DDS file format codec.
            </summary>
        </member>
        <member name="P:Axiom.Media.DDSCodec.ILType">
            <summary>
               DDS enum value.
            </summary>
        </member>
        <member name="P:Axiom.Media.DDSCodec.Type">
            <summary>
               Returns that this codec handles dds files.
            </summary>
        </member>
        <member name="T:Axiom.Math.Vector4">
            <summary>
            4D homogeneous vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector4.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Creates a new 4 dimensional Vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector4.Dot(Axiom.Math.Vector4)">
            <summary>
                Calculates the dot (scalar) product of this vector with another.
            </summary>
            <param name="vec">
                Vector with which to calculate the dot product (together with this one).
            </param>
            <returns>A float representing the dot product value.</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.Multiply(Axiom.Math.Vector4,Axiom.Math.Matrix4)">
            <summary>
            	
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Multiply(Axiom.Math.Matrix4,Axiom.Math.Vector4)">
            <summary>
            	
            </summary>
            <param name="vector"></param>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Multiply(Axiom.Math.Vector4,System.Single)">
            <summary>
            	Multiplies a Vector4 by a scalar value.
            </summary>
            <param name="vector"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Equality(Axiom.Math.Vector4,Axiom.Math.Vector4)">
            <summary>
            	User to compare two Vector4 instances for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_UnaryNegation(Axiom.Math.Vector4)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.op_Inequality(Axiom.Math.Vector4,Axiom.Math.Vector4)">
            <summary>
            	User to compare two Vector4 instances for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Vector4.
            </summary>
            <returns>A string representation of a Vector4.</returns>
        </member>
        <member name="M:Axiom.Math.Vector4.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector4.Equals(System.Object)">
            <summary>
            	Compares this Vector to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Vector4.Item(System.Int32)">
            <summary>
            	Used to access a Vector by index 0 = this.x, 1 = this.y, 2 = this.z, 3 = this.w.  
            </summary>
            <remarks>
            	Uses unsafe pointer arithmetic to reduce the code required.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.HardwareIndexBuffer">
            <summary>
            	Describes the graphics API independent functionality required by a hardware
            	index buffer.  
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareBuffer">
            <summary>
                Abstract class defining common features of hardware buffers.
            </summary>
            <remarks>
                A 'hardware buffer' is any area of memory held outside of core system ram,
                and in our case refers mostly to video ram, although in theory this class
                could be used with other memory areas such as sound card memory, custom
                coprocessor memory etc.
                <p/>
                This reflects the fact that memory held outside of main system RAM must 
                be interacted with in a more formal fashion in order to promote
                cooperative and optimal usage of the buffers between the various 
                processing units which manipulate them.
                <p/>
                This abstract class defines the core interface which is common to all
                buffers, whether it be vertex buffers, index buffers, texture memory
                or framebuffer memory etc.
                <p/>
                Buffers have the ability to be 'shadowed' in system memory, this is because
                the kinds of access allowed on hardware buffers is not always as flexible as
                that allowed for areas of system memory - for example it is often either 
                impossible, or extremely undesirable from a performance standpoint to read from
                a hardware buffer; when writing to hardware buffers, you should also write every
                byte and do it sequentially. In situations where this is too restrictive, 
                it is possible to create a hardware, write-only buffer (the most efficient kind) 
                and to back it with a system memory 'shadow' copy which can be read and updated arbitrarily.
                Axiom handles synchronizing this buffer with the real hardware buffer (which should still be
                created with the <see cref="F:Axiom.Graphics.BufferUsage.Dynamic"/> flag if you intend to update it very frequently). 
                Whilst this approach does have it's own costs, such as increased memory overhead, these costs can 
                often be outweighed by the performance benefits of using a more hardware efficient buffer.
                You should look for the 'useShadowBuffer' parameter on the creation methods used to create
                the buffer of the type you require (see <see cref="T:Axiom.Graphics.HardwareBufferManager"/>) to enable this feature.
                <seealso cref="T:Axiom.Graphics.HardwareBufferManager"/>
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.sizeInBytes">
            <summary>
                Total size (in bytes) of the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.usage">
            <summary>
                Usage type for this buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.isLocked">
            <summary>
                Is this buffer currently locked?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.lockStart">
            <summary>
                Byte offset into the buffer where the current lock is held.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.lockSize">
            <summary>
                Total size (int bytes) of locked buffer data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.useSystemMemory">
            <summary>
                
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.useShadowBuffer">
            <summary>
                Does this buffer have a shadow buffer?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.shadowBuffer">
            <summary>
                Reference to the sys memory shadow buffer tied to this hardware buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.shadowUpdated">
            <summary>
                Flag indicating whether the shadow buffer (if it exists) has been updated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.suppressHardwareUpdate">
            <summary>
                Flag indicating whether hardware updates from shadow buffer should be supressed.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBuffer.ID">
            <summary>
            	Unique id for this buffer.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.#ctor(Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
                Constructor.
            </summary>
            <param name="usage">Usage type.</param>
            <param name="useSystemMemory"></param>
            <param name="useShadowBuffer">Use a software shadow buffer?</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.Lock(Axiom.Graphics.BufferLocking)">
            <summary>
            	Convenient overload to allow locking the entire buffer with only having
            	to supply the locking type.
            </summary>
            <param name="locking">Locking options.</param>
            <returns>IntPtr to the beginning of the locked region of buffer memory.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.Lock(System.Int32,System.Int32,Axiom.Graphics.BufferLocking)">
            <summary>
            	Used to lock a vertex buffer in hardware memory in order to make modifications.
            </summary>
            <param name="offset">Starting index in the buffer to lock.</param>
            <param name="length">Nunber of bytes to lock after the offset.</param>
            <param name="locking">Specifies how to lock the buffer.</param>
            <returns>An array of the <code>System.Type</code> associated with this VertexBuffer.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.LockImpl(System.Int32,System.Int32,Axiom.Graphics.BufferLocking)">
            <summary>
                Internal implementation of Lock, which will be overridden by subclasses to provide
                the core locking functionality.
            </summary>
            <param name="offset">Offset into the buffer (in bytes) to lock.</param>
            <param name="length">Length of the portion of the buffer (int bytes) to lock.</param>
            <param name="locking">Locking type.</param>
            <returns>IntPtr to the beginning of the locked portion of the buffer.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.Unlock">
            <summary>
            	Must be called after a call to <code>Lock</code>.  Unlocks the vertex buffer in the hardware
            	memory.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.UnlockImpl">
            <summary>
                Abstract implementation of <see cref="M:Axiom.Graphics.HardwareBuffer.Unlock"/>.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.UpdateFromShadow">
            <summary>
                Updates the real buffer from the shadow buffer, if required.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.ReadData(System.Int32,System.Int32,System.IntPtr)">
            <summary>
                Reads data from the buffer and places it in the memory pointed to by 'dest'.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to read.</param>
            <param name="length">The size of the area to read, in bytes.</param>
            <param name="dest">
                The area of memory in which to place the data, must be large enough to 
                accommodate the data!
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.IntPtr)">
            <summary>
                Writes data to the buffer from an area of system memory; note that you must
                ensure that your buffer is big enough.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="src">The source of the data to be written.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.IntPtr,System.Boolean)">
            <summary>
                Writes data to the buffer from an area of system memory; note that you must
                ensure that your buffer is big enough.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="src">The source of the data to be written.</param>
            <param name="discardWholeBuffer">
                If true, this allows the driver to discard the entire buffer when writing,
                such that DMA stalls can be avoided; use if you can.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.Array)">
            <summary>
               Allows passing in a managed array of data to fill the vertex buffer.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="data">
                Array of data to blast into the buffer.  This can be an array of custom structs, that hold
                position, normal, etc data.  The size of the struct *must* match the vertex size of the buffer,
                so use with care.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.WriteData(System.Int32,System.Int32,System.Array,System.Boolean)">
            <summary>
               Allows passing in a managed array of data to fill the vertex buffer.
            </summary>
            <param name="offset">The byte offset from the start of the buffer to start writing.</param>
            <param name="length">The size of the data to write to, in bytes.</param>
            <param name="data">
                Array of data to blast into the buffer.  This can be an array of custom structs, that hold
                position, normal, etc data.  The size of the struct *must* match the vertex size of the buffer,
                so use with care.
            </param>
            <param name="discardWholeBuffer">
                If true, this allows the driver to discard the entire buffer when writing,
                such that DMA stalls can be avoided; use if you can.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.CopyData(Axiom.Graphics.HardwareBuffer,System.Int32,System.Int32,System.Int32)">
            <summary>
                Copy data from another buffer into this one.
            </summary>
            <param name="srcBuffer">The buffer from which to read the copied data.</param>
            <param name="srcOffset">Offset in the source buffer at which to start reading.</param>
            <param name="destOffset">Offset in the destination buffer to start writing.</param>
            <param name="length">Length of the data to copy, in bytes.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.CopyData(Axiom.Graphics.HardwareBuffer,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
                Copy data from another buffer into this one.
            </summary>
            <param name="srcBuffer">The buffer from which to read the copied data.</param>
            <param name="srcOffset">Offset in the source buffer at which to start reading.</param>
            <param name="destOffset">Offset in the destination buffer to start writing.</param>
            <param name="length">Length of the data to copy, in bytes.</param>
            <param name="discardWholeBuffer">If true, will discard the entire contents of this buffer before copying.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.SuppressHardwareUpdate(System.Boolean)">
            <summary>
                Pass true to suppress hardware upload of shadow buffer changes.
            </summary>
            <param name="suppress">If true, shadow buffer updates won't be uploaded to hardware.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBuffer.Dispose">
            <summary>
                Called to destroy resources used by this hardware buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.IsLocked">
            <summary>
            	Gets whether or not this buffer is currently locked.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.IsSystemMemory">
            <summary>
            	Gets whether this buffer is held in system memory.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.Size">
            <summary>
            	Gets the size (in bytes) for this buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.Usage">
            <summary>
            	Gets the usage of this buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBuffer.HasShadowBuffer">
            <summary>
                Gets a bool that specifies whether this buffer has a software shadow buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareIndexBuffer.type">
            <summary>
            	Type of index (16 or 32 bit).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareIndexBuffer.numIndices">
            <summary>
            	Number of indices in this buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareIndexBuffer.indexSize">
            <summary>
                Size of each index.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareIndexBuffer.#ctor(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
            	Constructor.
            </summary>
            <param name="type">Type of index (16 or 32 bit).</param>
            <param name="numIndices">Number of indices to create in this buffer.</param>
            <param name="usage">Buffer usage.</param>
            <param name="useSystemMemory">Create in system memory?</param>
            <param name="useShadowBuffer">Use a shadow buffer for reading/writing?</param>
        </member>
        <member name="P:Axiom.Graphics.HardwareIndexBuffer.Type">
            <summary>
            	Gets an enum specifying whether this index buffer is 16 or 32 bit elements.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareIndexBuffer.IndexCount">
            <summary>
            	Gets the number of indices in this buffer.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareIndexBuffer.IndexSize">
            <summary>
                Gets the size (in bytes) of each index element.
            </summary>
            <value></value>
        </member>
        <member name="T:Axiom.Graphics.EdgeListBuilder">
            <summary>
                General utility class for building edge lists for geometry.
            </summary>
            <remarks>
                You can add multiple sets of vertex and index data to build an edge list. 
                Edges will be built between the various sets as well as within sets; this allows 
                you to use a model which is built from multiple SubMeshes each using 
                separate index and (optionally) vertex data and still get the same connectivity 
                information. It's important to note that the indexes for the edge will be constrained
                to a single vertex buffer though (this is required in order to render the edge).
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.indexDataList">
            <summary>
            	List of objects that will provide index data to the build process.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.indexDataVertexDataSetList">
            <summary>
            	Mapping of index data sets to vertex data sets.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.vertexDataList">
            <summary>
            	List of vertex data objects.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.vertices">
            <summary>
            	List of common vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.edgeData">
            <summary>
            	Underlying edge data to use for building.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.operationTypes">
            <summary>
            	Mappings of operation type to vertex data.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.uniqueEdges">
            <summary>
            	Unique edges, used to detect whether there are too many triangles on an edge
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.weldVertices">
            <summary>
            	Do we weld common vertices at all?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.weldVerticesAcrossVertexSets">
            <summary>
            	Should we treat coincident vertices from different vertex sets as one?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.weldVerticesAcrossIndexSets">
            <summary>
            	Should we treat coincident vertices referenced from different index sets as one?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.AddVertexData(Axiom.Graphics.VertexData)">
            <summary>
                Add a set of vertex geometry data to the edge builder.
            </summary>
            <remarks>
                You must add at least one set of vertex data to the builder before invoking the
                <see cref="M:Axiom.Graphics.EdgeListBuilder.Build"/> method.
            </remarks>
            <param name="vertexData">Vertex data to consider for edge detection.</param>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.AddIndexData(Axiom.Graphics.IndexData)">
            <summary>
                Add a set of index geometry data to the edge builder.
            </summary>
            <remarks>
                You must add at least one set of index data to the builder before invoking the
                <see cref="M:Axiom.Graphics.EdgeListBuilder.Build"/> method.
            </remarks>
            <param name="indexData">The index information which describes the triangles.</param>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.AddIndexData(Axiom.Graphics.IndexData,System.Int32,Axiom.Graphics.OperationType)">
            <summary>
                Add a set of index geometry data to the edge builder.
            </summary>
            <remarks>
                You must add at least one set of index data to the builder before invoking the
                <see cref="M:Axiom.Graphics.EdgeListBuilder.Build"/> method.
            </remarks>
            <param name="indexData">The index information which describes the triangles.</param>
            <param name="vertexSet">
                The vertex data set this index data refers to; you only need to alter this
                if you have added multiple sets of vertices.
            </param>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.Build">
            <summary>
                Builds the edge information based on the information built up so far.
            </summary>
            <returns>All edge data from the vertex/index data recognized by the builder.</returns>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.BuildTrianglesEdges(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="indexSet"></param>
            <param name="vertexSet"></param>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.CreateEdge(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                
            </summary>
            <param name="vertexSet"></param>
            <param name="triangleIndex"></param>
            <param name="vertexIndex1"></param>
            <param name="vertexIndex2"></param>
            <param name="sharedVertIndex1"></param>
            <param name="sharedVertIndex2"></param>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.ConnectEdges">
            <summary>
                
            </summary>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.FindEdge(System.Int32,System.Int32)">
            <summary>
                
            </summary>
            <param name="sharedIndex1"></param>
            <param name="sharedIndex2"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.EdgeListBuilder.FindOrCreateCommonVertex(Axiom.Math.Vector3,System.Int32,System.Int32,System.Int32)">
            <summary>
            	Finds an existing common vertex, or inserts a new one.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Axiom.Graphics.EdgeListBuilder.CommonVertex">
            <summary>
                A vertex can actually represent several vertices in the final model, because
                vertices along texture seams etc will have been duplicated. In order to properly
                evaluate the surface properties, a single common vertex is used for these duplicates,
                and the faces hold the detail of the duplicated vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.position">
            <summary>
                Location of point in euclidean space.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.index">
            <summary>
                Place of vertex in original vertex set.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.vertexSet">
            <summary>
                 The vertex set this came from.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.indexSet">
            <summary>
                The index set this was referenced (first) from.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EdgeListBuilder.CommonVertex.originalIndex">
            <summary>
                Place of vertex in original vertex set.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.TextureManager" -->
        <member name="F:Axiom.Core.TextureManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
            <remarks>
                Protected internal because this singleton will actually hold the instance of a subclass
                created by a render system plugin.
            </remarks>
        </member>
        <member name="F:Axiom.Core.TextureManager.is32Bit">
            <summary>
               Flag that indicates whether 32-bit texture are being used.
            </summary>
        </member>
        <member name="F:Axiom.Core.TextureManager.defaultNumMipMaps">
            <summary>
               Default number of mipmaps to be used for loaded textures.
            </summary>
        </member>
        <member name="M:Axiom.Core.TextureManager.Create(System.String)">
            <summary>
                Creates a new texture.
            </summary>
            <param name="name">Name of the texture to create, which is the filename.</param>
            <returns>A newly created texture object, API dependent.</returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.Create(System.String,Axiom.Graphics.TextureType)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.CreateManual(System.String,Axiom.Graphics.TextureType,System.Int32,System.Int32,System.Int32,Axiom.Media.PixelFormat,Axiom.Graphics.TextureUsage)">
            <summary>
               Method for creating a new blank texture.
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="numMipMaps"></param>
            <param name="format"></param>
            <param name="usage"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String)">
            <summary>
               Loads a texture with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String,Axiom.Graphics.TextureType)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.Load(System.String,Axiom.Graphics.TextureType,System.Int32,System.Single,System.Int32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="numMipMaps"></param>
            <param name="gamma"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,Axiom.Media.Image)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <param name="image"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,Axiom.Media.Image,Axiom.Graphics.TextureType)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <param name="image"></param>
            <param name="texType"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.LoadImage(System.String,Axiom.Media.Image,Axiom.Graphics.TextureType,System.Int32,System.Single,System.Int32)">
            <summary>
            	Loads a pre-existing image into the texture.
            </summary>
            <param name="name"></param>
            <param name="image"></param>
            <param name="numMipMaps"></param>
            <param name="gamma"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.GetByName(System.String)">
            <summary>
               Returns an instance of Texture that has the supplied name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.TextureManager.Dispose">
            <summary>
                Called when the engine is shutting down.    
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Core.TextureManager.DefaultNumMipMaps">
            <summary>
               Gets/Sets the default number of mipmaps to be used for loaded textures.
            </summary>
        </member>
        <member name="T:Axiom.Core.SubMesh">
            <summary>
            	Defines a part of a complete 3D mesh.
            </summary>
            <remarks>
            	Models which make up the definition of a discrete 3D object
            	are made up of potentially multiple parts. This is because
            	different parts of the mesh may use different materials or
            	use different vertex formats, such that a rendering state
            	change is required between them.
            	<p/>
            	Like the Mesh class, instatiations of 3D objects in the scene
            	share the SubMesh instances, and have the option of overriding
            	their material differences on a per-object basis if required.
            	See the SubEntity class for more information.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SubMesh.parent">
            <summary>The parent mesh that this subMesh belongs to.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.materialName">
            <summary>Name of the material assigned to this subMesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.name">
            <summary>Name of this SubMesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.isMaterialInitialized">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.numFaces">
            <summary>Number of faces in this subMesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.boneAssignmentList">
            <summary>List of bone assignment for this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.boneAssignmentsOutOfDate">
            <summary>Flag indicating that bone assignments need to be recompiled.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.operationType">
            <summary>Mode used for rendering this submesh.</summary>
        </member>
        <member name="F:Axiom.Core.SubMesh.useSharedVertices">
            <summary>Indicates if this submesh shares vertex data with other meshes or whether it has it's own vertices.</summary>
        </member>
        <member name="M:Axiom.Core.SubMesh.#ctor(System.String)">
            <summary>
            	Basic contructor.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SubMesh.AddBoneAssignment(Axiom.Animating.VertexBoneAssignment@)">
            <summary>
               Assigns a vertex to a bone with a given weight, for skeletal animation. 
            </summary>
            <remarks>
               This method is only valid after setting the SkeletonName property.
               You should not need to modify bone assignments during rendering (only the positions of bones) 
               and the engine reserves the right to do some internal data reformatting of this information, 
               depending on render system requirements.
            </remarks>
            <param name="boneAssignment"></param>
        </member>
        <member name="M:Axiom.Core.SubMesh.ClearBoneAssignments">
            <summary>
               Removes all bone assignments for this mesh. 
            </summary>
            <remarks>
               This method is for modifying weights to the shared geometry of the Mesh. To assign
               weights to the per-SubMesh geometry, see the equivalent methods on SubMesh.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SubMesh.CompileBoneAssignments">
            <summary>
               Must be called once to compile bone assignments into geometry buffer.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubMesh.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SubMesh.GetRenderOperation(Axiom.Graphics.RenderOperation,System.Int32)">
            <summary>
               Fills a RenderOperation structure required to render this mesh.
            </summary>
            <param name="op">Reference to a RenderOperation structure to populate.</param>
            <param name="lodIndex">The index of the LOD to use.</param>
        </member>
        <member name="P:Axiom.Core.SubMesh.MaterialName">
            <summary>
            	Gets/Sets the name of the material this SubMesh will be using.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubMesh.Parent">
            <summary>
            	Gets/Sets the parent mode of this SubMesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubMesh.IsMaterialInitialized">
            <summary>
            	Gets whether or not a material has been set for this subMesh.
            </summary>
        </member>
        <member name="T:Axiom.Core.BillboardSet">
            <summary>
            	A collection of billboards (faces which are always facing the camera) with the same (default) dimensions, material
            	and which are fairly close proximity to each other.
             </summary>
             <remarks>
            	Billboards are rectangles made up of 2 tris which are always facing the camera. They are typically used
            	for special effects like particles. This class collects together a set of billboards with the same (default) dimensions,
            	material and relative locality in order to process them more efficiently. The entire set of billboards will be
            	culled as a whole (by default, although this can be changed if you want a large set of billboards
            	which are spread out and you want them culled individually), individual Billboards have locations which are relative to the set (which itself derives it's
            	position from the SceneNode it is attached to since it is a SceneObject), they will be rendered as a single rendering operation,
            	and some calculations will be sped up by the fact that they use the same dimensions so some workings can be reused.
            	<p/>
            	A BillboardSet can be created using the SceneManager.CreateBillboardSet method. They can also be used internally
            	by other classes to create effects.
            </remarks>
        </member>
        <member name="F:Axiom.Core.BillboardSet.buffersCreated">
            <summary> internal flag for determining if buffers are initialized. </summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.aab">
            <summary>Bounds of all billboards in this set</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.originType">
            <summary>Origin of each billboard</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.defaultWidth">
            <summary>Default width/height of each billboard.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.materialName">
            <summary>Name of the material to use</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.material">
            <summary>Reference to the material to use</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.allDefaultSize">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.poolSize">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.autoExtendPool">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.mainBuffer">
            Shortcut to main buffer (positions, colours, texture coords)
        </member>
        <member name="F:Axiom.Core.BillboardSet.cullIndividually">
            <summary>Indicates whether or not each billboard should be culled individually.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.billboardType">
            <summary>Type of billboard to render.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.commonDirection">
            <summary>Common direction for billboard oriented with type Common.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.boundingRadius">
            <summary>The local bounding radius of this object.</summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.numVisibleBillboards">
            <summary> </summary>
        </member>
        <member name="F:Axiom.Core.BillboardSet.fixedTextureCoords">
            <summary>Are tex coords fixed?  If not they have been modified. </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.#ctor">
            <summary>
            Usual constructor - this is called by the SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.#ctor(System.String,System.Int32)">
            <summary>
            Usual constructor - this is called by the SceneManager.
            </summary>
            <param name="name">The name to give the billboard set (must be unique)</param>
            <param name="poolSize">The initial size of the billboard pool. Estimate of the number of billboards
                   which will be required, and pass it using this parameter. The set will
                   preallocate this number to avoid memory fragmentation. The default behaviour
                   once this pool has run out is to double it.
            </param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Usual constructor - this is called by the SceneManager.
            </summary>
            <param name="name">The name to give the billboard set (must be unique)</param>
            <param name="poolSize">The initial size of the billboard pool. Estimate of the number of billboards
                   which will be required, and pass it using this parameter. The set will
                   preallocate this number to avoid memory fragmentation. The default behaviour
                   once this pool has run out is to double it.
            </param>
            <param name="externalData">If true, the source of data for drawing the 
                   billboards will not be the internal billboard list, but external 
                   data. When driving thebillboard from external data, you must call
                   _notifyCurrentCamera to reorient the billboards, setPoolSize to set
                   the maximum billboards you want to use, beginBillboards to 
                   start the update, and injectBillboard per billboard, 
                   followed by endBillboards.
            </param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.SetDefaultDimensions(System.Single,System.Single)">
            <summary>
            	Sets the default dimensions of the billboards in this set.
             </summary>
             <remarks>
            	All billboards in a set are created with these default dimensions. The set will render most efficiently if
            	all the billboards in the set are the default size. It is possible to alter the size of individual
            	billboards at the expense of extra calculation. See the Billboard class for more info.
            </remarks>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(System.Single,System.Single,System.Single,Axiom.Core.ColorEx)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(Axiom.Math.Vector3)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.CreateBillboard(Axiom.Math.Vector3,Axiom.Core.ColorEx)">
            <summary>
            	Creates a new billboard and adds it to this set.
            </summary>
            <param name="position"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.Clear">
            <summary>
            	Empties all of the active billboards from this set.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.UpdateBounds">
            <summary>
            	Update the bounds of the BillboardSet.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.createBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyBillboardResized">
            <summary>
            	Callback used by Billboards to notify their parent that they have been resized.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyBillboardTextureCoordsModified">
            <summary>
            	Notifies the billboardset that texture coordinates will be modified
            	for this set.
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.IncreasePool(System.Int32)">
            <summary>
            	Internal method for increasing pool size.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.IsBillboardVisible(Axiom.Core.Camera,Axiom.Core.Billboard)">
            <summary>
            	Determines whether the supplied billboard is visible in the camera or not.
            </summary>
            <param name="camera"></param>
            <param name="billboard"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateBillboardAxes(Axiom.Core.Camera,Axiom.Math.Vector3@,Axiom.Math.Vector3@)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="camera"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateBillboardAxes(Axiom.Core.Camera,Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Core.Billboard)">
            <summary>
            	Generates billboard corners.
            </summary>
            <param name="camera"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="billboard"></param>
            <remarks>Billboard param only required for type OrientedSelf</remarks>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GetParametericOffsets(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            	Generate parametric offsets based on the origin.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="top"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateVertices(Axiom.Math.Vector3[],Axiom.Core.Billboard)">
            <summary>
            	Generates vertex data for a billboard.
            </summary>
            <param name="offsets">Array of 4 Vector3 offsets.</param>
            <param name="billboard">A billboard.</param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GenerateVertexOffsets(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Math.Vector3[])">
            <summary>
            	Generates vertex offsets.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="top"></param>
            <param name="bottom"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="destVec"></param>
            <remarks>
            	Takes in parametric offsets as generated from GetParametericOffsets, width and height values
            	and billboard x and y axes as generated from GenerateBillboardAxes. 
            	Fills output array of 4 vectors with vector offsets
            	from origin for left-top, right-top, left-bottom, right-bottom corners.
            </remarks>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
            
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.BillboardSet.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            	Generate the vertices for all the billboards relative to the camera
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.BeginBillboards">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.InjectBillboard(Axiom.Core.Billboard)">
            <summary>
            
            </summary>
            <param name="billboard"></param>
        </member>
        <member name="M:Axiom.Core.BillboardSet.EndBillboards">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.BillboardSet.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            
            </summary>
            <param name="queue"></param>
        </member>
        <member name="P:Axiom.Core.BillboardSet.AutoExtend">
            <summary>
            	Tells the set whether to allow automatic extension of the pool of billboards.
             </summary>
             <remarks>
            	A BillboardSet stores a pool of pre-constructed billboards which are used as needed when
            	a new billboard is requested. This allows applications to create / remove billboards efficiently
            	without incurring construction / destruction costs (a must for sets with lots of billboards like
            	particle effects). This method allows you to configure the behaviour when a new billboard is requested
            	but the billboard pool has been exhausted.
            	<p/>
            	The default behaviour is to allow the pool to extend (typically this allocates double the current
            	pool of billboards when the pool is expended), equivalent to calling this property to
            	true. If you set the property to false however, any attempt to create a new billboard
            	when the pool has expired will simply fail silently, returning a null pointer.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.PoolSize">
            <summary>
            	Adjusts the size of the pool of billboards available in this set.
             </summary>
             <remarks>
            	See the BillboardSet.AutoExtend property for full details of the billboard pool. This method adjusts
            	the preallocated size of the pool. If you try to reduce the size of the pool, the set has the option
            	of ignoring you if too many billboards are already in use. Bear in mind that calling this method will
            	incur significant construction / destruction calls so should be avoided in time-critical code. The same
            	goes for auto-extension, try to avoid it by estimating the pool size correctly up-front.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BillboardOrigin">
            <summary>
            	Gets/Sets the point which acts as the origin point for all billboards in this set.
             </summary>
             <remarks>
            	This setting controls the fine tuning of where a billboard appears in relation to it's
            	position. It could be that a billboard's position represents it's center (e.g. for fireballs),
            	it could mean the center of the bottom edge (e.g. a tree which is positioned on the ground),
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.MaterialName">
            <summary>
            	Gets/Sets the name of the material to use for this billboard set.
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.CullIndividually">
            <summary>
            	Sets whether culling tests billboards in this individually as well as in a group.
             </summary>
             <remarks>
            	Billboard sets are always culled as a whole group, based on a bounding box which 
            	encloses all billboards in the set. For fairly localised sets, this is enough. However, you
            	can optionally tell the set to also cull individual billboards in the set, i.e. to test
            	each individual billboard before rendering. The default is not to do this.
            	<p/>
            	This is useful when you have a large, fairly distributed set of billboards, like maybe 
            	trees on a landscape. You probably still want to group them into more than one
            	set (maybe one set per section of landscape), which will be culled coarsely, but you also
            	want to cull the billboards individually because they are spread out. Whilst you could have
            	lots of single-tree sets which are culled separately, this would be inefficient to render
            	because each tree would be issued as it's own rendering operation.
            	<p/>
            	By setting this property to true, you can have large billboard sets which 
            	are spaced out and so get the benefit of batch rendering and coarse culling, but also have
            	fine-grained culling so unnecessary rendering is avoided.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BillboardType">
            <summary>
            	Gets/Sets the type of billboard to render.
             </summary>
             <remarks>
            	The default sort of billboard (Point), always has both x and y axes parallel to 
            	the camera's local axes. This is fine for 'point' style billboards (e.g. flares,
            	smoke, anything which is symmetrical about a central point) but does not look good for
            	billboards which have an orientation (e.g. an elongated raindrop). In this case, the
            	oriented billboards are more suitable (OrientedCommon or OrientedSelf) since they retain an independant Y axis
            	and only the X axis is generated, perpendicular to both the local Y and the camera Z.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.CommonDirection">
            <summary>
            	Use this to specify the common direction given to billboards of type OrientedCommon.
             </summary>
             <remarks>
            	Use OrientedCommon when you want oriented billboards but you know they are always going to 
            	be oriented the same way (e.g. rain in calm weather). It is faster for the system to calculate
            	the billboard vertices if they have a common direction.
            </remarks>
        </member>
        <member name="P:Axiom.Core.BillboardSet.Billboards">
            <summary>
            	Gets the list of active billboards.
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.DefaultWidth">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.DefaultHeight">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.NumWorldTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.UseIdentityProjection">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.UseIdentityView">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.RenderDetail">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.WorldOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.WorldPosition">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.BillboardSet.BoundingRadius">
            <summary>
               Local bounding radius of this billboard set.
            </summary>
        </member>
        <member name="T:Axiom.Collections.Map">
            <summary>
                The Map is a C# conversion of the std::map container from the C++ 
                standard library.  
            </summary>
            <remarks>
                A map allows multiple values per key, unlike the Hashtable which only allows
                unique keys and only a single value per key.  Multiple values assigned to the same
                key are placed in a "bucket", which in this case is an ArrayList.
                <p/>
                An example of values in a map would look like this:
                Key     Value
                "a"     "Alan"
                "a"     "Adam"
                "b"     "Brien"
                "c"     "Chris"
                "c"     "Carl"
                etc
                <p/>
                Currently, enumeration is the only way to iterate through the values, which is
                more pratical in terms of how the Map works internally anyway.  Intial testing showed
                that inserting and iterating through 100,000 items, the Inserts took ~260ms and a full
                enumeration of them all (with unboxing of the value type stored in the map) took between 16-30ms.
            </remarks>
        </member>
        <member name="F:Axiom.Collections.Map.count">
            <summary>
                Number of total items currently in this map.
            </summary>
        </member>
        <member name="F:Axiom.Collections.Map.buckets">
            <summary>
                A sorted list of buckets.
            </summary>
        </member>
        <member name="M:Axiom.Collections.Map.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.Map.#ctor(System.Collections.IComparer)">
            <summary>
                Constructor, takes the comparer to use for the bucket list.
            </summary>
            <param name="comparer">Custom <see cref="T:System.IComparable"/>implmentation to use to sort.</param>
        </member>
        <member name="M:Axiom.Collections.Map.Clear">
            <summary>
                Clears this map of all contained objects.
            </summary>
        </member>
        <member name="M:Axiom.Collections.Map.Find(System.Object)">
            <summary>
                Given a key, Find will return an IEnumerator that allows
                you to iterate over all items in the bucket associated
                with the key.
            </summary>
            <param name="key">Key for look for.</param>
            <returns>IEnumerator to go through the items assigned to the key.</returns>
        </member>
        <member name="M:Axiom.Collections.Map.Count(System.Object)">
            <summary>
                Gets the count of objects mapped to the specified key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Collections.Map.Insert(System.Object,System.Object)">
            <summary>
                Inserts a value into a bucket that is specified by the
                key.
            </summary>
            <param name="key"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Collections.Map.GetEnumerator">
            <summary>
                Gets an appropriate enumerator for the map, customized to go
                through each item in the map and return a Pair of the key and
                value.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Collections.Map.TotalCount">
            <summary>
                Gets the total count of all items contained within the map.
            </summary>
        </member>
        <member name="P:Axiom.Collections.Map.KeyCount">
            <summary>
            	Gets the number of keys in this map.
            </summary>
        </member>
        <member name="T:Axiom.Collections.Map.MapEnumerator">
            <summary>
                Private class serving as the custom Enumerator for the map
                collection.
            </summary>
        </member>
        <member name="F:Axiom.Collections.Map.MapEnumerator.totalPos">
            <summary>
                Overall position from the beginning of the map.
            </summary>
        </member>
        <member name="F:Axiom.Collections.Map.MapEnumerator.bucketIndex">
            <summary>
                Current index of the current bucket.
            </summary>
        </member>
        <member name="F:Axiom.Collections.Map.MapEnumerator.bucketPos">
            <summary>
                Current bucket position.
            </summary>
        </member>
        <member name="F:Axiom.Collections.Map.MapEnumerator.currentBucket">
            <summary>
                This is the current bucket being used in the enumeration.
            </summary>
        </member>
        <member name="F:Axiom.Collections.Map.MapEnumerator.map">
            <summary>
                Reference to the map that we are iterating over.
            </summary>
        </member>
        <member name="M:Axiom.Collections.Map.MapEnumerator.#ctor(Axiom.Collections.Map)">
            <summary>
                Constructor.
            </summary>
            <param name="map">The map this enumerator will enumerate over.</param>
        </member>
        <member name="M:Axiom.Collections.Map.MapEnumerator.Reset">
            <summary>
                Resets all current state of the enumeration process.
            </summary>
        </member>
        <member name="M:Axiom.Collections.Map.MapEnumerator.MoveNext">
            <summary>
                Moves to the next position in the enumeration.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Collections.Map.MapEnumerator.Current">
            <summary>
                Gets a Pair containing the key and value at the current state
                of the enumeration.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Pair">
            <summary>
            	A simple container class for returning a pair of objects from a method call 
            	(similar to std::pair, minus the templates).
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:Axiom.Math.Vector3">
            <summary>
               Standard 3-dimensional vector.
            </summary>
            <remarks>
                A direction in 3D space represented as distances along the 3
                orthoganal axes (x, y, z). Note that positions, directions and
                scaling factors can be represented by a vector, depending on how
                you interpret the values.
            </remarks>
        </member>
        <member name="F:Axiom.Math.Vector3.x">
            <summary>X component.</summary>
        </member>
        <member name="F:Axiom.Math.Vector3.y">
            <summary>Y component.</summary>
        </member>
        <member name="F:Axiom.Math.Vector3.z">
            <summary>Z component.</summary>
        </member>
        <member name="M:Axiom.Math.Vector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            	Creates a new 3 dimensional Vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Equality(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	User to compare two Vector3 instances for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Inequality(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	User to compare two Vector3 instances for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>true or false</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Multiply(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is multiplied by another vector.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Multiply(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is multiplied by another vector.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Divide(Axiom.Math.Vector3,System.Single)">
            <summary>
            Used to divide a vector by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Division(Axiom.Math.Vector3,System.Single)">
            <summary>
            Used to divide a vector by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Add(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is added to another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Addition(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used when a Vector3 is added to another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Multiply(Axiom.Math.Vector3,System.Single)">
            <summary>
            	Used when a Vector3 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Multiply(Axiom.Math.Vector3,System.Single)">
            <summary>
            	Used when a Vector3 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Multiply(System.Single,Axiom.Math.Vector3)">
            <summary>
            	Used when a scalar value is multiplied by a Vector3.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Multiply(System.Single,Axiom.Math.Vector3)">
            <summary>
            	Used when a scalar value is multiplied by a Vector3.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Subtract(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used to subtract a Vector3 from another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Subtraction(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Used to subtract a Vector3 from another Vector3.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Negate(Axiom.Math.Vector3)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_UnaryNegation(Axiom.Math.Vector3)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_GreaterThan(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
               Returns true if the vector's scalar components are all smaller
               that the ones of the vector it is compared against.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_LessThan(Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
               Returns true if the vector's scalar components are all greater
               that the ones of the vector it is compared against.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.op_Explicit(Axiom.Math.Vector3)~Axiom.Math.Vector4">
            <summary>
               
            </summary>
            <param name="vec3"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Dot(Axiom.Math.Vector3)">
            <summary>
            	Performs a Dot Product operation on 2 vectors, which produces the angle between them.
            </summary>
            <param name="vector">The vector to perform the Dot Product against.</param>
            <returns>The angle between the 2 vectors.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Cross(Axiom.Math.Vector3)">
            <summary>
            	Performs a Cross Product operation on 2 vectors, which returns a vector that is perpendicular
            	to the intersection of the 2 vectors.  Useful for finding face normals.
            </summary>
            <param name="vector">A vector to perform the Cross Product against.</param>
            <returns>A new Vector3 perpedicular to the 2 original vectors.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Perpendicular">
            <summary>
            	Finds a vector perpendicular to this one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.RandomDeviant(System.Single,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="angle"></param>
            <param name="up"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.PositionEquals(Axiom.Math.Vector3)">
            <overloads>
            <summary>Returns wether this vector is within a positional tolerance of another vector</summary>
            <param name="right">The vector to compare with</param>
            </overloads>
            <remarks>Uses a defalut tolerance of 1E-03</remarks>
        </member>
        <member name="M:Axiom.Math.Vector3.PositionEquals(Axiom.Math.Vector3,System.Single)">
            <param name="tolerance">The amount that each element of the vector may vary by and still be considered equal.</param>
        </member>
        <member name="M:Axiom.Math.Vector3.MidPoint(Axiom.Math.Vector3)">
            <summary>
            	Finds the midpoint between the supplied Vector and this vector.
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Ceil(Axiom.Math.Vector3)">
            <summary>
            	Compares the supplied vector and updates it's x/y/z components of they are higher in value.
            </summary>
            <param name="compare"></param>
        </member>
        <member name="M:Axiom.Math.Vector3.Floor(Axiom.Math.Vector3)">
            <summary>
            	Compares the supplied vector and updates it's x/y/z components of they are lower in value.
            </summary>
            <param name="compare"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.GetRotationTo(Axiom.Math.Vector3)">
            <summary>
            	Gets the shortest arc quaternion to rotate this vector to the destination vector. 
            </summary>
            <remarks>
            	Don't call this if you think the dest vector can be close to the inverse
            	of this vector, since then ANY axis of rotation is ok.
            </remarks>
        </member>
        <member name="M:Axiom.Math.Vector3.Normalize">
            <summary>
            	Normalizes the vector.
            </summary>
            <remarks>
            	This method normalises the vector such that it's
            	length / magnitude is 1. The result is called a unit vector.
            	<p/>
            	This function will not crash for zero-sized vectors, but there
            	will be no changes made to their components.
            </remarks>
            <returns>The previous length of the vector.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Reflect(Axiom.Math.Vector3)">
            <summary>
               Calculates a reflection vector to the plane with the given normal.
            </summary>
            <remarks>
               Assumes this vector is pointing AWAY from the plane, invert if not.
            </remarks>
            <param name="normal">Normal vector on which this vector will be reflected.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Vector3.
            </summary>
            <returns>A string representation of a vector3.</returns>
        </member>
        <member name="M:Axiom.Math.Vector3.GetHashCode">
            <summary>
            	Provides a unique hash code based on the member variables of this
            	class.  This should be done because the equality operators (==, !=)
            	have been overriden by this class.
            	<p/>
            	The standard implementation is a simple XOR operation between all local
            	member variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector3.Equals(System.Object)">
            <summary>
            	Compares this Vector to another object.  This should be done because the 
            	equality operators (==, !=) have been overriden by this class.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Math.Vector3.Item(System.Int32)">
            <summary>
            	Used to access a Vector by index 0 = x, 1 = y, 2 = z.  
            </summary>
            <remarks>
            	Uses unsafe pointer arithmetic to reduce the code required.
            </remarks>
        </member>
        <member name="P:Axiom.Math.Vector3.Length">
            <summary>
               Gets the length (magnitude) of this Vector3.  The Sqrt operation is expensive, so 
               only use this if you need the exact length of the Vector.  If vector lengths are only going
               to be compared, use LengthSquared instead.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.LengthSquared">
            <summary>
               Returns the length (magnitude) of the vector squared.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.Zero">
            <summary>
            	Gets a Vector3 with all components set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitScale">
            <summary>
            	Gets a Vector3 with all components set to 1.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitX">
            <summary>
            	Gets a Vector3 with the X set to 1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitY">
            <summary>
            	Gets a Vector3 with the Y set to 1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.UnitZ">
            <summary>
            	Gets a Vector3 with the Z set to 1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.NegativeUnitX">
            <summary>
            	Gets a Vector3 with the X set to -1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.NegativeUnitY">
            <summary>
            	Gets a Vector3 with the Y set to -1, and the others set to 0.
            </summary>
        </member>
        <member name="P:Axiom.Math.Vector3.NegativeUnitZ">
            <summary>
            	Gets a Vector3 with the Z set to -1, and the others set to 0.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexElement">
            <summary>
            	This class declares the usage of a single vertex buffer as a component
            	of a complete <see cref="T:Axiom.Graphics.VertexDeclaration"/>. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.source">
            <summary>
                The source vertex buffer, as bound to an index using <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.offset">
            <summary>
                The offset in the buffer that this element starts at.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.type">
            <summary>
                The type of element.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.semantic">
            <summary>
                The meaning of the element.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElement.index">
            <summary>
                Index of the item, only applicable for some elements like texture coords.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.#ctor(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The source vertex buffer, as bound to an index using <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.</param>
            <param name="offset">The offset in the buffer that this element starts at.</param>
            <param name="type">The type of element.</param>
            <param name="semantic">The meaning of the element.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.#ctor(System.Int16,System.Int32,Axiom.Graphics.VertexElementType,Axiom.Graphics.VertexElementSemantic,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="source">The source vertex buffer, as bound to an index using <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.</param>
            <param name="offset">The offset in the buffer that this element starts at.</param>
            <param name="type">The type of element.</param>
            <param name="semantic">The meaning of the element.</param>
            <param name="index">Index of the item, only applicable for some elements like texture coords.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.GetTypeSize(Axiom.Graphics.VertexElementType)">
            <summary>
                Utility method for helping to calculate offsets.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.GetTypeCount(Axiom.Graphics.VertexElementType)">
            <summary>
                Utility method which returns the count of values in a given type.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.MultiplyTypeCount(Axiom.Graphics.VertexElementType,System.Int32)">
            <summary>
            	Returns proper enum for a base type multiplied by a value.  This is helpful
            	when working with tex coords especially since you might not know the number
            	of texture dimensions at runtime, and when creating the VertexBuffer you will
            	have to get a VertexElementType based on that amount to creating the VertexElement.
            </summary>
            <param name="type">Data type.</param>
            <param name="count">Multiplier.</param>
            <returns>
                A <see cref="T:Axiom.Graphics.VertexElementType"/> that represents the requested type and count.
            </returns>
            <example>
                MultiplyTypeCount(VertexElementType.Float1, 3) returns VertexElementType.Float3.
            </example>
        </member>
        <member name="M:Axiom.Graphics.VertexElement.Clone">
            <summary>
                Simple memberwise clone since all local fields are value types.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Source">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Offset">
            <summary>
                Gets the offset into the buffer where this element starts.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Type">
            <summary>
                Gets the data format of this element.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Semantic">
            <summary>
                Gets the meaning of this element.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Index">
            <summary>
                Gets the index of this element, only applicable for repeating elements (like texcoords).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexElement.Size">
            <summary>
                Gets the size of this element in bytes.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.SoftwareBufferManager">
            <summary>
            	Summary description for SoftwareBufferManager.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareBufferManager">
            <summary>
            	Abstract singleton class for managing hardware buffers, a concrete instance
            	of this will be created by the RenderSystem.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
            <remarks>
                Protected internal because this singleton will actually hold the instance of a subclass
                created by a render system plugin.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.vertexDeclarations">
            <summary>
                A list of vertex declarations created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.vertexBufferBindings">
            <summary>
                A list of vertex buffer bindings created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.vertexBuffers">
            <summary>
                A list of vertex buffers created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.indexBuffers">
            <summary>
                A list of index buffers created by this buffer manager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.freeTempVertexBufferMap">
            <summary>
            	Map from original buffer to list of temporary buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareBufferManager.tempVertexBufferLicenses">
            <summary>
            	List of currently licensed temp buffers.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
            	Creates a hardware vertex buffer.
            </summary>
            <remarks>
            	This method creates a new vertex buffer; this will act as a source of geometry
            	data for rendering objects. Note that because the meaning of the contents of
            	the vertex buffer depends on the usage, this method does not specify a
            	vertex format; the user of this buffer can actually insert whatever data 
            	they wish, in any format. However, in order to use this with a RenderOperation,
            	the data in this vertex buffer will have to be associated with a semantic element
            	of the rendering pipeline, e.g. a position, or texture coordinates. This is done 
            	using the VertexDeclaration class, which itself contains VertexElement structures
            	referring to the source data.
            	<p/>
            	Note that because vertex buffers can be shared, they are reference
            	counted so you do not need to worry about destroying themm this will be done
            	automatically.
            </remarks>
            <param name="vertexSize">The size in bytes of each vertex in this buffer; you must calculate
            	this based on the kind of data you expect to populate this buffer with.</param>
            <param name="numVerts">The number of vertices in this buffer.</param>
            <param name="usage">One or more members of the BufferUsage enumeration; you are
            	strongly advised to use StaticWriteOnly wherever possible, if you need to 
            	update regularly, consider WriteOnly and useShadowBuffer=true.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Creates a hardware vertex buffer.
            </summary>
            <remarks>
            	This method creates a new vertex buffer; this will act as a source of geometry
            	data for rendering objects. Note that because the meaning of the contents of
            	the vertex buffer depends on the usage, this method does not specify a
            	vertex format; the user of this buffer can actually insert whatever data 
            	they wish, in any format. However, in order to use this with a RenderOperation,
            	the data in this vertex buffer will have to be associated with a semantic element
            	of the rendering pipeline, e.g. a position, or texture coordinates. This is done 
            	using the VertexDeclaration class, which itself contains VertexElement structures
            	referring to the source data.
            	<p/>
            	Note that because vertex buffers can be shared, they are reference
            	counted so you do not need to worry about destroying themm this will be done
            	automatically.
            </remarks>
            <param name="vertexSize">The size in bytes of each vertex in this buffer; you must calculate
            	this based on the kind of data you expect to populate this buffer with.</param>
            <param name="numVerts">The number of vertices in this buffer.</param>
            <param name="usage">One or more members of the BufferUsage enumeration; you are
            	strongly advised to use StaticWriteOnly wherever possible, if you need to 
            	update regularly, consider WriteOnly and useShadowBuffer=true.</param>
            <param name="useShadowBuffer"></param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.CreateIndexBuffer(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
                Create a hardware index buffer.
            </summary>
            <param name="type">
                The type in index, either 16- or 32-bit, depending on how many vertices
                you need to be able to address.
            </param>
            <param name="numIndices">The number of indexes in the buffer.</param>
            <param name="usage">One or more members of the <see cref="T:Axiom.Graphics.BufferUsage"/> enumeration.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.CreateIndexBuffer(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
                Create a hardware index buffer.
            </summary>
            <param name="type">
                The type in index, either 16- or 32-bit, depending on how many vertices
                you need to be able to address.
            </param>
            <param name="numIndices">The number of indexes in the buffer.</param>
            <param name="usage">One or more members of the <see cref="T:Axiom.Graphics.BufferUsage"/> enumeration.</param>
            <param name="useShadowBuffer">
                If set to true, this buffer will be 'shadowed' by one stored in 
                system memory rather than GPU or AGP memory. You should set this flag if you intend 
                to read data back from the index buffer, because reading data from a buffer
                in the GPU or AGP memory is very expensive, and is in fact impossible if you
                specify <see cref="F:Axiom.Graphics.BufferUsage.WriteOnly"/> for the main buffer. If you use this option, all 
                reads and writes will be done to the shadow buffer, and the shadow buffer will
                be synchronised with the real buffer at an appropriate time.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.CreateVertexDeclaration">
            <summary>
                Creates a vertex declaration, may be overridden by certain rendering APIs.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.CreateVertexBufferBinding">
            <summary>
                Creates a new VertexBufferBinding.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.DestroyVertexBufferBinding(Axiom.Graphics.VertexBufferBinding)">
            <summary>
            	Creates a new <see cref="T:Axiom.Graphics.VertexBufferBinding"/>.
            </summary>
            <param name="binding"></param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.DestroyVertexDeclaration(Axiom.Graphics.VertexDeclaration)">
            <summary>
            	Destroys a vertex declaration.
            </summary>
            <remarks>
            	Subclasses wishing to override this methods should call the base class implementation
            	first, which removes the object the collection of created objects.
            </remarks>
            <param name="decl">VertexDeclaration object to destroy.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.AllocateVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,Axiom.Graphics.IHardwareBufferLicensee)">
            <summary>
                Allocates a copy of a given vertex buffer.
            </summary>
            <remarks>
                This method allocates a temporary copy of an existing vertex buffer.
                This buffer is subsequently stored and can be made available for 
                other purposes later without incurring the cost of construction / 
                destruction.
            </remarks>
            <param name="sourceBuffer">The source buffer to use as a copy.</param>
            <param name="licenseType">
                The type of license required on this buffer - automatic
                release causes this class to release licenses every frame so that 
                they can be reallocated anew.
            </param>
            <param name="licensee">
                Reference back to the class requesting the copy, which must
                implement <see cref="!:IHardwareBufferLicense"/> in order to be notified when the license
                expires.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.AllocateVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,Axiom.Graphics.IHardwareBufferLicensee,System.Boolean)">
            <summary>
                Allocates a copy of a given vertex buffer.
            </summary>
            <remarks>
                This method allocates a temporary copy of an existing vertex buffer.
                This buffer is subsequently stored and can be made available for 
                other purposes later without incurring the cost of construction / 
                destruction.
            </remarks>
            <param name="sourceBuffer">The source buffer to use as a copy.</param>
            <param name="licenseType">
                The type of license required on this buffer - automatic
                release causes this class to release licenses every frame so that 
                they can be reallocated anew.
            </param>
            <param name="licensee">
                Reference back to the class requesting the copy, which must
                implement <see cref="!:IHardwareBufferLicense"/> in order to be notified when the license
                expires.
            </param>
            <param name="copyData">If true, the current data is copied as well as the structure of the buffer.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.ReleaseVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
                Manually release a vertex buffer copy for others to subsequently use.
            </summary>
            <remarks>
                Only required if the original call to <see cref="M:Axiom.Graphics.HardwareBufferManager.AllocateVertexBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,Axiom.Graphics.IHardwareBufferLicensee)"/>
                included a licenseType of <see cref="F:Axiom.Graphics.BufferLicenseRelease.Manual"/>. 
            </remarks>
            <param name="bufferCopy">
                The buffer copy. The caller is expected to no longer use this reference, 
                since another user may well begin to modify the contents of the buffer.
            </param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.ReleaseBufferCopies">
            <summary>
                Internal method for releasing all temporary buffers which have been 
                allocated using <see cref="F:Axiom.Graphics.BufferLicenseRelease.Automatic"/> is called by Axiom.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.ForceReleaseBufferCopies(Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
            	Internal method that forces the release of copies of a given buffer.
            </summary>
            <remarks>
            	This usually means that the buffer which the copies are based on has
            	been changed in some fundamental way, and the owner of the original 
            	wishes to make that known so that new copies will reflect the changes.
            </remarks>
            <param name="sourceBuffer">Buffer to release temp copies of.</param>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.MakeBufferCopy(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Creates  a new buffer as a copy of the source, does not copy data.
            </summary>
            <param name="source">Source vertex buffer.</param>
            <param name="usage">New usage type.</param>
            <param name="useShadowBuffer">New shadow buffer choice.</param>
            <returns>A copy of the vertex buffer, but data is not copied.</returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareBufferManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareBufferManager.BufferComparer">
            <summary>
                Used for buffer comparison.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareBufferManager.BufferComparer.Compare(System.Object,System.Object)">
            <summary>
                Comparse 2 HardwareBuffers for equality.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.SoftwareBufferManager.CreateIndexBuffer(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.Graphics.SoftwareBufferManager.CreateIndexBuffer(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.Graphics.SoftwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
            
            </summary>
            <param name="vertexSize"></param>
            <param name="numVerts"></param>
            <param name="usage"></param>
            <returns></returns>
            DOC
        </member>
        <member name="M:Axiom.Graphics.SoftwareBufferManager.CreateVertexBuffer(System.Int32,System.Int32,Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            
            </summary>
            <param name="vertexSize"></param>
            <param name="numVerts"></param>
            <param name="usage"></param>
            <param name="useShadowBuffer"></param>
            <returns></returns>
            DOC
        </member>
        <member name="T:Axiom.Graphics.SoftwareVertexBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareVertexBuffer">
            <summary>
            	Describes the graphics API independent functionality required by a hardware
            	vertex buffer.  
            </summary>
            <remarks>
            	
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.HardwareVertexBuffer.VertexSize">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="F:Axiom.Graphics.SoftwareVertexBuffer.data">
            <summary>
                Holds the buffer data.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.SoftwareVertexBuffer.#ctor(System.Int32,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
            	
            </summary>
            <remarks>
            	This is already in system memory, so no need to use a shadow buffer.
            </remarks>
            <param name="vertexSize"></param>
            <param name="numVertices"></param>
            <param name="usage"></param>
            DOC
        </member>
        <member name="M:Axiom.Graphics.SoftwareVertexBuffer.GetDataPointer(System.Int32)">
            <summary>
            	Allows direct access to the software buffer data in cases when it is known that the underlying
            	buffer is software and not hardware.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.SoftwareIndexBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SoftwareIndexBuffer.data">
            <summary>
                Holds the buffer data.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.SoftwareIndexBuffer.#ctor(Axiom.Graphics.IndexType,System.Int32,Axiom.Graphics.BufferUsage)">
            <summary>
            	
            </summary>
            <remarks>
            	This is already in system memory, so no need to use a shadow buffer.
            </remarks>
            <param name="type"></param>
            <param name="numIndices"></param>
            <param name="usage"></param>
            DOC
        </member>
        <member name="M:Axiom.Graphics.SoftwareIndexBuffer.GetDataPointer(System.Int32)">
            <summary>
            	Allows direct access to the software buffer data in cases when it is known that the underlying
            	buffer is software and not hardware.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowVolumeExtrudeProgram">
             <summary>
            		Static class containing source for vertex programs for extruding shadow volumes.
             </summary>
             <remarks>
            		This exists so we don't have to be dependent on an external media files.
            		 is used so we don't have to rely on particular plugins.
            		 assembler contents of this file were generated from the following Cg:
            		 
            		 <code>
            		 // Point light shadow volume extrude
                    void shadowVolumeExtrudePointLight_vp (
                        float4 position			: POSITION,
                        float  wcoord			: TEXCOORD0,
            
                        out float4 oPosition	: POSITION,
            
                        uniform float4x4 worldViewProjMatrix,
                        uniform float4   lightPos // homogenous, object space
                        )
                    {
                        // extrusion in object space
                        // vertex unmodified if w==1, extruded if w==0
                        float4 newpos = 
                            (wcoord.xxxx * lightPos) + 
                            float4(position.xyz - lightPos.xyz, 0);
            
                        oPosition = mul(worldViewProjMatrix, newpos);
            
                    }
            
                   // Directional light extrude
                    void shadowVolumeExtrudeDirLight_vp (
                       float4 position			: POSITION,
                       float  wcoord			: TEXCOORD0,
            
                      out float4 oPosition	: POSITION,
            
                       uniform float4x4 worldViewProjMatrix,
                     uniform float4   lightPos // homogenous, object space
                       )
                   {
                       // extrusion in object space
                       // vertex unmodified if w==1, extruded if w==0
                        float4 newpos = 
                           (wcoord.xxxx * (position + lightPos)) - lightPos;
            
                      oPosition = mul(worldViewProjMatrix, newpos);
            
                   }
                    // Point light shadow volume extrude - FINITE
                    void shadowVolumeExtrudePointLightFinite_vp (
                        float4 position			: POSITION,
                       float  wcoord			: TEXCOORD0,
            
                      out float4 oPosition	: POSITION,
            
                       uniform float4x4 worldViewProjMatrix,
                      uniform float4   lightPos, // homogenous, object space
            			uniform float    extrusionDistance // how far to extrude
                      )
                   {
                        // extrusion in object space
                       // vertex unmodified if w==1, extruded if w==0
            			float3 extrusionDir = position.xyz - lightPos.xyz;
            			extrusionDir = normalize(extrusionDir);
            			
                       float4 newpos = float4(position.xyz +  
                            ((1 - wcoord.x) * extrusionDistance * extrusionDir), 1);
            
                       oPosition = mul(worldViewProjMatrix, newpos);
            
                    }
            
                  // Directional light extrude - FINITE
                   void shadowVolumeExtrudeDirLightFinite_vp (
                        float4 position			: POSITION,
                        float  wcoord			: TEXCOORD0,
            
                        out float4 oPosition	: POSITION,
            
                        uniform float4x4 worldViewProjMatrix,
                        uniform float4   lightPos, // homogenous, object space
            			uniform float    extrusionDistance // how far to extrude
                        )
                   {
                        // extrusion in object space
                        // vertex unmodified if w==1, extruded if w==0
            			// -ve lightPos is direction
                        float4 newpos = float4(position.xyz - 
                            (wcoord.x * extrusionDistance * lightPos.xyz), 1);
            
                        oPosition = mul(worldViewProjMatrix, newpos);
            
                    }		
            		 </code>
             </remarks>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.#ctor">
            <summary>
            	This is a static class; don't allow instantiation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.isInitialized">
            <summary>
            	Have the hardware extrusion programs been initialized yet?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.GetProgramSource(Axiom.Graphics.LightType,System.String,System.Boolean,System.Boolean)">
            <summary>
            	General purpose method to get any of the program sources.
            </summary>
            <param name="lightType">Type of light to get the source for.</param>
            <param name="syntax">Syntax code of interest.</param>
            <param name="finite">Is this for finite volume extrusion?</param>
            <param name="debug">Should the shadow volumes be visible?</param>
            <returns>Source of the specified program.</returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.GetProgramName(Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs)">
            <summary>
            	Gets the name of the program for the given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.GetProgramName(Axiom.Graphics.LightType,System.Boolean,System.Boolean)">
            <summary>
            	General purpose method to get any of the program names based on the specified parameters.
            </summary>
            <param name="lightType">Type of light to get the source for.</param>
            <param name="finite">Is this for finite volume extrusion?</param>
            <param name="debug">Should the shadow volumes be visible?</param>
            <returns>Name of the program matching the specified parameters.</returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.Initialize">
            <summary>
            	Initialize the creation of these core vertex programs.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowVolumeExtrudeProgram.Shutdown">
            <summary>
                Called on engine shutdown; destroys all auto created gpu programs.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs">
            <summary>
            	Contains the possible hardware extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLight">
            <summary>
            	Point light extruder, infinite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLightDebug">
            <summary>
            	Point light extruder, infinite distance, debug mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLight">
            <summary>
            	Directional light extruder, infinite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLightDebug">
            <summary>
            	Directional light extruder, infinite distance, debug mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLightFinite">
            <summary>
            	Point light extruder, finite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.PointLightFiniteDebug">
            <summary>
            	Point light extruder, finite distance, debug mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLightFinite">
            <summary>
            	Directional light extruder, finite distance.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowVolumeExtrudeProgram.Programs.DirectionalLightFiniteDebug">
            <summary>
            	Directional light extruder, finite distance, debug mode.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IHardwareOcclusionQuery">
            <summary>
            	Interface specification for hardware queries that can be used to find the number
            	of fragments rendered by the last render operation.
            </summary>
            Original Author: Lee Sandberg.
        </member>
        <member name="M:Axiom.Graphics.IHardwareOcclusionQuery.Begin">
            <summary>
            	Begins the query.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.IHardwareOcclusionQuery.End">
            <summary>
            	Ends the current active occlusion test.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.IHardwareOcclusionQuery.PullResults(System.Boolean)">
            <summary>
            	Checks to see if there are results returned from the most recent execution
            	of this query.
            </summary>
            <param name="flush">
            	True if currently batched API calls should be processed.
            	Note: Only D3D uses this parameter at this time.
            </param>
            <returns>The number of fragment returned by the query.</returns>
        </member>
        <member name="P:Axiom.Graphics.IHardwareOcclusionQuery.LastFragmentCount">
            <summary>
            	Gets the fragment count from the last execution of this query.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.IHardwareOcclusionQuery.SkipRate">
            <summary>
            	Gets/Sets the number of frames that are skipped between each execution of the
            	query.
            </summary>
        </member>
        <member name="T:Axiom.Fonts.FontManager">
            <summary>
               Manages Font resources, parsing .fontdef files and generally organizing them.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.FontManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.FontManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.FontManager.ParseAllSources">
            <summary>
               Parses all .fontdef scripts available in all resource locations.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.FontManager.ParseScript(System.IO.Stream)">
            <summary>
               Parse a .fontdef script passed in as a chunk.
            </summary>
            <param name="script"></param>
        </member>
        <member name="M:Axiom.Fonts.FontManager.ParseAttribute(System.String,Axiom.Fonts.Font)">
            <summary>
               Parses an attribute of the font definitions.
            </summary>
            <param name="line"></param>
            <param name="font"></param>
        </member>
        <member name="P:Axiom.Fonts.FontManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.Folder">
            <summary>
            Represents a file system folder.
            </summary>
        </member>
        <member name="T:Axiom.Core.WireBoundingBox">
            <summary>
            Summary description for WireBoundingBox.
            </summary>
        </member>
        <member name="M:Axiom.Core.WireBoundingBox.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.WireBoundingBox.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
            
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.WireBoundingBox.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.WireBoundingBox.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
               Gets the rendering operation required to render the wire box.
            </summary>
            <param name="op">A reference to a precreate RenderOpertion to be modifed here.</param>
        </member>
        <member name="P:Axiom.Core.WireBoundingBox.BoundingRadius">
            <summary>
               Get the local bounding radius of the wire bounding box.
            </summary>
        </member>
        <member name="T:Axiom.Core.RenderQueueEvent">
            <summary>
            	Delegate for speicfying the method signature for a render queue event.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneManager">
            <summary>
                Manages the rendering of a 'scene' i.e. a collection of primitives.
            </summary>
            <remarks>
            	This class defines the basic behavior of the 'Scene Manager' family. These classes will
            	organize the objects in the scene and send them to the rendering system, a subclass of
            	RenderSystem. This basic superclass only does basic bounding box frustum culling.
               <p/>
            	Subclasses may use various techniques to organise the scene depending on how they are
            	designed (e.g. BSPs, octrees etc). As with other classes, methods marked as internal are 
            	designed to be called by other classes in the engine, not by user applications.
             </remarks>
            TODO: Thoroughly review node removal/cleanup.
            TODO: Review of method visibility/virtuality to ensure consistency.
        </member>
        <member name="F:Axiom.Core.SceneManager.renderQueue">
            <summary>A queue of objects for rendering.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.targetRenderSystem">
            <summary>A reference to the current active render system..</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.hasCameraChanged">
            <summary>Denotes whether or not the camera has been changed.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.ambientColor">
            <summary>The ambient color, cached from the RenderSystem</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.cameraList">
            <summary>A list of the valid cameras for this scene for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.lightList">
            <summary>A list of lights in the scene for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.entityList">
            <summary>A list of entities in the scene for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.sceneNodeList">
            <summary>A list of scene nodes (includes all in the scene graph).</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.billboardSetList">
            <summary>A list of billboard set for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.animationList">
            <summary>A list of animations for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.animationStateList">
            <summary>A list of animation states for easy lookup.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.camInProgress">
            <summary>A reference to the current camera being used for rendering.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.rootSceneNode">
            <summary>The root of the scene graph heirarchy.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.autoParamDataSource">
            <summary>
               Utility class for updating automatic GPU program params.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.displayNodes">
            <summary>Flag indicating whether SceneNodes will be rendered as a set of 3 axes.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.showBoundingBoxes">
            <summary>Flag that specifies whether scene nodes will have their bounding boxes rendered as a wire frame.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.optionList">
            <summary>Hashtable of options that can be used by this or any other scene manager.</summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.localLightList">
            <summary>
               Local light list for use during rendering passes.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.normalizeNormals">
            <summary>
               Whether normals are currently being normalized.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.autoTrackingSceneNodes">
            <summary>
            	Active list of nodes tracking other nodes.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTechnique">
            <summary>
            	Current shadow technique in use in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.showDebugShadows">
            <summary>
            	If true, shadow volumes will be visible in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowDebugPass">
            <summary>
            	Pass to use for rendering debug shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowStencilPass">
            <summary>
            	
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowModulativePass">
            <summary>
            	Pass to use while rendering the full screen quad for modulative shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterPlainBlackPass">
            <summary>
            	A pass designed to let us render shadow colour on white for texture shadows
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowReceiverPass">
            <summary>
            	A pass designed to let us render shadow receivers for texture shadows
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.lightsAffectingFrustum">
            <summary>
            	List of lights in view that could cast shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.fullScreenQuad">
            <summary>
            	Full screen rectangle to use for rendering stencil shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowIndexBuffer">
            <summary>
            	buffer to use for indexing shadow geometry required for certain techniques.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterList">
            <summary>
            	Current list of shadow casters within the view of the camera.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowDirLightExtrudeDist">
            <summary>
            	Explicit extrusion distance for directional lights.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterSphereQuery">
            <summary>
            	Sphere region query to find shadow casters within the attenuation range of a point/spot light.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterAABBQuery">
            <summary>
            	AxisAlignedBox region query to find shadow casters within the attenuation range of a directional light.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowCasterQueryListener">
            <summary>
            	Listener to use when finding shadow casters for a light within a scene.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowFarDistance">
            <summary>
            	Farthest distance from the camera at which to render shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowFarDistanceSquared">
            <summary>
            	shadowFarDistance ^ 2
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowIndexBufferSize">
            <summary>
            	The maximum size of the index buffer used to render shadow primitives.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.illuminationStage">
            <summary>
            	Current stage of rendering.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureOffset">
            <summary>
            	Proportion of texture offset in view direction e.g. 0.4
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureFadeStart">
            <summary>
            	As a proportion e.g. 0.6
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureFadeEnd">
            <summary>
            	As a proportion e.g. 0.9
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextureSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowTextures">
            <summary>
            	Current list of shadow textures.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowUseInfiniteFarPlane">
            <summary>
            	Whether we should override far distance when using stencil volumes
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.infiniteExtrusionParams">
            <summary>
            	Program parameters for infinite extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.finiteExtrusionParams">
            <summary>
            	Program parameters for finite extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.defaultRootNode">
            <summary>
            	If set, only this scene node (and children) will be rendered.
            	If null, root node is used.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManager.shadowMaterialInitDone">
            <summary>
            	For the RenderTextureShadowCasterQueueGroupObjects and
            	RenderTextureShadowReceiverQueueGroupObjects methods.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSceneNode">
            <summary>
            	Creates an instance of a SceneNode.
            </summary>
            <remarks>
               Note that this does not add the SceneNode to the scene hierarchy.
            	This method is for convenience, since it allows an instance to
            	be created for which the SceneManager is responsible for
            	allocating and releasing memory, which is convenient in complex
            	scenes.
            	<p/>
                To include the returned SceneNode in the scene, use the AddChild
            	method of the SceneNode which is to be it's parent.
            	<p/>
                Note that this method takes no parameters, and the node created is unnamed (it is
                actually given a generated name, which you can retrieve if you want).
                If you wish to create a node with a specific name, call the alternative method
                which takes a name parameter.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSceneNode(System.String)">
            <summary>
            	Creates an instance of a SceneNode with a given name.
            </summary>
            <remarks>
            	Note that this does not add the SceneNode to the scene hierarchy.
            	This method is for convenience, since it allows an instance to
            	be created for which the SceneManager is responsible for
            	allocating and releasing memory, which is convenient in complex
            	scenes.
            	<p/>
            	To include the returned SceneNode in the scene, use the AddChild
            	method of the SceneNode which is to be it's parent.
            	<p/>
            	Note that this method takes a name parameter, which makes the node easier to
            	retrieve directly again later.
            </remarks>
            <param name="pName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAnimation(System.String,System.Single)">
            <summary>
            	Creates an animation which can be used to animate scene nodes.
            </summary>
            <remarks>
            	An animation is a collection of 'tracks' which over time change the position / orientation
            	of Node objects. In this case, the animation will likely have tracks to modify the position
            	/ orientation of SceneNode objects, e.g. to make objects move along a path.
            	<p/>
            	You don't need to use an Animation object to move objects around - you can do it yourself
            	using the methods of the Node in your application. However, when you need relatively
            	complex scripted animation, this is the class to use since it will interpolate between
            	keyframes for you and generally make the whole process easier to manage.
            	<p/>
            	A single animation can affect multiple Node objects (each AnimationTrack affects a single Node).
            	In addition, through animation blending a single Node can be affected by multiple animations,
            	although this is more useful when performing skeletal animation (see Skeleton.CreateAnimation).
            </remarks>
            <param name="name"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Core.SceneManager.CreateAnimationState(System.String)" -->
        <member name="M:Axiom.Core.SceneManager.CreateBillboardSet(System.String)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateBillboardSet(System.String,System.Int32)">
            <summary>
            	Creates a billboard set which can be uses for particles, sprites, etc.
            </summary>
            <param name="name"></param>
            <param name="poolSize"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateCamera(System.String)">
            <summary>
            	Creates a camera to be managed by this scene manager.
            </summary>
            <remarks>
            	This camera can be added to the scene at a later time using
            	the AttachObject method of the SceneNode class.
             </remarks>
             <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateEntity(System.String,System.String)">
            <summary>
            	Create an Entity (instance of a discrete mesh).
            </summary>
            <param name="name">The name to be given to the entity (must be unique).</param>
            <param name="meshName">The name of the mesh to load.  Will be loaded if not already.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateEntity(System.String,Axiom.Core.PrefabEntity)">
            <summary>
            	Create an Entity (instance of a discrete mesh).
            </summary>
            <param name="name">The name to be given to the entity (must be unique).</param>
            <param name="meshName">The name of the mesh to load.  Will be loaded if not already.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateLight(System.String)">
            <summary>
            	Creates a light that will be managed by this scene manager.
            </summary>
            <remarks>
            	Lights can either be in a fixed position and independent of the
            	scene graph, or they can be attached to SceneNodes so they derive
            	their position from the parent node. Either way, they are created
            	using this method so that the SceneManager manages their
            	existence.
            </remarks>
            <param name="name">Name of the light to create.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateMaterial(System.String)">
            <summary>
            	Creates a new (blank) material with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateOverlay(System.String,System.Int32)">
            <summary>
            	Creates a new Overlay.
            </summary>
            <remarks>
            	<p>
            	Overlays can be used to render heads-up-displays (HUDs), menu systems,
            	cockpits and any other 2D or 3D object you need to appear above the
            	rest of the scene. See the Overlay class for more information.
            	</p>
            	<p>
            	NOTE: after creation, the Overlay is initially hidden. You can create
            	as many overlays as you like ready to be displayed whenever. Just call
            	Overlay.Show to display the overlay.
            	</p>
            </remarks>
            <param name="name">The name to give the overlay, must be unique.</param>
            <param name="zorder">The zorder of the overlay relative to it's peers, higher zorders appear on top of lower ones.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ClearScene">
            <summary>
            	Empties the entire scene, inluding all SceneNodes, Entities, Lights, 
            	BillboardSets etc. Cameras are not deleted at this stage since
            	they are still referenced by viewports, which are not destroyed during
            	this process.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroySceneNode(System.String)">
            <summary>
               Destroys and removes a node from the scene.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAnimation(System.String)">
            <summary>
            	Destroys an Animation. 
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAnimationState(System.String)">
            <summary>
            	Destroys an AnimationState. 
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllAnimations">
            <summary>
            	Removes all animations created using this SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllAnimationStates">
            <summary>
            	Removes all AnimationStates created using this SceneManager.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyAllOverlays">
            <summary>
            	Destroys all the overlays.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DestroyOverlay(System.String)">
            <summary>
            	Destroys the named Overlay.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetCamera(System.String)">
            <summary>
                Retreives the camera with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetLight(System.String)">
            <summary>
                Retreives the light with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetBillboardSet(System.String)">
            <summary>
                Retreives the BillboardSet with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetAnimation(System.String)">
            <summary>
                Retreives the animation with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetAnimationState(System.String)">
            <summary>
                Retreives the AnimationState with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetOverlay(System.String)">
            <summary>
            	Gets a the named Overlay, previously created using CreateOverlay.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetMaterial(System.String)">
            <summary>
                Returns the material with the specified name.
            </summary>
            <param name="name">Name of the material to retrieve.</param>
            <returns>A reference to a Material.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetMaterial(System.Int32)">
            <summary>
                Returns the material with the specified handle.
            </summary>
            <param name="name">Handle of the material to retrieve.</param>
            <returns>A reference to a Material.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetRenderQueue">
            <summary>
            	Retrieves the internal render queue.
            </summary>
            <returns>
            	The render queue in use by this scene manager.
            	Note: The queue is created if it doesn't already exist.
            </returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.InitRenderQueue">
            <summary>
            	Internal method for initializing the render queue.
            </summary>
            <remarks>
            	Subclasses can use this to install their own <see cref="T:Axiom.Graphics.RenderQueue"/> implementation.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetSceneNode(System.String)">
            <summary>
                Retreives the scene node with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.GetSuggestedViewpoint(System.Boolean)">
            <summary>
                Asks the SceneManager to provide a suggested viewpoint from which the scene should be viewed.
            </summary>
            <remarks>
                Typically this method returns the origin unless a) world geometry has been loaded using
                <see cref="M:Axiom.Core.SceneManager.LoadWorldGeometry(System.String)"/> and b) that world geometry has suggested 'start' points.
                If there is more than one viewpoint which the scene manager can suggest, it will always suggest
                the first one unless the random parameter is true.
            </remarks>
            <param name="random">
                If true, and there is more than one possible suggestion, a random one will be used. If false
                the same one will always be suggested.
            </param>
            <returns>Optimal ViewPoint defined by the scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.LoadWorldGeometry(System.String)">
            <summary>
            	Loads the source of the 'world' geometry, i.e. the large, mainly static geometry
            	making up the world e.g. rooms, landscape etc.
            </summary>
            <remarks>
            	Depending on the type of SceneManager (subclasses will be specialized
            	for particular world geometry types) you have requested via the Root or
            	SceneManagerEnumerator classes, you can pass a filename to this method and it
            	will attempt to load the world-level geometry for use. If you try to load
            	an inappropriate type of world data an exception will be thrown. The default
            	SceneManager cannot handle any sort of world geometry and so will always
            	throw an exception. However subclasses like BspSceneManager can load
            	particular types of world geometry e.g. "q3dm1.bsp".
            </remarks>
            <param name="fileName"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ManualRender(Axiom.Graphics.RenderOperation,Axiom.Graphics.Pass,Axiom.Core.Viewport,Axiom.Math.Matrix4,Axiom.Math.Matrix4,Axiom.Math.Matrix4,System.Boolean)">
            <summary>
            	Manual rendering method, for advanced users only.
            </summary>
            <remarks>
            	This method allows you to send rendering commands through the pipeline on
            	demand, bypassing any normal world processing. You should only use this if you
            	really know what you're doing; the engine does lots of things for you that you really should
            	let it do. However, there are times where it may be useful to have this manual interface,
            	for example overlaying something on top of the scene.
            	<p/>
            	Because this is an instant rendering method, timing is important. The best 
            	time to call it is from a RenderTarget event handler.
            	<p/>
            	Don't call this method a lot, it's designed for rare (1 or 2 times per frame) use. 
            	Calling it regularly per frame will cause frame rate drops!
            </remarks>
            <param name="op">A RenderOperation object describing the rendering op.</param>
            <param name="pass">The Pass to use for this render.</param>
            <param name="vp">Reference to the viewport to render to.</param>
            <param name="worldMatrix">The transform to apply from object to world space.</param>
            <param name="viewMatrix">The transform to apply from object to view space.</param>
            <param name="projMatrix">The transform to apply from view to screen space.</param>
            <param name="doBeginEndFrame">
            	If true, BeginFrame() and EndFrame() are called, otherwise not. 
            	You should leave this as false if you are calling this within the main render loop.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.FindLightsAffectingFrustum(Axiom.Core.Camera)">
            <summary>
            	Internal method for locating a list of lights which could be affecting the frustum.
            </summary>
            <remarks>
            	Custom scene managers are encouraged to override this method to make use of their
            	scene partitioning scheme to more efficiently locate lights, and to eliminate lights
            	which may be occluded by word geometry.
            </remarks>
            <param name="camera">Camera to find lights within it's view.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.FindShadowCastersForLight(Axiom.Core.Light,Axiom.Core.Camera)">
            <summary>
            	Internal method for locating a list of shadow casters which 
            	could be affecting the frustum for a given light. 
            </summary>
            <remarks>
            	Custom scene managers are encouraged to override this method to add optimizations, 
            	and to add their own custom shadow casters (perhaps for world geometry)
            </remarks>
            <param name="light"></param>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.InitShadowVolumeMaterials">
            <summary>
            	Internal method for setting up materials for shadows.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.DeriveShadowCasterPass(Axiom.Graphics.Pass)">
            <summary>
            	Internal method for turning a regular pass into a shadow caster pass.
            </summary>
            <remarks>
            	This is only used for texture shadows, basically we're trying to
            	ensure that objects are rendered solid black.
            	This method will usually return the standard solid black pass for
            	all fixed function passes, but will merge in a vertex program
            	and fudge the AutpoParamDataSource to set black lighting for
            	passes with vertex programs. 
            </remarks>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.DeriveShadowReceiverPass(Axiom.Graphics.Pass)">
            <summary>
            	Internal method for turning a regular pass into a shadow receiver pass.
            </summary>
            <remarks>
            	This is only used for texture shadows, basically we're trying to
            	ensure that objects are rendered with a projective texture.
            	This method will usually return a standard single-texture pass for
            	all fixed function passes, but will merge in a vertex program
            	for passes with vertex programs. 
            </remarks>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderShadowVolumesToStencil(Axiom.Core.Light,Axiom.Core.Camera)">
            <summary>
            	Internal method for rendering all the objects for a given light into the stencil buffer.
            </summary>
            <param name="light">The light source.</param>
            <param name="camera">The camera being viewed from.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetShadowVolumeStencilState(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            	Internal utility method for setting stencil state for rendering shadow volumes.
            </summary>
            <param name="secondPass">Is this the second pass?</param>
            <param name="zfail">Should we be using the zfail method?</param>
            <param name="twoSided">Should we use a 2-sided stencil?</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderSingleShadowVolumeToStencil(Axiom.Graphics.ShadowRenderable,System.Boolean,System.Boolean,Axiom.Collections.LightList,System.Boolean)">
            <summary>
            	Render a single shadow volume to the stencil buffer.
            </summary>
            <param name="sr"></param>
            <param name="zfail"></param>
            <param name="stencil2sided"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetPass(Axiom.Graphics.Pass)">
            <summary>Internal method for setting up the renderstate for a rendering pass.</summary>
            <param name="pass">The Pass details to set.</param>
            <returns>
            	A Pass object that was used instead of the one passed in, can
            	happen when rendering shadow passes
            </returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSkyboxPlane(Axiom.Core.BoxPlane,System.Single,Axiom.Math.Quaternion)">
            <summary>
            	Utility method for creating the planes of a skybox.
            </summary>
            <param name="plane"></param>
            <param name="distance"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSkyDomePlane(Axiom.Core.BoxPlane,System.Single,System.Single,System.Single,Axiom.Math.Quaternion)">
            <summary>
               
            </summary>
            <param name="plane"></param>
            <param name="curvature"></param>
            <param name="tiling"></param>
            <param name="distance"></param>
            <param name="orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.UseRenderableViewProjection(Axiom.Graphics.IRenderable)">
            <summary>
            	Protected method used by RenderVisibleObjects to deal with renderables
            	which override the camera's own view / projection materices.
            </summary>
            <param name="renderable"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.OnRenderQueueStarted(Axiom.Core.RenderQueueGroupID)">
            <summary>
            	Used to first the QueueStarted event.  
            </summary>
            <param name="group"></param>
            <returns>True if the queue should be skipped.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.OnRenderQueueEnded(Axiom.Core.RenderQueueGroupID)">
            <summary>
            	Used to first the QueueEnded event.  
            </summary>
            <param name="group"></param>
            <returns>True if the queue should be repeated.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAABBRegionQuery">
            <summary>
            	Creates a <see cref="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a AxisAlignedBox region.
            </remarks>
            <returns>A specialized implementation of AxisAlignedBoxRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAABBRegionQuery(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a AxisAlignedBox region.
            </remarks>
            <param name="box">AxisAlignedBox to use for the region query.</param>
            <returns>A specialized implementation of AxisAlignedBoxRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateAABBRegionQuery(Axiom.Math.AxisAlignedBox,System.UInt64)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a AxisAlignedBox region.
            </remarks>
            <param name="box">AxisAlignedBox to use for the region query.</param>
            <param name="mask">Custom user defined flags to use for the query.</param>
            <returns>A specialized implementation of AxisAlignedBoxRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateRayQuery">
            <summary>
               Creates a query to return objects found along the ray.
            </summary>
            <returns>A specialized implementation of RaySceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateRayQuery(Axiom.Math.Ray)">
            <summary>
               Creates a query to return objects found along the ray.
            </summary>
            <param name="ray">Ray to use for the intersection query.</param>
            <returns>A specialized implementation of RaySceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateRayQuery(Axiom.Math.Ray,System.UInt64)">
            <summary>
               Creates a query to return objects found along the ray. 
            </summary>
            <param name="ray">Ray to use for the intersection query.</param>
            <returns>A specialized implementation of RaySceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSphereRegionQuery">
            <summary>
            	Creates a <see cref="T:Axiom.Core.SphereRegionSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a spherical region.
            </remarks>
            <returns>A specialized implementation of SphereRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSphereRegionQuery(Axiom.Math.Sphere)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.SphereRegionSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a spherical region.
            </remarks>
            <param name="sphere">Sphere to use for the region query.</param>
            <returns>A specialized implementation of SphereRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateSphereRegionQuery(Axiom.Math.Sphere,System.UInt64)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.SphereRegionSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a spherical region.
            </remarks>
            <param name="sphere">Sphere to use for the region query.</param>
            <param name="mask">Custom user defined flags to use for the query.</param>
            <returns>A specialized implementation of SphereRegionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreatePlaneBoundedVolumeQuery">
            <summary>
            	Creates a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a PlaneBoundedVolumes region.
            </remarks>
            <returns>A specialized implementation of PlaneBoundedVolumeListSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreatePlaneBoundedVolumeQuery(Axiom.Math.Collections.PlaneBoundedVolumeList)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a PlaneBoundedVolumes region.
            </remarks>
            <param name="volumes">PlaneBoundedVolumeList to use for the region query.</param>
            <returns>A specialized implementation of PlaneBoundedVolumeListSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreatePlaneBoundedVolumeQuery(Axiom.Math.Collections.PlaneBoundedVolumeList,System.UInt64)">
            <summary>
            	Creates a <see cref="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery"/> for this scene manager. 
            </summary>
            <remarks>
            	This method creates a new instance of a query object for this scene manager, 
            	for querying for objects within a PlaneBoundedVolumes region.
            </remarks>
            <param name="volumes">PlaneBoundedVolumeList to use for the region query.</param>
            <param name="mask">Custom user defined flags to use for the query.</param>
            <returns>A specialized implementation of PlaneBoundedVolumeListSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateIntersectionQuery">
            <summary>
               Creates an IntersectionSceneQuery for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for locating
            	intersecting objects. See SceneQuery and IntersectionSceneQuery
            	for full details.
            </remarks>
            <returns>A specialized implementation of IntersectionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateIntersectionQuery(System.UInt64)">
            <summary>
               Creates an IntersectionSceneQuery for this scene manager.
            </summary>
            <remarks>
            	This method creates a new instance of a query object for locating
            	intersecting objects. See SceneQuery and IntersectionSceneQuery
            	for full details.
            </remarks>
            <param name="mask">The query mask to apply to this query; can be used to filter out certain objects.</param>
            <returns>A specialized implementation of IntersectionSceneQuery for this scene manager.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllCameras">
            <summary>
            	Removes all cameras from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllLights">
            <summary>
            	Removes all lights from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllEntities">
            <summary>
            	Removes all entities from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveAllBillboardSets">
            <summary>
            	Removes all billboardsets from the scene.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveCamera(Axiom.Core.Camera)">
            <summary>
            	Removes the specified camera from the scene.
            </summary>
            <remarks>
            	This method removes a previously added camera from the scene.
            </remarks>
            <param name="camera">Reference to the camera to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveCamera(System.String)">
            <summary>
            	Removes a camera from the scene with the specified name.
            </summary>
            <remarks>
            	This method removes a previously added camera from the scene.
            </remarks>
            <param name="name">Name of the camera to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveLight(Axiom.Core.Light)">
            <summary>
            	Removes the specified light from the scene.
            </summary>
            <remarks>
            	This method removes a previously added light from the scene.
            </remarks>
            <param name="camera">Reference to the light to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveLight(System.String)">
            <summary>
            	Removes a light from the scene with the specified name.
            </summary>
            <remarks>
            	This method removes a previously added light from the scene.
            </remarks>
            <param name="name">Name of the light to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveBillboardSet(Axiom.Core.BillboardSet)">
            <summary>
            	Removes the specified BillboardSet from the scene.
            </summary>
            <remarks>
            	This method removes a previously added BillboardSet from the scene.
            </remarks>
            <param name="camera">Reference to the BillboardSet to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveBillboardSet(System.String)">
            <summary>
            	Removes a BillboardSet from the scene with the specified name.
            </summary>
            <remarks>
            	This method removes a previously added BillboardSet from the scene.
            </remarks>
            <param name="name">Name of the BillboardSet to remove.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveEntity(Axiom.Core.Entity)">
            <summary>
               Removes the specified entity from the scene.
            </summary>
            <param name="entity">Entity to remove from the scene.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RemoveEntity(System.String)">
            <summary>
               Removes the entity with the specified name from the scene.
            </summary>
            <param name="entity">Entity to remove from the scene.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetFog(Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the fogging mode applied to the scene.
            </summary>
            <remarks>
            	This method sets up the scene-wide fogging effect. These settings
            	apply to all geometry rendered, UNLESS the material with which it
            	is rendered has it's own fog settings (see Material.SetFog).
            </remarks>
            <param name="mode">Set up the mode of fog as described in the FogMode
            	enum, or set to FogMode.None to turn off.</param>
            <param name="color">The color of the fog. Either set this to the same
            	as your viewport background color, or to blend in with a skydome or skybox.</param>
            <param name="density">The density of the fog in Exp or Exp2.
            	mode, as a value between 0 and 1. The default is 0.001. </param>
            <param name="linearStart">Distance in world units at which linear fog starts to
            	encroach. Only applicable if mode is</param>
            <param name="linearEnd">Distance in world units at which linear fog becomes completely
            	opaque. Only applicable if mode is</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetFog(Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single)">
            <summary>
            
            </summary>
            <param name="mode"></param>
            <param name="color"></param>
            <param name="density"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="enable"></param>
            <param name="materialName"></param>
            <param name="distance"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single,System.Boolean,Axiom.Math.Quaternion)">
            <summary>
            	Enables / disables a 'sky box' i.e. a 6-sided box at constant
            	distance from the camera representing the sky.
            </summary>
            <remarks>
            	You could create a sky box yourself using the standard mesh and
            	entity methods, but this creates a plane which the camera can
            	never get closer or further away from - it moves with the camera.
            	(you could create this effect by creating a world box which
            	was attached to the same SceneNode as the Camera too, but this
            	would only apply to a single camera whereas this skybox applies
            	to any camera using this scene manager).
            	<p/>
            	The material you use for the skybox can either contain layers
            	which are single textures, or they can be cubic textures, i.e.
            	made up of 6 images, one for each plane of the cube. See the
            	TextureLayer class for more information.
            </remarks>
            <param name="enable">True to enable the skybox, false to disable it</param>
            <param name="materialName">The name of the material the box will use.</param>
            <param name="distance">Distance in world coordinates from the camera to each plane of the box. </param>
            <param name="drawFirst">
            	If true, the box is drawn before all other
            	geometry in the scene, without updating the depth buffer.
            	This is the safest rendering method since all other objects
            	will always appear in front of the sky. However this is not
            	the most efficient way if most of the sky is often occluded
            	by other objects. If this is the case, you can set this
            	parameter to false meaning it draws <em>after</em> all other
            	geometry which can be an optimisation - however you must
            	ensure that the distance value is large enough that no
            	objects will 'poke through' the sky box when it is rendered.
            </param>
            <param name="orientation">
            	Specifies the orientation of the box. By default the 'top' of the box is deemed to be
            	in the +y direction, and the 'front' at the -z direction.
            	You can use this parameter to rotate the sky if you want.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="isEnabled"></param>
            <param name="materialName"></param>
            <param name="curvature"></param>
            <param name="tiling"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean,Axiom.Math.Quaternion)">
            <summary>
            
            </summary>
            <param name="isEnabled"></param>
            <param name="materialName"></param>
            <param name="curvature"></param>
            <param name="tiling"></param>
            <param name="distance"></param>
            <param name="drawFirst"></param>
            <param name="orientation"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetShadowTextureSettings(System.UInt16,System.UInt16)">
            <summary>
            	Sets the size and count of textures used in texture-based shadows. 
            </summary>
            <remarks>
            	See ShadowTextureSize and ShadowTextureCount for details, this
            	method just allows you to change both at once, which can save on 
            	reallocation if the textures have already been created.
            </remarks>
            <param name="size"></param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderScene(Axiom.Core.Camera,Axiom.Core.Viewport,System.Boolean)">
            <summary>
            	Prompts the class to send its contents to the renderer.
            </summary>
            <remarks>
            	This method prompts the scene manager to send the
            	contents of the scene it manages to the rendering
            	pipeline, possibly preceded by some sorting, culling
            	or other scene management tasks. Note that this method is not normally called
            	directly by the user application; it is called automatically
            	by the engine's rendering loop.
            </remarks>
            <param name="camera">Pointer to a camera from whose viewpoint the scene is to be rendered.</param>
            <param name="viewport">The target viewport</param>
            <param name="showOverlays">Whether or not any overlay objects should be rendered</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.UpdateSceneGraph(Axiom.Core.Camera)">
            <summary>
            	Internal method for updating the scene graph ie the tree of SceneNode instances managed by this class.
            </summary>
            <remarks>
            	This must be done before issuing objects to the rendering pipeline, since derived transformations from
            	parent nodes are not updated until required. This SceneManager is a basic implementation which simply
            	updates all nodes from the root. This ensures the scene is up to date but requires all the nodes
            	to be updated even if they are not visible. Subclasses could trim this such that only potentially visible
            	nodes are updated.
            </remarks>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.FindVisibleObjects(Axiom.Core.Camera,System.Boolean)">
            <summary>
            	Internal method which parses the scene to find visible objects to render.
            </summary>
            <remarks>
            	If you're implementing a custom scene manager, this is the most important method to
            	override since it's here you can apply your custom world partitioning scheme. Once you
            	have added the appropriate objects to the render queue, you can let the default
            	SceneManager objects RenderVisibleObjects handle the actual rendering of the objects
            	you pick.
            	<p/>
            	Any visible objects will be added to a rendering queue, which is indexed by material in order
            	to ensure objects with the same material are rendered together to minimise render state changes.
            </remarks>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ApplySceneAnimations">
            <summary>
            	Internal method for applying animations to scene nodes.
            </summary>
            <remarks>
            	Uses the internally stored AnimationState objects to apply animation to SceneNodes.
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.CreateShadowTextures(System.UInt16,System.UInt16)">
            <summary>
            Internal method for creating shadow textures (texture-based shadows).
            </summary>
            <param name="size"></param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.PrepareShadowTextures(Axiom.Core.Camera,Axiom.Core.Viewport)">
            <summary>
            Internal method for preparing shadow textures ready for use in a regular render
            </summary>
            <param name="camera"></param>
            <param name="viewPort"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetViewport(Axiom.Core.Viewport)">
            <summary>
            	Internal method for setting the destination viewport for the next render.
            </summary>
            <param name="viewport"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderSingleObject(Axiom.Graphics.IRenderable,Axiom.Graphics.Pass,System.Boolean,Axiom.Collections.LightList)">
            <summary>
            	Internal utility method for rendering a single object.
            </summary>
            <param name="renderable">The renderable to issue to the pipeline.</param>
            <param name="pass">The pass which is being used.</param>
            <param name="doLightIteration">If true, this method will issue the renderable to
            the pipeline possibly multiple times, if the pass indicates it should be
            done once per light.</param>
            <param name="manualLightList">Only applicable if 'doLightIteration' is false, this
            method allows you to pass in a previously determined set of lights
            which will be used for a single render of this object.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderSolidObjects(System.Collections.SortedList,System.Boolean,Axiom.Collections.LightList)">
            <summary>
            	Renders a set of solid objects.
            </summary>
            <param name="list">List of solid objects.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTransparentObjects(System.Collections.ArrayList,System.Boolean,Axiom.Collections.LightList)">
            <summary>
            	Renders a set of transparent objects.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderAdditiveStencilShadowedQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group with the added complexity of additive stencil shadows.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderModulativeStencilShadowedQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group with the added complexity of modulative stencil shadows.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTextureShadowCasterQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group rendering only shadow casters.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderModulativeTextureShadowedQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group with the added complexity of modulative texture shadows.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTextureShadowReceiverQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group rendering only shadow receivers.
            </summary>
            <param name="group">Render queue group.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.ValidatePassForRendering(Axiom.Graphics.Pass)">
            <summary>
            	Internal method to validate whether a Pass should be allowed to render.
            </summary>
            <remarks>
            	Called just before a pass is about to be used for rendering a group to
            	allow the SceneManager to omit it if required. A return value of false
            	skips this pass. 
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.ValidateRenderableForRendering(Axiom.Graphics.Pass,Axiom.Graphics.IRenderable)">
            <summary>
            	Internal method to validate whether a Renderable should be allowed to render.
            </summary>
            <remarks>
            	Called just before a pass is about to be used for rendering a Renderable to
            	allow the SceneManager to omit it if required. A return value of false
            	skips it. 
            </remarks>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render the objects in a given queue group.
            </summary>
            <param name="group">Group containing the objects to render.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderBasicQueueGroupObjects(Axiom.Graphics.RenderQueueGroup)">
            <summary>
            	Render a group in the ordinary way
            </summary>
            <param name="group">Group containing the objects to render.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderTransparentShadowCasterObjects(System.Collections.ArrayList,System.Boolean,Axiom.Collections.LightList)">
            <summary>
            	Render those objects in the transparent pass list which have shadow casting forced on
            </summary>
            <remarks>
            	This function is intended to be used to render the shadows of transparent objects which have
            	transparency_casts_shadows set to 'on' in their material
            </remarks>
            <param name="list"></param>
            <param name="doLightIteration"></param>
            <param name="manualLightList"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.RenderVisibleObjects">
            <summary>
            	Sends visible objects found in <see cref="M:Axiom.Core.SceneManager.FindVisibleObjects(Axiom.Core.Camera,System.Boolean)"/> to the rendering engine.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManager.QueueSkiesForRendering(Axiom.Core.Camera)">
            <summary>
            	Internal method for queueing the sky objects with the params as 
            	previously set through SetSkyBox, SetSkyPlane and SetSkyDome.
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.PopulateLightList(Axiom.Math.Vector3,System.Single,Axiom.Collections.LightList)">
            <summary>
            	Populate a light list with an ordered set of the lights which are closest 
            </summary>
            <remarks>
            	<p>
            	Note that since directional lights have no position, they are always considered
            	closer than any point lights and as such will always take precedence.
            	</p>
            	<p>
            	Subclasses of the default SceneManager may wish to take into account other issues
            	such as possible visibility of the light if that information is included in their
            	data structures. This basic scenemanager simply orders by distance, eliminating
            	those lights which are out of range.
            	</p>
            	<p>
            	The number of items in the list max exceed the maximum number of lights supported
            	by the renderer, but the extraneous ones will never be used. In fact the limit will
            	be imposed by Pass::getMaxSimultaneousLights.
            	</p>
            </remarks>
            <param name="position">The position at which to evaluate the list of lights</param>
            <param name="radius">The bounding radius to test</param>
            <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyPlane(System.Boolean,Axiom.Math.Plane,System.String,System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            	Enables / disables a 'sky plane' i.e. a plane at constant
            	distance from the camera representing the sky.
            </summary>
            <param name="enable">True to enable the plane, false to disable it.</param>
            <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera.</param>
            <param name="materialName">The name of the material the plane will use.</param>
            <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane.</param>
            <param name="tiling">How many times to tile the texture across the sky.</param>
            <param name="drawFirst">
            	If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer.
            	This is the safest rendering method since all other objects
            	will always appear in front of the sky. However this is not
            	the most efficient way if most of the sky is often occluded
            	by other objects. If this is the case, you can set this
            	parameter to false meaning it draws <em>after</em> all other
            	geometry which can be an optimisation - however you must
            	ensure that the plane.d value is large enough that no objects
            	will 'poke through' the sky plane when it is rendered.
             </param>
            <param name="bow">
            	If above zero, the plane will be curved, allowing
            	the sky to appear below camera level.  Curved sky planes are 
            	simular to skydomes, but are more compatable with fog.
            </param>
        </member>
        <member name="M:Axiom.Core.SceneManager.SetSkyPlane(System.Boolean,Axiom.Math.Plane,System.String)">
            <summary>
            	Overload.
            </summary>
            <param name="enable"></param>
            <param name="plane"></param>
        </member>
        <member name="M:Axiom.Core.SceneManager.NotifyAutoTrackingSceneNode(Axiom.Core.SceneNode,System.Boolean)">
            <summary>
            	Internal method for notifying the manager that a SceneNode is autotracking.
            </summary>
            <param name="node">Scene node that is auto tracking another scene node.</param>
            <param name="autoTrack">True if tracking, false if it is stopping tracking.</param>
        </member>
        <member name="M:Axiom.Core.SceneManager.OverrideRootSceneNode(Axiom.Core.SceneNode)">
            <summary>
            If set, only the selected node is rendered.
            To render all nodes, set to null.
            </summary>
            
        </member>
        <member name="E:Axiom.Core.SceneManager.QueueStarted">
            <summary>An event that will fire when a render queue is starting to be rendered.</summary>
        </member>
        <member name="E:Axiom.Core.SceneManager.QueueEnded">
            <summary>An event that will fire when a render queue is finished being rendered.</summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.TargetRenderSystem">
            <summary>
            Gets/Sets the target render system that this scene manager should be using.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.RootSceneNode">
            <summary>
            	Gets the SceneNode at the root of the scene hierarchy.
            </summary>
            <remarks>
            	The entire scene is held as a hierarchy of nodes, which
            	allows things like relative transforms, general changes in
            	rendering state etc (See the SceneNode class for more info).
            	In this basic SceneManager class, you are free to
            	structure this hierarchy however you like, since 
            	it has no real significance apart from making transforms
            	relative to each node (more specialised subclasses will
            	provide utility methods for building specific node structures
            	e.g. loading a BSP tree).
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.AmbientLight">
            <summary>
            	Gets/Sets the ambient light level to be used for the scene.
            </summary>
            <remarks>
            	This sets the color and intensity of the ambient light in the scene, i.e. the
            	light which is 'sourceless' and illuminates all objects equally.
            	The color of an object is affected by a combination of the light in the scene,
            	and the amount of light that object reflects (in this case based on the Material.Ambient
            	property).
            	<p/>
            	By default the ambient light in the scene is Black, i.e. no ambient light. This
            	means that any objects rendered with a Material which has lighting enabled 
            	(see Material.LightingEnabled) will not be visible unless you have some dynamic lights in your scene.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.Options">
            <summary>
            	Method for setting a specific option of the Scene Manager. These options are usually
            	specific for a certain implementation of the Scene Manager class, and may (and probably
            	will) not exist across different implementations.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowColor">
            <summary>
            	Gets/Sets the color used to modulate areas in shadow.
            </summary>
            <remarks>
            	This is only applicable for shadow techniques which involve 
            	darkening the area in shadow, as opposed to masking out the light. 
            	This color provided is used as a modulative value to darken the
            	areas.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowDirectionalLightExtrusionDistance">
            <summary>
            	Sets the distance a shadow volume is extruded for a directional light.
            </summary>
            <remarks>
            	Although directional lights are essentially infinite, there are many
            	reasons to limit the shadow extrusion distance to a finite number, 
            	not least of which is compatibility with older cards (which do not
            	support infinite positions), and shadow caster elimination.
            	<p/>
            	The default value is 10,000 world units. This does not apply to
            	point lights or spotlights, since they extrude up to their 
            	attenuation range.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowFarDistance">
            <summary>
            	Sets the maximum distance away from the camera that shadows will be visible.
            </summary>
            <remarks>
            	Shadow techniques can be expensive, therefore it is a good idea
            	to limit them to being rendered close to the camera if possible,
            	and to skip the expense of rendering shadows for distance objects.
            	This method allows you to set the distance at which shadows will no
            	longer be rendered.
            	Note:
            	Each shadow technique can interpret this subtely differently.
            	For example, one technique may use this to eliminate casters,
            	another might use it to attenuate the shadows themselves.
            	You should tweak this value to suit your chosen shadow technique
            	and scene setup.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowIndexBufferSize">
            <summary>
            	Sets the maximum size of the index buffer used to render shadow primitives.
            </summary>
            <remarks>
            	This property allows you to tweak the size of the index buffer used
            	to render shadow primitives (including stencil shadow volumes). The
            	default size is 51,200 entries, which is 100k of GPU memory, or
            	enough to render approximately 17,000 triangles. You can reduce this
            	as long as you do not have any models / world geometry chunks which 
            	could require more than the amount you set.
            	<p/>
            	The maximum number of triangles required to render a single shadow 
            	volume (including light and dark caps when needed) will be 3x the 
            	number of edges on the light silhouette, plus the number of 
            	light-facing triangles.	On average, half the 
            	triangles will be facing toward the light, but the number of 
            	triangles in the silhouette entirely depends on the mesh - 
            	angular meshes will have a higher silhouette tris/mesh tris
            	ratio than a smooth mesh. You can estimate the requirements for
            	your particular mesh by rendering it alone in a scene with shadows
            	enabled and a single light - rotate it or the light and make a note
            	of how high the triangle count goes (remembering to subtract the 
            	mesh triangle count)
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowTextureSize">
            <summary>
            	Set the size of the texture used for texture-based shadows.
            </summary>
            <remarks>
            	The larger the shadow texture, the better the detail on 
            	texture based shadows, but obviously this takes more memory.
            	The default size is 512. Sizes must be a power of 2.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowTextureCount">
            <summary>
            	Set the number of textures allocated for texture-based shadows.
            </summary>
            <remarks>
            	The default number of textures assigned to deal with texture based
            	shadows is 1; however this means you can only have one light casting
            	shadows at the same time. You can increase this number in order to 
            	make this more flexible, but be aware of the texture memory it will use.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShadowTechnique">
            <summary>
            	Sets the general shadow technique to be used in this scene.
            </summary>
            <remarks>
            	There are multiple ways to generate shadows in a scene, and each has 
            	strengths and weaknesses. 
            	<ul><li>Stencil-based approaches can be used to 
            	draw very long, extreme shadows without loss of precision and the 'additive'
            	version can correctly show the shadowing of complex effects like bump mapping
            	because they physically exclude the light from those areas. However, the edges
            	are very sharp and stencils cannot handle transparency, and they involve a 
            	fair amount of CPU work in order to calculate the shadow volumes, especially
            	when animated objects are involved.</li>
            	<li>Texture-based approaches are good for handling transparency (they can, for
            	example, correctly shadow a mesh which uses alpha to represent holes), and they
            	require little CPU overhead, and can happily shadow geometry which is deformed
            	by a vertex program, unlike stencil shadows. However, they have a fixed precision 
            	which can introduce 'jaggies' at long range and have fillrate issues of their own.</li>
            	</ul>
            	<p/>
            	We support 2 kinds of stencil shadows, and 2 kinds of texture-based shadows, and one
            	simple decal approach. The 2 stencil approaches differ in the amount of multipass work 
            	that is required - the modulative approach simply 'darkens' areas in shadow after the 
            	main render, which is the least expensive, whilst the additive approach has to perform 
            	a render per light and adds the cumulative effect, whcih is more expensive but more 
            	accurate. The texture based shadows both work in roughly the same way, the only difference is
            	that the shadowmap approach is slightly more accurate, but requires a more recent
            	graphics card.
            	<p/>
            	Note that because mixing many shadow techniques can cause problems, only one technique
            	is supported at once. Also, you should call this method at the start of the 
            	scene setup. 
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Core.SceneManager.ShadowUseInfiniteFarPlane" -->
        <member name="P:Axiom.Core.SceneManager.ShowBoundingBoxes">
            <summary>
            	Gets/Sets a value that forces all nodes to render their bounding boxes.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.ShowDebugShadows">
            <summary>
            	Gets/Sets a flag that indicates whether debug shadow info (i.e. visible volumes)
            	will be displayed.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.DisplayNodes">
            <summary>
            	Gets/Sets whether or not to display the nodes themselves in addition to their objects.
            </summary>
            <remarks>
            	What will be displayed is the local axes of the node (for debugging mainly).
            </remarks>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogMode">
            <summary>
            	Gets the fog mode that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogStart">
            <summary>
            	Gets the fog starting point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogEnd">
            <summary>
            	Gets the fog ending point that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogDensity">
            <summary>
            	Gets the fog density that was set during the last call to SetFog.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManager.FogColor">
            <summary>
            	Gets the fog color that was set during the last call to SetFog.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Core.SceneManager.DefaultMaterialSettings" -->
        <member name="T:Axiom.Core.SceneManager.ShadowCasterSceneQueryListener">
            <summary>
            	Nested class to use as a callback for shadow caster scene query.
            </summary>
        </member>
        <member name="T:Axiom.Core.ISceneQueryListener">
            <summary>
            	This optional class allows you to receive per-result callbacks from
            	SceneQuery executions instead of a single set of consolidated results.
            </summary>
        </member>
        <member name="M:Axiom.Core.ISceneQueryListener.OnQueryResult(Axiom.Core.MovableObject)">
            <summary>
            	Called when a <see cref="!:SceneObject"/> is returned by a query.
            </summary>
            <remarks>
            	The implementor should return 'true' to continue returning objects,
            	or 'false' to abandon any further results from this query.
            </remarks>
            <param name="sceneObject">Object found by the query.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.ISceneQueryListener.OnQueryResult(Axiom.Core.SceneQuery.WorldFragment)">
            <summary>
            	Called when a <see cref="T:Axiom.Core.SceneQuery.WorldFragment"/> is returned by a query.
            </summary>
            <param name="fragment">Fragment found by the query.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.SceneManager.ShadowCasterSceneQueryListener.Prepare(System.Boolean,Axiom.Math.Collections.PlaneBoundedVolumeList,Axiom.Core.Light,Axiom.Core.Camera,System.Collections.ArrayList,System.Single)">
            <summary>
            	Prepare the listener for use with a set of parameters.
            </summary>
            <param name="lightInFrustum"></param>
            <param name="lightClipVolumes"></param>
            <param name="light"></param>
            <param name="camera"></param>
            <param name="shadowCasterList"></param>
            <param name="farDistSquared"></param>
        </member>
        <member name="T:Axiom.Core.DefaultAxisAlignedBoxRegionSceneQuery">
            <summary>
            	Default implementation of a AxisAlignedBoxRegionSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.AxisAlignedBoxRegionSceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying items within an AxisAlignedBox.
            </summary>
        </member>
        <member name="T:Axiom.Core.RegionSceneQuery">
            <summary>
            	Abstract class defining a query which returns single results from within a region.
            </summary>
            <remarks>
            	This class is simply a generalization of the subtypes of query that return 
            	a set of individual results in a region. See the <see cref="T:Axiom.Core.SceneQuery"/> class for 
            	abstract information, and subclasses for the detail of each query type.
            </remarks>
        </member>
        <member name="T:Axiom.Core.SceneQuery">
            <summary>
            	A class for performing queries on a scene.
            </summary>
            <remarks>
            	This is an abstract class for performing a query on a scene, i.e. to retrieve
            	a list of objects and/or world geometry sections which are potentially intersecting a
            	given region. Note the use of the word 'potentially': the results of a scene query
            	are generated based on bounding volumes, and as such are not correct at a triangle
            	level; the user of the SceneQuery is expected to filter the results further if
            	greater accuracy is required.
            	<p/>
            	Different SceneManagers will implement these queries in different ways to
            	exploit their particular scene organization, and thus will provide their own
            	concrete subclasses. In fact, these subclasses will be derived from subclasses
            	of this class rather than directly because there will be region-type classes
            	in between.
            	<p/>
            	These queries could have just been implemented as methods on the SceneManager,
            	however, they are wrapped up as objects to allow 'compilation' of queries
            	if deemed appropriate by the implementation; i.e. each concrete subclass may
            	precalculate information (such as fixed scene partitions involved in the query)
            	to speed up the repeated use of the query.
            	<p/>
            	You should never try to create a SceneQuery object yourself, they should be created
            	using the SceneManager interfaces for the type of query required, e.g.
            	SceneManager.CreateRaySceneQuery.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneQuery.creator">
            <summary>
            	Reference to the SceneManager that this query was created by.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.queryMask">
            <summary>
            	User definable query bit mask which can be used to filter the results of a query.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.worldFragmentTypes">
            <summary>
            	A flag enum which holds the world fragment types supported by this query.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Internal constructor.
            </summary>
            <param name="creator">Reference to the scene manager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.SceneQuery.AddWorldFragmentType(Axiom.Core.WorldFragmentType)">
            <summary>
            	Used to add a supported world fragment type to this query.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneQuery.QueryMask">
            <summary>
               Sets the mask for results of this query.
            </summary>
            <remarks>
               This property allows you to set a 'mask' to limit the results of this
               query to certain types of result. The actual meaning of this value is
               up to the application; basically SceneObject instances will only be returned
               from this query if a bitwise AND operation between this mask value and the
               SceneObject.QueryFlags value is non-zero. The application will
               have to decide what each of the bits means.
            </remarks>
        </member>
        <member name="T:Axiom.Core.SceneQuery.WorldFragment">
            <summary>
            	Represents part of the world geometry that is a result of a <see cref="T:Axiom.Core.SceneQuery"/>.
            </summary>
            <remarks>
            	Since world geometry is normally vast and sprawling, we need a way of
            	retrieving parts of it based on a query. That is what this struct is for;
            	note there are potentially as many data structures for world geometry as there
            	are SceneManagers, however this structure includes a few common abstractions as 
            	well as a more general format.
            	<p/>
            	The type of world fragment that is returned from a query depends on the
            	SceneManager, and the fragment types are supported on the query.
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.FragmentType">
            <summary>
            	The type of this world fragment.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.SingleIntersection">
            <summary>
            	Single intersection point, only applicable for <see cref="F:Axiom.Core.WorldFragmentType.SingleIntersection"/>.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.Planes">
            <summary>
            	Planes bounding a convex region, only applicable for <see cref="F:Axiom.Core.WorldFragmentType.PlaneBoundedRegion"/>.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQuery.WorldFragment.RenderOp">
            <summary>
            	General render operation structure.  Fallback if nothing else is available.
            </summary>
        </member>
        <member name="F:Axiom.Core.RegionSceneQuery.lastResult">
            <summary>
            	List of results from the last non-listener query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.ClearResults">
            <summary>
            	Clears out any cached results from the last query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.Execute">
            <summary>
            	Executes the query, returning the results back in one list.
            </summary>
            <remarks>
            	This method executes the scene query as configured, gathers the results
            	into one structure and returns a reference to that structure. These
            	results will also persist in this query object until the next query is
            	executed, or <see cref="M:Axiom.Core.RegionSceneQuery.ClearResults"/> is called. An more lightweight version of
            	this method that returns results through a listener is also available.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.Execute(Axiom.Core.ISceneQueryListener)">
            <summary>
            	Executes the query and returns each match through a listener interface.
            </summary>
            <remarks>
            	Note that this method does not store the results of the query internally 
            	so does not update the 'last result' value. This means that this version of
            	execute is more lightweight and therefore more efficient than the version 
            	which returns the results as a collection.
            </remarks>
            <param name="listener"></param>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.OnQueryResult(Axiom.Core.MovableObject)">
            <summary>
            	Self-callback in order to deal with execute which returns collection.
            </summary>
            <param name="sceneObject"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.RegionSceneQuery.OnQueryResult(Axiom.Core.SceneQuery.WorldFragment)">
            <summary>
            	Self-callback in order to deal with execute which returns collection.
            </summary>
            <param name="fragment"></param>
            <returns></returns>
        </member>
        <member name="F:Axiom.Core.AxisAlignedBoxRegionSceneQuery.box">
            <summary>
            	Sphere to query items within.
            </summary>
        </member>
        <member name="M:Axiom.Core.AxisAlignedBoxRegionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="P:Axiom.Core.AxisAlignedBoxRegionSceneQuery.Box">
            <summary>
            	Gets/Sets the sphere to use for the query.
            </summary>
        </member>
        <member name="T:Axiom.Core.DefaultRaySceneQuery">
            <summary>
               Default implementation of RaySceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.RaySceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying for objects along a ray.
            </summary>
        </member>
        <member name="T:Axiom.Core.IRaySceneQueryListener">
            <summary>
            	Alternative listener interface for dealing with <see cref="T:Axiom.Core.RaySceneQuery"/>.
            </summary>
        </member>
        <member name="M:Axiom.Core.IRaySceneQueryListener.OnQueryResult(Axiom.Core.MovableObject,System.Single)">
            <summary>
            	Called when a scene objects intersect the ray.
            </summary>
            <param name="sceneObject">Reference to the object hit by the ray.</param>
            <param name="distance">Distance from the origin of the ray where the intersection took place.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="M:Axiom.Core.IRaySceneQueryListener.OnQueryResult(Axiom.Core.SceneQuery.WorldFragment,System.Single)">
            <summary>
            	Called when a world fragment is intersected by the ray.
            </summary>
            <param name="fragment">World fragment hit by the ray.</param>
            <param name="distance">Distance from the origin of the ray where the intersection took place.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.ray">
            <summary>
            	Reference to a ray to use for this query.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.sortByDistance">
            <summary>
            	If true, results returned in the list 
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.maxResults">
            <summary>
            	Maximum results to return when executing the query.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQuery.lastResults">
            <summary>
            	List of query results from the last execution of this query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Constructor.
            </summary>
            <param name="creator">Scene manager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.ClearResults">
            <summary>
            	Clears out any cached results from the last query.
            </summary>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.Execute">
            <summary>
            	Executes the query, returning the results back in one list.
            </summary>
            <remarks>
            	This method executes the scene query as configured, gathers the results
            	into one structure and returns a reference to that structure. These
            	results will also persist in this query object until the next query is
            	executed, or <see cref="M:Axiom.Core.RaySceneQuery.ClearResults"/>. A more lightweight version of
            	this method that returns results through a listener is also available.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.RaySceneQuery.Execute(Axiom.Core.IRaySceneQueryListener)">
            <summary>
            	Executes the query and returns each match through a listener interface.
            </summary>
            <remarks>
            	Note that this method does not store the results of the query internally 
            	so does not update the 'last result' value. This means that this version of
            	execute is more lightweight and therefore more efficient than the version 
            	which returns the results as a collection.
            </remarks>
            <param name="listener">Listener object to handle the result callbacks.</param>
        </member>
        <member name="P:Axiom.Core.RaySceneQuery.Ray">
            <summary>
               Gets/Sets the Ray being used for this query.
            </summary>
        </member>
        <member name="P:Axiom.Core.RaySceneQuery.SortByDistance">
            <summary>
            	Gets/Sets whether this queries results are sorted by distance.
            </summary>
            <remarks>
            	Often you want to know what was the first object a ray intersected with, and this 
            	method allows you to ask the query to sort the results so that the nearest results
            	are listed first.
            	<p/>
            	Note that because the query returns results based on bounding volumes, the ray may not
            	actually intersect the detail of the objects returned from the query, just their 
            	bounding volumes. For this reason the caller is advised to use more detailed 
            	intersection tests on the results if a more accurate result is required; we use 
            	bounds checking in order to give the most speedy results since not all applications 
            	need extreme accuracy.
            </remarks>
        </member>
        <member name="P:Axiom.Core.RaySceneQuery.MaxResults">
            <summary>
            	Gets/Sets the maximum number of results to return from this query when 
            	sorting is enabled.
            </summary>
            <remarks>
            	If sorting by distance is not enabled, then this value has no affect.
            </remarks>
        </member>
        <member name="T:Axiom.Core.DefaultSphereRegionSceneQuery">
            <summary>
            	Default implementation of a SphereRegionSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.SphereRegionSceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying items within a sphere.
            </summary>
        </member>
        <member name="F:Axiom.Core.SphereRegionSceneQuery.sphere">
            <summary>
            	Sphere to query items within.
            </summary>
        </member>
        <member name="M:Axiom.Core.SphereRegionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="P:Axiom.Core.SphereRegionSceneQuery.Sphere">
            <summary>
            	Gets/Sets the sphere to use for the query.
            </summary>
        </member>
        <member name="T:Axiom.Core.DefaultPlaneBoundedVolumeListSceneQuery">
            <summary>
            	Default implementation of a PlaneBoundedVolumeListSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.PlaneBoundedVolumeListSceneQuery">
            <summary>
            	Specializes the SceneQuery class for querying items within PlaneBoundedVolumes.
            </summary>
        </member>
        <member name="F:Axiom.Core.PlaneBoundedVolumeListSceneQuery.volumes">
            <summary>
            	Sphere to query items within.
            </summary>
        </member>
        <member name="M:Axiom.Core.PlaneBoundedVolumeListSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Default constructor.
            </summary>
            <param name="creator">SceneManager who created this query.</param>
        </member>
        <member name="P:Axiom.Core.PlaneBoundedVolumeListSceneQuery.Volumes">
            <summary>
            	Gets/Sets the sphere to use for the query.
            </summary>
        </member>
        <member name="T:Axiom.Core.DefaultIntersectionSceneQuery">
            <summary>
               Default implementation of IntersectionSceneQuery.
            </summary>
        </member>
        <member name="T:Axiom.Core.IntersectionSceneQuery">
            <summary>
            Separate SceneQuery class to query for pairs of objects which are
            possibly intersecting one another.
            </summary>
            <remarks>
            This SceneQuery subclass considers the whole world and returns pairs of objects
            which are close enough to each other that they may be intersecting. Because of
            this slightly different focus, the return types and listener interface are
            different for this class.
            </remarks>
        </member>
        <member name="T:Axiom.Core.IIntersectionSceneQueryListener">
            <summary>
            	Alternative listener interface for dealing with <see cref="T:Axiom.Core.IntersectionSceneQuery"/>.
            </summary>
            <remarks>
            	Because the IntersectionSceneQuery returns results in pairs, rather than singularly,
            	the listener interface must be customised from the standard SceneQueryListener.
            </remarks>
        </member>
        <member name="M:Axiom.Core.IIntersectionSceneQueryListener.OnQueryResult(Axiom.Core.MovableObject,Axiom.Core.MovableObject)">
            <summary>
            	Called when 2 movable objects intersect one another.
            </summary>
            <param name="first">Reference to the first intersecting object.</param>
            <param name="second">Reference to the second intersecting object.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="M:Axiom.Core.IIntersectionSceneQueryListener.OnQueryResult(Axiom.Core.MovableObject,Axiom.Core.SceneQuery.WorldFragment)">
            <summary>
            	Called when a movable intersects a world fragment.
            </summary>
            <param name="obj">Intersecting object.</param>
            <param name="fragment">Intersecting world fragment.</param>
            <returns>Should return false to abandon returning additional results, or true to continue.</returns>
        </member>
        <member name="F:Axiom.Core.IntersectionSceneQuery.lastResults">
            <summary>
            	List of query results from the last execution of this query.
            </summary>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.#ctor(Axiom.Core.SceneManager)">
            <summary>
            	Constructor.
            </summary>
            <param name="creator">Scene manager who created this query.</param>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.ClearResults">
            <summary>
            	Clears out any cached results from the last query.
            </summary>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.Execute">
            <summary>
            	Executes the query, returning the results back in one list.
            </summary>
            <remarks>
            	This method executes the scene query as configured, gathers the results
            	into one structure and returns a reference to that structure. These
            	results will also persist in this query object until the next query is
            	executed, or <see cref="M:Axiom.Core.IntersectionSceneQuery.ClearResults"/>. A more lightweight version of
            	this method that returns results through a listener is also available.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.IntersectionSceneQuery.Execute(Axiom.Core.IIntersectionSceneQueryListener)">
            <summary>
            	Executes the query and returns each match through a listener interface.
            </summary>
            <remarks>
            	Note that this method does not store the results of the query internally 
            	so does not update the 'last result' value. This means that this version of
            	execute is more lightweight and therefore more efficient than the version 
            	which returns the results as a collection.
            </remarks>
            <param name="listener">Listener object to handle the result callbacks.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.ViewPoint" -->
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.#ctor">
            Constructor
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.UpdateRenderQueue(Axiom.Graphics.RenderQueue,Axiom.ParticleSystems.ParticleList,System.Boolean)">
            <summary>
             Delegated to by ParticleSystem::UpdateRenderQueue
            </summary>
            <remarks>
            The subclass must update the render queue using whichever Renderable instance(s) it wishes.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyCurrentCamera(Axiom.Core.Camera)">
            <summary>
            Delegated to by ParticleSystem.NotifyCurrentCamera
            </summary>
            <param name="cam"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyAttached(Axiom.Core.Node)">
            <summary>
            Delegated to by ParticleSystem.NotifyAttached
            </summary>
            <param name="parent"></param>
            <param name="isTagPoint"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleRotated">
            <summary>
            Optional callback notified when particles are rotated
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleResized">
            <summary>
            Optional callback notified when particles are resized individually
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyParticleQuota(System.Int32)">
            <summary>
            Tells the renderer that the particle quota has changed 
            </summary>
            <param name="quota"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.NotifyDefaultDimensions(System.Single,System.Single)">
            <summary>
            Tells the renderer that the particle default size has changed
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.CreateVisualData">
            <summary>
            Create a new ParticleVisualData instance for attachment to a particle.
            </summary>
            <remarks>
            If this renderer needs additional data in each particle, then this should
            be held in an instance of a subclass of ParticleVisualData, and this method
            should be overridden to return a new instance of it. The default
            behaviour is to return null.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystemRenderer.DestroyVisualData(Axiom.ParticleSystems.ParticleVisualData)">
            <summary>
             Destroy a ParticleVisualData instance.
            </summary>
            <remarks>
            If this renderer needs additional data in each particle, then this should
            be held in an instance of a subclass of ParticleVisualData, and this method
            should be overridden to destroy an instance of it. The default
            behaviour is to do nothing.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemRenderer.Material">
            <summary>
            Sets the material this renderer must use; called by ParticleSystem.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystemRenderer.RenderQueueGroup">
            <summary>
            Sets which render queue group this renderer should target with it's output.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleAffectorFactory">
            <summary>
            	Abstract class defining the interface to be implemented by creators of ParticleAffector subclasses.
            </summary>
            <remarks>
            	Plugins or 3rd party applications can add new types of particle affectors  by creating
            	subclasses of the ParticleAffector class. Because multiple instances of these affectors may be
            	required, a factory class to manage the instances is also required. 
            	<p/>
            	ParticleAffectorFactory subclasses must allow the creation and destruction of ParticleAffector
            	subclasses. They must also be registered with the ParticleSystemManager. All factories have
            	a name which identifies them, examples might be 'ForceVector', 'Attractor', or 'Fader', and these can be 
            	also be used from particle system scripts.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.Create">
            <summary>
            	Creates a new affector instance.
            </summary>
            <remarks>
            	Subclasses MUST add a reference to the affectorList.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleAffectorFactory.Destroy(Axiom.ParticleSystems.ParticleAffector)">
            <summary>
            	Destroys the affector referenced by the parameter.
            </summary>
            <param name="e">The Affector to destroy.</param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleAffectorFactory.Name">
            <summary>
            	Returns the name of the factory, which identifies the affector type this factory creates.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.OverlayManager">
            <summary>
               Manages Overlay objects, parsing them from Ogre .overlay files and
               storing a lookup library of them.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.OverlayManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.Create(System.String)">
            <summary>
            	Creates and return a new overlay.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.QueueOverlaysForRendering(Axiom.Core.Camera,Axiom.Graphics.RenderQueue,Axiom.Core.Viewport)">
            <summary>
            	Internal method for queueing the visible overlays for rendering.
            </summary>
            <param name="camera"></param>
            <param name="queue"></param>
            <param name="viewport"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.LoadAndParseOverlayFile(System.String)">
            <summary>
               Load a specific overlay file by name.
            </summary>
            <remarks>
               This is required from allowing .overlay scripts to include other overlay files.  It
               is not guaranteed what order the files will be loaded in, so this can be used to ensure
               depencies in a script are loaded prior to the script itself being loaded.
            </remarks>
            <param name="fileName"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseAllSources">
            <summary>
               Parses all overlay files in resource folders and archives.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseAttrib(System.String,Axiom.Overlays.Overlay)">
            <summary>
               Parses an attribute belonging to an Overlay.
            </summary>
            <param name="line"></param>
            <param name="overlay"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseChildren(System.IO.TextReader,System.String,Axiom.Overlays.Overlay,System.Boolean,Axiom.Overlays.OverlayElementContainer)">
            <summary>
            
            </summary>
            <param name="script"></param>
            <param name="line"></param>
            <param name="overlay"></param>
            <param name="isTemplate"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseElementAttrib(System.String,Axiom.Overlays.Overlay,Axiom.Overlays.OverlayElement)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <param name="overlay"></param>
            <param name="element"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseNewElement(System.IO.TextReader,System.String,System.String,System.Boolean,Axiom.Overlays.Overlay,System.Boolean)">
            <summary>
               Overloaded.  Calls overload with default of empty template name and null for the parent container.
            </summary>
            <param name="script"></param>
            <param name="type"></param>
            <param name="name"></param>
            <param name="isContainer"></param>
            <param name="overlay"></param>
            <param name="isTemplate"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseNewElement(System.IO.TextReader,System.String,System.String,System.Boolean,Axiom.Overlays.Overlay,System.Boolean,System.String,Axiom.Overlays.OverlayElementContainer)">
            <summary>
               Parses a new element
            </summary>
            <param name="script"></param>
            <param name="type"></param>
            <param name="name"></param>
            <param name="isContainer"></param>
            <param name="overlay"></param>
            <param name="isTemplate"></param>
            <param name="templateName"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseNewMesh(System.IO.TextReader,System.String,System.String,Axiom.Overlays.Overlay)">
            <summary>
               Parses a 3D mesh which will be used in the overlay.
            </summary>
            <param name="script"></param>
            <param name="meshName"></param>
            <param name="entityName"></param>
            <param name="overlay"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayManager.ParseOverlayScript(System.IO.Stream)">
            <summary>
               Parses an individual .overlay file.
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.HasViewportChanged">
            <summary>
            	Gets if the viewport has changed dimensions. 
            </summary>
            <remarks>
            	This is used by pixel-based GuiControls to work out if they need to reclaculate their sizes.
            </remarks>																				  
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.ViewportHeight">
            <summary>
            	Gets the height of the destination viewport in pixels.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayManager.ViewportWidth">
            <summary>
            	Gets the width of the destination viewport in pixels.
            </summary>
        </member>
        <member name="T:Axiom.Math.Vector2">
            <summary>
                2 dimensional vector.
            </summary>
        </member>
        <member name="M:Axiom.Math.Vector2.#ctor(System.Single,System.Single)">
            <summary>
                Constructor.
            </summary>
            <param name="x">X position.</param>
            <param name="y">Y position</param>
        </member>
        <member name="M:Axiom.Math.Vector2.Add(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used when a Vector2 is added to another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Addition(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used when a Vector2 is added to another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Subtract(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used to subtract a Vector2 from another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Subtraction(Axiom.Math.Vector2,Axiom.Math.Vector2)">
            <summary>
            	Used to subtract a Vector2 from another Vector2.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Multiply(Axiom.Math.Vector2,System.Single)">
            <summary>
            	Used when a Vector2 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Multiply(Axiom.Math.Vector2,System.Single)">
            <summary>
            	Used when a Vector2 is multiplied by a scalar value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Multiply(System.Single,Axiom.Math.Vector2)">
            <summary>
            	Used when a scalar value is multiplied by a Vector2.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_Multiply(System.Single,Axiom.Math.Vector2)">
            <summary>
            	Used when a scalar value is multiplied by a Vector2.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.Negate(Axiom.Math.Vector2)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Vector2.op_UnaryNegation(Axiom.Math.Vector2)">
            <summary>
            	Used to negate the elements of a vector.
            </summary>
            <param name="left"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Math.Plane">
             <summary>
             Defines a plane in 3D space.
             </summary>
             <remarks>
             A plane is defined in 3D space by the equation
             Ax + By + Cz + D = 0
            
             This equates to a vector (the normal of the plane, whose x, y
             and z components equate to the coefficients A, B and C
             respectively), and a constant (D) which is the distance along
             the normal you have to go to move the plane back to the origin.
             </remarks>
        </member>
        <member name="F:Axiom.Math.Plane.Normal">
            <summary>
            	Direction the plane is facing.
            </summary>
        </member>
        <member name="F:Axiom.Math.Plane.D">
            <summary>
            	Distance from the origin.
            </summary>
        </member>
        <member name="M:Axiom.Math.Plane.#ctor(Axiom.Math.Vector3,System.Single)">
            <summary>
            	Construct a plane through a normal, and a distance to move the plane along the normal.
            </summary>
            <param name="normal"></param>
            <param name="constant"></param>
        </member>
        <member name="M:Axiom.Math.Plane.#ctor(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Construct a plane from 3 coplanar points.
            </summary>
            <param name="point0">First point.</param>
            <param name="point1">Second point.</param>
            <param name="point2">Third point.</param>
        </member>
        <member name="M:Axiom.Math.Plane.GetSide(Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.GetDistance(Axiom.Math.Vector3)">
            <summary>
            This is a pseudodistance. The sign of the return value is
            positive if the point is on the positive side of the plane,
            negative if the point is on the negative side, and zero if the
             point is on the plane.
            The absolute value of the return value is the true distance only
            when the plane normal is a unit length vector.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.Redefine(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            	Construct a plane from 3 coplanar points.
            </summary>
            <param name="point0">First point.</param>
            <param name="point1">Second point.</param>
            <param name="point2">Third point.</param>
        </member>
        <member name="M:Axiom.Math.Plane.Equals(System.Object)">
            <summary>
            	Object method for testing equality.
            </summary>
            <param name="obj">Object to test.</param>
            <returns>True if the 2 planes are logically equal, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Plane.GetHashCode">
            <summary>
            	Gets the hashcode for this Plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.ToString">
            <summary>
            	Returns a string representation of this Plane.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Plane.op_Equality(Axiom.Math.Plane,Axiom.Math.Plane)">
            <summary>
            	Compares 2 Planes for equality.
            </summary>
            <param name="left">First plane.</param>
            <param name="right">Second plane.</param>
            <returns>true if equal, false if not equal.</returns>
        </member>
        <member name="M:Axiom.Math.Plane.op_Inequality(Axiom.Math.Plane,Axiom.Math.Plane)">
            <summary>
            	Compares 2 Planes for inequality.
            </summary>
            <param name="left">First plane.</param>
            <param name="right">Second plane.</param>
            <returns>true if not equal, false if equal.</returns>
        </member>
        <member name="T:Axiom.Graphics.Technique">
            <summary>
            	Class representing an approach to rendering a particular Material. 
            </summary>
            <remarks>
               The engine will attempt to use the best technique supported by the active hardware, 
               unless you specifically request a lower detail technique (say for distant rendering)
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.Technique.parent">
            <summary>
               The material that owns this technique.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique.passes">
            <summary>
               The list of passes (fixed function or programmable) contained in this technique.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique.illuminationPasses">
            <summary>
            	List of derived passes, categorized (and ordered) into illumination stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique.isSupported">
            <summary>
               Flag that states whether or not this technique is supported on the current hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique.name">
            <summary>
               Name of this technique.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Technique.lodIndex">
            <summary>
            	Level of detail index for this technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.ClearIlluminationPasses">
            <summary>
            	Internal method for clearing the illumination pass list.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.Clone(Axiom.Graphics.Material)">
            <summary>
               Clones this Technique.
            </summary>
            <param name="parent">Material that will own this technique.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.Technique.CopyTo(Axiom.Graphics.Technique)">
            <summary>
            	Copy the details of this Technique to another.
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Graphics.Technique.Compile(System.Boolean)">
            <summary>
               Compilation method for Techniques.  See <see cref="!:Axiom.Core.Material"/>
            </summary>
            <param name="autoManageTextureUnits">
               Determines whether or not the engine should split up extra texture unit requests
               into extra passes if the hardware does not have enough available units.
            </param>
        </member>
        <member name="M:Axiom.Graphics.Technique.CompileIlluminationPasses">
            <summary>
            	Internal method for splitting the passes into illumination passes.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.CreatePass">
            <summary>
               Creates a new Pass for this technique.
            </summary>
            <remarks>
               A Pass is a single rendering pass, ie a single draw of the given material.
               Note that if you create a non-programmable pass, during compilation of the
               material the pass may be split into multiple passes if the graphics card cannot
               handle the number of texture units requested. For programmable passes, however, 
               the number of passes you create will never be altered, so you have to make sure 
               that you create an alternative fallback Technique for if a card does not have 
               enough facilities for what you're asking for.
            </remarks>
            <param name="programmable">
               True if programmable via vertex or fragment programs, false if fixed function.
            </param>
            <returns>A new Pass object reference.</returns>
        </member>
        <member name="M:Axiom.Graphics.Technique.GetPass(System.Int32)">
            <summary>
               Retreives the Pass at the specified index.
            </summary>
            <param name="index">Index of the Pass to retreive.</param>
        </member>
        <member name="M:Axiom.Graphics.Technique.GetIlluminationPass(System.Int32)">
            <summary>
               Retreives the IlluminationPass at the specified index.
            </summary>
            <param name="index">Index of the IlluminationPass to retreive.</param>
        </member>
        <member name="M:Axiom.Graphics.Technique.Load">
            <summary>
               Loads resources required by this Technique.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.NotifyNeedsRecompile">
            <summary>
               Forces this Technique to recompile.
            </summary>
            <remarks>
               The parent Material is asked to recompile to accomplish this.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.Technique.RemovePass(Axiom.Graphics.Pass)">
            <summary>
               Removes the specified Pass from this Technique.
            </summary>
            <param name="pass">A reference to the Pass to be removed.</param>
        </member>
        <member name="M:Axiom.Graphics.Technique.RemoveAllPasses">
            <summary>
            	Removes all passes from this technique and queues them for deletion.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.Technique.Unload">
            <summary>
               Unloads resources used by this Technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.IsLoaded">
            <summary>
               Returns true if this Technique has already been loaded.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.IsSupported">
            <summary>
               Flag that states whether or not this technique is supported on the current hardware.
            </summary>
            <remarks>
               This will only be correct after the Technique has been compiled, which is
               usually triggered in Material.Compile.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.IsTransparent">
            <summary>
               Returns true if this Technique involves transparency.
            </summary>
            <remarks>
               This basically boils down to whether the first pass
               has a scene blending factor. Even if the other passes 
               do not, the base color, including parts of the original 
               scene, may be used for blending, therefore we have to treat
               the whole Technique as transparent.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Lighting">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.LodIndex">
            <summary>
            	Assigns a level-of-detail (LOD) index to this Technique.
            </summary>
            <remarks>
            	As noted previously, as well as providing fallback support for various
            	graphics cards, multiple Technique objects can also be used to implement
            	material LOD, where the detail of the material diminishes with distance to 
            	save rendering power.
            	<p/>
            	By default, all Techniques have a LOD index of 0, which means they are the highest
            	level of detail. Increasing LOD indexes are lower levels of detail. You can 
            	assign more than one Technique to the same LOD index, meaning that the best 
            	Technique that is supported at that LOD index is used. 
            	<p/>
            	You should not leave gaps in the LOD sequence; the engine will allow you to do this
            	and will continue to function as if the LODs were sequential, but it will 
            	confuse matters.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.Technique.Name">
            <summary>
               Gets/Sets the name of this technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.NumPasses">
            <summary>
               Gets the number of passes within this Technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.IlluminationPassCount">
            <summary>
            	Gets the number of illumination passes compiled from this technique.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.Technique.Parent">
            <summary>
               Gets a reference to the Material that owns this Technique.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Graphics.StaticFaceGroup" -->
        <member name="F:Axiom.Graphics.StaticFaceGroup.type">
            <summary>
                Type of face group.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.isSky">
            <summary>
                Is this a sky surface?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.vertexStart">
            <summary>
                Index into a buffer containing vertex definitions. Because we're
                dealing with subsets of large levels this is likely to be part-way
                through a huge vertex buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.numVertices">
            <summary>
                The range of vertices in the buffer this facegroup references.
                This is really for copying purposes only, so that we know which
                subset of vertices to copy from our large-level buffer into the rendering buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.elementStart">
            <summary>
                Index into a buffer containing vertex indices. This buffer
                may be individual to this group or shared for memory allocation
                efficiency.  The vertex indexes are relative the the vertexStart pointer,
                not to the start of the large-level buffer, allowing simple reindexing
                when copying data into rendering buffers.
                This is only applicable to FaceGroup.FaceList face groups.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.numElements">
            <summary>
                The number of vertex indices. This is only applicable to FaceGroup.FaceList face group types.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.materialHandle">
            <summary>
                Handle to material used by this group.
                Note the use of the material handle rather than the material
                name - this is for efficiency since there will be many of these.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.StaticFaceGroup.patchSurf">
            <remarks>
                Patch surface (only applicable when type == FaceGroup.Patch)
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.ShadowRenderable">
            <summary>
            	Class which represents the renderable aspects of a set of shadow volume faces.
            </summary>
            <remarks>
            	Note that for casters comprised of more than one set of vertex buffers (e.g. SubMeshes each
            	using their own geometry), it will take more than one <see cref="T:Axiom.Graphics.ShadowRenderable"/> to render the 
            	shadow volume. Therefore for shadow caster geometry, it is best to stick to one set of
            	vertex buffers (not necessarily one buffer, but the positions for the entire geometry 
            	should come from one buffer if possible)
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderable.lightCap">
            <summary>
            	Used only if IsLightCapSeparate == true.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.ShadowRenderable.GetRenderOperationForUpdate">
            <summary>
            	Gets the internal render operation for setup.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.ShadowRenderable.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
            	Gets the render operation for this shadow renderable.
            </summary>
            <param name="op"></param>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.IsLightCapSeperate">
            <summary>
            	Does this renderable require a separate light cap?
            </summary>
            <remarks>
            	If possible, the light cap (when required) should be contained in the
            	usual geometry of the shadow renderable. However, if for some reason
            	the normal depth function (less than) could cause artefacts, then a
            	separate light cap with a depth function of 'always fail' can be used 
            	instead. The primary example of this is when there are floating point
            	inaccuracies caused by calculating the shadow geometry separately from
            	the real geometry. 
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.LightCapRenderable">
            <summary>
            	Get the light cap version of this renderable.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.IsVisible">
            <summary>
            	Should this ShadowRenderable be treated as visible?
            </summary>
        </member>
        <member name="P:Axiom.Graphics.ShadowRenderable.Material">
            <summary>
            	Gets/Sets the material to use for this shadow renderable.
            </summary>
            <remarks>
            	Should be set by the caller before adding to a render queue.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.RenderSystem">
            <summary>
               Defines the functionality of a 3D API
            </summary>
            <remarks>
            	The RenderSystem class provides a base class
            	which abstracts the general functionality of the 3D API
            	e.g. Direct3D or OpenGL. Whilst a few of the general
            	methods have implementations, most of this class is
            	abstract, requiring a subclass based on a specific API
            	to be constructed to provide the full functionality.
            	<p/>
            	Note there are 2 levels to the interface - one which
            	will be used often by the caller of the engine library,
            	and one which is at a lower level and will be used by the
            	other classes provided by the engine. These lower level
            	methods are marked as internal, and are not accessible outside
            	of the Core library.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.DefaultWindowTitle">
            <summary>
            	Default window title if one is not specified upon a call to <see cref="M:Axiom.Graphics.RenderSystem.Initialize(System.Boolean,System.String)"/>.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.renderTargets">
            <summary>
            	List of current render targets (i.e. a <see cref="T:Axiom.Graphics.RenderWindow"/>, or a<see cref="T:Axiom.Graphics.RenderTexture"/>)
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.textureMgr">
            <summary>
            	A reference to the texture management class specific to this implementation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.hardwareBufferManager">
            <summary>
            	A reference to the hardware vertex/index buffer manager specific to this API.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.cullingMode">
            <summary>
            	Current hardware culling mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.isVSync">
            <summary>
            	Are we syncing frames with the refresh rate of the screen?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.depthWrite">
            <summary>
            	Current depth write setting.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.numCurrentLights">
            <summary>
            	Number of current active lights.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.engineConfig">
            <summary>
            	Reference to the config options for the graphics engine.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.activeViewport">
            <summary>
            	Active viewport (dest for future rendering operations) and target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.activeRenderTarget">
            <summary>
            	Active render target.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.numFaces">
            <summary>
            	Number of faces currently rendered this frame.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.numVertices">
            <summary>
            	Number of faces currently rendered this frame.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.caps">
            <summary>
            	Capabilites of the current hardware (populated at startup).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.worldMatrices">
            <summary>
            	Saved set of world matrices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderSystem.invertVertexWinding">
            <summary>
                Flag for whether vertex winding needs to be inverted, useful for reflections.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.#ctor">
            <summary>
            	Base constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.AttachRenderTarget(Axiom.Graphics.RenderTarget)">
            <summary>
               Attaches a render target to this render system.
            </summary>
            <param name="target">Reference to the render target to attach to this render system.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BeginGeometryCount">
            <summary>
            	The RenderSystem will keep a count of tris rendered, this resets the count.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DetachRenderTarget(System.String)">
            <summary>
            	Detaches the render target with the specified name from this render system.
            </summary>
            <param name="name">Name of the render target to detach.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DetachRenderTarget(Axiom.Graphics.RenderTarget)">
            <summary>
            	Detaches the render target from this render system.
            </summary>
            <param name="target">Reference to the render target to detach.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.DisableTextureUnit(System.Int32)">
            <summary>
            	Turns off a texture unit if not needed.
            </summary>
            <param name="stage"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.InitRenderTargets">
            <summary>
                Utility method for initializing all render targets attached to this rendering system.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.NotifyCameraRemoved(Axiom.Core.Camera)">
            <summary>
            	Utility method to notify all render targets that a camera has been removed, 
            	incase they were referring to it as their viewer. 
            </summary>
            <param name="camera">Camera being removed.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Render(Axiom.Graphics.RenderOperation)">
            <summary>
            	Render something to the active viewport.
            </summary>
            <remarks>
            	Low-level rendering interface to perform rendering
            	operations. Unlikely to be used directly by client
            	applications, since the <see cref="T:Axiom.Core.SceneManager"/> and various support
            	classes will be responsible for calling this method.
            	Can only be called between <see cref="!:BeginScene"/> and <see cref="!:EndScene"/>
            </remarks>
            <param name="op">
            	A rendering operation instance, which contains details of the operation to be performed.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureUnit(System.Int32,Axiom.Graphics.TextureUnitState)">
            <summary>
            	Utility function for setting all the properties of a texture unit at once.
            	This method is also worth using over the individual texture unit settings because it
            	only sets those settings which are different from the current settings for this
            	unit, thus minimising render state changes.
            </summary>
            <param name="textureUnit">Index of the texture unit to configure</param>
            <param name="layer">Reference to a TextureLayer object which defines all the settings.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureUnitFiltering(System.Int32,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions,Axiom.Graphics.FilterOptions)">
            <summary>
               Sets the filtering options for a given texture unit.
            </summary>
            <param name="unit">The texture unit to set the filtering options for.</param>
            <param name="minFilter">The filter used when a texture is reduced in size.</param>
            <param name="magFilter">The filter used when a texture is magnified.</param>
            <param name="mipFilter">
            	The filter used between mipmap levels, <see cref="F:Axiom.Graphics.FilterOptions.None"/> disables mipmapping.
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetWorldMatrices(Axiom.Math.Matrix4[],System.UInt16)">
            <summary>
            
            </summary>
            <param name="matrices"></param>
            <param name="count"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Shutdown">
            <summary>
            	Shuts down the RenderSystem.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UpdateAllRenderTargets">
            <summary>
               Internal method for updating all render targets attached to this rendering system.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ApplyObliqueDepthProjection(Axiom.Math.Matrix4@,Axiom.Math.Plane,System.Boolean)">
            <summary>
            	Update a perspective projection matrix to use 'oblique depth projection'.
            </summary>
            <remarks>
            	This method can be used to change the nature of a perspective 
            	transform in order to make the near plane not perpendicular to the 
            	camera view direction, but to be at some different orientation. 
            	This can be useful for performing arbitrary clipping (e.g. to a 
            	reflection plane) which could otherwise only be done using user
            	clip planes, which are more expensive, and not necessarily supported
            	on all cards.
            </remarks>
            <param name="projMatrix">
            	The existing projection matrix. Note that this must be a
            	perspective transform (not orthographic), and must not have already
            	been altered by this method. The matrix will be altered in-place.
            </param>
            <param name="plane">
            	The plane which is to be used as the clipping plane. This
            	plane must be in CAMERA (view) space.
            </param>
            <param name="forGpuProgram">Is this for use with a Gpu program or fixed-function transforms?</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BeginFrame">
            <summary>
            	Signifies the beginning of a frame, ie the start of rendering on a single viewport. Will occur
            	several times per complete frame if multiple viewports exist.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BindGpuProgram(Axiom.Graphics.GpuProgram)">
            <summary>
               Binds a given GpuProgram (but not the parameters). 
            </summary>
            <remarks>
               Only one GpuProgram of each type can be bound at once, binding another
               one will simply replace the existing one.
            </remarks>
            <param name="program"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.BindGpuProgramParameters(Axiom.Graphics.GpuProgramType,Axiom.Graphics.GpuProgramParameters)">
            <summary>
               Bind Gpu program parameters.
            </summary>
            <param name="parms"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ClearFrameBuffer(Axiom.Graphics.FrameBuffer,Axiom.Core.ColorEx,System.Single,System.Int32)">
            <summary>
            	Clears one or more frame buffers on the active render target.
            </summary>
            <param name="buffers">
            	Combination of one or more elements of <see cref="T:Axiom.Graphics.FrameBuffer"/>
            	denoting which buffers are to be cleared.
            </param>
            <param name="color">The color to clear the color buffer with, if enabled.</param>
            <param name="depth">The value to initialize the depth buffer with, if enabled.</param>
            <param name="stencil">The value to initialize the stencil buffer with, if enabled.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ConvertColor(Axiom.Core.ColorEx)">
            <summary>
            	Converts the System.Drawing.Color value to a int.  Each API may need the 
            	bytes of the packed color data in different orders. i.e. OpenGL - ABGR, D3D - ARGB
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateRenderTexture(System.String,System.Int32,System.Int32)">
            <summary>
               Creates and registers a render texture object.
            </summary>
            <param name="name">The name for the new render texture. Note that names must be unique.</param>
            <param name="width">Requested width for the render texture.</param>
            <param name="height">Requested height for the render texture.</param>
            <returns>
               On success, a reference to a new API-dependent, RenderTexture-derived
               class is returned. On failure, null is returned.
            </returns>
            <remarks>
               Because a render texture is basically a wrapper around a texture object,
               the width and height parameters of this method just hint the preferred
               size for the texture. Depending on the hardware driver or the underlying
               API, these values might change when the texture is created.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)">
            <summary>
            	Creates a new render window.
            </summary>
            <remarks>
            	This method creates a new rendering window as specified
            	by the paramteters. The rendering system could be
            	responible for only a single window (e.g. in the case
            	of a game), or could be in charge of multiple ones (in the
            	case of a level editor). The option to create the window
            	as a child of another is therefore given.
            	This method will create an appropriate subclass of
            	RenderWindow depending on the API and platform implementation.
            </remarks>
            <param name="name"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="isFullscreen"></param>
            <param name="miscParams">
            	A collection of addition rendersystem specific options.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.CreateHardwareOcclusionQuery">
            <summary>
            	Requests an API implementation of a hardware occlusion query used to test for the number
            	of fragments rendered between calls to <see cref="M:Axiom.Graphics.IHardwareOcclusionQuery.Begin"/> and 
            	<see cref="M:Axiom.Graphics.IHardwareOcclusionQuery.End"/> that pass the depth buffer test.
            </summary>
            <returns>An API specific implementation of an occlusion query.</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.EndFrame">
            <summary>
            	Ends rendering of a frame to the current viewport.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Initialize(System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="autoCreateWindow"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.MakeOrthoMatrix(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            	Builds an orthographic projection matrix suitable for this render system.
            </summary>
            <remarks>
            	Because different APIs have different requirements (some incompatible) for the
            	projection matrix, this method allows each to implement their own correctly and pass
            	back a generic Matrix3 for storage in the engine.
             </remarks>
            <param name="fov">Field of view angle.</param>
            <param name="aspectRatio">Aspect ratio.</param>
            <param name="near">Near clipping plane distance.</param>
            <param name="far">Far clipping plane distance.</param>
            <param name="forGpuProgram"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.MakeProjectionMatrix(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            	Builds a perspective projection matrix suitable for this render system.
            </summary>
            <remarks>
            	Because different APIs have different requirements (some incompatible) for the
            	projection matrix, this method allows each to implement their own correctly and pass
            	back a generic Matrix3 for storage in the engine.
             </remarks>
            <param name="fov">Field of view angle.</param>
            <param name="aspectRatio">Aspect ratio.</param>
            <param name="near">Near clipping plane distance.</param>
            <param name="far">Far clipping plane distance.</param>
            <param name="forGpuProgram"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetAlphaRejectSettings(System.Int32,Axiom.Graphics.CompareFunction,System.Byte)">
            <summary>
            
            </summary>
            <param name="stage"></param>
            <param name="func"></param>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetColorBufferWriteEnabled(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
               Sets whether or not color buffer writing is enabled, and for which channels. 
            </summary>
            <remarks>
               For some advanced effects, you may wish to turn off the writing of certain color
               channels, or even all of the color channels so that only the depth buffer is updated
               in a rendering pass. However, the chances are that you really want to use this option
               through the Material class.
            </remarks>
            <param name="red">Writing enabled for red channel.</param>
            <param name="green">Writing enabled for green channel.</param>
            <param name="blue">Writing enabled for blue channel.</param>
            <param name="alpha">Writing enabled for alpha channel.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetDepthBufferParams(System.Boolean,System.Boolean,Axiom.Graphics.CompareFunction)">
            <summary>
            	Sets the mode of operation for depth buffer tests from this point onwards.
            </summary>
            <remarks>
            	Sometimes you may wish to alter the behavior of the depth buffer to achieve
            	special effects. Because it's unlikely that you'll set these options for an entire frame,
            	but rather use them to tweak settings between rendering objects, this is intended for internal
            	uses, which will be used by a <see cref="T:Axiom.Core.SceneManager"/> implementation rather than directly from 
            	the client application.
            </remarks>
            <param name="depthTest">
            	If true, the depth buffer is tested for each pixel and the frame buffer is only updated
            	if the depth function test succeeds. If false, no test is performed and pixels are always written.
            </param>
            <param name="depthWrite">
            	If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds.
            	If false, the depth buffer is left unchanged even if a new pixel is written.
            </param>
            <param name="depthFunction">Sets the function required for the depth test.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetFog(Axiom.Graphics.FogMode,Axiom.Core.ColorEx,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the fog with the given params.
            </summary>
            <param name="mode"></param>
            <param name="color"></param>
            <param name="density"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Graphics.RenderSystem.SetSceneBlending(Axiom.Graphics.SceneBlendFactor,Axiom.Graphics.SceneBlendFactor)" -->
        <member name="M:Axiom.Graphics.RenderSystem.SetScissorTest(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Sets the 'scissor region' ie the region of the target in which rendering can take place.
            </summary>
            <remarks>
                This method allows you to 'mask off' rendering in all but a given rectangular area
                as identified by the parameters to this method.
                <p/>
                Not all systems support this method. Check the <see cref="!:Axiom.Graphics.Capabilites"/> enum for the
                ScissorTest capability to see if it is supported.
            </remarks>
            <param name="enabled">True to enable the scissor test, false to disable it.</param>
            <param name="left">Left corner (in pixels).</param>
            <param name="top">Top corner (in pixels).</param>
            <param name="right">Right corner (in pixels).</param>
            <param name="bottom">Bottom corner (in pixels).</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Graphics.RenderSystem.SetStencilBufferParams(Axiom.Graphics.CompareFunction,System.Int32,System.Int32,Axiom.Graphics.StencilOperation,Axiom.Graphics.StencilOperation,Axiom.Graphics.StencilOperation,System.Boolean)" -->
        <member name="M:Axiom.Graphics.RenderSystem.SetSurfaceParams(Axiom.Core.ColorEx,Axiom.Core.ColorEx,Axiom.Core.ColorEx,Axiom.Core.ColorEx,System.Single)">
            <summary>
            	Sets the surface parameters to be used during rendering an object.
            </summary>
            <param name="ambient"></param>
            <param name="diffuse"></param>
            <param name="specular"></param>
            <param name="emissive"></param>
            <param name="shininess"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTexture(System.Int32,System.Boolean,System.String)">
            <param name="enabled">Boolean to turn the unit on/off</param>
            <param name="textureName">The name of the texture to use - this should have
            	already been loaded with TextureManager.Load.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureAddressingMode(System.Int32,Axiom.Graphics.TextureAddressing)">
            <summary>
            	Tells the hardware how to treat texture coordinates.
            </summary>
            <param name="stage"></param>
            <param name="texAddressingMode"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureBlendMode(System.Int32,Axiom.Graphics.LayerBlendModeEx)">
            <summary>
            	Sets the texture blend modes from a TextureLayer record.
            	Meant for use internally only - apps should use the Material
            	and TextureLayer classes.
            </summary>
            <param name="stage">Texture unit.</param>
            <param name="blendMode">Details of the blending modes.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureCoordCalculation(System.Int32,Axiom.Graphics.TexCoordCalcMethod,Axiom.Core.Frustum)">
            <summary>
            	Sets a method for automatically calculating texture coordinates for a stage.
            </summary>
            <param name="stage">Texture stage to modify.</param>
            <param name="method">Calculation method to use</param>
            <param name="frustum">Frustum, only used for projective effects</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureCoordSet(System.Int32,System.Int32)">
            <summary>
            	Sets the index into the set of tex coords that will be currently used by the render system.
            </summary>
            <param name="stage"></param>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureLayerAnisotropy(System.Int32,System.Int32)">
            <summary>
            	Sets the maximal anisotropy for the specified texture unit.
            </summary>
            <param name="stage"></param>
            <param name="index">maxAnisotropy</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureMatrix(System.Int32,Axiom.Math.Matrix4)">
            <summary>
            	Sets the texture matrix for the specified stage.  Used to apply rotations, translations,
            	and scaling to textures.
            </summary>
            <param name="stage"></param>
            <param name="xform"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureUnitFiltering(System.Int32,Axiom.Graphics.FilterType,Axiom.Graphics.FilterOptions)">
            <summary>
               Sets a single filter for a given texture unit.
            </summary>
            <param name="stage">The texture unit to set the filtering options for.</param>
            <param name="type">The filter type.</param>
            <param name="filter">The filter to be used.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetViewport(Axiom.Core.Viewport)">
            <summary>
            	Sets the current viewport that will be rendered to.
            </summary>
            <param name="viewport"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UnbindGpuProgram(Axiom.Graphics.GpuProgramType)">
            <summary>
               Unbinds the current GpuProgram of a given GpuProgramType.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.UseLights(Axiom.Collections.LightList,System.Int32)">
            <summary>
               Tells the rendersystem to use the attached set of lights (and no others) 
               up to the number specified (this allows the same list to be used with different
               count limits).
            </summary>
            <param name="lightList">List of lights.</param>
            <param name="limit">Max number of lights that can be used from the list currently.</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.MakeProjectionMatrix(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Builds a perspective projection matrix suitable for this render system.
            </summary>
            <remarks>
            	Because different APIs have different requirements (some incompatible) for the
            	projection matrix, this method allows each to implement their own correctly and pass
            	back a generic Matrix3 for storage in the engine.
             </remarks>
            <param name="fov">Field of view angle.</param>
            <param name="aspectRatio">Aspect ratio.</param>
            <param name="near">Near clipping plane distance.</param>
            <param name="far">Far clipping plane distance.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.MakeOrthoMatrix(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Builds a orthographic projection matrix suitable for this render system.
            </summary>
            <remarks>
            	Because different APIs have different requirements (some incompatible) for the
            	projection matrix, this method allows each to implement their own correctly and pass
            	back a generic Matrix3 for storage in the engine.
             </remarks>
            <param name="fov">Field of view angle.</param>
            <param name="aspectRatio">Aspect ratio.</param>
            <param name="near">Near clipping plane distance.</param>
            <param name="far">Far clipping plane distance.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Initialize(System.Boolean)">
            <summary>
            	Initialize the rendering engine.
            </summary>
            <param name="autoCreateWindow">If true, a default window is created to serve as a rendering target.</param>
            <returns>A RenderWindow implementation specific to this RenderSystem.</returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.SetTextureCoordCalculation(System.Int32,Axiom.Graphics.TexCoordCalcMethod)">
            <summary>
            	Sets a method for automatically calculating texture coordinates for a stage.
            </summary>
            <param name="stage">Texture stage to modify.</param>
            <param name="method">Calculation method to use</param>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.ToString">
            <summary>
            Returns the name of this RenderSystem.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderSystem.Dispose">
            <summary>
            	Override to dispose of resources on shutdown if needed.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.Caps">
            <summary>
            	Gets a set of hardware capabilities queryed by the current render system.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ConfigOptions">
            <summary>
            Gets a dataset with the options set for the rendering system.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.FacesRendered">
            <summary>
            	Number of faces rendered during the current frame so far.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.InvertVertexWinding">
            <summary>
                Sets whether or not vertex windings set should be inverted; this can be important
                for rendering reflections.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.IsVSync">
            <summary>
            Gets/Sets a value that determines whether or not to wait for the screen to finish refreshing
            before drawing the next frame.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.Name">
            <summary>
            Gets the name of this RenderSystem based on it's assembly attribute Title.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Axiom.Graphics.RenderSystem.AmbientLight" -->
        <member name="P:Axiom.Graphics.RenderSystem.CullingMode">
            <summary>
               Gets/Sets the culling mode for the render system based on the 'vertex winding'.
            </summary>
            <remarks>
            	A typical way for the rendering engine to cull triangles is based on the
            	'vertex winding' of triangles. Vertex winding refers to the direction in
            	which the vertices are passed or indexed to in the rendering operation as viewed
            	from the camera, and will wither be clockwise or counterclockwise.  The default is <see cref="!:CullingMode.Clockwise"/>  
            	i.e. that only triangles whose vertices are passed/indexed in counterclockwise order are rendered - this 
            	is a common approach and is used in 3D studio models for example. You can alter this culling mode 
            	if you wish but it is not advised unless you know what you are doing. You may wish to use the 
            	<see cref="!:CullingMode.None"/> option for mesh data that you cull yourself where the vertex winding is uncertain.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DepthWrite">
            <summary>
            	Gets/Sets whether or not the depth buffer is updated after a pixel write.
            </summary>
            <value>
            	If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds.
            	If false, the depth buffer is left unchanged even if a new pixel is written.
            </value>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DepthCheck">
            <summary>
            	Gets/Sets whether or not the depth buffer check is performed before a pixel write.
            </summary>
            <value>
            	If true, the depth buffer is tested for each pixel and the frame buffer is only updated
            	if the depth function test succeeds. If false, no test is performed and pixels are always written.
            </value>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DepthFunction">
            <summary>
            	Gets/Sets the comparison function for the depth buffer check.
            </summary>
            <remarks>
            	Advanced use only - allows you to choose the function applied to compare the depth values of
            	new and existing pixels in the depth buffer. Only an issue if the depth buffer check is enabled.
            <seealso cref="P:Axiom.Graphics.RenderSystem.DepthCheck"/>
            </remarks>
            <value>
            	The comparison between the new depth and the existing depth which must return true
            	for the new pixel to be written.
            </value>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.DepthBias">
            <summary>
            	Gets/Sets the depth bias.
            </summary>
            <remarks>
            	When polygons are coplanar, you can get problems with 'depth fighting' where
            	the pixels from the two polys compete for the same screen pixel. This is particularly
            	a problem for decals (polys attached to another surface to represent details such as
            	bulletholes etc.).
            	<p/>
            	A way to combat this problem is to use a depth bias to adjust the depth buffer value
            	used for the decal such that it is slightly higher than the true value, ensuring that
            	the decal appears on top.
            </remarks>
            <value>The bias value, should be between 0 and 16.</value>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.HorizontalTexelOffset">
            <summary>
            	Returns the horizontal texel offset value required for mapping 
            	texel origins to pixel origins in this rendersystem.
            </summary>
            <remarks>
            	Since rendersystems sometimes disagree on the origin of a texel, 
            	mapping from texels to pixels can sometimes be problematic to 
            	implement generically. This method allows you to retrieve the offset
            	required to map the origin of a texel to the origin of a pixel in
            	the horizontal direction.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.LightingEnabled">
            <summary>
            	Gets/Sets whether or not dynamic lighting is enabled.
            	<p/>
            	If true, dynamic lighting is performed on geometry with normals supplied, geometry without
            	normals will not be displayed. If false, no lighting is applied and all geometry will be full brightness.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.NormalizeNormals">
            <summary>
               Get/Sets whether or not normals are to be automatically normalized.
            </summary>
            <remarks>
               This is useful when, for example, you are scaling SceneNodes such that
               normals may not be unit-length anymore. Note though that this has an
               overhead so should not be turn on unless you really need it.
               <p/>
               You should not normally call this direct unless you are rendering
               world geometry; set it on the Renderable because otherwise it will be
               overridden by material settings. 
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ProjectionMatrix">
            <summary>
            	Gets/Sets the current projection matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.RasterizationMode">
            <summary>
            	Gets/Sets how to rasterise triangles, as points, wireframe or solid polys.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ShadingMode">
            <summary>
            	Gets/Sets the type of light shading required (default = Gouraud).
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.StencilCheckEnabled">
            <summary>
            	Turns stencil buffer checking on or off. 
            </summary>
            <remarks>
            	Stencilling (masking off areas of the rendering target based on the stencil 
            	buffer) can be turned on or off using this method. By default, stencilling is
            	disabled.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.VerticalTexelOffset">
            <summary>
            	Returns the vertical texel offset value required for mapping 
            	texel origins to pixel origins in this rendersystem.
            </summary>
            <remarks>
            	Since rendersystems sometimes disagree on the origin of a texel, 
            	mapping from texels to pixels can sometimes be problematic to 
            	implement generically. This method allows you to retrieve the offset
            	required to map the origin of a texel to the origin of a pixel in
            	the vertical direction.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.ViewMatrix">
            <summary>
            	Gets/Sets the current view matrix.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderSystem.WorldMatrix">
            <summary>
            	Gets/Sets the current world matrix.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters">
            <summary>
            	Collects together the program parameters used for a GpuProgram.
            </summary>
            <remarks>
               Gpu program state includes constant parameters used by the program, and
               bindings to render system state which is propagated into the constants 
               by the engine automatically if requested.
               <p/>
               GpuProgramParameters objects should be created through the GpuProgramManager and
               may be shared between multiple GpuProgram instances. For this reason they
               are managed using a shared pointer, which will ensure they are automatically
               deleted when no program is using them anymore.
               <p/>
               Different types of GPU programs support different types of constant parameters.
               For example, it's relatively common to find that vertex programs only support
               floating point constants, and that fragment programs only support integer (fixed point)
               parameters. This can vary depending on the program version supported by the
               graphics card being used. You should consult the documentation for the type of
               low level program you are using, or alternatively use the methods
               provided on Capabilities to determine the options.
               <p/>
               Another possible limitation is that some systems only allow constants to be set
               on certain boundaries, e.g. in sets of 4 values for example. Again, see
               Capabilities for full details.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.intConstants">
            <summary>
               Packed list of integer constants
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.floatConstants">
            <summary>
               Table of Vector4 constants by index.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.autoConstantList">
            <summary>
               List of automatically updated parameters.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.namedParams">
            <summary>
               Lookup of constant indicies for named parameters.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.transposeMatrices">
            <summary>
                Specifies whether matrices need to be transposed prior to
                being sent to the hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.tmpVals">
            <summary>
            	Temp array for use when passing constants around.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.autoAddParamName">
            <summary>
            	Flag to indicate if names not found will be automatically added.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.ClearAutoConstants">
            <summary>
               Clears all the existing automatic constants.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.CopyConstantsFrom(Axiom.Graphics.GpuProgramParameters)">
            <summary>
            	Copies the values of all constants (including auto constants) from another <see cref="T:Axiom.Graphics.GpuProgramParameters"/> object.
            </summary>
            <param name="source">Set of params to use as the source.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetFloatConstant(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetIntConstant(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetParamIndex(System.String)">
            <summary>
               Gets the constant index of the specified named param.
            </summary>
            <param name="name">
               Name of the param.
            </param>
            <returns>
               Constant index.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetNameByIndex(System.Int32)">
            <summary>
            	Given an index, this function will return the name of the paramater at that index.
            </summary>
            <param name="index">Index of the parameter to look up.</param>
            <returns>Name of the param at the specified index.</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetNamedFloatConstant(System.String)">
            <summary>
            	Gets a Named Float Constant entry if the name is found otherwise returns a null.
            </summary>
            <param name="name">Name of the constant to retreive.</param>
            <returns>A reference to the float constant entry with the specified name, else null if not found.</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.GetNamedIntConstant(System.String)">
            <summary>
            	Gets a Named Int Constant entry if the name is found otherwise returns a null.
            </summary>
            <param name="name">Name of the constant to retreive.</param>
            <returns>A reference to the int constant entry with the specified name, else null if not found.</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.MapParamNameToIndex(System.String,System.Int32)">
            <summary>
               Maps a parameter name to the specified constant index.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="index">Constant index of the param.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetAutoConstant(System.Int32,Axiom.Graphics.AutoConstants)">
            <summary>
               Sets up a constant which will automatically be updated by the engine.
            </summary>
            <remarks>
               Vertex and fragment programs often need parameters which are to do with the
               current render state, or particular values which may very well change over time,
               and often between objects which are being rendered. This feature allows you 
               to set up a certain number of predefined parameter mappings that are kept up to 
               date for you.
            </remarks>
            <param name="type">The type of automatic constant to set.</param>
            <param name="index">
               The location in the constant list to place this updated constant every time
               it is changed. Note that because of the nature of the types, we know how big the 
               parameter details will be so you don't need to set that like you do for manual constants.
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetAutoConstant(System.Int32,Axiom.Graphics.AutoConstants,System.Int32)">
            <summary>
               Overloaded method.
            </summary>
            <param name="type">The type of automatic constant to set.</param>
            <param name="index">
               The location in the constant list to place this updated constant every time
               it is changed. Note that because of the nature of the types, we know how big the 
               parameter details will be so you don't need to set that like you do for manual constants.
            </param>
            <param name="extraInfo">If the constant type needs more information (like a light index) put it here.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Vector4)">
            <summary>
               Sends 4 packed floating-point values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="val">Structure containing 4 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Vector3)">
            <summary>
               Sends 3 packed floating-point values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="val">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Core.ColorEx)">
            <summary>
               Sends 4 packed floating-point RGBA color values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="color">Structure containing 4 packed RGBA color values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Matrix4)">
            <summary>
               Sends a multiple value constant floating-point parameter to the program.
            </summary>
            <remarks>
                This method is made virtual to allow GpuProgramManagers, or even individual
                GpuProgram implementations to supply their own implementation if need be.
                An example would be where a Matrix needs to be transposed to row-major format
                before passing to the hardware.
            </remarks>
            <param name="index">Index of the contant register.</param>
            <param name="val">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,Axiom.Math.Matrix4[],System.Int32)">
            <summary>
               Sends a multiple matrix values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="val">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,System.Int32[])">
            <summary>
               Sets an array of int values starting at the specified index.
            </summary>
            <param name="index">Index of the contant register to start at.</param>
            <param name="ints">Array of ints.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstant(System.Int32,System.Single[])">
            <summary>
               Sets an array of int values starting at the specified index.
            </summary>
            <param name="index">Index of the contant register to start at.</param>
            <param name="ints">Array of ints.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetConstantFromTime(System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="factor"></param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedAutoConstant(System.String,Axiom.Graphics.AutoConstants,System.Int32)">
            <summary>
               Sets up a constant which will automatically be updated by the engine.
            </summary>
            <remarks>
               Vertex and fragment programs often need parameters which are to do with the
               current render state, or particular values which may very well change over time,
               and often between objects which are being rendered. This feature allows you 
               to set up a certain number of predefined parameter mappings that are kept up to 
               date for you.
            </remarks>
            <param name="name">
               Name of the param.
            </param>
            <param name="type">
               The type of automatic constant to set.
            </param>
            <param name="extraInfo">
               Any extra infor needed by the auto constant (i.e. light index, etc).
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Math.Vector4)">
            <summary>
               Sends 4 packed floating-point values to the program.
            </summary>
            <param name="index">Index of the contant register.</param>
            <param name="val">Structure containing 4 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Math.Vector3)">
            <summary>
               Sends 3 packed floating-point values to the program.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="val">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Core.ColorEx)">
            <summary>
               Sends 4 packed floating-point RGBA color values to the program.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="color">Structure containing 4 packed RGBA color values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Math.Matrix4)">
            <summary>
               Sends a multiple value constant floating-point parameter to the program.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="val">Structure containing 3 packed float values.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstant(System.String,Axiom.Math.Matrix4[],System.Int32)">
            <summary>
               Sends multiple matrices into a program.
            </summary>
            <param name="name">Name of the param.</param>
            <param name="matrices">Array of matrices.</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.SetNamedConstantFromTime(System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="factor"></param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.UpdateAutoParamsNoLights(Axiom.Graphics.AutoParamDataSource)">
            <summary>
               Updates the automatic parameters (except lights) based on the details provided.
            </summary>
            <param name="source">
               A source containing all the updated data to be made available for auto updating
               the GPU program constants.
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.UpdateAutoParamsLightsOnly(Axiom.Graphics.AutoParamDataSource)">
            <summary>
               Updates the automatic light parameters based on the details provided.
            </summary>
            <param name="source">
               A source containing all the updated data to be made available for auto updating
               the GPU program constants.
            </param>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.AutoAddParamName">
            <summary>
            	Gets/Sets the auto add parameter name flag.
            </summary>
            <remarks>
            	Not all GPU programs make named parameters available after the high level
            	source is compiled.  GLSL is one such case.  If parameter names are not loaded
            	prior to the material serializer reading in parameter names in a script then
            	an exception is generated.  Set this to true to have names not found
            	in the map added to the map.
            	The index of the parameter name will be set to the end of the Float Constant List.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.HasAutoConstants">
            <summary>
               Returns true if this instance contains any automatic constants.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.HasIntConstants">
            <summary>
               Returns true if int constants have been set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.HasFloatConstants">
            <summary>
               Returns true if floating-point constants have been set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.IntConstants">
            <summary>
               Gets a packed array of all current integer contants.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.IntConstantCount">
            <summary>
               Gets the number of int contants values currently set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.FloatConstantCount">
            <summary>
               Gets the number of floating-point contant values currently set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.NamedParamCount">
            <summary>
            	Gets the number of named parameters in this param set.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramParameters.TransposeMatrices">
            <summary>
                Specifies whether matrices need to be transposed prior to
                being sent to the hardware.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry">
            <summary>
               A structure for recording the use of automatic parameters.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.type">
            <summary>
               The type of the parameter.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.index">
            <summary>
               The target index.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.data">
            <summary>
               Any additional info to go with the parameter.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramParameters.AutoConstantEntry.#ctor(Axiom.Graphics.AutoConstants,System.Int32,System.Int32)">
            <summary>
               Default constructor.
            </summary>
            <param name="type">Type of auto param (i.e. WorldViewMatrix, etc)</param>
            <param name="index">Index of the param.</param>
            <param name="data">Any additional info to go with the parameter.</param>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.FloatConstantEntry">
            <summary>
            	Float parameter entry; contains both a group of 4 values and 
            	an indicator to say if it's been set or not. This allows us to 
            	filter out constant entries which have not been set by the renderer
            	and may actually be being used internally by the program.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameters.IntConstantEntry">
            <summary>
            	Int parameter entry; contains both a group of 4 values and 
            	an indicator to say if it's been set or not. This allows us to 
            	filter out constant entries which have not been set by the renderer
            	and may actually be being used internally by the program.
            </summary>
        </member>
        <member name="T:Axiom.Core.Root">
            <summary>
            	The Engine class is the main container of all the subsystems.  This includes the RenderSystem, various ResourceManagers, etc.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.instance">
            <summary>
                Singleton instance of Root.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.#ctor(System.String,System.String)">
            <summary>
                Constructor.
            </summary>
            <remarks>
                This public contructor is intended for the user to decide when the Root object gets instantiated.
                This is a critical step in preparing the engine for use.
            </remarks>
            <param name="configFileName">Name of the config file to load.</param>
            <param name="logFileName">Name of the default log file.</param>
        </member>
        <member name="F:Axiom.Core.Root.sceneManager">
            <summary>
                Current active scene manager.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.sceneManagerList">
            <summary>
                List of available scene managers.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.renderSystemList">
            <summary>
                List of available render systems.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.activeRenderSystem">
            <summary>
                Current active render system.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.timer">
            <summary>
                Current active timer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.autoWindow">
            <summary>
                Auto created window (if one was created).
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.configFileName">
            <summary>
                Name of the file containing configuration info.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lastStartTime">
            <summary>
                Start time of last frame.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lastEndTime">
            <summary>
                End time of last frame.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lastCalculationTime">
            <summary>
                The last time we calculated the framerate.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.frameCount">
            <summary>
                Frames drawn counter for FPS calculations.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.currentFPS">
            <summary>
                Current frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.highestFPS">
            <summary>
                Highest recorded frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.lowestFPS">
            <summary>
                Lowest recorded frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.averageFPS">
            <summary>
                Average frames per second.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.currentFrameCount">
            <summary>
            	Global frame count since startup.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.firstTimePostWindowInit">
            <summary>
               In case multiple render windows are created, only once are the resources loaded.
            </summary>
        </member>
        <member name="F:Axiom.Core.Root.queuedEnd">
            <summary>
            	True if a request has been made to shutdown the rendering engine.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.Initialize(System.Boolean)">
            <summary>
               Initializes the renderer.
            </summary>
            <remarks>
                This method can only be called after a renderer has been
                selected with <see cref="P:Axiom.Core.Root.RenderSystem"/>, and it will initialize
                the selected rendering system ready for use.
            </remarks>
            <param name="autoCreateWindow">
                If true, a rendering window will automatically be created (saving a call to
                <see cref="!:RenderSystem.CreateRenderWindow"/>). The window will be
                created based on the options currently set on the render system.
            </param>
            <returns>A reference to the automatically created window (if requested), or null otherwise.</returns>
        </member>
        <member name="M:Axiom.Core.Root.Initialize(System.Boolean,System.String)">
            <summary>
               Initializes the renderer.
            </summary>
            <remarks>
                This method can only be called after a renderer has been
                selected with <see cref="P:Axiom.Core.Root.RenderSystem"/>, and it will initialize
                the selected rendering system ready for use.
            </remarks>
            <param name="autoCreateWindow">
                If true, a rendering window will automatically be created (saving a call to
                <see cref="!:RenderSystem.CreateRenderWindow"/>). The window will be
                created based on the options currently set on the render system.
            </param>
            <param name="windowTitle">Title to use by the window.</param>
            <returns>A reference to the automatically created window (if requested), or null otherwise.</returns>
        </member>
        <member name="M:Axiom.Core.Root.OneTimePostWindowInit">
            <summary>
               Internal method for one-time tasks after first window creation.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="name"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="isFullscreen"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.CreateRenderWindow(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)">
            <summary>
            	
            </summary>
            <param name="name"></param>
            <param name="target"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="isFullscreen"></param>
            <param name="miscParams">
            	A collection of addition render system specific options.
            </param>
        </member>
        <member name="M:Axiom.Core.Root.ConvertColor(Axiom.Core.ColorEx)">
            <summary>
            	Asks the current API to convert an instance of ColorEx to a 4 byte packed
            	int value the way it would expect it. 		
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Root.DetachRenderTarget(Axiom.Graphics.RenderTarget)">
            <summary>
                
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Core.Root.RenderOneFrame">
            <summary>
            	Renders one frame.
            </summary>
            <remarks>
            	Updates all the render targets automatically and then returns, raising frame events before and after.
            </remarks>
            <returns>True if execution should continue, false if a quit was requested.</returns>
        </member>
        <member name="M:Axiom.Core.Root.StartRendering">
            <summary>
            	Starts the default rendering loop.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.Shutdown">
            <summary>
            	Shuts down the engine and unloads plugins.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.QueueEndRendering">
            <summary>
            	Requests that the rendering engine shutdown at the beginning of the next frame.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.UpdateAllRenderTargets">
            <summary>
                Internal method used for updating all <see cref="T:Axiom.Graphics.RenderTarget"/> objects (windows, 
                renderable textures etc) which are set to auto-update.
            </summary>
            <remarks>
                You don't need to use this method if you're using Axiom's own internal
                rendering loop (<see cref="M:Axiom.Core.Root.StartRendering"/>). If you're running your own loop
                you may wish to call it to update all the render targets which are
                set to auto update (<see cref="!:RenderTarget.AutoUpdated"/>). You can also update
                individual <see cref="T:Axiom.Graphics.RenderTarget"/> instances using their own Update() method.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.Dispose">
            <summary>
            	Called to shutdown the engine and dispose of all it's resources.
            </summary>
        </member>
        <member name="M:Axiom.Core.Root.CalculateEventTime(System.Int64,Axiom.Core.FrameEventType)">
            <summary>
               Internal method for calculating the average time between recently fired events.
            </summary>
            <param name="time">The current time in milliseconds.</param>
            <param name="type">The type event to calculate.</param>
            <returns>Average time since last event of the same type.</returns>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameStarted">
            <summary>
               Method for raising frame started events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on 
               this.
               <p/>
               This method calculates the frame timing information for you based on the elapsed
               time. If you want to specify elapsed times yourself you should call the other 
               version of this method which takes event details as a parameter.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameEnded">
            <summary>
               Method for raising frame ended events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on 
               this.
               <p/>
               This method calculates the frame timing information for you based on the elapsed
               time. If you want to specify elapsed times yourself you should call the other 
               version of this method which takes event details as a parameter.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameStarted(Axiom.Core.FrameEventArgs)">
            <summary>
               Method for raising frame started events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on 
               this.
               <p/>
               This method takes an event object as a parameter, so you can specify the times
               yourself. If you are happy for the engine to automatically calculate the frame time
               for you, then call the other version of this method with no parameters.
            </remarks>
            <param name="e">
               Event object which includes all the timing information which must already be 
               calculated.  RequestShutdown should be checked after each call, because that means
               an event handler is requesting that shudown begin for one reason or another.
            </param>
        </member>
        <member name="M:Axiom.Core.Root.OnFrameEnded(Axiom.Core.FrameEventArgs)">
            <summary>
               Method for raising frame ended events.
            </summary>
            <remarks>
               This method is only for internal use when you use the built-in rendering
               loop (Root.StartRendering). However, if you run your own rendering loop then
               you should call this method to ensure that FrameEvent handlers are notified
               of frame events; processes like texture animation and particle systems rely on 
               this.
               <p/>
               This method takes an event object as a parameter, so you can specify the times
               yourself. If you are happy for the engine to automatically calculate the frame time
               for you, then call the other version of this method with no parameters.
            </remarks>
            <param name="e">
               Event object which includes all the timing information which must already be 
               calculated.  RequestShutdown should be checked after each call, because that means
               an event handler is requesting that shudown begin for one reason or another.
            </param>
        </member>
        <member name="P:Axiom.Core.Root.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
            <value></value>
        </member>
        <member name="E:Axiom.Core.Root.FrameStarted">
            <summary>
            Fired as a frame is about to be rendered.
            </summary>
        </member>
        <member name="E:Axiom.Core.Root.FrameEnded">
            <summary>
            Fired after a frame has completed rendering.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.Copyright">
            <summary>
            Specifies the name of the engine that will be used where needed (i.e. log files, etc).  
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.Version">
            <summary>
            Returns the current version of the Engine assembly.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.SceneManager">
            <summary>
            The current SceneManager in use by the engine.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.SceneManagers">
            <summary>
            	
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.RenderSystem">
            <summary>
            Gets/Sets the current active RenderSystem that the engine is using.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.RenderSystems">
            <summary>
            The list of available render systems for the engine to use (made available via plugins).
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.Timer">
            <summary>
               Gets a reference to the timer being used for timing throughout the engine.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.CurrentFrameCount">
            <summary>
            	Gets the number of frames drawn since startup.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.CurrentFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.BestFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.WorstFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="P:Axiom.Core.Root.AverageFPS">
            <summary>
            	Exposes FPS stats to anyone who cares.
            </summary>
        </member>
        <member name="T:Axiom.Core.FrameEvent">
            <summary>
            	A delegate for defining frame events.
            </summary>
        </member>
        <member name="T:Axiom.Core.FrameEventArgs">
            <summary>
            	Used to supply info to the FrameStarted and FrameEnded events.
            </summary>
        </member>
        <member name="F:Axiom.Core.FrameEventArgs.TimeSinceLastEvent">
            <summary>
               Time elapsed (in milliseconds) since the last frame event.
            </summary>
        </member>
        <member name="F:Axiom.Core.FrameEventArgs.TimeSinceLastFrame">
            <summary>
               Time elapsed (in milliseconds) since the last frame.
            </summary>
        </member>
        <member name="T:Axiom.Core.PluginManager">
            <summary>
            Summary description for PluginManager.
            </summary>
        </member>
        <member name="F:Axiom.Core.PluginManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Core.PluginManager.plugins">
            <summary>
            	List of loaded plugins.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.LoadAll">
            <summary>
            	Loads all plugins specified in the plugins section of the app.config file.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.ScanForPlugins">
            <summary>
            	Scans for plugin files in the current directory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.PluginManager.UnloadAll">
            <summary>
            	Unloads all currently loaded plugins.
            </summary>
        </member>
        <member name="M:Axiom.Core.PluginManager.LoadPlugin(Axiom.Core.ObjectCreator)">
            <summary>
            	Loads a plugin of the given class name from the given assembly, and calls Start() on it.
            	This function does NOT add the plugin to the PluginManager's
            	list of plugins.
            </summary>
            <param name="assemblyName">The assembly filename ("xxx.dll")</param>
            <param name="className">The class ("MyNamespace.PluginClassname") that implemented IPlugin.</param>
            <returns>The loaded plugin.</returns>
        </member>
        <member name="P:Axiom.Core.PluginManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.PluginConfigurationSectionHandler">
            <summary>
            The plugin configuration handler
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Canned.FloatGpuParamControllerValue">
            <summary>
                Predefined controller value for setting a single floating-
                point value in a constant paramter of a vertex or fragment program.
            </summary>
            <remarks>
                Any value is accepted, it is propagated into the 'x'
                component of the constant register identified by the index. If you
                need to use named parameters, retrieve the index from the param
                object before setting this controller up.
                <p/>
                Note: Retrieving a value from the program parameters is not currently 
                supported, therefore do not use this controller value as a source,
                only as a target.
            </remarks>
        </member>
        <member name="F:Axiom.Controllers.Canned.FloatGpuParamControllerValue.parms">
            <summary>
                Gpu parameters to access.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.FloatGpuParamControllerValue.index">
            <summary>
                The constant register index of the parameter to set.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Canned.FloatGpuParamControllerValue.vec4">
            <summary>
                Member level Vector to use for returning.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Canned.FloatGpuParamControllerValue.#ctor(Axiom.Graphics.GpuProgramParameters,System.Int32)">
            <summary>
                Constructor.
            </summary>
            <param name="parms">Params to set.</param>
            <param name="index">Index of the parameter to set.</param>
        </member>
        <member name="P:Axiom.Controllers.Canned.FloatGpuParamControllerValue.Value">
            <summary>
                Sets the value of the gpu param.  Get is not currently supported.
            </summary>
        </member>
        <member name="T:Axiom.Configuration.ConfigOption">
            <summary>
            Packages the details of a configuration option.
            </summary>
            <remarks>Used for RenderSystem::getConfigOptions. If immutable is true, this option must be disabled for modifying.</remarks>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption.Name">
            <summary>
            The name for the Configuration Option
            </summary>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption.Value">
            <summary>
            The value of the Configuration Option
            </summary>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption.PossibleValues">
            <summary>
            A list of the possible values for this Configuration Option
            </summary>
        </member>
        <member name="P:Axiom.Configuration.ConfigOption.Immutable">
            <summary>
            Indicates if this option can be modified.
            </summary>
        </member>
        <member name="T:Axiom.Collections.MovableObjectCollection">
            <summary>
            Summary description for MovableObjectCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.MovableObjectCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.MovableObjectCollection.Add(Axiom.Core.MovableObject)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.MovableObjectCollection.Add(System.String,Axiom.Core.MovableObject)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.MovableObjectCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.MovableObjectCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.BillboardSetCollection">
            <summary>
            Summary description for BillboardSetCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.BillboardSetCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.BillboardSetCollection.Add(Axiom.Core.BillboardSet)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.BillboardSetCollection.Add(System.String,Axiom.Core.BillboardSet)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="key"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.BillboardSetCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.BillboardSetCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Skeleton">
            <summary>
            	A collection of Bone objects used to animate a skinned mesh.
             </summary>
             <remarks>
            	Skeletal animation works by having a collection of 'bones' which are 
            	actually just joints with a position and orientation, arranged in a tree structure.
            	For example, the wrist joint is a child of the elbow joint, which in turn is a
            	child of the shoulder joint. Rotating the shoulder automatically moves the elbow
            	and wrist as well due to this hierarchy.
            	<p/>
            	So how does this animate a mesh? Well every vertex in a mesh is assigned to one or more
            	bones which affects it's position when the bone is moved. If a vertex is assigned to 
            	more than one bone, then weights must be assigned to determine how much each bone affects
            	the vertex (actually a weight of 1.0 is used for single bone assignments). 
            	Weighted vertex assignments are especially useful around the joints themselves
            	to avoid 'pinching' of the mesh in this region. 
            	<p/>
            	Therefore by moving the skeleton using preset animations, we can animate the mesh. The
            	advantage of using skeletal animation is that you store less animation data, especially
            	as vertex counts increase. In addition, you are able to blend multiple animations together
            	(e.g. walking and looking around, running and shooting) and provide smooth transitions
            	between animations without incurring as much of an overhead as would be involved if you
            	did this on the core vertex data.
            	<p/>
            	Skeleton definitions are loaded from datafiles, namely the .xsf file format. They
            	are loaded on demand, especially when referenced by a Mesh.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Skeleton.MAX_BONE_COUNT">
            <summary>Maximum total available bone matrices that are available during blending.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.blendMode">
            <summary>Mode of animation blending to use.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.boneList">
            <summary>Internal list of bones attached to this skeleton, indexed by handle.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.namedBoneList">
            <summary>Internal list of bones attached to this skeleton, indexed by name.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.currentEntity">
            <summary>The entity that is currently updating this skeleton.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.rootBones">
            <summary>Reference to the root bone of this skeleton.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.nextAutoHandle">
            <summary>Used for auto generated handles to ensure they are unique.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.animationList">
            <summary>Lookup table for animations related to this skeleton.</summary>
        </member>
        <member name="F:Axiom.Animating.Skeleton.lastAnimationState">
            <summary>Saved version of the last animation.</summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.#ctor(System.String)">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateAnimation(System.String,System.Single)">
            <summary>
               Creates a new Animation object for animating this skeleton.
            </summary>
            <param name="name">The name of this animation</param>
            <param name="length">The length of the animation in seconds</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone">
            <summary>
               Creates a brand new Bone owned by this Skeleton. 
            </summary>
            <remarks>
               This method creates an unattached new Bone for this skeleton. Unless this is to
               be the root bone (there must only be one of these), you must
               attach it to another Bone in the skeleton using addChild for it to be any use. 
               For this reason you will likely be better off creating child bones using the
               Bone.CreateChild method instead, once you have created the root bone. 
               <p/>
               Note that this method automatically generates a handle for the bone, which you
               can retrieve using Bone.Handle. If you wish the new Bone to have a specific
               handle, use the alternate form of this method which takes a handle as a parameter,
               although you should note the restrictions.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone(System.String)">
            <summary>
               Creates a brand new Bone owned by this Skeleton. 
            </summary>
            <remarks>
               This method creates an unattached new Bone for this skeleton. Unless this is to
               be the root bone (there must only be one of these), you must
               attach it to another Bone in the skeleton using addChild for it to be any use. 
               For this reason you will likely be better off creating child bones using the
               Bone.CreateChild method instead, once you have created the root bone. 
            </remarks>
            <param name="name">
               The name to give to this new bone - must be unique within this skeleton. 
               Note that the way the engine looks up bones is via a numeric handle, so if you name a
               Bone this way it will be given an automatic sequential handle. The name is just
               for your convenience, although it is recommended that you only use the handle to 
               retrieve the bone in performance-critical code.
            </param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone(System.UInt16)">
            <summary>
               Creates a brand new Bone owned by this Skeleton. 
            </summary>
            <param name="handle">
               The handle to give to this new bone - must be unique within this skeleton. 
               You should also ensure that all bone handles are eventually contiguous (this is to simplify
               their compilation into an indexed array of transformation matrices). For this reason
               it is advised that you use the simpler createBone method which automatically assigns a
               sequential handle starting from 0.
            </param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.CreateBone(System.String,System.UInt16)">
            <summary>
               Creates a brand new Bone owned by this Skeleton. 
            </summary>
            <param name="name">
               The name to give to this new bone - must be unique within this skeleton. 
               Note that the way the engine looks up bones is via a numeric handle, so if you name a
               Bone this way it will be given an automatic sequential handle. The name is just
               for your convenience, although it is recommended that you only use the handle to 
               retrieve the bone in performance-critical code.
            </param>
            <param name="handle">
               The handle to give to this new bone - must be unique within this skeleton. 
               You should also ensure that all bone handles are eventually contiguous (this is to simplify
               their compilation into an indexed array of transformation matrices). For this reason
               it is advised that you use the simpler createBone method which automatically assigns a
               sequential handle starting from 0.
            </param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.DeriveRootBone">
            <summary>
               Internal method which parses the bones to derive the root bone.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetAnimation(System.Int32)">
            <summary>
               Returns the animation with the specified index.
            </summary>
            <param name="index">Index of the animation to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetAnimation(System.String)">
            <summary>
               Returns the animation with the specified name.
            </summary>
            <param name="name">Name of the animation to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetBone(System.UInt16)">
            <summary>
               Gets a bone by its handle.
            </summary>
            <param name="handle">Handle of the bone to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetBone(System.String)">
            <summary>
               Gets a bone by its name.
            </summary>
            <param name="name">Name of the bone to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetRootBone(System.Int32)">
            <summary>
            	Gets the root bone at the specified index.
            </summary>
            <param name="index">Index of the root bone to return.</param>
            <returns>Root bone at the specified index, or null if the index is out of bounds.</returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.GetBoneMatrices(Axiom.Math.Matrix4[])">
            <summary>
               Populates the passed in array with the bone matrices based on the current position.
            </summary>
            <remarks>
               Internal use only. The array passed in must
               be at least as large as the number of bones.
               Assumes animation has already been updated.
            </remarks>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.InitAnimationState(Axiom.Collections.AnimationStateCollection)">
            <summary>
               Initialise an animation set suitable for use with this mesh. 
            </summary>
            <remarks>
               Only recommended for use inside the engine, not by applications.
            </remarks>
            <param name="animSet"></param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.RemoveAnimation(System.String)">
            <summary>
               Removes the animation with the specified name from this skeleton.
            </summary>
            <param name="name">Name of the animation to remove.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Skeleton.Reset">
            <summary>
               Resets the position and orientation of all bones in this skeleton to their original binding position.
            </summary>
            <remarks>
               A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this
               position during animation. This method returns all the bones to their original position and
               orientation.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.Reset(System.Boolean)">
            <summary>
               Resets the position and orientation of all bones in this skeleton to their original binding position.
            </summary>
            <remarks>
               A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this
               position during animation. This method returns all the bones to their original position and
               orientation.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Skeleton.SetAnimationState(Axiom.Collections.AnimationStateCollection)">
            <summary>
               
            </summary>
            <param name="animSet"></param>
        </member>
        <member name="M:Axiom.Animating.Skeleton.SetBindingPose">
            <summary>
               Sets the current position / orientation to be the 'binding pose' ie the layout in which 
               bones were originally bound to a mesh.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.UpdateTransforms">
            <summary>
            	Updates all the derived transforms in the skeleton.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.Load">
            <summary>
               Generic load, called by SkeletonManager.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.Unload">
            <summary>
               Generic unload, called by SkeletonManager.
            </summary>
        </member>
        <member name="M:Axiom.Animating.Skeleton.DumpContents(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="P:Axiom.Animating.Skeleton.AnimationCount">
            <summary>
               Gets the number of animations associated with this skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.BlendMode">
            <summary>
               Gets/Sets the animation blending mode which this skeleton will use.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.BoneCount">
            <summary>
               Gets the number of bones in this skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.CurrentEntity">
            <summary>
               Get/Set the entity that is currently updating this skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Skeleton.RootBone">
            <summary>
               Gets the root bone of the skeleton.
            </summary>
            <remarks>
               The system derives the root bone the first time you ask for it. The root bone is the
               only bone in the skeleton which has no parent. The system locates it by taking the
               first bone in the list and going up the bone tree until there are no more parents,
               and saves this top bone as the root. If you are building the skeleton manually using
               CreateBone then you must ensure there is only one bone which is not a child of 
               another bone, otherwise your skeleton will not work properly. If you use CreateBone
               only once, and then use Bone.CreateChild from then on, then inherently the first
               bone you create will by default be the root.
            </remarks>
        </member>
        <member name="P:Axiom.Animating.Skeleton.RootBoneCount">
            <summary>
            	Gets the number of root bones in this skeleton.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MaterialSerializer">
            <summary>
            Summary description for MaterialSerializer.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.scriptContext">
            <summary>
            	Represents the current parsing context.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.rootAttribParsers">
            <summary>
            	Parsers for the root of the material script
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.materialAttribParsers">
            <summary>
            	Parsers for the material section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.techniqueAttribParsers">
            <summary>
            	Parsers for the technique section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.passAttribParsers">
            <summary>
            	Parsers for the pass section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.textureUnitAttribParsers">
            <summary>
            	Parsers for the texture unit section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.programRefAttribParsers">
            <summary>
            	Parsers for the program reference section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.programAttribParsers">
            <summary>
            	Parsers for the program definition section of a script.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MaterialSerializer.programDefaultParamAttribParsers">
            <summary>
            	Parsers for the program definition section of a script.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Serialization.MaterialSerializer.InvokeParser(System.String,System.Collections.Hashtable)" -->
        <member name="M:Axiom.Serialization.MaterialSerializer.FinishProgramDefinition">
            <summary>
            	Internal method for saving a program definition which has been built up.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.LogParseError(Axiom.Serialization.MaterialScriptContext,System.String,System.Object[])">
            <summary>
            	Helper method for logging parser errors.
            </summary>
            <param name="context">Current parsing context.</param>
            <param name="error">Error message.</param>
            <param name="substitutions">Items to sub in for the error message, if the error contains them.</param>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseScriptLine(System.String)">
            <summary>
            	Internal method for parsing a material.
            </summary>
            <param name="line"></param>
            <returns>True if it expects the next line to be a "{", false otherwise.</returns>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.RegisterParserMethods">
            <summary>
            	Queries this serializer class for methods intended to parse material script attributes.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseProgramCustomParameter(System.String,Axiom.Serialization.MaterialScriptContext)">
            <summary>
            	Parse custom GPU program parameters.
            </summary>
            <remarks>
            	This one is called explicitly, and is not added to any parser list.
            </remarks>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseColorOp(System.String,Axiom.Serialization.MaterialScriptContext)">
            Note: Allows both spellings of color :-).
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseColorOpFallback(System.String,Axiom.Serialization.MaterialScriptContext)">
            Note: Allows both spellings of color :-).
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ParseColorOpEx(System.String,Axiom.Serialization.MaterialScriptContext)">
            Note: Allows both spellings of color :-).
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Serialization.MaterialSerializer.ParseScript(System.IO.Stream,System.String)" -->
        <member name="M:Axiom.Serialization.MaterialSerializer.ProcessManualProgramParam(System.Int32,System.String,System.String[],Axiom.Serialization.MaterialScriptContext)">
            <summary>
            	
            </summary>
            <param name="index"></param>
            <param name="commandName"></param>
            <param name="parameters"></param>
            <param name="context"></param>
        </member>
        <member name="M:Axiom.Serialization.MaterialSerializer.ProcessAutoProgramParam(System.Int32,System.String,System.String[],Axiom.Serialization.MaterialScriptContext)">
            <summary>
            	
            </summary>
            <param name="index"></param>
            <param name="commandName"></param>
            <param name="parameters"></param>
            <param name="context"></param>
        </member>
        <member name="T:Axiom.Serialization.MaterialSerializer.MaterialAttributeParserHandler">
            <summary>
            	The method signature for all material attribute parsing methods.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MaterialScriptSection">
            <summary>
            	Enum to identify material sections.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MaterialScriptContext">
            <summary>
            	Struct for holding the script context while parsing.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MaterialAttributeParserAttribute">
            <summary>
            	Custom attribute to mark methods as handling the parsing for a material script attribute.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.OverlayElementManager">
            <summary>
               This class acts as a repository and regitrar of overlay components.
            </summary>
            <remarks>
               OverlayElementManager's job is to manage the lifecycle of OverlayElement (subclass)
               instances, and also to register plugin suppliers of new components.
            </remarks>
        </member>
        <member name="F:Axiom.Overlays.OverlayElementManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.OverlayElementManager.factories">
            <summary>
                List of OverlayElement factories.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.OverlayElementManager.instances">
            <summary>
                List of created elements.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.OverlayElementManager.templates">
            <summary>
                List of template elements.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.AddElementFactory(Axiom.Overlays.IOverlayElementFactory)">
            <summary>
                Registers a new OverlayElementFactory with this manager.
            </summary>
            <remarks>
               Should be used by plugins or other apps wishing to provide
               a new OverlayElement subclass.
            </remarks>
            <param name="factory"></param>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElement(System.String,System.String)">
            <summary>
               Creates a new OverlayElement of the type requested.
            </summary>
            <param name="typeName">The type of element to create is passed in as a string because this
               allows plugins to register new types of component.</param>
            <param name="instanceName">The type of element to create.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElement(System.String,System.String,System.Boolean)">
            <summary>
               Creates a new OverlayElement of the type requested.
            </summary>
            <param name="typeName">The type of element to create is passed in as a string because this
               allows plugins to register new types of component.</param>
            <param name="instanceName">The type of element to create.</param>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElementFromFactory(System.String,System.String)">
            <summary>
               Creates an element of the specified type, with the specified name
            </summary>
            <remarks>
               A factory must be available to handle the requested type, or an exception will be thrown.
            </remarks>
            <param name="typeName"></param>
            <param name="instanceName"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.CreateElementFromTemplate(System.String,System.String,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="templateName"></param>
            <param name="typeName"></param>
            <param name="instanceName"></param>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.GetElement(System.String)">
            <summary>
               Gets a reference to an existing element.
            </summary>
            <param name="name">Name of the element to retrieve.</param>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.GetElement(System.String,System.Boolean)">
            <summary>
               Gets a reference to an existing element.
            </summary>
            <param name="name">Name of the element to retrieve.</param>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.GetElementTable(System.Boolean)">
            <summary>
               Quick helper method to return the lookup table for the right element type.
            </summary>
            <param name="isTemplate"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Overlays.OverlayElementManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.OverlayElementManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexBufferBinding">
            <summary>
            	Records the state of all the vertex buffer bindings required to provide a vertex declaration
            	with the input data it needs for the vertex elements.
             </summary>
             <remarks>
            	Why do we have this binding list rather than just have VertexElement referring to the
            	vertex buffers direct? Well, in the underlying APIs, binding the vertex buffers to an
            	index (or 'stream') is the way that vertex data is linked, so this structure better
            	reflects the realities of that. In addition, by separating the vertex declaration from
            	the list of vertex buffer bindings, it becomes possible to reuse bindings between declarations
            	and vice versa, giving opportunities to reduce the state changes required to perform rendering.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.VertexBufferBinding.bindingMap">
            <summary>
            	Defines the vertex buffer bindings used as source for vertex declarations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexBufferBinding.highIndex">
            <summary>
            	The highest index in use for this binding.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.SetBinding(System.Int16,Axiom.Graphics.HardwareVertexBuffer)">
            <summary>
            	Set a binding, associating a vertex buffer with a given index.
            </summary>
            <remarks>
            	If the index is already associated with a vertex buffer, 
            	the association will be replaced. This may cause the old buffer
            	to be destroyed if nothing else is referring to it.
            	You should assign bindings from 0 and not leave gaps, although you can
            	bind them in any order.
            </remarks>
            <param name="index">Index at which to bind the buffer.</param>
            <param name="buffer">Vertex buffer to bind.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.UnsetBinding(System.Int16)">
            <summary>
            	Removes an existing binding.
            </summary>
            <param name="index">Index of the buffer binding to remove.</param>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.UnsetAllBindings">
            <summary>
            	Removes all current buffer bindings.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferBinding.GetBuffer(System.Int16)">
            <summary>
            	Gets the buffer bound to the given source index.
            </summary>
            <param name="index">Index of the binding to retreive the buffer for.</param>
            <returns>Buffer at the specified index.</returns>
        </member>
        <member name="P:Axiom.Graphics.VertexBufferBinding.Bindings">
            <summary>
            	Gets an enumerator to iterate through the buffer bindings.
            </summary>
            TODO: Change this to strongly typed later on
        </member>
        <member name="P:Axiom.Graphics.VertexBufferBinding.BindingCount">
            <summary>
            	Gets the number of bindings.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.VertexBufferBinding.NextIndex">
            <summary>
            	Gets the highest index which has already been set, plus 1.
            </summary>
            <remarks>
            	This is to assist in binding the vertex buffers such that there are
            	not gaps in the list.
            </remarks>
        </member>
        <member name="T:Axiom.Core.SceneQueryResult">
            <summary>
            	Holds the results of a single scene query.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryResult.objects">
            <summary>
            	List of scene objects in the query (entities, particle systems etc).
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneQueryResult.worldFragments">
            <summary>
            	List of world fragments.
            </summary>
        </member>
        <member name="T:Axiom.Core.RaySceneQueryResultEntry">
            <summary>
            	This struct allows a single comparison of result data no matter what the type.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQueryResultEntry.Distance">
            <summary>
            	Distance along the ray.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQueryResultEntry.SceneObject">
            <summary>
            	The object, or null if this is not a scene object result.
            </summary>
        </member>
        <member name="F:Axiom.Core.RaySceneQueryResultEntry.worldFragment">
            <summary>
            	The world fragment, or null if this is not a fragment result.
            </summary>
        </member>
        <member name="M:Axiom.Core.RaySceneQueryResultEntry.CompareTo(System.Object)">
            <summary>
            	Implemented to allow sorting of results based on distance.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.IntersectionSceneQueryResult">
            <summary>Holds the results of an intersection scene query (pair values).</summary>
        </member>
        <member name="T:Axiom.Core.NodeUpdateHandler">
            <summary>
            Signature for the Node.UpdatedFromParent event which provides the newly-updated derived properties for syncronization in a physics engine for instance
            </summary>
        </member>
        <member name="T:Axiom.Core.BillboardOrigin">
            <summary>
            	Covers what a billboards position means.
            </summary>
        </member>
        <member name="T:Axiom.Core.BillboardType">
            <summary>
            	Type of billboard to use for a BillboardSet.
            </summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.Point">
            <summary>Standard point billboard (default), always faces the camera completely and is always upright</summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.OrientedCommon">
            <summary>Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera</summary>
        </member>
        <member name="F:Axiom.Core.BillboardType.OrientedSelf">
            <summary>Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera</summary>
        </member>
        <member name="T:Axiom.Core.BoxPlane">
            <summary>
            	Specifying the side of a box, used for things like skyboxes, etc.
            </summary>
        </member>
        <member name="T:Axiom.Core.FrustumPlane">
            <summary>
            Defines the 6 planes the make up a frustum.  
            </summary>
        </member>
        <member name="F:Axiom.Core.FrustumPlane.None">
            <summary>Used for methods that require returning a value of this type but cannot return null.</summary>
        </member>
        <member name="T:Axiom.Core.LoggingLevel">
            <summary>
                The level of detail in which the log will go into.
            </summary>
        </member>
        <member name="T:Axiom.Core.LogMessageLevel">
            <summary>
                The importance of a logged message.
            </summary>
        </member>
        <member name="T:Axiom.Core.PrefabEntity">
            <summary>
            	Canned entities that can be created on demand.
            </summary>
        </member>
        <member name="F:Axiom.Core.PrefabEntity.Plane">
            <summary>A flat plane.</summary>
        </member>
        <member name="F:Axiom.Core.PrefabEntity.Teapot">
            <summary>The obligatory teapot.</summary>
        </member>
        <member name="F:Axiom.Core.PrefabEntity.Box">
            <summary>Typical box.</summary>
        </member>
        <member name="F:Axiom.Core.PrefabEntity.Pyramid">
            <summary>Full cairo action.</summary>
        </member>
        <member name="T:Axiom.Core.RenderQueueGroupID">
            <summary>
            	Priorities that can be assigned to renderable objects for sorting.
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Background">
            <summary>
            	Objects that must be rendered first (like backgrounds).
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.SkiesEarly">
            <summary>
            	First queue (after backgrounds), used for skyboxes if rendered first.
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.One">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Two">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Three">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Four">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Main">
            <summary>Default queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Six">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Seven">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Eight">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Nine">
            <summary>All purpose queue.</summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.SkiesLate">
            <summary>
            	Last queue before overlays, used for skyboxes if rendered last.
            </summary>
        </member>
        <member name="F:Axiom.Core.RenderQueueGroupID.Overlay">
            <summary>
            	Use this queue for objects which must be rendered last e.g. overlays.
            </summary>
        </member>
        <member name="T:Axiom.Core.SceneType">
            <summary>
               The different types of scenes types that can be handled by the engine.  The various types can
               be altered by plugin functionality (i.e. BSP for interior, Octree for Exterior, etc).
            </summary>
        </member>
        <member name="T:Axiom.Core.TransformSpace">
            <summary>
                Denotes the spaces which a transform can be relative to.
            </summary>
        </member>
        <member name="F:Axiom.Core.TransformSpace.Local">
            <summary>
                Transform is relative to the local space.
            </summary>
        </member>
        <member name="F:Axiom.Core.TransformSpace.Parent">
            <summary>
                Transform is relative to the space of the parent node.
            </summary>
        </member>
        <member name="F:Axiom.Core.TransformSpace.World">
            <summary>
                Transform is relative to world space.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.WorldFragmentType" -->
        <member name="F:Axiom.Core.WorldFragmentType.None">
            <summary>
               Return no world geometry hits at all.
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.PlaneBoundedRegion">
            <summary>
               Return references to convex plane-bounded regions.
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.SingleIntersection">
            <summary>
               Return a single intersection point (typically RaySceneQuery only)
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.CustomGeometry">
            <summary>
               Custom geometry as defined by the SceneManger.
            </summary>
        </member>
        <member name="F:Axiom.Core.WorldFragmentType.RenderOperation">
            <summary>
               General RenderOperation structure.
            </summary>
        </member>
        <member name="T:Axiom.Controllers.ControllerManager">
            <summary>
            Summary description for ControllerManager.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.controllers">
            <summary>
            	List of references to controllers in a scene.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.ControllerManager.frameTimeController">
            <summary>
            	Local instance of a FrameTimeControllerValue to be used for time based controllers.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateController(Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerFunction)">
            <summary>
            	Overloaded method.  Creates a new controller, using a reference to a FrameTimeControllerValue as
            	the source.
            </summary>
            <param name="destination">Controller value to use as the destination.</param>
            <param name="function">Controller funcion that will use the source value to set the destination.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateController(Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerFunction)">
            <summary>
            	Factory method for creating an instance of a controller based on the input provided.
            </summary>
            <param name="source">Controller value to use as the source.</param>
            <param name="destination">Controller value to use as the destination.</param>
            <param name="function">Controller funcion that will use the source value to set the destination.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureAnimator(Axiom.Graphics.TextureUnitState,System.Single)">
            <summary>
                Creates a texture layer animator controller.
            </summary>
            <remarks>
                This helper method creates the Controller, IControllerValue and IControllerFunction classes required
                to animate a texture.
            </remarks>
            <param name="texUnit">The texture unit to animate.</param>
            <param name="sequenceTime">Length of the animation (in seconds).</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureRotator(Axiom.Graphics.TextureUnitState,System.Single)">
            <summary>
                Creates a basic time-based texture coordinate modifier designed for creating rotating textures.
            </summary>
            <remarks>
                This simple method allows you to easily create constant-speed rotating textures. If you want more
                control, look up the ControllerManager.CreateTextureWaveTransformer for more complex wave-based
                scrollers / stretchers / rotaters.
            </remarks>
            <param name="layer">The texture unit to animate.</param>
            <param name="speed">Speed of the rotation, in counter-clockwise revolutions per second.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateGpuProgramTimerParam(Axiom.Graphics.GpuProgramParameters,System.Int32,System.Single)">
            <summary>
                Predefined controller value for setting a single floating-
                point value in a constant paramter of a vertex or fragment program.
            </summary>
            <remarks>
                Any value is accepted, it is propagated into the 'x'
                component of the constant register identified by the index. If you
                need to use named parameters, retrieve the index from the param
                object before setting this controller up.
            </remarks>
            <param name="parms"></param>
            <param name="index"></param>
            <param name="timeFactor"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureScroller(Axiom.Graphics.TextureUnitState,System.Single,System.Single)">
            <summary>
                Creates a basic time-based texture coordinate modifier designed for creating rotating textures.
            </summary>
            <remarks>
                This simple method allows you to easily create constant-speed scrolling textures. If you want more
                control, look up the ControllerManager.CreateTextureWaveTransformer for more complex wave-based
                scrollers / stretchers / rotaters.
            </remarks>
            <param name="layer">The texture unit to animate.</param>
            <param name="speedU">Horizontal speed, in wraps per second.</param>
            <param name="speedV">Vertical speed, in wraps per second.</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.CreateTextureWaveTransformer(Axiom.Graphics.TextureUnitState,Axiom.Graphics.TextureTransform,Axiom.Controllers.WaveformType,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Creates a very flexible time-based texture transformation which can alter the scale, position or
                rotation of a texture based on a wave function.	
            </summary>
            <param name="layer">The texture unit to effect.</param>
            <param name="transformType">The type of transform, either translate (scroll), scale (stretch) or rotate (spin).</param>
            <param name="waveType">The shape of the wave, see WaveformType enum for details.</param>
            <param name="baseVal">The base value of the output.</param>
            <param name="frequency">The speed of the wave in cycles per second.</param>
            <param name="phase">The offset of the start of the wave, e.g. 0.5 to start half-way through the wave.</param>
            <param name="amplitude">Scales the output so that instead of lying within 0..1 it lies within 0..(1 * amplitude) for exaggerated effects</param>
            <returns>A newly created controller object that will be updated during the main render loop.</returns>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.UpdateAll">
            <summary>
            	Causes all registered controllers to execute.  This will depend on RenderSystem.BeginScene already
            	being called so that the time since last frame can be obtained for calculations.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.ControllerManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.ControllerManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Collections.RenderWindowCollection">
            <summary>
            Summary description for RenderWindowCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderWindowCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderWindowCollection.Add(Axiom.Graphics.RenderWindow)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.RenderWindowCollection.Add(System.String,Axiom.Graphics.RenderWindow)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.RenderWindowCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.RenderWindowCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.RenderTargetCollection">
            <summary>
            Summary description for RenderTargetCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderTargetCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.RenderTargetCollection.Add(Axiom.Graphics.RenderTarget)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.RenderTargetCollection.Add(System.String,Axiom.Graphics.RenderTarget)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.RenderTargetCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.RenderTargetCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.KeyFrameCollection">
            <summary>
            Summary description for KeyFrameCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.KeyFrameCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.KeyFrameCollection.Add(Axiom.Animating.KeyFrame)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.KeyFrameCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="T:Axiom.Animating.SkeletonInstance">
            <summary>
            	A SkeletonInstance is a single instance of a Skeleton used by a world object.
            </summary>
            <remarks>
            	The difference between a Skeleton and a SkeletonInstance is that the
            	Skeleton is the 'master' version much like Mesh is a 'master' version of
            	Entity. Many SkeletonInstance objects can be based on a single Skeleton, 
            	and are copies of it when created. Any changes made to this are not
            	reflected in the master copy. The exception is animations; these are
            	shared on the Skeleton itself and may not be modified here.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.SkeletonInstance.skeleton">
            <summary>
            	Reference to the master Skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Animating.SkeletonInstance.nextTagPointAutoHandle">
            <summary>
            	Used for auto generated tag point handles to ensure they are unique.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.#ctor(Axiom.Animating.Skeleton)">
            <summary>
            	Constructor, don't call directly, this will be created automatically
            	when you create an <see cref="!:Entity"/> based on a skeletally animated Mesh.
            </summary>
            <param name="masterCopy"></param>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.CloneBoneAndChildren(Axiom.Animating.Bone,Axiom.Animating.Bone)">
            <summary>
            	Clones bones, for use in cloning the master skeleton to make this a unique 
            	skeleton instance.
            </summary>
            <param name="source"></param>
            <param name="parent"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Animating.SkeletonInstance.CreateAnimation(System.String,System.Single)" -->
        <member name="M:Axiom.Animating.SkeletonInstance.GetAnimation(System.String)">
            <summary>
            	Returns the <see cref="T:Axiom.Animating.Animation"/> object with the specified name.
            </summary>
            <param name="name">Name of the animation to retrieve.</param>
            <returns>Animation with the specified name, or null if none exists.</returns>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.GetAnimation(System.Int32)">
            <summary>
            	Returns the <see cref="T:Axiom.Animating.Animation"/> object at the specified index.
            </summary>
            <param name="index">Index of the animation to retrieve.</param>
            <returns>Animation at the specified index, or null if none exists.</returns>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.RemoveAnimation(System.String)">
            <summary>
            	Removes an <see cref="T:Axiom.Animating.Animation"/> from this skeleton.
            </summary>
            <param name="name">Name of the animation to remove.</param>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.Load">
            <summary>
            	Overriden to copy/clone the bones of the master skeleton.
            </summary>
        </member>
        <member name="M:Axiom.Animating.SkeletonInstance.Unload">
            <summary>
            	Overriden to unload the skeleton and clear the tagpoint list.
            </summary>
        </member>
        <member name="P:Axiom.Animating.SkeletonInstance.AnimationCount">
            <summary>
            	Gets the number of animations on this skeleton.
            </summary>
        </member>
        <member name="T:Axiom.Animating.InterpolationMode">
            <summary>
            	Types of interpolation used in animation.
            </summary>
        </member>
        <member name="F:Axiom.Animating.InterpolationMode.Linear">
            <summary>
            	Values are interpolated along straight lines.  
            	More robotic movement, not as realistic.
             </summary>
        </member>
        <member name="F:Axiom.Animating.InterpolationMode.Spline">
            <summary>
            	Values are interpolated along a spline, resulting in smoother changes in direction.  
            	Smooth movement between keyframes.
             </summary>
        </member>
        <member name="T:Axiom.Animating.RotationInterpolationMode">
            <summary>
            The types of rotational interpolation available.
            </summary>
        </member>
        <member name="F:Axiom.Animating.RotationInterpolationMode.Linear">
            <summary>
            Values are interpolated linearly. This is faster but does not 
               necessarily give a completely accurate result.
            </summary>
        </member>
        <member name="F:Axiom.Animating.RotationInterpolationMode.Spherical">
            <summary>
             Values are interpolated spherically. This is more accurate but
               has a higher cost.
            </summary>
        </member>
        <member name="T:Axiom.Animating.Animation">
            <summary>
            	An animation sequence. 
            </summary>
            <remarks>
            	This class defines the interface for a sequence of animation, whether that
            	be animation of a mesh, a path along a spline, or possibly more than one
            	type of animation in one. An animation is made up of many 'tracks', which are
            	the more specific types of animation.
            	<p/>
            	You should not create these animations directly. They will be created via a parent
            	object which owns the animation, e.g. Skeleton, SceneManager, etc.
            </remarks>
        </member>
        <member name="F:Axiom.Animating.Animation.name">
            <summary>Name of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.length">
            <summary>The total length of this animation (sum of the tracks).</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.trackList">
            <summary>Collection of AnimationTracks.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.interpolationMode">
            <summary>Interpolation mode of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.rotationInterpolationMode">
            <summary>Rotation Interpolation mode of this animation.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.defaultInterpolationMode">
            <summary>Default interpolation mode of any animations.</summary>
        </member>
        <member name="F:Axiom.Animating.Animation.defaultRotationInterpolationMode">
            <summary>Default rotation interpolation mode of any animations.</summary>
        </member>
        <member name="M:Axiom.Animating.Animation.#cctor">
            <summary>Static constructor.</summary>
        </member>
        <member name="M:Axiom.Animating.Animation.#ctor(System.String,System.Single)">
            <summary>
            	Internal constructor, to prevent from using new outside of the engine.
            	<p/>
            	Animations should be created within objects that can own them (skeletons, scene managers, etc).
            </summary>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateTrack(System.Int16)">
            <summary>
            	Creates an AnimationTrack. 
            </summary>
            <param name="handle">Numeric handle to give the track, used for accessing the track later.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.Optimise">
            <summary>
            Optimise an animation by removing unnecessary tracks and keyframes.
            </summary>
            <remarks>
            			When you export an animation, it is possible that certain tracks
            			have been keyfamed but actually don't include anything useful - the
            			keyframes include no transformation. These tracks can be completely
            			eliminated from the animation and thus speed up the animation. 
            			In addition, if several keyframes in a row have the same value, 
            			then they are just adding overhead and can be removed.
            </remarks>
        </member>
        <member name="M:Axiom.Animating.Animation.CreateTrack(System.Int16,Axiom.Core.Node)">
             <summary>
            		Creates a new AnimationTrack automatically associated with a Node. 
             </summary>
            <remarks>
            		This method creates a standard AnimationTrack, but also associates it with a
            		target Node which will receive all keyframe effects.
            	</remarks>
             <param name="index">Numeric handle to give the track, used for accessing the track later.</param>
             <param name="target">Node object which will be affected by this track.</param>
             <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.GetTrack(System.Int16)">
            <summary>
            Gets a track by it's handle
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Animating.Animation.DestroyTrack(System.Int16)">
            <summary>
            Destroys the track with the given handle
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:Axiom.Animating.Animation.DestroyAllTracks(System.Int16)">
            <summary>
            Removes and destroys all tracks making up this animation.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:Axiom.Animating.Animation.Apply(System.Single,System.Single,System.Boolean)">
            <summary>
            	Applies an animation given a specific time point and weight.
            </summary>
            <remarks>
            	Where you have associated animation tracks with Node objects, you can eaily apply
            	an animation to those nodes by calling this method.
            </remarks>
            <param name="time">The time position in the animation to apply.</param>
            <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with
            	other animations.</param>
            <param name="accumulate"></param>
        </member>
        <member name="M:Axiom.Animating.Animation.Apply(System.Single,System.Single,System.Boolean,System.Single,System.Boolean)">
            <summary>
            	Applies an animation given a specific time point and weight.
            </summary>
            <remarks>
            	Where you have associated animation tracks with Node objects, you can eaily apply
            	an animation to those nodes by calling this method.
            </remarks>
            <param name="time">The time position in the animation to apply.</param>
            <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with
            	other animations.</param>
            <param name="accumulate"></param>
        </member>
        <member name="P:Axiom.Animating.Animation.Name">
            <summary>
            	Gets the name of this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.Length">
            <summary>
            	Gets the total length of this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.InterpolationMode">
             <summary>
            		Tells the animation how to interpolate between keyframes.
             </summary>
             <remarks>
            		By default, animations normally interpolate linearly between keyframes. 
            		This is fast, but when animations include quick changes in direction it can look a little
            		unnatural because directions change instantly at keyframes. An alternative is to 
            		tell the animation to interpolate along a spline, which is more expensive in terms
            		of calculation time, but looks smoother because major changes in direction are 
            		distributed around the keyframes rather than just at the keyframe.
            </remarks>
        </member>
        <member name="P:Axiom.Animating.Animation.RotationInterpolationMode">
             <summary>
             Tells the animation how to interpolate rotations
             </summary>
             <remarks>
             By default, animations interpolate lieanrly between rotations. This
             is fast but not necessarily completely accurate. If you want more 
             accurate interpolation, use spherical interpolation, but be aware 
             that it will incur a higher cost.
            </remarks>
        </member>
        <member name="P:Axiom.Animating.Animation.Tracks">
            <summary>
            	A collection of the tracks in this animation.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.DefaultInterpolationMode">
            <summary>
            	Gets/Sets the default interpolation mode to be used for all animations.
            </summary>
        </member>
        <member name="P:Axiom.Animating.Animation.DefaultRotationInterpolationMode">
            <summary>
            	Gets/Sets the default rotation interpolation mode to be used for all animations.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleVisualData">
            <summary>
            Abstract class containing any additional data required to be associated
            with a particle to perform the required rendering. 
            </summary>
            <remarks>
            Because you can specialise the way that particles are renderered by supplying
            custom ParticleSystemRenderer classes, you might well need some additional 
            data for your custom rendering routine which is not held on the default particle
            class. If that's the case, then you should define a subclass of this class, 
            and construct it when asked in your custom ParticleSystemRenderer class.
            </remarks>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleVisualData.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.Panel">
            <summary>
            	GuiElement representing a flat, single-material (or transparent) panel which can contain other elements.
            </summary>
            <remarks>
            	This class subclasses GuiContainer because it can contain other elements. Like other
            	containers, if hidden it's contents are also hidden, if moved it's contents also move etc. 
            	The panel itself is a 2D rectangle which is either completely transparent, or is rendered 
            	with a single material. The texture(s) on the panel can be tiled depending on your requirements.
            	<p/>
            	This component is suitable for backgrounds and grouping other elements. Note that because
            	it has a single repeating material it cannot have a discrete border (unless the texture has one and
            	the texture is tiled only once). For a bordered panel, see it's subclass BorderPanel.
            	<p/>
            	Note that the material can have all the usual effects applied to it like multiple texture
            	layers, scrolling / animated textures etc. For multiple texture layers, you have to set 
            	the tiling level for each layer.
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
               Returns the geometry to use during rendering.
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.SetTiling(System.Single,System.Single,System.Int32)">
            <summary>
               
            </summary>
            <param name="tileX"></param>
            <param name="tileY"></param>
            <param name="layer"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.UpdatePositionGeometry">
            <summary>
               Internal method for setting up geometry, called by GuiElement.Update
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.Panel.UpdateTextureGeometry">
            <summary>
               Called to update the texture coords when layers change.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.Panel.IsTransparent">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.Panel.MaterialName">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.QuaternionCollection">
            <summary>
            	A strongly-typed collection of <see cref="T:Axiom.Math.Quaternion"/> objects.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Synchronized(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Creates a synchronized (thread-safe) wrapper for a 
                <c>QuaternionCollection</c> instance.
            </summary>
            <returns>
                An <c>QuaternionCollection</c> wrapper that is synchronized (thread-safe).
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.ReadOnly(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Creates a read-only wrapper for a 
                <c>QuaternionCollection</c> instance.
            </summary>
            <returns>
                An <c>QuaternionCollection</c> wrapper that is read-only.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor(System.Int32)">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that has the specified initial capacity.
            </summary>
            <param name="capacity">
            	The number of elements that the new <c>QuaternionCollection</c> is initially capable of storing.
            </param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that contains elements copied from the specified <c>QuaternionCollection</c>.
            </summary>
            <param name="c">The <c>QuaternionCollection</c> whose elements are copied to the new collection.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.#ctor(Axiom.Math.Quaternion[])">
            <summary>
            	Initializes a new instance of the <c>QuaternionCollection</c> class
            	that contains elements copied from the specified <see cref="T:Axiom.Math.Quaternion"/> array.
            </summary>
            <param name="a">The <see cref="T:Axiom.Math.Quaternion"/> array whose elements are copied to the new list.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.CopyTo(Axiom.Math.Quaternion[])">
            <summary>
            	Copies the entire <c>QuaternionCollection</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Quaternion"/> array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Quaternion"/> array to copy to.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.CopyTo(Axiom.Math.Quaternion[],System.Int32)">
            <summary>
            	Copies the entire <c>QuaternionCollection</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Quaternion"/> array, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Quaternion"/> array to copy to.</param>
            <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Add(Axiom.Math.Quaternion)">
            <summary>
            	Adds a <see cref="T:Axiom.Math.Quaternion"/> to the end of the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to be added to the end of the <c>QuaternionCollection</c>.</param>
            <returns>The index at which the value has been added.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Clear">
            <summary>
            	Removes all elements from the <c>QuaternionCollection</c>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Clone">
            <summary>
            	Creates a shallow copy of the <see cref="T:Axiom.Math.Collections.QuaternionCollection"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Contains(Axiom.Math.Quaternion)">
            <summary>
            	Determines whether a given <see cref="T:Axiom.Math.Quaternion"/> is in the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to check for.</param>
            <returns><c>true</c> if <paramref name="item"/> is found in the <c>QuaternionCollection</c>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.IndexOf(Axiom.Math.Quaternion)">
            <summary>
            	Returns the zero-based index of the first occurrence of a <see cref="T:Axiom.Math.Quaternion"/>
            	in the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to locate in the <c>QuaternionCollection</c>.</param>
            <returns>
            	The zero-based index of the first occurrence of <paramref name="item"/> 
            	in the entire <c>QuaternionCollection</c>, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Insert(System.Int32,Axiom.Math.Quaternion)">
            <summary>
            	Inserts an element into the <c>QuaternionCollection</c> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to insert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Remove(Axiom.Math.Quaternion)">
            <summary>
            	Removes the first occurrence of a specific <see cref="T:Axiom.Math.Quaternion"/> from the <c>QuaternionCollection</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Quaternion"/> to remove from the <c>QuaternionCollection</c>.</param>
            <exception cref="T:System.ArgumentException">
            	The specified <see cref="T:Axiom.Math.Quaternion"/> was not found in the <c>QuaternionCollection</c>.
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.RemoveAt(System.Int32)">
            <summary>
            	Removes the element at the specified index of the <c>QuaternionCollection</c>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.GetEnumerator">
            <summary>
            	Returns an enumerator that can iterate through the <c>QuaternionCollection</c>.
            </summary>
            <returns>An <see cref="T:Axiom.Math.Collections.QuaternionCollection.Enumerator"/> for the entire <c>QuaternionCollection</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.AddRange(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Adds the elements of another <c>QuaternionCollection</c> to the current <c>QuaternionCollection</c>.
            </summary>
            <param name="x">The <c>QuaternionCollection</c> whose elements should be added to the end of the current <c>QuaternionCollection</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/> of the <c>QuaternionCollection</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.AddRange(Axiom.Math.Quaternion[])">
            <summary>
            	Adds the elements of a <see cref="T:Axiom.Math.Quaternion"/> array to the current <c>QuaternionCollection</c>.
            </summary>
            <param name="x">The <see cref="T:Axiom.Math.Quaternion"/> array whose elements should be added to the end of the <c>QuaternionCollection</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/> of the <c>QuaternionCollection</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.TrimToSize">
            <summary>
            	Sets the capacity to the actual number of elements.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.ValidateIndex(System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.ValidateIndex(System.Int32,System.Boolean)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Count">
            <summary>
            	Gets the number of elements actually contained in the <c>QuaternionCollection</c>.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IsSynchronized">
            <summary>
            	Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
            <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.SyncRoot">
            <summary>
            	Gets an object that can be used to synchronize access to the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Item(System.Int32)">
            <summary>
            	Gets or sets the <see cref="T:Axiom.Math.Quaternion"/> at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.QuaternionCollection.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IsFixedSize">
            <summary>
            	Gets a value indicating whether the collection has a fixed size.
            </summary>
            <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IsReadOnly">
            <summary>
            	gets a value indicating whether the <B>IList</B> is read-only.
            </summary>
            <value>true if the collection is read-only; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Capacity">
            <summary>
            	Gets or sets the number of elements the <c>QuaternionCollection</c> can contain.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator">
            <summary>
            	Supports type-safe iteration over a <see cref="T:Axiom.Math.Collections.QuaternionCollection"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.IQuaternionCollectionEnumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.QuaternionCollection.Enumerator">
            <summary>
            	Supports simple iteration over a <see cref="T:Axiom.Math.Collections.QuaternionCollection"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Enumerator.#ctor(Axiom.Math.Collections.QuaternionCollection)">
            <summary>
            	Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
            <param name="tc"></param>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.QuaternionCollection.Enumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.QuaternionCollection.Enumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Math.RotationalSpline">
            <summary>
            	A class used to interpolate orientations (rotations) along a spline using 
            	derivatives of quaternions.
            </summary>
            <remarks>
            	Like the PositionalSpline class, this class is about interpolating values 
            	smoothly over a spline. Whilst PositionalSpline deals with positions (the normal
            	sense we think about splines), this class interpolates orientations. The
            	theory is identical, except we're now in 4-dimensional space instead of 3.
            	<p/>
            	In positional splines, we use the points and tangents on those points to generate
            	control points for the spline. In this case, we use quaternions and derivatives
            	of the quaternions (i.e. the rate and direction of change at each point). This is the
            	same as PositionalSpline since a tangent is a derivative of a position. We effectively 
            	generate an extra quaternion in between each actual quaternion which when take with 
            	the original quaternion forms the 'tangent' of that quaternion.
            </remarks>
        </member>
        <member name="F:Axiom.Math.RotationalSpline.pointList">
            <summary>Collection of control points.</summary>
        </member>
        <member name="F:Axiom.Math.RotationalSpline.tangentList">
            <summary>Collection of generated tangents for the spline controls points.</summary>
        </member>
        <member name="F:Axiom.Math.RotationalSpline.autoCalculateTangents">
            <summary>Specifies whether or not to recalculate tangents as each control point is added.</summary>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.#ctor">
            <summary>
            	Creates a new Rotational Spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.AddPoint(Axiom.Math.Quaternion)">
            <summary>
               Adds a control point to the end of the spline.
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.Clear">
            <summary>
               Removes all current control points from this spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.Interpolate(System.Single,System.Boolean)">
            <summary>
            	Returns an interpolated point based on a parametric value over the whole series.
            </summary>
            <remarks>
            	Given a t value between 0 and 1 representing the parametric distance along the
            	whole length of the spline, this method returns an interpolated point.
            </remarks>
            <param name="t">Parametric value.</param>
            <param name="useShortestPath">True forces rotations to use the shortest path.</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.Interpolate(System.Int32,System.Single,System.Boolean)">
            <summary>
            	Interpolates a single segment of the spline given a parametric value.
            </summary>
            <param name="index">The point index to treat as t=0. index + 1 is deemed to be t=1</param>
            <param name="t">Parametric value</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.RotationalSpline.RecalculateTangents">
            <summary>
            	Recalculates the tangents associated with this spline. 
            </summary>
            <remarks>
            	If you tell the spline not to update on demand by setting AutoCalculate to false,
            	then you must call this after completing your updates to the spline points.
            </remarks>
        </member>
        <member name="P:Axiom.Math.RotationalSpline.AutoCalculate">
            <summary>
            	Specifies whether or not to recalculate tangents as each control point is added.
            </summary>
        </member>
        <member name="P:Axiom.Math.RotationalSpline.PointCount">
            <summary>
               Gets the number of control points in this spline.
            </summary>
        </member>
        <member name="T:Axiom.Math.Intersection">
            <summary>
               Type of intersection detected between 2 object.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.None">
            <summary>
               The objects are not intersecting.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.Contained">
            <summary>
               An object is fully contained within another object.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.Contains">
            <summary>
               An object fully contains another object.
            </summary>
        </member>
        <member name="F:Axiom.Math.Intersection.Partial">
            <summary>
               The objects are partially intersecting each other.
            </summary>
        </member>
        <member name="T:Axiom.Math.PlaneSide">
            <summary>
            The "positive side" of the plane is the half space to which the
            plane normal points. The "negative side" is the other half
            space. The flag "no side" indicates the plane itself.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TempBlendedBufferInfo">
            <summary>
                Records the use of temporary blend buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.srcPositionBuffer">
            <summary>
                Pre-blended position buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.srcNormalBuffer">
            <summary>
                Pre-blended normal buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.destPositionBuffer">
            <summary>
                Post-blended position buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.destNormalBuffer">
            <summary>
                Post-blended normal buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.posNormalShareBuffer">
            <summary>
               Both positions and normals are contained in the same buffer. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.posBindIndex">
            <summary>
                Index at which the positions are bound in the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.normBindIndex">
            <summary>
                Index at which the normals are bound in the buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.bindPositions">
            <summary>
            	
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TempBlendedBufferInfo.bindNormals">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.CheckoutTempCopies(System.Boolean,System.Boolean)">
            <summary>
                Utility method, checks out temporary copies of src into dest.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.BindTempCopies(Axiom.Graphics.VertexData,System.Boolean)">
            <summary>
                Utility method, binds dest copies into a given VertexData.
            </summary>
            <param name="targetData">VertexData object to bind the temp buffers into.</param>
            <param name="suppressHardwareUpload"></param>
        </member>
        <member name="M:Axiom.Graphics.TempBlendedBufferInfo.LicenseExpired(Axiom.Graphics.HardwareBuffer)">
            <summary>
                Implementation of LicenseExpired.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="T:Axiom.Graphics.RenderQueueGroup">
            <summary>
            	A grouping level underneath RenderQueue which groups renderables
            	to be issued at coarsely the same time to the renderer.	
            </summary>
            <remarks>
            	Each instance of this class itself hold RenderPriorityGroup instances, 
            	which are the groupings of renderables by priority for fine control
            	of ordering (not required for most instances).
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.parent">
            <summary>
            	Render queue that this queue group belongs to.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.splitPassesByLightingType">
            <summary>
            	Should passes be split by their lighting stage?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.priorityGroups">
            <summary>
            	List of priority groups.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueueGroup.shadowsEnabled">
            <summary>
            	Are shadows enabled for this group?
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.#ctor(Axiom.Graphics.RenderQueue,System.Boolean,System.Boolean)">
            <summary>
            	Default constructor.
            </summary>
            <param name="parent">Render queue that owns this group.</param>
            <param name="splitPassesByLightingType">Split passes based on lighting stage?</param>
            <param name="splitNoShadowPasses"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.AddRenderable(Axiom.Graphics.IRenderable,System.UInt16)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.Clear">
            <summary>
            	Clears all the priority groups within this group.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueueGroup.GetPriorityGroup(System.Int32)">
            <summary>
               Gets the hashlist entry for the priority group at the specified index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.NumPriorityGroups">
            <summary>
               Gets the number of priority groups within this queue group.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.ShadowsEnabled">
            <summary>
            	Indicate whether a given queue group will be doing any shadow setup.
            </summary>
            <remarks>
            	This method allows you to inform the queue about a queue group, and to 
            	indicate whether this group will require shadow processing of any sort.
            	In order to preserve rendering order, Axiom/Ogre has to treat queue groups
            	as very separate elements of the scene, and this can result in it
            	having to duplicate shadow setup for each group. Therefore, if you
            	know that a group which you are using will never need shadows, you
            	should preregister the group using this method in order to improve
            	the performance.
            </remarks>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.SplitPassesByLightingType">
            <summary>
            	Gets/Sets whether or not the queue will split passes by their lighting type,
            	ie ambient, per-light and decal. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueueGroup.SplitNoShadowPasses">
            <summary>
            	Gets/Sets whether or not the queue will split passes which have shadow receive
            	turned off (in their parent material), which is needed when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderQueue">
            <summary>
            	Class to manage the scene object rendering queue.
            </summary>
            <remarks>
            	Objects are grouped by material to minimize rendering state changes. The map from
            	material to renderable object is wrapped in a class for ease of use.
            	<p/>
            	This class includes the concept of 'queue groups' which allows the application
            	adding the renderable to specifically schedule it so that it is included in 
            	a discrete group. Good for separating renderables into the main scene,
            	backgrounds and overlays, and also could be used in the future for more
            	complex multipass routines like stenciling.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.DEFAULT_PRIORITY">
            <summary>
            	Default priority of items added to the render queue.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.renderGroups">
            <summary>
            	Cached list of render groups, indexed by RenderQueueGroupID.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.defaultGroup">
            <summary>
            	Default render group for this queue.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.splitPassesByLightingType">
            <summary>
            	Should passes be split by their lighting stage?
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.splitNoShadowPasses">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderQueue.defaultRenderablePriority">
            <summary>
            	Default priority of items added to the render queue.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.AddRenderable(Axiom.Graphics.IRenderable,System.UInt16,Axiom.Core.RenderQueueGroupID)">
            <summary>
            	Adds a renderable item to the queue.
            </summary>
            <param name="item">IRenderable object to add to the queue.</param>
            <param name="groupID">Group to add the item to.</param>
            <param name="priority"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.AddRenderable(Axiom.Graphics.IRenderable,System.UInt16)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="item"></param>
            <param name="groupID"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.AddRenderable(Axiom.Graphics.IRenderable)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.Clear">
            <summary>
            	Clears all 
            </summary>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.GetQueueGroup(Axiom.Core.RenderQueueGroupID)">
            <summary>
            	Get a render queue group.
            </summary>
            <remarks>
            	New queue groups are registered as they are requested, 
            	therefore this method will always return a valid group.
            </remarks>
            <param name="queueID">ID of the queue group to retreive.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.RenderQueue.GetQueueGroupByIndex(System.Int32)">
            <summary>
               
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.DefaultRenderGroup">
            <summary>
            	Gets/Sets the default priority for rendering objects in the queue.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.DefaultRenderablePriority">
            <summary>
            	Gets/Sets the default priority for rendering objects in the queue.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.NumRenderQueueGroups">
            <summary>
               Gets the number of render queue groups contained within this queue.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.SplitPassesByLightingType">
            <summary>
            	Gets/Sets whether or not the queue will split passes by their lighting type,
            	ie ambient, per-light and decal. 
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderQueue.SplitNoShadowPasses">
            <summary>
            	Gets/Sets whether or not the queue will split passes which have shadow receive
            	turned off (in their parent material), which is needed when certain shadow
            	techniques are used.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderablePass">
            <summary>
               Internal structure reflecting a single Pass for a Renderable
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.FolderFactory">
            <summary>
                Specialization of IArchiveFactory for file system folders.
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.FolderFactory.CreateArchive(System.String)">
            <summary>
                Creates a new Folder archive.
            </summary>
            <param name="name">Name of the archive to create.</param>
            <returns>A new instance of a folder archive.</returns>
        </member>
        <member name="P:Axiom.FileSystem.FolderFactory.Type">
            <summary>
                Type of archive this factory creates.
            </summary>
            <value></value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.MeshLodUsageList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.IntList" -->
        <!-- Badly formed XML comment ignored for member "T:Axiom.Core.FloatList" -->
        <member name="T:Axiom.Controllers.WaveformType">
            <summary>
            Enumerates the wave types usable with the engine.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Sine">
            <summary>Standard sine wave which smoothly changes from low to high and back again.</summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Triangle">
            <summary>An angular wave with a constant increase / decrease speed with pointed peaks.</summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Square">
            <summary>Half of the time is spent at the min, half at the max with instant transition between. </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.Sawtooth">
            <summary>Gradual steady increase from min to max over the period with an instant return to min at the end. </summary>
        </member>
        <member name="F:Axiom.Controllers.WaveformType.InverseSawtooth">
            <summary>Gradual steady decrease from max to min over the period, with an instant return to max at the end. </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImpl">
            <summary>
            Summary description for MeshSerializerImpl.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializerImpl.mesh">
            <summary>
            	Target mesh for importing/exporting.
            </summary>
        </member>
        <member name="F:Axiom.Serialization.MeshSerializerImpl.isSkeletallyAnimated">
            <summary>
            	Is this mesh animated with a skeleton?
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.ExportMesh(Axiom.Core.Mesh,System.String)">
            <summary>
            	Exports a mesh to the file specified.
            </summary>
            <remarks>
            	This method takes an externally created Mesh object, and exports both it
            	to a .mesh file.
            </remarks>
            <param name="mesh">Reference to the mesh to export.</param>
            <param name="fileName">The destination file name.</param>
        </member>
        <member name="M:Axiom.Serialization.MeshSerializerImpl.ImportMesh(System.IO.Stream,Axiom.Core.Mesh)">
            <summary>
            	Imports mesh data from a .mesh file.
            </summary>
            <param name="stream">A stream containing the .mesh data.</param>
            <param name="mesh">Mesh to populate with the data.</param>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImplv12">
            <summary>
                Mesh serializer for supporint OGRE 1.20 meshes.
            </summary>
        </member>
        <member name="T:Axiom.Serialization.MeshSerializerImplv11">
            <summary>
                Mesh serializer for supporint OGRE 1.10 meshes.
            </summary>
        </member>
        <member name="T:Axiom.ParticleSystems.ParticleSystem">
            <summary>
            	Class defining particle system based special effects.
            </summary>
            <remarks>
            	Particle systems are special effects generators which are based on a number of moving points
            	which are rendered perhaps using billboards (quads which always face the camera) to create
            	the impression of things like like sparkles, smoke, blood spurts, dust etc.
            	<p/>
            	This class simply manages a single collection of particles with a shared local center point
            	and a bounding box. The visual aspect of the particles is handled by the base BillboardSet class
            	which the ParticleSystem manages automatically.
            	<p/>
            	Particle systems are created using the ParticleSystemManager.CreateParticleSystem method, never directly.
            	In addition, like all subclasses of SceneObject, the ParticleSystem will only be considered for
            	rendering once it has been attached to a SceneNode. 
            </remarks>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.emitterList">
            <summary>List of emitters for this system.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.affectorList">
            <summary>List of affectors for this system.</summary>
        </member>
        <member name="F:Axiom.ParticleSystems.ParticleSystem.requested">
            <summary>Cached for less memory usage during emitter processing.</summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.#ctor(System.String,System.String)">
            <summary>
            	Creates a particle system with no emitters or affectors.
            </summary>
            <remarks>
            	You should use the ParticleSystemManager to create systems, rather than doing it directly.
            </remarks>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddEmitter(System.String)">
            <summary>
            	Adds an emitter to this particle system.
             </summary>
             <remarks>	
            	Particles are created in a particle system by emitters - see the ParticleEmitter
            	class for more details.
            </remarks>
            <param name="emitterType">
            	string identifying the emitter type to create. Emitter types are defined
            	by registering new factories with the manager - see ParticleEmitterFactory for more details.
            	Emitter types can be extended by plugin authors.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddAffector(System.String)">
            <summary>
            	Adds an affector to this particle system.
             </summary>
             <remarks>	
            	Particles are modified over time in a particle system by affectors - see the ParticleAffector
            	class for more details.
            </remarks>
            <param name="emitterType">
            	string identifying the affector type to create. Affector types are defined
            	by registering new factories with the manager - see ParticleAffectorFactory for more details.
            	Affector types can be extended by plugin authors.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.GetAffector(System.Int32)">
            <summary>
               Get a particle affector assigned to this particle system by index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.GetEmitter(System.Int32)">
            <summary>
               Get a particle emitter assigned to this particle system by index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.Update(System.Single)">
            <summary>
            	Updates the particles in the system based on time elapsed.
             </summary>
             <remarks>	
            	This is called automatically every frame by the engine.
            </remarks>
            <param name="timeElapsed">The amount of time (in seconds) since the last frame.</param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.FastForward(System.Single)">
            <summary>
            	Overloaded method.
            </summary>
            <param name="time"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.ParticleSystems.ParticleSystem.FastForward(System.Single,System.Single)" -->
        <member name="M:Axiom.ParticleSystems.ParticleSystem.UpdateBounds">
            <summary>
            	Overriden.
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.Expire(System.Single)">
            <summary>
            	Used to expire dead particles.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.TriggerEmitters(System.Single)">
            <summary>
            	Spawn new particles based on free quota and emitter requirements.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.ApplyMotion(System.Single)">
            <summary>
            	Updates existing particles based on their momentum.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.TriggerAffectors(System.Single)">
            <summary>
            	Applies the effects of particle affectors.
            </summary>
            <param name="timeElapsed"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.IncreasePool(System.Int32)">
            <summary>
            	Overriden from BillboardSet to create Particles instead of Billboards.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.AddParticle">
            <summary>
            	Used internally for adding a new active particle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.GenerateBillboardAxes(Axiom.Core.Camera,Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Core.Billboard)">
            <summary>
            	Overriden from BillboardSet.
            </summary>
            <param name="camera"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="billboard"></param>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleSystem.CopyTo(Axiom.ParticleSystems.ParticleSystem)">
            <summary>
            	Cloning will deep copy all particle emitters and effectors, but not particles. The
            	system's name is also not copied.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.ParticleCount">
            <summary>
            	Gets the count of active particles currently in the system.
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.Quota">
            <summary>
            	Returns the maximum number of particles this system is allowed to have active at once.
            </summary>
            <remarks>
            	Particle systems all have a particle quota, i.e. a maximum number of particles they are 
            	allowed to have active at a time. This allows the application to set a keep particle systems
            	under control should they be affected by complex parameters which alter their emission rates
            	etc. If a particle system reaches it's particle quota, none of the emitters will be able to 
            	emit any more particles. As existing particles die, the spare capacity will be allocated
            	equally across all emitters to be as consistent to the origina particle system style as possible.
            </remarks>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.Particles">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleSystem.ResourceGroup">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Media.ImageFlags">
            <summary>
               Various flags that give details on a particular image.
            </summary>
        </member>
        <member name="T:Axiom.Media.PixelFormat">
            <summary>
               The pixel format used for images.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.Unknown">
            <summary>
               Unknown pixel format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.L8">
            <summary>
               8-bit pixel format, all bits luminance.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A8">
            <summary>
               8-bit pixel format, all bits alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A4L4">
            <summary>
               8-bit pixel format, 4 bits alpha, 4 bits luminance.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.L4A4">
            <summary>
               8-bit pixel format, 4 bits luminace, 4 bits alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.R5G6B5">
            <summary>
               16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B5G6R5">
            <summary>
               16-bit pixel format, 5 bits blue, 6 bits green, 5 bits red.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A4R4G4B4">
            <summary>
               16-bit pixel format, 4 bits for alpha, red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B4G4R4A4">
            <summary>
               16-bit pixel format, 4 bits for blue, green, red and alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.R8G8B8">
            <summary>
               24-bit pixel format, 8 bits for red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B8G8R8">
            <summary>
               24-bit pixel format, 8 bits for blue, green and red.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A8R8G8B8">
            <summary>
               32-bit pixel format, 8 bits for alpha, red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B8G8R8A8">
            <summary>
               32-bit pixel format, 8 bits for blue, green, red and alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.A2R10G10B10">
            <summary>
               32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.B10G10R10A2">
            <summary>
               32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT1">
            <summary>
               DDS (DirectDraw Surface) DXT1 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT2">
            <summary>
               DDS (DirectDraw Surface) DXT2 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT3">
            <summary>
               DDS (DirectDraw Surface) DXT3 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT4">
            <summary>
               DDS (DirectDraw Surface) DXT4 format.
            </summary>
        </member>
        <member name="F:Axiom.Media.PixelFormat.DXT5">
            <summary>
               DDS (DirectDraw Surface) DXT5 format.
            </summary>
        </member>
        <member name="T:Axiom.Math.Quaternion">
            <summary>
            	Summary description for Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Math.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Creates a new Quaternion.
            </summary>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used to multiply 2 Quaternions together.
            </summary>
            <remarks>
            	Quaternion multiplication is not communative in most cases.
            	i.e. p*q != q*p
            </remarks>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used to multiply 2 Quaternions together.
            </summary>
            <remarks>
            	Quaternion multiplication is not communative in most cases.
            	i.e. p*q != q*p
            </remarks>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="quat"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="quat"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(System.Single,Axiom.Math.Quaternion)">
            <summary>
            Used when a float value is multiplied by a Quaternion.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(System.Single,Axiom.Math.Quaternion)">
            <summary>
            Used when a float value is multiplied by a Quaternion.
            </summary>
            <param name="scalar"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Multiply(Axiom.Math.Quaternion,System.Single)">
            <summary>
            Used when a Quaternion is multiplied by a float value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Multiply(Axiom.Math.Quaternion,System.Single)">
            <summary>
            Used when a Quaternion is multiplied by a float value.
            </summary>
            <param name="left"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Add(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used when a Quaternion is added to another Quaternion.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_Addition(Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <summary>
            Used when a Quaternion is added to another Quaternion.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.op_UnaryNegation(Axiom.Math.Quaternion)">
            <summary>
                Negates a Quaternion, which simply returns a new Quaternion
                with all components negated.
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Slerp(System.Single,Axiom.Math.Quaternion,Axiom.Math.Quaternion,System.Boolean)">
            <summary>
            
            </summary>
            <param name="time"></param>
            <param name="quatA"></param>
            <param name="quatB"></param>
            <param name="useShortestPath"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Nlerp(System.Single,Axiom.Math.Quaternion,Axiom.Math.Quaternion)">
            <overloads><summary>
            normalised linear interpolation - faster but less accurate (non-constant rotation velocity)
            </summary>
            <param name="fT"></param>
            <param name="rkP"></param>
            <param name="rkQ"></param>
            <returns></returns>
            </overloads>
        </member>
        <member name="M:Axiom.Math.Quaternion.Nlerp(System.Single,Axiom.Math.Quaternion,Axiom.Math.Quaternion,System.Boolean)">
            <param name="shortestPath"></param>
        </member>
        <member name="M:Axiom.Math.Quaternion.FromAngleAxis(System.Single,Axiom.Math.Vector3)">
            <summary>
            Creates a Quaternion from a supplied angle and axis.
            </summary>
            <param name="angle">Value of an angle in radians.</param>
            <param name="axis">Arbitrary axis vector.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Squad(System.Single,Axiom.Math.Quaternion,Axiom.Math.Quaternion,Axiom.Math.Quaternion,Axiom.Math.Quaternion,System.Boolean)">
            <summary>
            	Performs spherical quadratic interpolation.
            </summary>
            <param name="t"></param>
            <param name="p"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Dot(Axiom.Math.Quaternion)">
            <summary>
            Performs a Dot Product operation on 2 Quaternions.
            </summary>
            <param name="quat"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Normalize">
            <summary>
            	Normalizes elements of this quaterion to the range [0,1].
            </summary>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToAngleAxis(System.Single@,Axiom.Math.Vector3@)">
            <summary>
               
            </summary>
            <param name="angle"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToRotationMatrix">
            <summary>
            Gets a 3x3 rotation matrix from this Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Inverse">
            <summary>
            Computes the inverse of a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToAxes(Axiom.Math.Vector3@,Axiom.Math.Vector3@,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Quaternion.FromAxes(Axiom.Math.Vector3,Axiom.Math.Vector3,Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="xAxis"></param>
            <param name="yAxis"></param>
            <param name="zAxis"></param>
        </member>
        <member name="M:Axiom.Math.Quaternion.FromRotationMatrix(Axiom.Math.Matrix3)">
            <summary>
            
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Axiom.Math.Quaternion.Log">
            <summary>
            	Calculates the logarithm of a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.Exp">
            <summary>
            	Calculates the Exponent of a Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Math.Quaternion.ToString">
            <summary>
            	Overrides the Object.ToString() method to provide a text representation of 
            	a Quaternion.
            </summary>
            <returns>A string representation of a Quaternion.</returns>
        </member>
        <member name="P:Axiom.Math.Quaternion.Identity">
            <summary>
               An Identity Quaternion.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.Zero">
            <summary>
               A Quaternion with all elements set to 0.0f;
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.Norm">
            <summary>
            	Squared 'length' of this quaternion.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.XAxis">
            <summary>
               Local X-axis portion of this rotation.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.YAxis">
            <summary>
               Local Y-axis portion of this rotation.
            </summary>
        </member>
        <member name="P:Axiom.Math.Quaternion.ZAxis">
            <summary>
               Local Z-axis portion of this rotation.
            </summary>
        </member>
        <member name="T:Axiom.Core.SubEntity">
            <summary>
            	Utility class which defines the sub-parts of an Entity.
            </summary>
            <remarks>
            	<para>
            	Just as models are split into meshes, an Entity is made up of
            	potentially multiple SubEntities. These are mainly here to provide the
            	link between the Material which the SubEntity uses (which may be the
            	default Material for the SubMesh or may have been changed for this
            	object) and the SubMesh data.
            	</para>
            	<para>
            	SubEntity instances are never created manually. They are created at
            	the same time as their parent Entity by the SceneManager method
            	CreateEntity.
            	</para>
            </remarks>
        </member>
        <member name="F:Axiom.Core.SubEntity.parent">
            <summary>
               Reference to the parent Entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.materialName">
            <summary>
               Name of the material being used.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.material">
            <summary>
               Reference to the material being used by this SubEntity.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.subMesh">
            <summary>
               Reference to the subMesh that represents the geometry for this SubEntity.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.renderDetail">
            <summary>
               Detail to be used for rendering this sub entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.materialLodIndex">
            <summary>
            	Current LOD index to use.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.isVisible">
            <summary>
            	Flag indicating whether this sub entity should be rendered or not.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.blendedVertexData">
            <summary>
            	Blend buffer details for dedicated geometry.
            </summary>
        </member>
        <member name="F:Axiom.Core.SubEntity.tempBlendedBuffer">
            <summary>
            	Quick lookup of buffers.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.#ctor">
            <summary>
            	Internal constructor, only allows creation of SubEntities within the engine core.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.PrepareTempBlendBuffers">
            <summary>
            	Internal method for preparing this sub entity for use in animation.
            </summary>
        </member>
        <member name="M:Axiom.Core.SubEntity.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
            
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Axiom.Core.SubEntity.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
            
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:Axiom.Core.SubEntity.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.SubEntity.IsVisible">
            <summary>
            	Gets a flag indicating whether or not this sub entity should be rendered or not.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.MaterialName">
            <summary>
            	Gets/Sets the name of the material used for this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.SubMesh">
            <summary>
            	Gets/Sets the subMesh to be used for rendering this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Parent">
            <summary>
            	Gets/Sets the parent entity of this SubEntity.
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Material">
            <summary>
            	Gets/Sets a reference to the material being used by this SubEntity.
            </summary>
            <remarks>
            	By default, the SubEntity will use the material defined by the SubMesh.  However,
            	this can be overridden by the SubEntity in the case where several entities use the
            	same SubMesh instance, but want to shade it different.
            </remarks>
        </member>
        <member name="P:Axiom.Core.SubEntity.NumWorldTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.UseIdentityProjection">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.UseIdentityView">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.RenderDetail">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.WorldOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.WorldPosition">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.SubEntity.Lights">
            <summary>
               
            </summary>
        </member>
        <member name="T:Axiom.Controllers.Controller">
            <summary>
            	Instances of this class 'control' the value of another object in the system.
            </summary>
             <remarks>
            	Controller classes are used to manage the values of object automatically based
            	on the value of some input. For example, a Controller could animate a texture
            	by controlling the current frame of the texture based on time, or a different Controller
            	could change the color of a material used for a spaceship shield mesh based on the remaining
            	shield power level of the ship.
            	<p/>
            	The Controller is an intentionally abstract concept - it can generate values
            	based on input and a function, which can either be one of the standard ones
            	supplied, or a function can be 'plugged in' for custom behavior - see the <see cref="!:ControllerFunction"/> class for details.
            	Both the input and output values are via <see cref="!:ControllerValue"/> objects, meaning that any value can be both
            	input and output of the controller.
            	<p/>
            	While this is very flexible, it can be a little bit confusing so to make it simpler the most often used
            	controller setups are available by calling methods on the ControllerManager object.
            </remarks>
        </member>
        <member name="F:Axiom.Controllers.Controller.source">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller.destination">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller.function">
            <summary>
            	Local reference to the function to be used for this controller.
            </summary>
        </member>
        <member name="F:Axiom.Controllers.Controller.isEnabled">
            <summary>
            	States whether or not this controller is enabled.
            </summary>
        </member>
        <member name="M:Axiom.Controllers.Controller.#ctor(Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerValue,Axiom.Controllers.IControllerFunction)">
            <summary>
            	Main constructor.  Should not be used directly, rather a controller should be created using the
            	ControllerManager so it can keep track of them.
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="function"></param>
        </member>
        <member name="M:Axiom.Controllers.Controller.Update">
            <summary>
            	Called to update the destination value for this controller.  Will be called during
            	the render loop by ControllerManager.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.Source">
            <summary>
            	The value that returns the source data for this controller.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.Destination">
            <summary>
            	The object the sets the destination objects value.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.Function">
            <summary>
            	Gets/Sets the eference to the function to be used for this controller.
            </summary>
        </member>
        <member name="P:Axiom.Controllers.Controller.IsEnabled">
            <summary>
            	Gets/Sets whether this controller is active or not.
            </summary>
        </member>
        <member name="T:Axiom.Collections.SceneQueryMovableObjectIntersectionList">
            <summary>
            Summary description for SceneQuerySceneObjectPairCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneQueryMovableObjectIntersectionList.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneQueryMovableObjectIntersectionList.Add(Axiom.Collections.SceneQueryMovableObjectPair)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.SceneQueryMovableObjectIntersectionList.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="T:Axiom.Media.TGACodec">
            <summary>
               TGA image file codec.
            </summary>
        </member>
        <member name="M:Axiom.Media.TGACodec.Decode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
               Passthrough implementation, no special code needed.
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Media.TGACodec.Encode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="args"></param>
        </member>
        <member name="P:Axiom.Media.TGACodec.Type">
            <summary>
               Returns the JPG file extension.
            </summary>
        </member>
        <member name="P:Axiom.Media.TGACodec.ILType">
            <summary>
               Returns JPG enum.
            </summary>
        </member>
        <member name="T:Axiom.Media.Image">
            <summary>
               Class representing an image file.
            </summary>
            <remarks>
               The Image class usually holds uncompressed image data and is the
               only object that can be loaded in a texture. Image objects handle 
               image data decoding themselves by the means of locating the correct 
               ICodec implementation for each data type.
            </remarks>
        </member>
        <member name="F:Axiom.Media.Image.buffer">
            <summary>
               Byte array containing the image data.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.width">
            <summary>
               Width of the image (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.height">
            <summary>
               Width of the image (in pixels).
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.depth">
            <summary>
               Depth of the image
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.size">
            <summary>
               Size of the image buffer.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.numMipMaps">
            <summary>
               Number of mip maps in this image.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.flags">
            <summary>
               Additional features on this image.
            </summary>
        </member>
        <member name="F:Axiom.Media.Image.format">
            <summary>
               Image format.
            </summary>
        </member>
        <member name="M:Axiom.Media.Image.ApplyGamma(System.Byte[],System.Single,System.Int32,System.Int32)">
            <summary>
               Performs gamma adjusment on this image.
            </summary>
            <remarks>
               Basic algo taken from Titan Engine, copyright (c) 2000 Ignacio 
               Castano Iguado.
            </remarks>
            <param name="buffer"></param>
            <param name="gamma"></param>
            <param name="size"></param>
            <param name="bpp"></param>
        </member>
        <member name="M:Axiom.Media.Image.FlipAroundX">
            <summary>
            	Flips this image around the Y axis.
            </summary>
        </member>
        <member name="M:Axiom.Media.Image.FormatHasAlpha(Axiom.Media.PixelFormat)">
            <summary>
               Checks the specified image format to determine if it contains an alpha
               component.
            </summary>
            <param name="format">Pixel format to check.</param>
            <returns>True if the pixel format contains an alpha component.</returns>
        </member>
        <member name="M:Axiom.Media.Image.FromFile(System.String)">
            <summary>
               Loads an image file from the file system.
            </summary>
            <param name="fileName">Full path to the image file on disk.</param>
        </member>
        <member name="M:Axiom.Media.Image.FromRawStream(System.IO.Stream,System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from memory.
            </summary>
            <param name="stream">Stream containing the raw image data.</param>
            <param name="width">Width of this image data (in pixels).</param>
            <param name="height">Height of this image data (in pixels).</param>
            <param name="format">Pixel format used in this texture.</param>
            <returns>A new instance of Image containing the raw data supplied.</returns>
        </member>
        <member name="M:Axiom.Media.Image.FromDynamicImage(System.Byte[],System.Int32,System.Int32,Axiom.Media.PixelFormat)">
            <summary>
               Loads raw image data from a byte array.
            </summary>
            <param name="buffer">Raw image buffer.</param>
            <param name="width">Width of this image data (in pixels).</param>
            <param name="height">Height of this image data (in pixels).</param>
            <param name="format">Pixel format used in this texture.</param>
            <returns>A new instance of Image containing the raw data supplied.</returns>
        </member>
        <member name="M:Axiom.Media.Image.FromStream(System.IO.Stream,System.String)">
            <summary>
               Loads an image from a stream.
            </summary>
            <remarks>
               This method allows loading an image from a stream, which is helpful for when
               images are being decompressed from an archive into a stream, which needs to be
               loaded as is.
            </remarks>
            <param name="stream">Stream serving as the data source.</param>
            <param name="type">
               Type (i.e. file format) of image.  Used to decide which image decompression codec to use.
            </param>
        </member>
        <member name="M:Axiom.Media.Image.GetNumElemBits(Axiom.Media.PixelFormat)">
            <summary>
               Returns the size in bits of an element of the given pixel format.
            </summary>
            <param name="format">Pixel format to test.</param>
            <returns>Size in bits.</returns>
        </member>
        <member name="M:Axiom.Media.Image.GetNumElemBytes(Axiom.Media.PixelFormat)">
            <summary>
               Returns the size in bytes of an element of the given pixel format.
            </summary>
            <param name="format">Pixel format to test.</param>
            <returns>Size in bytes.</returns>
        </member>
        <member name="M:Axiom.Media.Image.HasFlag(Axiom.Media.ImageFlags)">
            <summary>
               Checks if the specified flag is set on this image.
            </summary>
            <param name="flag">The flag to check for.</param>
            <returns>True if the flag is set, false otherwise.</returns>
        </member>
        <member name="P:Axiom.Media.Image.Data">
            <summary>
               Gets the byte array that holds the image data.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Width">
            <summary>
               Gets the width of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Height">
            <summary>
               Gets the height of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.BitsPerPixel">
            <summary>
               Gets the number of bits per pixel in this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Depth">
            <summary>
               Gets the depth of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Size">
            <summary>
               Gets the size (in bytes) of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.NumMipMaps">
            <summary>
               Gets the number of mipmaps contained in this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.Format">
            <summary>
               Gets the format of this image.
            </summary>
        </member>
        <member name="P:Axiom.Media.Image.HasAlpha">
            <summary>
               Gets whether or not this image has an alpha component in its pixel format.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexBufferLicense">
            <summary>
            	Structure holding details of a license to use a temporary shared buffer.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexBufferLicense.#ctor(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.BufferLicenseRelease,Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.IHardwareBufferLicensee)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderWindow">
             <summary>
            		Manages the target rendering window.
             </summary>
             <remarks>
            		This class handles a window into which the contents
            		of a scene are rendered. There is a many-to-1 relationship
            		between instances of this class an instance of RenderSystem
            		which controls the rendering of the scene. There may be
            		more than one window in the case of level editor tools etc.
            		This class is abstract since there may be
            		different implementations for different windowing systems.
            
            		Instances are created and communicated with by the render system
            		although client programs can get a reference to it from
            		the render system if required for resizing or moving.
            		Note that you can have multiple viewpoints
            		in the window for effects like rear-view mirrors and
            		picture-in-picture views (see Viewport and Camera).
            	</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Graphics.RenderWindow.Create(System.String,System.Int32,System.Int32,System.Boolean,Axiom.Collections.NamedParameterList)" -->
        <member name="M:Axiom.Graphics.RenderWindow.Resize(System.Int32,System.Int32)">
            <summary>
            	Alter the size of the window.
            </summary>
            <param name="pWidth"></param>
            <param name="pHeight"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.Reposition(System.Int32,System.Int32)">
            <summary>
            	Reposition the window.
            </summary>
            <param name="pLeft"></param>
            <param name="pRight"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.WindowMovedOrResized">
            <summary>
            Notify that the window has been resized
            </summary>
            <remarks>You don't need to call this unless you created the window externally.</remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.SwapBuffers(System.Boolean)">
             <summary>
            		Swaps the frame buffers to display the next frame.
             </summary>
             <remarks>
            		All render windows are float-buffered so that no
                 'in-progress' versions of the scene are displayed
                  during rendering. Once rendering has completed (to
            		an off-screen version of the window) the buffers
            		are swapped to display the new frame.
            	</remarks>
             <param name="pWaitForVSync">
            		If true, the system waits for the
            		next vertical blank period (when the CRT beam turns off
            		as it travels from bottom-right to top-left at the
            		end of the pass) before flipping. If false, flipping
            		occurs no matter what the beam position. Waiting for
            		a vertical blank can be slower (and limits the
            		framerate to the monitor refresh rate) but results
            		in a steadier image with no 'tearing' (a flicker
            		resulting from flipping buffers when the beam is
            		in the progress of drawing the last frame). 
            </param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.GetMetrics(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Retrieve information about the render target.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="colourDepth"></param>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.Update">
            <summary>
            	Updates the window contents.
            </summary>
            <remarks>
            	The window is updated by telling each camera which is supposed
            	to render into this window to render it's view, and then
            	the window buffers are swapped via SwapBuffers()
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.RenderWindow.Update(System.Boolean)">
            <summary>
            	Updates the window contents.
            </summary>
            <remarks>
            	The window is updated by telling each camera which is supposed
            	to render into this window to render it's view, and then
            	the window buffers are swapped via SwapBuffers() if requested.
            </remarks>
            <param name="swapBuffers">
            If set to true, the window will immediately
            swap it's buffers after update. Otherwise, the buffers are
            not swapped, and you have to call swapBuffers yourself sometime
            later. You might want to do this on some rendersystems which 
            pause for queued rendering commands to complete before accepting
            swap buffers calls - so you could do other CPU tasks whilst the 
            queued commands complete. Or, you might do this if you want custom
            control over your windows, such as for externally created windows.
            </param>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.top">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.left">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsFullScreen">
            <summary>
            Returns true if window is running in fullscreen mode.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsVisible">
            <summary>
            Indicates whether the window is visible (not minimized or obscured)
            </summary>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsClosed">
            <summary>
            Indicates whether the window has been closed by the user.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Graphics.RenderWindow.IsPrimary">
            <summary>
            Indicates wether the window is the primary window. The
            primary window is special in that it is destroyed when 
            ogre is shut down, and cannot be destroyed directly.
            This is the case because it holds the context for vertex,
            index buffers and textures.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.HardwareCaps">
            <summary>
            	This serves as a way to query information about the capabilies of a 3D API and the
            	users hardware configuration.  A RenderSystem should create and initialize an instance
            	of this class during startup so that it will be available for use ASAP for checking caps.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.caps">
            <summary>
               Flag enum holding the bits that identify each supported feature.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.numTextureUnits">
            <summary>
               Max number of texture units available on the current hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.numWorldMatrices">
            <summary>
               Max number of world matrices supported.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.maxVertexProgramVersion">
            <summary>
               The best vertex program version supported by the hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.maxFragmentProgramVersion">
            <summary>
               The best fragment program version supported by the hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.vertexProgramConstantFloatCount">
            <summary>
               The number of floating point constants the current hardware supports for vertex programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.vertexProgramConstantIntCount">
            <summary>
               The number of integer constants the current hardware supports for vertex programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.fragmentProgramConstantFloatCount">
            <summary>
               The number of floating point constants the current hardware supports for fragment programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.fragmentProgramConstantIntCount">
            <summary>
               The number of integer constants the current hardware supports for fragment programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.stencilBufferBits">
            <summary>
               Stencil buffer bits available.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.HardwareCaps.maxLights">
            <summary>
               Maximum number of lights that can be active in the scene at any given time.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareCaps.#ctor">
            <summary>
               Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareCaps.CheckCap(Axiom.Graphics.Capabilities)">
            <summary>
               Returns true if the current hardware supports the requested feature.
            </summary>
            <param name="cap">Feature to query (i.e. Dot3 bump mapping)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.HardwareCaps.SetCap(Axiom.Graphics.Capabilities)">
            <summary>
               Sets a flag stating the specified feature is supported.
            </summary>
            <param name="cap"></param>
        </member>
        <member name="M:Axiom.Graphics.HardwareCaps.Log">
            <summary>
               Write all hardware capability information to registered listeners.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.HardwareCaps.ConvertBool(System.Boolean)">
            <summary>
                Helper method to convert true/false to yes/no.
            </summary>
            <param name="val">Bool bal.</param>
            <returns>"yes" if true, else "no".</returns>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.FragmentProgramConstantFloatCount">
            <summary>
               Max number of floating point constants supported by the hardware for fragment programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.FragmentProgramConstantIntCount">
            <summary>
               Max number of integer constants supported by the hardware for fragment programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.MaxFragmentProgramVersion">
            <summary>
               Best fragment program version supported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.MaxLights">
            <summary>
            	Maximum number of lights that can be active in the scene at any given time.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.MaxVertexProgramVersion">
            <summary>
               Best vertex program version supported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.TextureUnitCount">
            <summary>
            	Reports on the number of texture units the graphics hardware has available.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.NumWorldMatrices">
            <summary>
               Max number of world matrices supported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.StencilBufferBits">
            <summary>
            	Number of stencil buffer bits suppported by the hardware.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.VertexProgramConstantFloatCount">
            <summary>
               Max number of floating point constants supported by the hardware for vertex programs.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.HardwareCaps.VertexProgramConstantIntCount">
            <summary>
               Max number of integer constants supported by the hardware for vertex programs.
            </summary>
        </member>
        <member name="T:Axiom.FileSystem.ZipArchiveFactory">
            <summary>
                Specialization of IArchiveFactory for Zip files.
            </summary>
        </member>
        <member name="M:Axiom.FileSystem.ZipArchiveFactory.CreateArchive(System.String)">
            <summary>
                Creates a new zip file archive.
            </summary>
            <param name="name">Name of the archive to create.</param>
            <returns>A new isntance of ZipArchive.</returns>
        </member>
        <member name="P:Axiom.FileSystem.ZipArchiveFactory.Type">
            <summary>
                Type of archive this factory creates.
            </summary>
            <value></value>
        </member>
        <member name="T:Axiom.Core.StringConverter">
            <summary>
                Helper class for going back and forth between strings and various types.
            </summary>
        </member>
        <member name="F:Axiom.Core.StringConverter.englishCulture">
            <summary>
            	Culture info to use for parsing numeric data.
            </summary>
        </member>
        <member name="M:Axiom.Core.StringConverter.#ctor">
            <summary>
                Private constructor so no instances can be created.
            </summary>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseBool(System.String)">
            <summary>
            	Parses a boolean type value 
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseColor(System.String[])">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseColor(System.String)">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseVector3(System.String[])">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseVector3(System.String)">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseVector4(System.String[])">
            <summary>
            	Parses an array of params and returns a color from it.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Axiom.Core.StringConverter.ParseFloat(System.String)">
            <summary>
            	Parse a float value from a string.
            </summary>
            <remarks>
            	Since our file formats assume the 'en-US' style format for numbers, we need to
            	let the framework know that where numbers are being parsed.
            </remarks>
            <param name="val">String value holding the float.</param>
            <returns>A float representation of the string value.</returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(Axiom.Core.ColorEx)">
            <summary>
                
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(Axiom.Math.Vector4)">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.StringConverter.ToString(System.Single)">
            <summary>
                Converts a 
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Core.SceneManagerEnumerator">
            <summary>
                Enumerates the SceneManager classes available to applications.
            </summary>
            <remarks>
                As described in the SceneManager class, SceneManagers are responsible
                for organizing the scene and issuing rendering commands to the
                RenderSystem. Certain scene types can benefit from different
                rendering approaches, and it is intended that subclasses will
                be created to special case this.
                <p/>
                In order to give applications easy access to these implementations,
                the Root object has a GetSceneManager method to retrieve a SceneManager
                which is appropriate to the scene type. However, this is the class
                which implements this behavior and defines the scene types, because
                it is intended that the Root class is not customized by everybody
                (and it may be restricted access in the future).
            </remarks>
        </member>
        <member name="F:Axiom.Core.SceneManagerEnumerator.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerEnumerator.defaultSceneManager">
            <summary>
                Standard scene manager for default management.
            </summary>
        </member>
        <member name="F:Axiom.Core.SceneManagerEnumerator.sceneManagers">
            <summary>
                Collection of loaded scene managers, keyed by scene type.
            </summary>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.GetSceneManager(Axiom.Core.SceneType)">
            <summary>
                Gets a reference to the scene manager of the specified type.
            </summary>
            <param name="type">Type of scene manager to retrieve.</param>
            <returns>A reference to the scene manager of the specified type.</returns>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.SetRenderSystem(Axiom.Graphics.RenderSystem)">
            <summary>
                Notifies all SceneManagers of the destination rendering system.
            </summary>
            <param name="system">Current destination render system.</param>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.SetSceneManager(Axiom.Core.SceneType,Axiom.Core.SceneManager)">
            <summary>
                Sets a scene manager implementation for the given type.
            </summary>
            <param name="type">Type of scene this manager implements.</param>
            <param name="manager">Reference to the scene manager.</param>
        </member>
        <member name="M:Axiom.Core.SceneManagerEnumerator.ShutdownAll">
            <summary>
                Shuts down all registered scene managers.
            </summary>
        </member>
        <member name="P:Axiom.Core.SceneManagerEnumerator.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.Light">
            <summary>
               Representation of a dynamic light source in the scene.
            </summary>
            <remarks>
               Lights are added to the scene like any other object. They contain various
               parameters like type, position, attenuation (how light intensity fades with
               distance), color etc.
               <p/>
               The defaults when a light is created is pure white diffues light, with no
               attenuation (does not decrease with distance) and a range of 1000 world units.
               <p/>
               Lights are created by using the SceneManager.CreateLight method. They can subsequently be
               added to a SceneNode if required to allow them to move relative to a node in the scene. A light attached
               to a SceneNode is assumed to have a base position of (0,0,0) and a direction of (0,0,1) before modification
               by the SceneNode's own orientation. If not attached to a SceneNode,
               the light's position and direction is as set using Position and Direction.
               <p/>
               Remember also that dynamic lights rely on modifying the color of vertices based on the position of
               the light compared to an object's vertex normals. Dynamic lighting will only look good if the
               object being lit has a fair level of tesselation and the normals are properly set. This is particularly
               true for the spotlight which will only look right on highly tesselated models.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Light.type">
            <summary>
               Type of light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.position">
            <summary>
               Position of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.direction">
            <summary>
               Direction of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.derivedPosition">
            <summary>
            	Derived position of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.derivedDirection">
            <summary>
            	Derived direction of this light.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.lastParentOrientation">
            <summary>
            	Stored version of parent orientation.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.lastParentPosition">
            <summary>
            	Stored version of parent position.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.diffuse">
            <summary>
            	Diffuse color.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.specular">
            <summary>
            	Specular color.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.spotOuter">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.spotInner">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.spotFalloff">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.range">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationConst">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationLinear">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.attenuationQuad">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.localTransformDirty">
            <summary></summary>
        </member>
        <member name="F:Axiom.Core.Light.tempSquaredDist">
            <summary>
               Used for sorting.  Internal for "friend" access to SceneManager.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.nearClipVolume">
            <summary>
            	Stored version of the last near clip volume tested.
            </summary>
        </member>
        <member name="F:Axiom.Core.Light.frustumClipVolumes">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.#ctor(System.String)">
            <summary>
            	Normal constructor. Should not be called directly, but rather the SceneManager.CreateLight method should be used.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Light.Update">
            <summary>
            	Updates this lights position.
            </summary>
        </member>
        <member name="M:Axiom.Core.Light.GetAs4DVector">
            <summary>
            	Gets the details of this light as a 4D vector.
            </summary>
            <remarks>
            	Getting details of a light as a 4D vector can be useful for
            	doing general calculations between different light types; for
            	example the vector can represent both position lights (w=1.0f)
            	and directional lights (w=0.0f) and be used in the same 
            	calculations.
            </remarks>
            <returns>A 4D vector represenation of the light.</returns>
        </member>
        <member name="M:Axiom.Core.Light.SetSpotlightRange(System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="innerAngle"></param>
            <param name="outerAngle"></param>
        </member>
        <member name="M:Axiom.Core.Light.SetSpotlightRange(System.Single,System.Single,System.Single)">
            <summary>
            	Sets the spotlight parameters in a single call.
            </summary>
            <param name="innerAngle"></param>
            <param name="outerAngle"></param>
            <param name="falloff"></param>
        </member>
        <member name="M:Axiom.Core.Light.SetAttenuation(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the attenuation parameters of the light in a single call.
            </summary>
            <param name="range"></param>
            <param name="constant"></param>
            <param name="linear"></param>
            <param name="quadratic"></param>
        </member>
        <member name="M:Axiom.Core.Light.GetNearClipVolume(Axiom.Core.Camera)">
            <summary>
            	Internal method for calculating the 'near clip volume', which is
            	the volume formed between the near clip rectangle of the 
            	camera and the light.
            </summary>
            <remarks>
            	This volume is a pyramid for a point/spot light and
            	a cuboid for a directional light. It can used to detect whether
            	an object could be casting a shadow on the viewport. Note that
            	the reference returned is to a shared volume which will be 
            	reused across calls to this method.
            </remarks>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Light.GetFrustumClipVolumes(Axiom.Core.Camera)">
            <summary>
            	Internal method for calculating the clip volumes outside of the 
            	frustum which can be used to determine which objects are casting
            	shadow on the frustum as a whole. 
            </summary>
            <remarks>
            	Each of the volumes is a pyramid for a point/spot light and
            	a cuboid for a directional light.
            </remarks>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Light.CompareTo(System.Object)">
            <summary>
               Used to compare this light to another light for sorting.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Light.Type">
            <summary>
            	Gets/Sets the type of light this is.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Position">
            <summary>
            	Gets/Sets the position of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Direction">
            <summary>
            	Gets/Sets the direction of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightInnerAngle">
            <summary>
            	Gets the inner angle of the spotlight.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightOuterAngle">
            <summary>
            	Gets the outer angle of the spotlight.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.SpotlightFalloff">
            <summary>
            	Gets the spotlight falloff.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Diffuse">
            <summary>
            	Gets/Sets the diffuse color of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.Specular">
            <summary>
            	Gets/Sets the diffuse color of the light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationRange">
            <summary>
            	Gets the attenuation range value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationConstant">
            <summary>
            	Gets the constant attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationLinear">
            <summary>
            	Gets the linear attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.AttenuationQuadratic">
            <summary>
            	Gets the quadratic attenuation value.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.DerivedPosition">
            <summary>
            	Gets the derived position of this light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.DerivedDirection">
            <summary>
            	Gets the derived position of this light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.IsVisible">
            <summary>
            	Override IsVisible to ensure we are updated when this changes.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.BoundingRadius">
            <summary>
               Local bounding radius of this light.
            </summary>
        </member>
        <member name="P:Axiom.Core.Light.BoundingBox">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Collections.SceneQueryMovableObjectWorldFragmentIntersectionList">
            <summary>
            Summary description for SceneQuerySceneObjectWorldFragmentPairCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneQueryMovableObjectWorldFragmentIntersectionList.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SceneQueryMovableObjectWorldFragmentIntersectionList.Add(Axiom.Collections.SceneQueryMovableObjectWorldFragmentPair)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.SceneQueryMovableObjectWorldFragmentIntersectionList.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="T:Axiom.Collections.NameValuePairList">
            <summary>
            Summary for NewClass
            </summary>
        </member>
        <member name="M:Axiom.Collections.NameValuePairList.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="T:Axiom.Collections.AnimationCollection">
            <summary>
            Summary description for AnimationCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.AnimationCollection.Add(Axiom.Animating.Animation)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.AnimationCollection.Add(System.String,Axiom.Animating.Animation)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="key"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.AnimationCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.AnimationCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Scripting.ParseHelper">
            <summary>
            	Class contining helper methods for parsing text files.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.Combine(System.String[],System.Int32,System.Int32)">
            <summary>
               Helper method for taking a string array and returning a single concatenated
               string composed of the range of specified elements.
            </summary>
            <param name="items"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.LogParserError(System.String,System.String,System.String)">
            <summary>
            	Helper method to log a formatted error when encountering problems with parsing
            	an attribute.
            </summary>
            <param name="attribute"></param>
            <param name="context"></param>
            <param name="expectedParams"></param>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.ReadLine(System.IO.TextReader)">
            <summary>
            	Helper method to nip/tuck the string before parsing it.  This includes trimming spaces from the beginning
            	and end of the string, as well as removing excess spaces in between values.
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.GetParams(System.String[])">
            <summary>
            	Helper method to remove the first item from a string array and return a new array 1 element smaller
            	starting at the second element of the original array.  This helpe to seperate the params from the command
            	in the various script files.
            </summary>
            <param name="splitLine"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.SkipToNextOpenBrace(System.IO.TextReader)">
            <summary>
               Advances in the stream until it hits the next {.
            </summary>
        </member>
        <member name="M:Axiom.Scripting.ParseHelper.SkipToNextCloseBrace(System.IO.TextReader)">
            <summary>
               Advances in the stream until it hits the next }.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanel">
            <summary>
            	A specialization of the Panel element to provide a panel with a border with a seperate material.
            </summary>
            <remarks>
            	Whilst the standard panel can use a single tiled material, this class allows
            	panels with a tileable backdrop plus a border texture. This is handy for large
            	panels that are too big to use a single large texture with a border, or
            	for multiple different size panels where you want the border a constant width
            	but the center to repeat.
            	<p/>
            	In addition to the usual PanelGuiElement properties, this class has a 'border
            	material', which specifies the material used for the edges of the panel,
            	a border width (which can either be constant all the way around, or specified
            	per edge), and the texture coordinates for each of the border sections.
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.#ctor(System.String)">
            <summary>
               Internal constructor, used when objects create by the factory.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.Initialize">
            <summary>
               Override from Panel.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetBorderSize(System.Single)">
            <summary>
               Sets the size of the border.
            </summary>
            <remarks>
               This method sets a constant size for all borders. There are also alternative
               methods which allow you to set border widths for individual edges separately.
               Remember that the dimensions specified here are in relation to the size of
               the screen, so 0.1 is 1/10th of the screen width or height. Also note that because
               most screen resolutions are 1.333:1 width:height ratio that using the same
               border size will look slightly bigger across than up.
            </remarks>
            <param name="size">The size of the border as a factor of the screen dimensions ie 0.2 is one-fifth
               of the screen size.
            </param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetBorderSize(System.Single,System.Single)">
            <summary>
               Sets the size of the border, with different sizes for vertical and horizontal borders.
            </summary>
            <remarks>
               This method sets a size for the side and top / bottom borders separately. 
               Remember that the dimensions specified here are in relation to the size of
               the screen, so 0.1 is 1/10th of the screen width or height. Also note that because
               most screen resolutions are 1.333:1 width:height ratio that using the same
               border size will look slightly bigger across than up.
            </remarks>
            <param name="sides">The size of the side borders as a factor of the screen dimensions ie 0.2 is one-fifth
               of the screen size.</param>
            <param name="topAndBottom">The size of the top and bottom borders as a factor of the screen dimensions.</param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetBorderSize(System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Sets the size of the border separately for all borders.
            </summary>
            <remarks>
               This method sets a size all borders separately. 
               Remember that the dimensions specified here are in relation to the size of
               the screen, so 0.1 is 1/10th of the screen width or height. Also note that because
               most screen resolutions are 1.333:1 width:height ratio that using the same
               border size will look slightly bigger across than up.
            </remarks>
            <param name="left">The size of the left border as a factor of the screen dimensions ie 0.2 is one-fifth
            of the screen size.</param>
            <param name="right">The size of the right border as a factor of the screen dimensions.</param>
            <param name="top">The size of the top border as a factor of the screen dimensions.</param>
            <param name="bottom">The size of the bottom border as a factor of the screen dimensions.</param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.SetCellUV(Axiom.Overlays.Elements.BorderPanel.BorderCell,System.Single,System.Single,System.Single,System.Single)">
            <summary>
               Sets the texture coordinates for the left edge of the border.
            </summary>
            <remarks>
               The border panel uses 8 panels for the border (9 including the center). 
               Imagine a table with 3 rows and 3 columns. The corners are always the same size,
               but the edges stretch depending on how big the panel is. Those who have done
               resizable HTML tables will be familiar with this approach.
               <p/>
               We only require 2 sets of uv coordinates, one for the top-left and one for the
               bottom-right of the panel, since it is assumed the sections are aligned on the texture.
            </remarks>
            <param name="cell">Index of the cell to update.</param>
            <param name="u1">Top left u.</param>
            <param name="v1">Top left v.</param>
            <param name="u2">Bottom right u.</param>
            <param name="v2">Bottom right v.</param>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.Update">
            <summary>
               Overriden from Panel.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.UpdatePositionGeometry">
            <summary>
               Override from Panel.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
               Overriden from Panel.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.LeftBorderSize">
            <summary>
               Gets the size of the left border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.RightBorderSize">
            <summary>
               Gets the size of the right border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.TopBorderSize">
            <summary>
               Gets the size of the top border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.BottomBorderSize">
            <summary>
               Gets the size of the bottom border.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.BorderMaterialName">
            <summary>
               Gets/Sets the name of the material to use for just the borders.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.BorderPanel.MetricsMode">
            <summary>
               Override of Panel.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanel.BorderRenderable">
            <summary>
               Class for rendering the border of a BorderPanel.
            </summary>
            <remarks>
               We need this because we have to render twice, once with the inner panel's repeating
               material (handled by superclass) and once for the border's separate meterial. 
            </remarks>
        </member>
        <member name="M:Axiom.Overlays.Elements.BorderPanel.BorderRenderable.#ctor(Axiom.Overlays.Elements.BorderPanel)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="T:Axiom.Overlays.Elements.BorderPanel.BorderCell">
            <summary>
               Enum for border cells.
            </summary>
        </member>
        <member name="T:Axiom.Math.Sphere">
            <summary>
            	A standard sphere, used mostly for bounds checking.
            </summary>
            <remarks>
            	A sphere in math texts is normally represented by the function
            	x^2 + y^2 + z^2 = r^2 (for sphere's centered on the origin). We store spheres
            	simply as a center point and a radius.
            </remarks>
        </member>
        <member name="M:Axiom.Math.Sphere.#ctor">
            <summary>
            	Creates a unit sphere centered at the origin.
            </summary>
        </member>
        <member name="M:Axiom.Math.Sphere.#ctor(Axiom.Math.Vector3,System.Single)">
            <summary>
            Creates an arbitrary spehere.
            </summary>
            <param name="center">Center point of the sphere.</param>
            <param name="radius">Radius of the sphere.</param>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.Sphere)">
            <summary>
            	Tests for intersection between this sphere and another sphere.
            </summary>
            <param name="sphere">Other sphere.</param>
            <returns>True if the spheres intersect, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.AxisAlignedBox)">
            <summary>
            	Returns whether or not this sphere interects a box.
            </summary>
            <param name="box"></param>
            <returns>True if the box intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.Plane)">
            <summary>
            	Returns whether or not this sphere interects a plane.
            </summary>
            <param name="plane"></param>
            <returns>True if the plane intersects, false otherwise.</returns>
        </member>
        <member name="M:Axiom.Math.Sphere.Intersects(Axiom.Math.Vector3)">
            <summary>
            	Returns whether or not this sphere interects a Vector3.
            </summary>
            <param name="vector"></param>
            <returns>True if the vector intersects, false otherwise.</returns>
        </member>
        <member name="P:Axiom.Math.Sphere.Center">
            <summary>
            	Gets/Sets the center of the sphere.
            </summary>
        </member>
        <member name="P:Axiom.Math.Sphere.Radius">
            <summary>
            	Gets/Sets the radius of the sphere.
            </summary>
        </member>
        <member name="T:Axiom.Fonts.Font">
            <summary>
            	This class is simply a way of getting a font texture into the engine and
            	to easily retrieve the texture coordinates required to accurately render them.
            	Fonts can either be loaded from precreated textures, or the texture can be generated
            	using a truetype font. You can either create the texture manually in code, or you
            	can use an XML font script to define it (probably more practical since you can reuse
            	the definition more easily)
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font.fontType">
            <summary>
               Type of font, either imag based or TrueType.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font.source">
            <summary>
               Source of the font (either an image name or a TrueType font).
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font.ttfSize">
            <summary>
               Size of the truetype font, in points.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font.ttfResolution">
            <summary>
               Resolution (dpi) of truetype font.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font.antialiasColor">
            <summary>
               For TrueType fonts only.
            </summary>
        </member>
        <member name="F:Axiom.Fonts.Font.material">
            <summary>
               Material create for use on entities by this font.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.Font.#ctor(System.String)">
            <summary>
            	Constructor, should be called through FontManager.Create.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.Font.Load">
            <summary>
               Loads either an image based font, or creates one on the fly from a TrueType font file.
            </summary>
        </member>
        <member name="M:Axiom.Fonts.Font.GetGlyphTexCoords(System.Char,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            	Retreives the texture coordinates for the specifed character in this font.
            </summary>
            <param name="c"></param>
            <param name="u1"></param>
            <param name="u2"></param>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:Axiom.Fonts.Font.GetGlyphAspectRatio(System.Char)">
            <summary>
            	Finds the aspect ratio of the specified character in this font.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Fonts.Font.AntialiasColor">
            <summary>
               Sets whether or not the color of this font is antialiased as it is generated
               from a TrueType font.
            </summary>
            <remarks>
               This is valid only for a TrueType font. If you are planning on using 
               alpha blending to draw your font, then it is a good idea to set this to
               false (which is the default), otherwise the darkening of the font will combine
               with the fading out of the alpha around the edges and make your font look thinner
               than it should. However, if you intend to blend your font using a color blending
               mode (add or modulate for example) then it's a good idea to set this to true, in
               order to soften your font edges.
            </remarks>
        </member>
        <member name="P:Axiom.Fonts.Font.Material">
            <summary>
               Gets a reference to the material being used for this font.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.Source">
            <summary>
               Source of the font (either an image name or a truetype font)
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.TrueTypeResolution">
            <summary>
               Resolution (dpi) of truetype font.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.TrueTypeSize">
            <summary>
               Size of the truetype font, in points.
            </summary>
        </member>
        <member name="P:Axiom.Fonts.Font.Type">
            <summary>
               Type of font.
            </summary>
        </member>
        <member name="T:Axiom.Core.PatchMesh">
            <summary>
                Patch specialization of <see cref="T:Axiom.Core.Mesh"/>.
            </summary>
            <remarks>
                Instances of this class should be created by calling
                <see cref="M:Axiom.Core.MeshManager.CreateBezierPatch(System.String,System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Core.VisibleSide,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="T:Axiom.Core.Mesh">
            <summary>
               Resource holding data about a 3D mesh.
            </summary>
            <remarks>
               This class holds the data used to represent a discrete
               3-dimensional object. Mesh data usually contains more
               than just vertices and triangle information; it also
               includes references to materials (and the faces which use them),
               level-of-detail reduction information, convex hull definition,
               skeleton/bones information, keyframe animation etc.
               However, it is important to note the emphasis on the word
               'discrete' here. This class does not cover the large-scale
               sprawling geometry found in level / landscape data.
               <p/>
               Multiple world objects can (indeed should) be created from a
               single mesh object - see the Entity class for more info.
               The mesh object will have it's own default
               material properties, but potentially each world instance may
               wish to customize the materials from the original. When the object
               is instantiated into a scene node, the mesh material properties
               will be taken by default but may be changed. These properties
               are actually held at the SubMesh level since a single mesh may
               have parts with different materials.
               <p/>
               As described above, because the mesh may have sections of differing
               material properties, a mesh is inherently a compound contruct,
               consisting of one or more SubMesh objects.
               However, it strongly 'owns' it's SubMeshes such that they
               are loaded / unloaded at the same time. This is contrary to
               the approach taken to hierarchically related (but loosely owned)
               scene nodes, where data is loaded / unloaded separately. Note
               also that mesh sub-sections (when used in an instantiated object)
               share the same scene node as the parent.
            </remarks>
            TODO: Add Clone method
        </member>
        <member name="F:Axiom.Core.Mesh.sharedVertexData">
            <summary>
            	Shared vertex data between multiple meshes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.subMeshList">
            <summary>
            	Collection of sub meshes for this mesh.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.isManuallyDefined">
            <summary>
            	Flag that indicates whether or not this mesh will be loaded from a file, or constructed manually.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.boundingBox">
            <summary>
            	Local bounding box of this mesh.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.boundingSphereRadius">
            <summary>
            	Radius of this mesh's bounding sphere.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.skeletonName">
            <summary>Name of the skeleton bound to this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.skeleton">
            <summary>Reference to the skeleton bound to this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.boneAssignmentList">
            <summary>List of bone assignment for this mesh.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.boneAssignmentsOutOfDate">
            <summary>Flag indicating that bone assignments need to be recompiled.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.numBlendWeightsPerVertex">
            <summary>Number of blend weights that are assigned to each vertex.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.useSoftwareBlending">
            <summary>Option whether to use software or hardware blending, there are tradeoffs to both.</summary>
        </member>
        <member name="F:Axiom.Core.Mesh.isLodManual">
            <summary>
            	Flag indicating the use of manually created LOD meshes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.numLods">
            <summary>
            	Number of LOD meshes available.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.lodUsageList">
            <summary>
            	List of data structures describing LOD usage.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.vertexBufferUsage">
            <summary>
            	Usage type for the vertex buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.indexBufferUsage">
            <summary>
            	Usage type for the index buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.useVertexShadowBuffer">
            <summary>
            	Use a shadow buffer for the vertex data?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.useIndexShadowBuffer">
            <summary>
            	Use a shadow buffer for the index data?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.isPreparedForShadowVolumes">
            <summary>
            	Flag indicating whether precalculation steps to support shadows have been taken.
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.autoBuildEdgeLists">
            <summary>
            	Should edge lists be automatically built for this mesh?
            </summary>
        </member>
        <member name="F:Axiom.Core.Mesh.edgeListsBuilt">
            <summary>
                Have the edge lists been built for this mesh yet?
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.GetEdgeList">
            <summary>
            	Gets the edge list for this mesh, building it if required. 
            </summary>
            <returns>The edge list for mesh LOD 0.</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetEdgeList(System.Int32)">
            <summary>
            	Gets the edge list for this mesh, building it if required. 
            </summary>
            <remarks>
            	You must ensure that the Mesh as been prepared for shadow volume 
            	rendering if you intend to use this information for that purpose.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.AddBoneAssignment(Axiom.Animating.VertexBoneAssignment@)">
            <summary>
               Assigns a vertex to a bone with a given weight, for skeletal animation. 
            </summary>
            <remarks>
               This method is only valid after setting SkeletonName.
               You should not need to modify bone assignments during rendering (only the positions of bones) 
               and the engine reserves the right to do some internal data reformatting of this information, 
               depending on render system requirements.
            </remarks>
            <param name="boneAssignment">Bone assignment to add.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.BuildEdgeList">
            <summary>
            	Builds an edge list for this mesh, which can be used for generating a shadow volume
            	among other things.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.BuildTangentVectors(System.Int16,System.Int16)">
            <summary>
                Builds tangent space vector required for accurate bump mapping.
            </summary>
            <remarks>
               Adapted from bump mapping tutorials at:
               http://www.paulsprojects.net/tutorials/simplebump/simplebump.html
               author : paul.baker@univ.ox.ac.uk
               <p/>
               Note: Only the tangent vector is calculated, it is assumed the binormal
               will be calculated in a vertex program.
            </remarks>
            <param name="sourceTexCoordSet">Source texcoord set that holds the current UV texcoords.</param>
            <param name="destTexCoordSet">Destination texcoord set to hold the tangent vectors.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.BuildTangentVectors">
            <summary>
                Builds tangent space vector required for accurate bump mapping.
            </summary>
            <remarks>
               Adapted from bump mapping tutorials at:
               http://www.paulsprojects.net/tutorials/simplebump/simplebump.html
               author : paul.baker@univ.ox.ac.uk
               <p/>
               Note: Only the tangent vector is calculated, it is assumed the binormal
               will be calculated in a vertex program.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.ClearBoneAssignments">
            <summary>
               Removes all bone assignments for this mesh. 
            </summary>
            <remarks>
               This method is for modifying weights to the shared geometry of the Mesh. To assign
               weights to the per-SubMesh geometry, see the equivalent methods on SubMesh.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.CompileBoneAssignments">
            <summary>
               Compile bone assignments into blend index and weight buffers.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.CompileBoneAssignments(Axiom.Collections.Map,System.Int32,Axiom.Graphics.VertexData)">
            <summary>
               Software blending oriented bone assignment compilation.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.GetLodIndex(System.Single)">
            <summary>
               Retrieves the level of detail index for the given depth value.
            </summary>
            <param name="depth"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetLodLevel(System.Int32)">
            <summary>
               Gets the mesh lod level at the specified index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.OrganizeTangentsBuffer(Axiom.Graphics.VertexData,System.Int16)">
            <summary>
               Internal method for making the space for a 3D texture coord buffer to hold tangents.
            </summary>
            <param name="vertexData">Target vertex data.</param>
            <param name="destCoordSet">Destination texture coordinate set.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.SuggestTangentVectorBuildParams(System.Int16@,System.Int16@)">
            <summary>
                Ask the mesh to suggest parameters to a future <see cref="M:Axiom.Core.Mesh.BuildTangentVectors(System.Int16,System.Int16)"/> call.
            </summary>
            <remarks>
                This helper method will suggest source and destination texture coordinate sets
                for a call to <see cref="M:Axiom.Core.Mesh.BuildTangentVectors(System.Int16,System.Int16)"/>. It will detect when there are inappropriate
                conditions (such as multiple geometry sets which don't agree). 
                Moreover, it will return 'true' if it detects that there are aleady 3D 
                coordinates in the mesh, and therefore tangents may have been prepared already.
            </remarks>
            <param name="sourceCoordSet">A source texture coordinate set which will be populated.</param>
            <param name="destCoordSet">A destination texture coordinate set which will be populated.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.GetLodIndexSquaredDepth(System.Single)">
            <summary>
               Retrieves the level of detail index for the given squared depth value.
            </summary>
            <remarks>
               Internally the lods are stored at squared depths to avoid having to perform
               square roots when determining the lod. This method allows you to provide a
               squared length depth value to avoid having to do your own square roots.
            </remarks>
            <param name="squaredDepth"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetSubMesh(System.Int32)">
            <summary>
               Gets the sub mesh at the specified index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.GetSubMesh(System.String)">
            <summary>
                Gets the sub mesh with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Mesh.InitAnimationState(Axiom.Collections.AnimationStateCollection)">
            <summary>
               Initialise an animation set suitable for use with this mesh.
            </summary>
            <remarks>
               Only recommended for use inside the engine, not by applications.
            </remarks>
            <param name="animSet"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.NotifySkeleton(Axiom.Animating.Skeleton)">
            <summary>
               Internal notification, used to tell the Mesh which Skeleton to use without loading it. 
            </summary>
            <remarks>
               This is only here for unusual situation where you want to manually set up a
               Skeleton. Best to let the engine deal with this, don't call it yourself unless you
               really know what you're doing.
            </remarks>
            <param name="skeleton"></param>
        </member>
        <member name="M:Axiom.Core.Mesh.PrepareForShadowVolume">
            <summary>
            	This method prepares the mesh for generating a renderable shadow volume.
            </summary>
            <remarks>
            	Preparing a mesh to generate a shadow volume involves firstly ensuring that the 
            	vertex buffer containing the positions for the mesh is a standalone vertex buffer,
            	with no other components in it. This method will therefore break apart any existing
            	vertex buffers this mesh holds if position is sharing a vertex buffer. 
            	Secondly, it will double the size of this vertex buffer so that there are 2 copies of 
            	the position data for the mesh. The first half is used for the original, and the second 
            	half is used for the 'extruded' version of the mesh. The vertex count of the main 
            	<see cref="T:Axiom.Graphics.VertexData"/> used to render the mesh will remain the same though, so as not to add any 
            	overhead to regular rendering of the object.
            	Both copies of the position are required in one buffer because shadow volumes stretch 
            	from the original mesh to the extruded version.
            	<p/>
            	Because shadow volumes are rendered in turn, no additional
            	index buffer space is allocated by this method, a shared index buffer allocated by the
            	shadow rendering algorithm is used for addressing this extended vertex buffer.
            </remarks>
        </member>
        <member name="M:Axiom.Core.Mesh.RationalizeBoneAssignments(System.Int32,Axiom.Collections.Map)">
            <summary>
                Rationalizes the passed in bone assignment list.
            </summary>
            <remarks>
                We support up to 4 bone assignments per vertex. The reason for this limit
                is that this is the maximum number of assignments that can be passed into
                a hardware-assisted blending algorithm. This method identifies where there are
                more than 4 bone assignments for a given vertex, and eliminates the bone
                assignments with the lowest weights to reduce to this limit. The remaining
                weights are then re-balanced to ensure that they sum to 1.0.
            </remarks>
            <param name="vertexCount">The number of vertices.</param>
            <param name="assignments">
                The bone assignment list to rationalize. This list will be modified and
                entries will be removed where the limits are exceeded.
            </param>
            <returns>The maximum number of bone assignments per vertex found, clamped to [1-4]</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.CreateSubMesh(System.String)">
            <summary>
            	Creates a new <see cref="T:Axiom.Core.SubMesh"/> and gives it a name.
            </summary>
            <param name="name">Name of the new <see cref="T:Axiom.Core.SubMesh"/>.</param>
            <returns>A new <see cref="T:Axiom.Core.SubMesh"/> with this Mesh as its parent.</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.CreateSubMesh">
            <summary>
            	Creates a new <see cref="T:Axiom.Core.SubMesh"/>.
            </summary>
            <remarks>
            	Method for manually creating geometry for the mesh.
            	Note - use with extreme caution - you must be sure that
            	you have set up the geometry properly.
            </remarks>
            <returns>A new SubMesh with this Mesh as its parent.</returns>
        </member>
        <member name="M:Axiom.Core.Mesh.SetVertexBufferPolicy(Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Sets the policy for the vertex buffers to be used when loading this Mesh.
            </summary>
            <remarks>
            	By default, when loading the Mesh, static, write-only vertex and index buffers 
            	will be used where possible in order to improve rendering performance. 
            	However, such buffers
            	cannot be manipulated on the fly by CPU code (although shader code can). If you
            	wish to use the CPU to modify these buffers, you should call this method. Note,
            	however, that it only takes effect after the Mesh has been reloaded. Note that you
            	still have the option of manually repacing the buffers in this mesh with your
            	own if you see fit too, in which case you don't need to call this method since it
            	only affects buffers created by the mesh itself.
            	<p/>
            	You can define the approach to a Mesh by changing the default parameters to 
            	<see cref="M:Axiom.Core.MeshManager.Load(System.String)"/> if you wish; this means the Mesh is loaded with those options
            	the first time instead of you having to reload the mesh after changing these options.
            </remarks>
            <param name="usage">The usage flags, which by default are <see cref="F:Axiom.Graphics.BufferUsage.StaticWriteOnly"/></param>
            <param name="useShadowBuffer">
            	If set to true, the vertex buffers will be created with a
            	system memory shadow buffer. You should set this if you want to be able to
            	read from the buffer, because reading from a hardware buffer is a no-no.
            </param>
        </member>
        <member name="M:Axiom.Core.Mesh.SetIndexBufferPolicy(Axiom.Graphics.BufferUsage,System.Boolean)">
            <summary>
            	Sets the policy for the index buffers to be used when loading this Mesh.
            </summary>
            <remarks>
            	By default, when loading the Mesh, static, write-only vertex and index buffers 
            	will be used where possible in order to improve rendering performance. 
            	However, such buffers
            	cannot be manipulated on the fly by CPU code (although shader code can). If you
            	wish to use the CPU to modify these buffers, you should call this method. Note,
            	however, that it only takes effect after the Mesh has been reloaded. Note that you
            	still have the option of manually repacing the buffers in this mesh with your
            	own if you see fit too, in which case you don't need to call this method since it
            	only affects buffers created by the mesh itself.
            	<p/>
            	You can define the approach to a Mesh by changing the default parameters to 
            	<see cref="M:Axiom.Core.MeshManager.Load(System.String)"/> if you wish; this means the Mesh is loaded with those options
            	the first time instead of you having to reload the mesh after changing these options.
            </remarks>
            <param name="usage">The usage flags, which by default are <see cref="F:Axiom.Graphics.BufferUsage.StaticWriteOnly"/></param>
            <param name="useShadowBuffer">
            	If set to true, the index buffers will be created with a
            	system memory shadow buffer. You should set this if you want to be able to
            	read from the buffer, because reading from a hardware buffer is a no-no.
            </param>
        </member>
        <member name="M:Axiom.Core.Mesh.SoftwareVertexBlend(Axiom.Graphics.VertexData,Axiom.Graphics.VertexData,Axiom.Math.Matrix4[],System.Boolean)">
            <summary>
            	Performs a software indexed vertex blend, of the kind used for
            	skeletal animation although it can be used for other purposes. 
            </summary>
            <remarks>
            	This function is supplied to update vertex data with blends 
            	done in software, either because no hardware support is available, 
            	or that you need the results of the blend for some other CPU operations.
            </remarks>
            <param name="sourceVertexData">
            	<see cref="T:Axiom.Graphics.VertexData"/> class containing positions, normals, blend indices and blend weights.
            </param>
            <param name="targetVertexData">
            	<see cref="T:Axiom.Graphics.VertexData"/> class containing target position
            	and normal buffers which will be updated with the blended versions.
            	Note that the layout of the source and target position / normal 
            	buffers must be identical, ie they must use the same buffer indexes.
            </param>
            <param name="matrices">An array of matrices to be used to blend.</param>
            <param name="blendNormals">If true, normals are blended as well as positions.</param>
        </member>
        <member name="M:Axiom.Core.Mesh.Load">
            <summary>
            	Loads the mesh data.
            </summary>
        </member>
        <member name="M:Axiom.Core.Mesh.Unload">
            <summary>
            	Unloads the mesh data.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.AutoBuildEdgeLists">
            <summary>
            	Gets/Sets whether or not this Mesh should automatically build edge lists
            	when asked for them, or whether it should never build them if
            	they are not already provided.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.SharedVertexData">
            <summary>
            	Gets/Sets the shared VertexData for this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.SubMeshCount">
            <summary>
               Gets the number of submeshes belonging to this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.BoundingBox">
            <summary>
            	Gets/Sets the bounding box for this mesh.
            </summary>
            <remarks>
            	Setting this property is required when building manual meshes now, because Axiom can no longer 
            	update the bounds for you, because it cannot necessarily read vertex data back from 
            	the vertex buffers which this mesh uses (they very well might be write-only, and even
            	if they are not, reading data from a hardware buffer is a bottleneck).
            </remarks>
        </member>
        <member name="P:Axiom.Core.Mesh.BoundingSphereRadius">
            <summary>
               Bounding spehere radius from this mesh in local coordinates.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.HasSkeleton">
            <summary>
               Determins whether or not this mesh has a skeleton associated with it.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IndexBufferUsage">
            <summary>
               Gets the usage setting for this meshes index buffers.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.UseIndexShadowBuffer">
            <summary>
               Gets whether or not this meshes index buffers are shadowed.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IsEdgeListBuilt">
            <summary>
                Returns whether this mesh has an attached edge list.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IsLodManual">
            <summary>
                Returns true if this mesh is using manual LOD.
            </summary>
            <remarks>
                A mesh can either use automatically generated LOD, or it can use alternative
                meshes as provided by an artist. A mesh can only use either all manual LODs 
                or all generated LODs, not a mixture of both.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Mesh.IsManuallyDefined">
            <summary>
            	Defines whether this mesh is to be loaded from a resource, or created manually at runtime.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.IsPreparedForShadowVolumes">
            <summary>
            	Gets whether this mesh has already had it's geometry prepared for use in 
            	rendering shadow volumes.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.LodLevelCount">
            <summary>
            	Gets the current number of Lod levels associated with this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.Skeleton">
            <summary>
               Gets the skeleton currently bound to this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.SkeletonName">
            <summary>
               Get/Sets the name of the skeleton which will be bound to this mesh.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.VertexBufferUsage">
            <summary>
               Gets the usage setting for this meshes vertex buffers.
            </summary>
        </member>
        <member name="P:Axiom.Core.Mesh.UseVertexShadowBuffer">
            <summary>
               Gets whether or not this meshes vertex buffers are shadowed.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchMesh.patchSurface">
            <summary>
                Internal surface definition.
            </summary>
        </member>
        <member name="F:Axiom.Core.PatchMesh.vertexDeclaration">
            <summary>
                Vertex declaration, cloned from the input.
            </summary>
        </member>
        <member name="M:Axiom.Core.PatchMesh.#ctor(System.String,System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Core.VisibleSide,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)">
            <summary>
                Creates a new PatchMesh.
            </summary>
            <remarks>
                As defined in <see cref="M:Axiom.Core.MeshManager.CreateBezierPatch(System.String,System.Array,Axiom.Graphics.VertexDeclaration,System.Int32,System.Int32,System.Int32,System.Int32,Axiom.Core.VisibleSide,Axiom.Graphics.BufferUsage,Axiom.Graphics.BufferUsage,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="T:Axiom.Core.ObjectCreator">
            <summary>
            Used by configuration classes to store assembly/class names and instantiate
            objects from them.
            </summary>
        </member>
        <member name="T:Axiom.Core.MeshLodUsage">
            <summary>
                 A way of recording the way each LOD is recorded this Mesh.
             </summary>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.fromSquaredDepth">
            <summary>
            	Squared Z value from which this LOD will apply.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.manualName">
            <summary>
            Only relevant if isLodManual is true, the name of the alternative mesh to use.
            </summary>
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.manualMesh">
            <summary>
            	Reference to the manual mesh to avoid looking up each time.
            </summary>    	
        </member>
        <member name="F:Axiom.Core.MeshLodUsage.edgeData">
            <summary>
            	Edge list for this LOD level (may be derived from manual mesh).	
            </summary>
        </member>
        <member name="T:Axiom.Core.Entity">
            <summary>
               Defines an instance of a discrete, movable object based on a Mesh.
            </summary>
            <remarks>
            	Axiom generally divides renderable objects into 2 groups, discrete
            	(separate) and relatively small objects which move around the world,
            	and large, sprawling geometry which makes up generally immovable
            	scenery, aka 'level geometry'.
            	<para>
            	The <see cref="P:Axiom.Core.Entity.Mesh"/> and <see cref="T:Axiom.Core.SubMesh"/> classes deal with the definition of the geometry
            	used by discrete movable objects. Entities are actual instances of
            	objects based on this geometry in the world. Therefore there is
            	usually a single set <see cref="P:Axiom.Core.Entity.Mesh"/> for a car, but there may be multiple
            	entities based on it in the world. Entities are able to override
            	aspects of the Mesh it is defined by, such as changing material
            	properties per instance (so you can have many cars using the same
            	geometry but different textures for example). Because a <see cref="P:Axiom.Core.Entity.Mesh"/> is split
            	into a list of <see cref="T:Axiom.Core.SubMesh"/> objects for this purpose, the Entity class is a grouping class
            	(much like the <see cref="P:Axiom.Core.Entity.Mesh"/> class) and much of the detail regarding
            	individual changes is kept in the <see cref="T:Axiom.Core.SubEntity"/> class. There is a 1:1
            	relationship between <see cref="T:Axiom.Core.SubEntity"/> instances and the <see cref="T:Axiom.Core.SubMesh"/> instances
            	associated with the <see cref="P:Axiom.Core.Entity.Mesh"/> the Entity is based on.
            	</para>
            	<para>
            	Entity and <see cref="T:Axiom.Core.SubEntity"/> classes are never created directly. 
            	Use <see cref="M:Axiom.Core.SceneManager.CreateEntity(System.String,System.String)"/> (passing a model name) to
            	create one.
            	</para>
            	<para>
            	Entities are included in the scene by using <see cref="M:Axiom.Core.SceneNode.AttachObject(Axiom.Core.MovableObject)"/>
            	to associate them with a scene node.
            	</para>
            </remarks>
        </member>
        <member name="F:Axiom.Core.Entity.mesh">
            <summary>
               3D Mesh that represents this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.subEntityList">
            <summary>
               List of sub entities.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.sceneMgr">
            <summary>
               SceneManager responsible for creating this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.materialName">
            <summary>
               Name of the material to be used for this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.fullBoundingBox">
            <summary>
               Bounding box that 'contains' all the meshes of each child entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.animationState">
            <summary>
               State of animation for animable meshes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.boneMatrices">
            <summary>
               Cached bone matrices, including and world transforms.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.numBoneMatrices">
            <summary>
               Number of matrices associated with this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.displaySkeleton">
            <summary>
               Flag that determines whether or not to display skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.meshLodIndex">
            <summary>
               The LOD number of the mesh to use, calculated by NotifyCurrentCamera.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.meshLodFactorInv">
            <summary>
               LOD bias factor, inverted for optimization when calculating adjusted depth.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.minMeshLodIndex">
            <summary>
               Index of minimum detail LOD (higher index is lower detail).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.maxMeshLodIndex">
            <summary>
               Index of maximum detail LOD (lower index is higher detail).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.usingManualLod">
            <summary>
               Flag indicating that mesh uses manual LOD and so might have multiple SubEntity versions.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.renderDetail">
            <summary>
               Render detail to be used for this entity (solid, wireframe, point).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.tempBlendedBuffer">
            <summary>
            	Temp blend buffer details for shared geometry.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.sharedBlendedVertexData">
            <summary>
            	Temp blend buffer details for shared geometry.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.useHardwareSkinning">
            <summary>
            	Flag indicating whether hardware skinning is supported by this entity's materials.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.vertexProgramInUse">
            <summary>
                Flag indicating whether we have a vertex program in use on any of our subentities.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.frameAnimationLastUpdated">
            <summary>
            	Records the last frame in which animation was updated.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.skeletonInstance">
            <summary>
            	This entity's personal copy of a master skeleton.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.childObjectList">
            <summary>
            	List of child objects attached to this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.shadowRenderables">
            <summary>
            	List of shadow renderables for this entity.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.materialLodFactorInv">
            <summary>
            	LOD bias factor, inverted for optimisation when calculating adjusted depth.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.minMaterialLodIndex">
            <summary>
            	Index of minimum detail LOD (NB higher index is lower detail).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.maxMaterialLodIndex">
            <summary>
            	Index of maximum detail LOD (NB lower index is higher detail).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.frameBonesLastUpdated">
            <summary>
                Frame the bones were last update.
            </summary>
            <remarks>
                Stored as an array so the reference can be shared amongst skeleton instances.
            </remarks>
        </member>
        <member name="F:Axiom.Core.Entity.lodEntityList">
            <summary>
                List of entities with various levels of detail.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.#ctor(System.String,Axiom.Core.Mesh,Axiom.Core.SceneManager)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="mesh"></param>
            <param name="creator"></param>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject)">
            <summary>
            	Attaches another object to a certain bone of the skeleton which this entity uses.
            </summary>
            <remarks>
            	This method can be used to attach another object to an animated part of this entity,
            	by attaching it to a bone in the skeleton (with an offset if required). As this entity 
            	is animated, the attached object will move relative to the bone to which it is attached.
            </remarks>
            <param name="boneName">The name of the bone (in the skeleton) to attach this object.</param>
            <param name="sceneObject">Reference to the object to attach.</param>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject,Axiom.Math.Quaternion)">
            <summary>
            	Attaches another object to a certain bone of the skeleton which this entity uses.
            </summary>
            <param name="boneName">The name of the bone (in the skeleton) to attach this object.</param>
            <param name="sceneObject">Reference to the object to attach.</param>
            <param name="offsetOrientation">An adjustment to the orientation of the attached object, relative to the bone.</param>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectToBone(System.String,Axiom.Core.MovableObject,Axiom.Math.Quaternion,Axiom.Math.Vector3)">
            <summary>
            	Attaches another object to a certain bone of the skeleton which this entity uses.
            </summary>
            <param name="boneName">The name of the bone (in the skeleton) to attach this object.</param>
            <param name="sceneObject">Reference to the object to attach.</param>
            <param name="offsetOrientation">An adjustment to the orientation of the attached object, relative to the bone.</param>
            <param name="offsetPosition">An adjustment to the position of the attached object, relative to the bone.</param>
        </member>
        <member name="M:Axiom.Core.Entity.AttachObjectImpl(Axiom.Core.MovableObject,Axiom.Animating.TagPoint)">
            <summary>
            	Internal implementation of attaching a 'child' object to this entity and assign 
            	the parent node to the child entity.
            </summary>
            <param name="sceneObject">Object to attach.</param>
            <param name="tagPoint">TagPoint to attach the object to.</param>
        </member>
        <member name="M:Axiom.Core.Entity.DetachAllObjectsImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.BuildSubEntities">
            <summary>
            	Used to build a list of sub-entities from the meshes located in the mesh.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.CacheBoneMatrices">
            <summary>
               Protected method to cache bone matrices from a skeleton.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.FindBlendedVertexData(Axiom.Graphics.VertexData)">
            <summary>
            	Internal method - given vertex data which could be from the <see cref="P:Axiom.Core.Entity.Mesh"/> or 
            	any <see cref="T:Axiom.Core.SubMesh"/>, finds the temporary blend copy.
            </summary>
            <param name="originalData"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.FindSubEntityForVertexData(Axiom.Graphics.VertexData)">
            <summary>
            	Internal method - given vertex data which could be from the	Mesh or 
            	any SubMesh, finds the corresponding SubEntity.
            </summary>
            <param name="original"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.UpdateAnimation">
            <summary>
            	Perform all the updates required for an animated entity.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.GetAllAnimationStates">
            <summary>
               For entities based on animated meshes, gets the AnimationState object for a single animation.
            </summary>
            <remarks>
               You animate an entity by updating the animation state objects. Each of these represents the
               current state of each animation available to the entity. The AnimationState objects are
               initialized from the Mesh object.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.GetAnimationState(System.String)">
            <summary>
               For entities based on animated meshes, gets the AnimationState object for a single animation.
            </summary>
            <remarks>
               You animate an entity by updating the animation state objects. Each of these represents the
               current state of each animation available to the entity. The AnimationState objects are
               initialized from the Mesh object.
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.Dispose">
            <summary>
            	
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.GetSubEntity(System.Int32)">
            <summary>
               Gets the SubEntity at the specified index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.GetSubEntity(System.String)">
            <summary>
                Gets a sub entity of this mesh with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Entity.ReevaluateVertexProcessing">
            <summary>
            	Trigger an evaluation of whether hardware skinning is supported for this entity.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.SetMaterialLodBias(System.Single,System.Int32,System.Int32)">
            <summary>
               Sets a level-of-detail bias for the material detail of this entity.
            </summary>
            <remarks>
               Level of detail reduction is normally applied automatically based on the Material 
               settings. However, it is possible to influence this behavior for this entity
               by adjusting the LOD bias. This 'nudges' the material level of detail used for this 
               entity up or down depending on your requirements. You might want to use this
               if there was a particularly important entity in your scene which you wanted to
               detail better than the others, such as a player model.
               <p/>
               There are three parameters to this method; the first is a factor to apply; it 
               defaults to 1.0 (no change), by increasing this to say 2.0, this model would 
               take twice as long to reduce in detail, whilst at 0.5 this entity would use lower
               detail versions twice as quickly. The other 2 parameters are hard limits which 
               let you set the maximum and minimum level-of-detail version to use, after all
               other calculations have been made. This lets you say that this entity should
               never be simplified, or that it can only use LODs below a certain level even
               when right next to the camera.
            </remarks>
            <param name="factor">Proportional factor to apply to the distance at which LOD is changed. 
               Higher values increase the distance at which higher LODs are displayed (2.0 is 
               twice the normal distance, 0.5 is half).</param>
            <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower
               indexes are higher detail: index 0 is the original full detail model).</param>
            <param name="minDetailIndex">The index of the minimum LOD this entity is allowed to use (higher
               indexes are lower detail. Use something like 99 if you want unlimited LODs (the actual
               LOD will be limited by the number in the material)</param>
        </member>
        <member name="M:Axiom.Core.Entity.SetMeshLodBias(System.Single,System.Int32,System.Int32)">
            <summary>
               Sets a level-of-detail bias on this entity.
            </summary>
            <remarks>
               Level of detail reduction is normally applied automatically based on the Mesh 
               settings. However, it is possible to influence this behavior for this entity
               by adjusting the LOD bias. This 'nudges' the level of detail used for this 
               entity up or down depending on your requirements. You might want to use this
               if there was a particularly important entity in your scene which you wanted to
               detail better than the others, such as a player model.
               <p/>
               There are three parameters to this method; the first is a factor to apply; it 
               defaults to 1.0 (no change), by increasing this to say 2.0, this model would 
               take twice as long to reduce in detail, whilst at 0.5 this entity would use lower
               detail versions twice as quickly. The other 2 parameters are hard limits which 
               let you set the maximum and minimum level-of-detail version to use, after all
               other calculations have been made. This lets you say that this entity should
               never be simplified, or that it can only use LODs below a certain level even
               when right next to the camera.
            </remarks>
            <param name="factor">Proportional factor to apply to the distance at which LOD is changed. 
               Higher values increase the distance at which higher LODs are displayed (2.0 is 
               twice the normal distance, 0.5 is half).</param>
            <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower
               indexes are higher detail: index 0 is the original full detail model).</param>
            <param name="minDetailIndex">The index of the minimum LOD this entity is allowed to use (higher
               indexes are lower detail. Use something like 99 if you want unlimited LODs (the actual
               LOD will be limited by the number in the Mesh)</param>
        </member>
        <member name="M:Axiom.Core.Entity.CopyAnimationStateSubset(Axiom.Collections.AnimationStateCollection,Axiom.Collections.AnimationStateCollection)">
            <summary>
                Copies a subset of animation states from source to target.
            </summary>
            <remarks>
                This routine assume target is a subset of source, it will copy all animation state
                of the target with the settings from source.
            </remarks>
            <param name="target">Reference to animation state set which will receive the states.</param>
            <param name="source">Reference to animation state set which will use as source.</param>
        </member>
        <member name="M:Axiom.Core.Entity.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            	
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Core.Entity.PrepareTempBlendedBuffers">
            <summary>
            	Internal method for preparing this Entity for use in animation.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.CloneVertexDataRemoveBlendInfo(Axiom.Graphics.VertexData)">
            <summary>
            	Internal method to clone vertex data definitions but to remove blend buffers.
            </summary>
            <param name="sourceData">Vertex data to clone.</param>
            <returns>A cloned instance of 'source' without blending information.</returns>
        </member>
        <member name="M:Axiom.Core.Entity.ExtractTempBufferInfo(Axiom.Graphics.VertexData,Axiom.Graphics.TempBlendedBufferInfo)">
            <summary>
            	Internal method for extracting metadata out of source vertex data
            	for fast assignment of temporary buffers later.
            </summary>
            <param name="sourceData"></param>
            <param name="info"></param>
        </member>
        <member name="M:Axiom.Core.Entity.Clone(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Entity.BoundingRadius">
            <summary>
               Local bounding radius of this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.ChildObjectsBoundingBox">
            <summary>
               Merge all the child object Bounds and return it.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Entity.DisplaySkeleton">
            <summary>
               Gets/Sets the flag to render the skeleton of this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.HasSkeleton">
            <summary>
            	Returns true if this entity has a skeleton.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.IsHardwareSkinningEnabled">
            <summary>
            	Returns whether or not hardware skinning is enabled.
            </summary>
            <remarks>
            	Because fixed-function indexed vertex blending is rarely supported
            	by existing graphics cards, hardware skinning can only be done if
            	the vertex programs in the materials used to render an entity support
            	it. Therefore, this method will only return true if all the materials
            	assigned to this entity have vertex programs assigned, and all those
            	vertex programs must support 'include_skeletal_animation true'.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Entity.MeshLodIndex">
            <summary>
            
            </summary>
            DOC
        </member>
        <member name="P:Axiom.Core.Entity.Mesh">
            <summary>
            	Gets the 3D mesh associated with this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.MaterialName">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.RenderDetail">
            <summary>
               Sets the rendering detail of this entire entity (solid, wireframe etc).
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.SubEntityCount">
            <summary>
               Gets the number of sub entities that belong to this entity.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.BoneMatrixCount">
            <summary>
            	Gets the number of bone matrices for this entity if it has a skeleton attached.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.BoundingBox">
            <summary>
            	Gets the full local bounding box of this entity.
            </summary>
        </member>
        <member name="T:Axiom.Core.Entity.EntityShadowRenderable">
            <summary>
            	Nested class to allow entity shadows.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.positionBuffer">
            <summary>
            	Shared ref to the position buffer.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.wBuffer">
            <summary>
            	Shared ref to w-coord buffer (optional).
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.originalVertexData">
            <summary>
            	Ref to original vertex data.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.originalPosBufferBinding">
            <summary>
            	Original position buffer source binding.
            </summary>
        </member>
        <member name="F:Axiom.Core.Entity.EntityShadowRenderable.subEntity">
            <summary>
            	Link to SubEntity, only present if SubEntity has it's own geometry.
            </summary>
        </member>
        <member name="M:Axiom.Core.Entity.EntityShadowRenderable.RebindPositionBuffer">
            <summary>
            	Rebind the source positions for temp buffer users.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.EntityShadowRenderable.PositionBuffer">
            <summary>
            	Gets a reference to the position buffer in use by this renderable.
            </summary>
        </member>
        <member name="P:Axiom.Core.Entity.EntityShadowRenderable.WBuffer">
            <summary>
            	Gets a reference to the w-buffer in use by this renderable.
            </summary>
        </member>
        <member name="T:Axiom.Core.Camera">
             <summary>
            		A viewpoint from which the scene will be rendered.
             </summary>
            <remarks>
            		The engine renders scenes from a camera viewpoint into a buffer of
            		some sort, normally a window or a texture (a subclass of
            		RenderTarget). the engine cameras support both perspective projection (the default,
            		meaning objects get smaller the further away they are) and
            		orthographic projection (blueprint-style, no decrease in size
            		with distance). Each camera carries with it a style of rendering,
            		e.g. full textured, flat shaded, wireframe), field of view,
            		rendering distances etc, allowing you to use the engine to create
            		complex multi-window views if required. In addition, more than
            		one camera can point at a single render target if required,
            		each rendering to a subset of the target, allowing split screen
            		and picture-in-picture views.
            		<p/>
            		Cameras maintain their own aspect ratios, field of view, and frustrum,
            		and project co-ordinates into a space measured from -1 to 1 in x and y,
            		and 0 to 1 in z. At render time, the camera will be rendering to a
            		Viewport which will translate these parametric co-ordinates into real screen
            		co-ordinates. Obviously it is advisable that the viewport has the same
            		aspect ratio as the camera to avoid distortion (unless you want it!).
            		<p/>
            		Note that a Camera can be attached to a SceneNode, using the method
            		SceneNode.AttachObject. If this is done the Camera will combine it's own
            		position/orientation settings with it's parent SceneNode. 
            		This is useful for implementing more complex Camera / object
            		relationships i.e. having a camera attached to a world object.
             </remarks>
        </member>
        <member name="F:Axiom.Core.Camera.sceneManager">
            <summary>
            	Parent scene manager.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.orientation">
            <summary>
            	Camera orientation.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.position">
            <summary>
            	Camera position.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.derivedOrientation">
            <summary>
            	Orientation dervied from parent.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.derivedPosition">
            <summary>
            	Position dervied from parent.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.isYawFixed">
            <summary>
            	Whether to yaw around a fixed axis.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.yawFixedAxis">
            <summary>
            	Fixed axis to yaw around.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.sceneDetail">
            <summary>
            	Rendering type (wireframe, solid, point).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.numFacesRenderedLastFrame">
            <summary>
            	Stored number of visible faces in the last render.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.autoTrackTarget">
            <summary>
            	SceneNode which this Camera will automatically track.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.autoTrackOffset">
            <summary>
            	Tracking offset for fine tuning.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.sceneLodFactor">
            <summary>
            	Scene LOD factor used to adjust overall LOD.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.invSceneLodFactor">
            <summary>
            	Inverted scene LOD factor, can be used by Renderables to adjust their LOD.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowLeft">
            <summary>
            	Left window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowRight">
            <summary>
            	Right window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowTop">
            <summary>
            	Top window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowBottom">
            <summary>
            	Bottom window edge (window clip planes).
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.isWindowSet">
            <summary>
            	Is viewing window used.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.windowClipPlanes">
            <summary>
            	Windowed viewport clip planes.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.recalculateWindow">
            <summary>
            	Was viewing window changed?
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.lastViewport">
            <summary>
            	The last viewport to be added using this camera.
            </summary>
        </member>
        <member name="F:Axiom.Core.Camera.autoAspectRatio">
            <summary>
            	Whether aspect ratio will automaticaally be recalculated when a vieport changes its size.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.GetOrientationForViewUpdate">
            <summary>
            	Get the derived orientation of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.GetPositionForViewUpdate">
            <summary>
            	Get the derived position of this frustum.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.InvalidateView">
            <summary>
            	Signal to update view information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.InvalidateFrustum">
            <summary>
            	Signal to update frustum information.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.UpdateFrustum">
            <summary>
            	Updates the frustum data.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.UpdateView">
            <summary>
            	Updates the view matrix.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.NotifyRenderedFaces(System.Int32)">
            <summary>
               Called by the scene manager to let this camera know how many faces were renderer within
               view of this camera every frame.
            </summary>
            <param name="renderedFaceCount"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Move(Axiom.Math.Vector3)">
            <summary>
            Moves the camera's position by the vector offset provided along world axes.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Axiom.Core.Camera.MoveRelative(Axiom.Math.Vector3)">
            <summary>
            Moves the camera's position by the vector offset provided along it's own axes (relative to orientation).
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Axiom.Core.Camera.LookAt(Axiom.Math.Vector3)">
            <summary>
            	Specifies a target that the camera should look at.
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Pitch(System.Single)">
            <summary>
            	Pitches the camera up/down counter-clockwise around it's local x axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Yaw(System.Single)">
            <summary>
            	Rolls the camera counter-clockwise, in degrees, around its local y axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Roll(System.Single)">
            <summary>
            	Rolls the camera counter-clockwise, in degrees, around its local z axis.
            </summary>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Rotate(Axiom.Math.Quaternion)">
            <summary>
            	Rotates the camera about an arbitrary axis.
            </summary>
            <param name="quat"></param>
        </member>
        <member name="M:Axiom.Core.Camera.Rotate(Axiom.Math.Vector3,System.Single)">
            <summary>
            	Rotates the camera about an arbitrary axis.
            </summary>
            <param name="axis"></param>
            <param name="degrees"></param>
        </member>
        <member name="M:Axiom.Core.Camera.SetAutoTracking(System.Boolean,Axiom.Core.MovableObject)">
            <summary>
            	Enables / disables automatic tracking of a SceneObject.
            </summary>
            <remarks>
            	If you enable auto-tracking, this Camera will automatically rotate to
            	look at the target SceneNode every frame, no matter how 
            	it or SceneNode move. This is handy if you want a Camera to be focused on a
            	single object or group of objects. Note that by default the Camera looks at the 
            	origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            	attached to this target node is quite big and you want to point the camera at
            	a specific point on it, provide a vector in the 'offset' parameter and the 
            	camera's target point will be adjusted.
            </remarks>
            <param name="enabled">If true, the Camera will track the SceneNode supplied as the next 
            	parameter (cannot be null). If false the camera will cease tracking and will
            	remain in it's current orientation.
             </param> 
            <param name="target">The SceneObject which this Camera will track.</param>
        </member>
        <member name="M:Axiom.Core.Camera.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode)">
            <summary>
            	Enables / disables automatic tracking of a SceneNode.
            </summary>
            <remarks>
            	If you enable auto-tracking, this Camera will automatically rotate to
            	look at the target SceneNode every frame, no matter how 
            	it or SceneNode move. This is handy if you want a Camera to be focused on a
            	single object or group of objects. Note that by default the Camera looks at the 
            	origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            	attached to this target node is quite big and you want to point the camera at
            	a specific point on it, provide a vector in the 'offset' parameter and the 
            	camera's target point will be adjusted.
            </remarks>
            <param name="enabled">If true, the Camera will track the SceneNode supplied as the next 
            	parameter (cannot be null). If false the camera will cease tracking and will
            	remain in it's current orientation.
             </param> 
            <param name="target">The SceneNode which this Camera will track. Make sure you don't
            	delete this SceneNode before turning off tracking (e.g. SceneManager.ClearScene will
            	delete it so be careful of this). Can be null if and only if the enabled param is false.
            </param>
        </member>
        <member name="M:Axiom.Core.Camera.SetAutoTracking(System.Boolean,Axiom.Core.SceneNode,Axiom.Math.Vector3)">
            <summary>
            	Enables / disables automatic tracking of a SceneNode.
            </summary>
            <remarks>
            	If you enable auto-tracking, this Camera will automatically rotate to
            	look at the target SceneNode every frame, no matter how 
            	it or SceneNode move. This is handy if you want a Camera to be focused on a
            	single object or group of objects. Note that by default the Camera looks at the 
            	origin of the SceneNode, if you want to tweak this, e.g. if the object which is
            	attached to this target node is quite big and you want to point the camera at
            	a specific point on it, provide a vector in the 'offset' parameter and the 
            	camera's target point will be adjusted.
            </remarks>
            <param name="enabled">If true, the Camera will track the SceneNode supplied as the next 
            	parameter (cannot be null). If false the camera will cease tracking and will
            	remain in it's current orientation.
             </param> 
            <param name="target">The SceneNode which this Camera will track. Make sure you don't
            	delete this SceneNode before turning off tracking (e.g. SceneManager.ClearScene will
            	delete it so be careful of this). Can be null if and only if the enabled param is false.
            </param>
            <param name="offset">If supplied, the camera targets this point in local space of the target node
            	instead of the origin of the target node. Good for fine tuning the look at point.
            </param>
        </member>
        <member name="M:Axiom.Core.Camera.SetWindow(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            	Sets the viewing window inside of viewport.
            </summary>
            <remarks>
            	This method can be used to set a subset of the viewport as the rendering target. 
            </remarks>
            <param name="left">Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 0).</param>
            <param name="top">Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 0).</param>
            <param name="right">Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 1).</param>
            <param name="bottom">Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 1).</param>
        </member>
        <member name="M:Axiom.Core.Camera.SetWindowImpl">
            <summary>
            	Do actual window setting, using parameters set in <see cref="M:Axiom.Core.Camera.SetWindow(System.Single,System.Single,System.Single,System.Single)"/> call.
            </summary>
            <remarks>The method is called after projection matrix each change.</remarks>
        </member>
        <member name="M:Axiom.Core.Camera.ResetWindow">
            <summary>
            	Cancel view window.
            </summary>
        </member>
        <member name="M:Axiom.Core.Camera.GetWindowPlane(System.Int32)">
            <summary>
            	Gets the window plane at the specified index.
            </summary>
            <param name="index">Index of the plane to get.</param>
            <returns>The window plane at the specified index.</returns>
        </member>
        <member name="M:Axiom.Core.Camera.GetCameraToViewportRay(System.Single,System.Single)">
            <summary>
                Gets a world space ray as cast from the camera through a viewport position.
            </summary>
            <param name="screenX">
                The x position at which the ray should intersect the viewport, 
                in normalised screen coordinates [0,1].
            </param>
            <param name="screenY">
                The y position at which the ray should intersect the viewport, 
                in normalised screen coordinates [0,1].
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Core.Camera.NotifyViewport(Axiom.Core.Viewport)">
            <summary>
            	Notifies this camera that a viewport is using it.
            </summary>
            <param name="viewport">Viewport that is using this camera.</param>
        </member>
        <member name="M:Axiom.Core.Camera.RenderScene(Axiom.Core.Viewport,System.Boolean)">
            <summary>
            	Called to ask a camera to render the scene into the given viewport.
            </summary>
            <param name="viewport"></param>
            <param name="showOverlays"></param>
        </member>
        <member name="M:Axiom.Core.Camera.AutoTrack">
            <summary>
            	Updates an auto-tracking camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.IsViewOutOfDate">
            <summary>
            	Evaluates whether or not the view matrix is out of date.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Axiom.Core.Camera.BoundingRadius">
            <summary>
            	Overridden to return a proper bounding radius for the camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.AutoAspectRatio">
            <summary>
            	If set to true a vieport that owns this frustum will be able to 
            	recalculate the aspect ratio whenever the frustum is resized.
            </summary>
            <remarks>
            	You should set this to true only if the frustum / camera is used by 
            	one viewport at the same time. Otherwise the aspect ratio for other 
            	viewports may be wrong.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.SceneManager">
            <summary>
               Returns the current SceneManager that this camera is using.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.SceneDetail">
            <summary>
            	Sets the level of rendering detail required from this camera.
            </summary>
            <remarks>
            	Each camera is set to render at full detail by default, that is
            	with full texturing, lighting etc. This method lets you change
            	that behavior, allowing you to make the camera just render a
            	wireframe view, for example.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.Orientation">
            <summary>
                Gets/Sets the camera's orientation.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Position">
            <summary>
                Gets/Sets the camera's position.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Direction">
            <summary>
            	Gets/Sets the camera's direction vector.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Right">
            <summary>
            	Gets camera's 'right' vector.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Up">
            <summary>
            	Gets camera's 'up' vector.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.Viewport">
            <summary>
            	Get the last viewport which was attached to this camera. 
            </summary>
            <remarks>
            	This is not guaranteed to be the only viewport which is
            	using this camera, just the last once which was created referring
            	to it.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.FixedYawAxis">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.LodBias">
            <summary>
                Sets the level-of-detail factor for this Camera.
            </summary>
            <remarks>
                This method can be used to influence the overall level of detail of the scenes 
                rendered using this camera. Various elements of the scene have level-of-detail
                reductions to improve rendering speed at distance; this method allows you 
                to hint to those elements that you would like to adjust the level of detail that
                they would normally use (up or down). 
                <p/>
                The most common use for this method is to reduce the overall level of detail used
                for a secondary camera used for sub viewports like rear-view mirrors etc.
                Note that scene elements are at liberty to ignore this setting if they choose,
                this is merely a hint.
                <p/>
                Higher values increase the detail, so 2.0 doubles the normal detail and 0.5 halves it.
            </remarks>
        </member>
        <member name="P:Axiom.Core.Camera.InverseLodBias">
            <summary>
                Used for internal Lod calculations.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.RenderedFaceCount">
            <summary>
            Gets the last count of triangles visible in the view of this camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedOrientation">
            <summary>
            	Gets the derived orientation of the camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedPosition">
            <summary>
            	Gets the derived position of the camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.DerivedDirection">
            <summary>
            	Gets the derived direction of the camera.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.IsWindowSet">
            <summary>
            	Gets the flag specifying if a viewport window is being used.
            </summary>
        </member>
        <member name="P:Axiom.Core.Camera.WindowPlaneCount">
            <summary>
            	Gets the number of window clip planes for this camera.
            </summary>
            <remarks>Only applicable if IsWindowSet == true.
            </remarks>
        </member>
        <member name="T:Axiom.Collections.SubMeshCollection">
            <summary>
            Summary description for SubMeshCollection.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SubMeshCollection.#ctor">
            <summary>
            	Default constructor.
            </summary>
        </member>
        <member name="M:Axiom.Collections.SubMeshCollection.Add(Axiom.Core.SubMesh)">
            <summary>
            	Adds an object to the collection.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Axiom.Collections.SubMeshCollection.Add(System.String,Axiom.Core.SubMesh)">
            <summary>
            	Adds a named object to the collection.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
        </member>
        <member name="P:Axiom.Collections.SubMeshCollection.Item(System.Int32)">
            <summary>
            	Get/Set indexer that allows access to the collection by index.
            </summary>
        </member>
        <member name="P:Axiom.Collections.SubMeshCollection.Item(System.String)">
            <summary>
            	Get/Set indexer that allows access to the collection by key value.
            </summary>
        </member>
        <member name="T:Axiom.Collections.HashList">
            <summary>
            	Summary description for HashList.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Axiom.ParticleSystems.ParticleEmitterFactory" -->
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.#ctor">
            <summary>
            	Default constructor
            </summary>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.Create">
            <summary>
            	Creates a new instance of an emitter.
            </summary>
            <remarks>
            	Subclasses must add newly created emitters to the emitterList.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.ParticleSystems.ParticleEmitterFactory.Destroy(Axiom.ParticleSystems.ParticleEmitter)">
            <summary>
            	Destroys the emitter referenced by the parameter.
            </summary>
            <param name="emitter"></param>
        </member>
        <member name="P:Axiom.ParticleSystems.ParticleEmitterFactory.Name">
            <summary>
            	Returns the name of the factory, which identifies which type of emitter this factory creates.
            </summary>
        </member>
        <member name="T:Axiom.Overlays.Elements.TextArea">
            <summary>
            	Label type control that can be used to display text using a specified font.
            </summary>
        </member>
        <member name="F:Axiom.Overlays.Elements.TextArea.colorBottom">
            Colors to use for the vertices
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.#ctor(System.String)">
            <summary>
               Basic constructor, internal since it should only be created by factories.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.CheckMemoryAllocation(System.Int32)">
            <summary>
               
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.GetRenderOperation(Axiom.Graphics.RenderOperation)">
            <summary>
            
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.Update">
            <summary>
               Override to update char sizing based on current viewport settings.
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.UpdateColors">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.UpdateGeometry">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Overlays.Elements.TextArea.UpdatePositionGeometry">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.CharHeight">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.Color">
            <summary>
               Gets/Sets the color value of the text when it is all the same color.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.ColorTop">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.ColorBottom">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.FontName">
            <summary>
               Gets/Sets the name of the font currently being used when rendering the text.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.MaterialName">
            <summary>
               Override to update geometry when new material is assigned.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.MetricsMode">
            <summary>
               Override to handle character spacing
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.SpaceWidth">
            <summary>
               
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.TextAlign">
            <summary>
               Alignment of text specifically.
            </summary>
        </member>
        <member name="P:Axiom.Overlays.Elements.TextArea.Text">
            <summary>
               Override to update string geometry.
            </summary>
        </member>
        <member name="T:Axiom.Media.PNGCodec">
            <summary>
               PNG image file codec.
            </summary>
        </member>
        <member name="M:Axiom.Media.PNGCodec.Decode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
               Passthrough implementation, no special code needed.
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Media.PNGCodec.Encode(System.IO.Stream,System.IO.Stream,System.Object[])">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="args"></param>
        </member>
        <member name="P:Axiom.Media.PNGCodec.Type">
            <summary>
               Returns the PNG file extension.
            </summary>
        </member>
        <member name="P:Axiom.Media.PNGCodec.ILType">
            <summary>
               Returns PNG enum.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Vector3List">
            <summary>
            	A strongly-typed collection of <see cref="T:Axiom.Math.Vector3"/> objects.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Synchronized(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Creates a synchronized (thread-safe) wrapper for a 
                <c>Vector3List</c> instance.
            </summary>
            <returns>
                An <c>Vector3List</c> wrapper that is synchronized (thread-safe).
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.ReadOnly(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Creates a read-only wrapper for a 
                <c>Vector3List</c> instance.
            </summary>
            <returns>
                An <c>Vector3List</c> wrapper that is read-only.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor(System.Int32)">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that has the specified initial capacity.
            </summary>
            <param name="capacity">
            	The number of elements that the new <c>Vector3List</c> is initially capable of storing.
            </param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that contains elements copied from the specified <c>Vector3List</c>.
            </summary>
            <param name="c">The <c>Vector3List</c> whose elements are copied to the new collection.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.#ctor(Axiom.Math.Vector3[])">
            <summary>
            	Initializes a new instance of the <c>Vector3List</c> class
            	that contains elements copied from the specified <see cref="T:Axiom.Math.Vector3"/> array.
            </summary>
            <param name="a">The <see cref="T:Axiom.Math.Vector3"/> array whose elements are copied to the new list.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.CopyTo(Axiom.Math.Vector3[])">
            <summary>
            	Copies the entire <c>Vector3List</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Vector3"/> array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Vector3"/> array to copy to.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.CopyTo(Axiom.Math.Vector3[],System.Int32)">
            <summary>
            	Copies the entire <c>Vector3List</c> to a one-dimensional
            	<see cref="T:Axiom.Math.Vector3"/> array, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:Axiom.Math.Vector3"/> array to copy to.</param>
            <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Add(Axiom.Math.Vector3)">
            <summary>
            	Adds a <see cref="T:Axiom.Math.Vector3"/> to the end of the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to be added to the end of the <c>Vector3List</c>.</param>
            <returns>The index at which the value has been added.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Clear">
            <summary>
            	Removes all elements from the <c>Vector3List</c>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Clone">
            <summary>
            	Creates a shallow copy of the <see cref="T:Axiom.Math.Collections.Vector3List"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Contains(Axiom.Math.Vector3)">
            <summary>
            	Determines whether a given <see cref="T:Axiom.Math.Vector3"/> is in the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to check for.</param>
            <returns><c>true</c> if <paramref name="item"/> is found in the <c>Vector3List</c>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.IndexOf(Axiom.Math.Vector3)">
            <summary>
            	Returns the zero-based index of the first occurrence of a <see cref="T:Axiom.Math.Vector3"/>
            	in the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to locate in the <c>Vector3List</c>.</param>
            <returns>
            	The zero-based index of the first occurrence of <paramref name="item"/> 
            	in the entire <c>Vector3List</c>, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Insert(System.Int32,Axiom.Math.Vector3)">
            <summary>
            	Inserts an element into the <c>Vector3List</c> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to insert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Remove(Axiom.Math.Vector3)">
            <summary>
            	Removes the first occurrence of a specific <see cref="T:Axiom.Math.Vector3"/> from the <c>Vector3List</c>.
            </summary>
            <param name="item">The <see cref="T:Axiom.Math.Vector3"/> to remove from the <c>Vector3List</c>.</param>
            <exception cref="T:System.ArgumentException">
            	The specified <see cref="T:Axiom.Math.Vector3"/> was not found in the <c>Vector3List</c>.
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.RemoveAt(System.Int32)">
            <summary>
            	Removes the element at the specified index of the <c>Vector3List</c>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.GetEnumerator">
            <summary>
            	Returns an enumerator that can iterate through the <c>Vector3List</c>.
            </summary>
            <returns>An <see cref="T:Axiom.Math.Collections.Vector3List.Enumerator"/> for the entire <c>Vector3List</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.AddRange(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Adds the elements of another <c>Vector3List</c> to the current <c>Vector3List</c>.
            </summary>
            <param name="x">The <c>Vector3List</c> whose elements should be added to the end of the current <c>Vector3List</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.Vector3List.Count"/> of the <c>Vector3List</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.AddRange(Axiom.Math.Vector3[])">
            <summary>
            	Adds the elements of a <see cref="T:Axiom.Math.Vector3"/> array to the current <c>Vector3List</c>.
            </summary>
            <param name="x">The <see cref="T:Axiom.Math.Vector3"/> array whose elements should be added to the end of the <c>Vector3List</c>.</param>
            <returns>The new <see cref="P:Axiom.Math.Collections.Vector3List.Count"/> of the <c>Vector3List</c>.</returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.TrimToSize">
            <summary>
            	Sets the capacity to the actual number of elements.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.ValidateIndex(System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.ValidateIndex(System.Int32,System.Boolean)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Count">
            <summary>
            	Gets the number of elements actually contained in the <c>Vector3List</c>.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IsSynchronized">
            <summary>
            	Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
            <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.SyncRoot">
            <summary>
            	Gets an object that can be used to synchronize access to the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Item(System.Int32)">
            <summary>
            	Gets or sets the <see cref="T:Axiom.Math.Vector3"/> at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<para><paramref name="index"/> is less than zero</para>
            	<para>-or-</para>
            	<para><paramref name="index"/> is equal to or greater than <see cref="P:Axiom.Math.Collections.Vector3List.Count"/>.</para>
            </exception>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IsFixedSize">
            <summary>
            	Gets a value indicating whether the collection has a fixed size.
            </summary>
            <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IsReadOnly">
            <summary>
            	gets a value indicating whether the <B>IList</B> is read-only.
            </summary>
            <value>true if the collection is read-only; otherwise, false. The default is false</value>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Capacity">
            <summary>
            	Gets or sets the number of elements the <c>Vector3List</c> can contain.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator">
            <summary>
            	Supports type-safe iteration over a <see cref="T:Axiom.Math.Collections.Vector3List"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.IVector3ListEnumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Math.Collections.Vector3List.Enumerator">
            <summary>
            	Supports simple iteration over a <see cref="T:Axiom.Math.Collections.Vector3List"/>.
            </summary>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Enumerator.#ctor(Axiom.Math.Collections.Vector3List)">
            <summary>
            	Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
            <param name="tc"></param>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created.
            </exception>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:Axiom.Math.Collections.Vector3List.Enumerator.Reset">
            <summary>
            	Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
        </member>
        <member name="P:Axiom.Math.Collections.Vector3List.Enumerator.Current">
            <summary>
            	Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Axiom.Math.PositionalSpline">
            <summary>
            	A Catmull-Rom spline that can be used for interpolating translation movements.
            </summary>
            <remarks>
            	A Catmull-Rom spline is a derivitive of the Hermite spline.  The difference is that the Hermite spline
            	allows you to specifiy 2 endpoints and 2 tangents, then the spline is generated.  A Catmull-Rom spline
            	allows you to just supply 1-n number of points and the tangents will be automatically calculated.
            	<p/>
            	Derivation of the hermite polynomial can be found here: 
            	<a href="http://www.cs.unc.edu/~hoff/projects/comp236/curves/papers/hermite.html">Hermite splines.</a>
            </remarks>
        </member>
        <member name="F:Axiom.Math.PositionalSpline.pointList">
            <summary>Collection of control points.</summary>
        </member>
        <member name="F:Axiom.Math.PositionalSpline.tangentList">
            <summary>Collection of generated tangents for the spline controls points.</summary>
        </member>
        <member name="F:Axiom.Math.PositionalSpline.autoCalculateTangents">
            <summary>Specifies whether or not to recalculate tangents as each control point is added.</summary>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.#ctor">
            <summary>
            	Creates a new Positional Spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.AddPoint(Axiom.Math.Vector3)">
            <summary>
               Adds a new control point to the end of this spline.
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.Clear">
            <summary>
               Removes all current control points from this spline.
            </summary>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.GetPoint(System.Int32)">
            <summary>
                Returns the point at the specified index.
            </summary>
            <param name="index">Index at which to retreive a point.</param>
            <returns>Vector3 containing the point data.</returns>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.Interpolate(System.Single)">
            <summary>
            	Returns an interpolated point based on a parametric value over the whole series.
            </summary>
            <remarks>
            	Given a t value between 0 and 1 representing the parametric distance along the
            	whole length of the spline, this method returns an interpolated point.
            </remarks>
            <param name="t">Parametric value.</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.Interpolate(System.Int32,System.Single)">
            <summary>
            	Interpolates a single segment of the spline given a parametric value.
            </summary>
            <param name="index">The point index to treat as t=0. index + 1 is deemed to be t=1</param>
            <param name="t">Parametric value</param>
            <returns>An interpolated point along the spline.</returns>
        </member>
        <member name="M:Axiom.Math.PositionalSpline.RecalculateTangents">
            <summary>
            	Recalculates the tangents associated with this spline. 
            </summary>
            <remarks>
            	If you tell the spline not to update on demand by setting AutoCalculate to false,
            	then you must call this after completing your updates to the spline points.
            </remarks>
        </member>
        <member name="P:Axiom.Math.PositionalSpline.AutoCalculate">
            <summary>
            	Specifies whether or not to recalculate tangents as each control point is added.
            </summary>
        </member>
        <member name="P:Axiom.Math.PositionalSpline.PointCount">
            <summary>
               Gets the number of control points in this spline.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexData">
            <summary>
            	Summary class collecting together vertex source information.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexDeclaration">
            <summary>
            	Declaration of the vertex to be used in this operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexBufferBinding">
            <summary>
            	The vertex buffer bindings to be used.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexStart">
            <summary>
            	The base vertex index to start from, if using unindexed geometry.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.vertexCount">
            <summary>
            	The number of vertices used in this operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexData.hardwareShadowVolWBuffer">
            <summary>
            	Additional shadow volume vertex buffer storage.
            </summary>
            <remarks>
            	This additional buffer is only used where we have prepared this VertexData for
            	use in shadow volume contruction, and where the current render system supports
            	vertex programs. This buffer contains the 'w' vertex position component which will
            	be used by that program to differentiate between extruded and non-extruded vertices.
            	This 'w' component cannot be included in the original position buffer because
            	DirectX does not allow 4-component positions in the fixed-function pipeline, and the original
            	position buffer must still be usable for fixed-function rendering.
            	<p/>
            	Note that we don't store any vertex declaration or vertex buffer binding here becuase this
            	can be reused in the shadow algorithm.
            </remarks>
        </member>
        <member name="M:Axiom.Graphics.VertexData.#ctor">
            <summary>
            	Default constructor.  Calls on the current buffer manager to initialize the bindings and declarations.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.VertexData.Clone">
            <summary>
            	Clones this vertex data, potentially including replicating any vertex buffers.
            </summary>
            <returns>A cloned vertex data object.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexData.Clone(System.Boolean)">
            <summary>
            	Clones this vertex data, potentially including replicating any vertex buffers.
            </summary>
            <param name="copyData">
            	If true, makes a copy the vertex buffer in addition to the definition.
            	If false, the clone will refer to the same vertex buffer this object refers to.
            </param>
            <returns>A cloned vertex data object.</returns>
        </member>
        <member name="M:Axiom.Graphics.VertexData.PrepareForShadowVolume">
            <summary>
            	Modifies the vertex data to be suitable for use for rendering shadow geometry.
            </summary>
            <remarks>
            	<para>
            		Preparing vertex data to generate a shadow volume involves firstly ensuring that the 
            		vertex buffer containing the positions is a standalone vertex buffer,
            		with no other components in it. This method will therefore break apart any existing
            		vertex buffers if position is sharing a vertex buffer. 
            		Secondly, it will double the size of this vertex buffer so that there are 2 copies of 
            		the position data for the mesh. The first half is used for the original, and the second 
            		half is used for the 'extruded' version. The vertex count used to render will remain 
            		the same though, so as not to add any overhead to regular rendering of the object.
            		Both copies of the position are required in one buffer because shadow volumes stretch 
            		from the original mesh to the extruded version. 
            	</para>
            	<para>
            		It's important to appreciate that this method can fundamentally change the structure of your
            		vertex buffers, although in reality they will be new buffers. As it happens, if other 
            		objects are using the original buffers then they will be unaffected because the reference
            		counting will keep them intact. However, if you have made any assumptions about the 
            		structure of the vertex data in the buffers of this object, you may have to rethink them.
            	</para>
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.IndexData">
            <summary>
            	Summary class collecting together index data source information.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IndexData.indexBuffer">
            <summary>
            	Reference to the <see cref="T:Axiom.Graphics.HardwareIndexBuffer"/> to use, must be specified if useIndexes = true
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IndexData.indexStart">
            <summary>
            	Index in the buffer to start from for this operation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IndexData.indexCount">
            <summary>
            	The number of indexes to use from the buffer.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.IndexData.Clone">
            <summary>
            	Creates a copy of the index data object, without a copy of the buffer data.
            </summary>
            <returns>A copy of this IndexData object without the data.</returns>
        </member>
        <member name="M:Axiom.Graphics.IndexData.Clone(System.Boolean)">
            <summary>
            	Clones this vertex data, potentially including replicating any index buffers.
            </summary>
            <param name="copyData">
            	If true, makes a copy the index buffer in addition to the definition.
            	If false, the clone will refer to the same index buffer this object refers to.
            </param>
            <returns>A copy of this IndexData object.</returns>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramManager">
            <summary>
            	Summary description for GpuProgramManager.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
            <remarks>
                Protected internal because this singleton will actually hold the instance of a subclass
                created by a render system plugin.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramManager.syntaxCodes">
            <summary>
               Collection of syntax codes that this program manager supports.
            </summary>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.Create(System.String)">
            <summary>
                Overrides the base Create method to enforce the use of Load or Create instead.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.Create(System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Creates a new GpuProgram.
            </summary>
            <param name="name">
               Name of the program to create.
            </param>
            <param name="type">
               Type of the program to create, i.e. vertex or fragment.
            </param>
            <param name="syntaxCode">
               Syntax of the program, i.e. vs_1_1, arbvp1, etc.
            </param>
            <returns>
               A new instance of GpuProgram.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.CreateProgram(System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Create a new, unloaded GpuProgram from a file of assembly.
            </summary>
            <remarks>
               Use this method in preference to the 'load' methods if you wish to define
               a GpuProgram, but not load it yet; useful for saving memory.
            </remarks>
            <param name="name">
               The name of the program.
            </param>
            <param name="fileName">
               The file to load.
            </param>
            <param name="syntaxCode">
               Name of the syntax to use for the program, i.e. vs_1_1, arbvp1, etc.
            </param>
            <returns>
               An unloaded GpuProgram instance.
            </returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.CreateProgramFromString(System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Create a new, unloaded GpuProgram from a string of assembly code.
            </summary>
            <remarks>
               Use this method in preference to the 'load' methods if you wish to define
               a GpuProgram, but not load it yet; useful for saving memory.
            </remarks>
            <param name="name">
               The name of the program.
            </param>
            <param name="source">
               The asm source of the program to create.
            </param>
            <param name="syntaxCode">
               Name of the syntax to use for the program, i.e. vs_1_1, arbvp1, etc.
            </param>
            <returns>An unloaded GpuProgram instance.</returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.CreateParameters">
            <summary>
               Creates a new GpuProgramParameters instance which can be used to bind parameters 
               to your programs.
            </summary>
            <remarks>
               Program parameters can be shared between multiple programs if you wish.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.IsSyntaxSupported(System.String)">
            <summary>
               Returns whether a given syntax code (e.g. "ps_1_3", "fp20", "arbvp1") is supported. 
            </summary>
            <param name="syntaxCode"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.Load(System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Loads a GPU program from a file of assembly.
            </summary>
            <remarks>
               This method creates a new program of the type specified as the second parameter.
               As with all types of ResourceManager, this class will search for the file in
               all resource locations it has been configured to look in.
            </remarks>
            <param name="name">
               Identifying name of the program to load.
            </param>
            <param name="fileName">
               The file to load.
            </param>
            <param name="type">
               Type of program to create.
            </param>
            <param name="syntaxCode">
               Syntax code of the program, i.e. vs_1_1, arbvp1, etc.
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.LoadFromString(System.String,System.String,Axiom.Graphics.GpuProgramType,System.String)">
            <summary>
               Loads a GPU program from a string containing the assembly source.
            </summary>
            <remarks>
               This method creates a new program of the type specified as the second parameter.
               As with all types of ResourceManager, this class will search for the file in
               all resource locations it has been configured to look in.
            </remarks>
            <param name="name">
               Name used to identify this program.
            </param>
            <param name="source">
               Source code of the program to load.
            </param>
            <param name="type">
               Type of program to create.
            </param>
            <param name="syntaxCode">
               Syntax code of the program, i.e. vs_1_1, arbvp1, etc.
            </param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.PushSyntaxCode(System.String)">
            <summary>
               Used internally to register support for a particular syntax code.
            </summary>
            <param name="code">The syntax code (i.e. vs_1_1).</param>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.GetByName(System.String)">
            <summary>
                Gets a GpuProgram with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Graphics.GpuProgramManager.Dispose">
            <summary>
                Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:Axiom.Graphics.GpuProgramManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.AutoConstants">
            <summary>
               Parameters that are available via the engine and automatically caclulated for use in GPU programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.WorldMatrix">
            <summary>
               Current world matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.WorldMatrixArray3x4">
            <summary>
               The current array of world matrices, as a 3x4 matrix, used for blending.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.WorldMatrixArray">
            <summary>
               The current array of world matrices, used for blending
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.ViewMatrix">
            <summary>
               Current view matrix.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.ProjectionMatrix">
            <summary>
               Current projection matrix.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Graphics.AutoConstants.ViewProjMatrix" -->
        <member name="F:Axiom.Graphics.AutoConstants.WorldViewMatrix">
            <summary>
               Current world and view matrices concatenated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.WorldViewProjMatrix">
            <summary>
               Current world, view, and projection matrics concatenated.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.InverseWorldMatrix">
            <summary>
               Current world matrix, inverted.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.InverseWorldViewMatrix">
            <summary>
               Current world and view matrices concatenated, then inverted.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.AmbientLightColor">
            <summary>
               Global ambient light color.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightDiffuseColor">
            <summary>
               Light diffuse color.  Index determined when setting up auto constants.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightSpecularColor">
            <summary>
               Light specular color.  Index determined when setting up auto constants.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightAttenuation">
            <summary>
               Light attenuation.  Vector4(range, constant, linear, quadratic).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightPosition">
            <summary>
               A light position in world space.  Index determined when setting up auto constants.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightDirection">
            <summary>
               A light direction in world space.  Index determined when setting up auto constants.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightPositionObjectSpace">
            <summary>
               A light position in object space.  Index determined when setting up auto constants.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightDirectionObjectSpace">
            <summary>
               A light direction in object space.  Index determined when setting up auto constants.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.LightDistanceObjectSpace">
            <summary>
               The distance of the light from the center of the object a useful approximation as an 
               alternative to per-vertex distance calculations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.ShadowExtrusionDistance">
            <summary>
               The distance a shadow volume should be extruded when using finite extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.TextureViewProjMatrix">
            <summary>
               The distance a shadow volume should be extruded when using finite extrusion programs.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.CameraPositionObjectSpace">
            <summary>
               The current camera's position in object space.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.Custom">
            <summary>
               A custom parameter which will come from the renderable, using 'data' as the identifier.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.AutoConstants.Time">
            <summary>
            	Specifies that the time elapsed since last frame will be passed along to the program.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferLicenseRelease">
            <summary>
                Describes types of hardware buffer licenses.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLicenseRelease.Manual">
            <summary>
                Licensee will only release buffer when it says so.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLicenseRelease.Automatic">
            <summary>
                Licensee can have license revoked.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferLocking">
            <summary>
            	Describes how a vertex buffer should act when it is locked.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.Normal">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.Discard">
            <summary>
            	Discards the <em>entire</em> buffer while locking; this allows optimisation to be 
            	performed because synchronisation issues are relaxed. Only allowed on buffers 
            	created with the Dynamic flag. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.ReadOnly">
            <summary>
            	Lock the buffer for reading only. Not allowed in buffers which are created with WriteOnly. 
            	Mandatory on static buffers, ie those created without the Dynamic flag.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferLocking.NoOverwrite">
            <summary>
               Potential optimization for some API's.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.BufferUsage">
            <summary>
            	Describes how a vertex buffer is to be used, and affects how it is created.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.Static">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.Dynamic">
            <summary>
            	Indicates the application would like to modify this buffer with the CPU
            	sometimes. Absence of this flag means the application will never modify. 
            	Buffers created with this flag will typically end up in AGP memory rather 
            	than video memory.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.WriteOnly">
            <summary>
            	Indicates the application will never read the contents of the buffer back, 
            	it will only ever write data. Locking a buffer with this flag will ALWAYS 
            	return a pointer to new, blank memory rather than the memory associated 
            	with the contents of the buffer; this avoids DMA stalls because you can 
            	write to a new memory area while the previous one is being used
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.StaticWriteOnly">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.BufferUsage.DynamicWriteOnly">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Capabilities">
            <summary>
            	Various types of capabilities supported by hardware that must be checked.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.StencilBuffer">
            <summary>
            	Supports hardware stencil buffer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.AnisotropicFiltering">
            <summary>
            	Supports anisotropic texture filtering.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.Dot3">
            <summary>
            	Supports fixed-function DOT3 texture blend.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.VertexBuffer">
            <summary>
            	Supports hardware vertex and index buffers.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.HardwareMipMaps">
            <summary>
            	Supports generating mipmaps in hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.CubeMapping">
            <summary>
            	Supports cube mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.VertexPrograms">
            <summary>
            	Supports vertex programs (vertex shaders).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.FragmentPrograms">
            <summary>
            	Supports fragment programs (pixel shaders).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureCompression">
            <summary>
            	Supports compressed textures.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureCompressionDXT">
            <summary>
            	Supports compressed textures in the DXT/ST3C formats.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TextureCompressionVTC">
            <summary>
            	Supports compressed textures in the VTC format.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.ScissorTest">
            <summary>
            	Supports performing a scissor test to exclude areas of the screen.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.TwoSidedStencil">
            <summary>
            	Supports separate stencil updates for both front and back faces.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.StencilWrap">
            <summary>
            	Supports wrapping the stencil value at the range extremeties.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.HardwareOcculusion">
            <summary>
            	Hardware occlusion queries.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.UserClipPlanes">
            <summary>
            	User clipping planes.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.VertexFormatUByte4">
            <summary>
            	4 byte wide vertex elemet format.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Capabilities.InfiniteFarPlane">
            <summary>
            	Infinite far plane projection
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CompareFunction">
            <summary>
             Comparison functions, for things such as stencil buffer or depth comparisons.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.CullingMode">
            <summary>
            Options for deciding what geometry gets excluded from the rendering process.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.CullingMode.None">
            <summary>
            	Draw everything (2 sided geometry).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CullingMode.Clockwise">
            <summary>
            	Only draw geomtry where vertices were specified in clockwise order.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.CullingMode.CounterClockwise">
            <summary>
            	Only draw geomtry where vertices were specified in counterclockwise order.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.EnvironmentMap">
            <summary>
            	Specifes the type of environment mapping to use.
            </summary>
            <remarks>
               Note that these have no effect when using the programmable pipeline, since their
               effect is overridden by the vertex / fragment programs.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Curved">
            <summary>
            	Envmap based on vector from camera to vertex position, good for planar geometry.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Planar">
            <summary>
            	Envmap based on dot of vector from camera to vertex and vertex normal, good for curves.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Reflection">
            <summary>
            	Envmap entended to supply reflection vectors for cube mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.EnvironmentMap.Normal">
            <summary>
            	Envmap entended to supply normal vectors for cube mapping
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FaceGroup">
            <summary>
                A type of face group, i.e. face list of procedural etc
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FilterOptions">
            <summary>
               Filtering options for textures / mipmaps.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.None">
            <summary>
               No filtering, used for FilterType.Mip to turn off mipmapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.Point">
            <summary>
               Use the closest pixel.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.Linear">
            <summary>
               Average of a 2x2 pixel area, denotes bilinear for Min and Mag, trilinear for Mip.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterOptions.Anisotropic">
            <summary>
               Similar to Linear, but compensates for the angle of the texture plane.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FilterType">
            <summary>
               Stages of texture rendering to which filters can be applied.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterType.Min">
            <summary>
               The filter used when shrinking a texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterType.Mag">
            <summary>
               The filter used when magnifiying a texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FilterType.Mip">
            <summary>
               The filter used when determining the mipmap.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FogMode">
            <summary>
            Type of fog to use in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.None">
            <summary>
            	No fog.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.Exp">
            <summary>
            	Fog density increases exponentially from the camera (fog = 1/e^(distance * density)).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.Exp2">
            <summary>
            	Fog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.FogMode.Linear">
            <summary>
            	Fog density increases linearly between the start and end distances.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramType">
            <summary>
               Enumerates the types of programs which can run on the GPU.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramType.Vertex">
            <summary>
               Executes for each vertex passed through the pipeline while this program is active.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramType.Fragment">
            <summary>
               Executes for each fragment (or pixel) for primitives that are passed through the pipeline
               while this program is active..
            </summary>
        </member>
        <member name="T:Axiom.Graphics.GpuProgramParameterType">
            <summary>
               Enumerates the types of parameters that can be specified for shaders
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.Indexed">
            <summary>
               Parameter is passed in by index. Used for ASM shaders.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.IndexedAuto">
            <summary>
               Parameter is managed by Axiom and passed in by index. Used for ASM shaders.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.Named">
            <summary>
               Parameter is passed in by name. Used for high-level shaders.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.GpuProgramParameterType.NamedAuto">
            <summary>
               Parameter is managed by Axiom and passed in by name. Used for HL shaders.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.FrameBuffer">
            <summary>
            	Defines the frame buffers which can be cleared.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IlluminationRenderStage">
            <summary>
            	Describes the stage of rendering when performing complex illumination.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.None">
            <summary>
            	No special illumination stage.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.Ambient">
            <summary>
            	Ambient stage, when background light is added.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.PerLight">
            <summary>
            	Diffuse / specular stage, when individual light contributions are added.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.Decal">
            <summary>
            	Decal stage, when texture detail is added to the lit base.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.RenderToTexture">
            <summary>
            	Render to texture stage, used for texture based shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationRenderStage.RenderModulativePass">
            <summary>
            	Modulative render from shadow texture stage.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IlluminationStage">
            <summary>
            	Possible stages of illumination during the rendering process.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationStage.Ambient">
            <summary>
            	Part of the rendering which occurs without any kind of direct lighting.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationStage.PerLight">
            <summary>
            	Part of the rendering which occurs per light.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.IlluminationStage.Decal">
            <summary>
            	Post-lighting rendering.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.IndexType">
            <summary>
            	Type of index buffer to use.
            </summary>
            <remarks>
            	No declarations can begin with a number, so Size prefix is used.
            </remarks>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendOperation">
            <summary>
            	Lists the texture layer operations that are available on both multipass and multitexture
            	hardware.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.Replace">
            <summary>
            	Replace all color with texture and no adjustment.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.Add">
            <summary>
            	Add color components together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.Modulate">
            <summary>
            	Multiply the color components together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperation.AlphaBlend">
            <summary>
            	Blend based on texture alpha.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendOperationEx">
            <summary>
            	Full and complete list of valid texture blending operations.  Fallbacks will be required on older hardware
            	that does not supports some of these multitexturing techniques.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Source1">
            <summary>
            	Use source 1 as is.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Source2">
            <summary>
            	Use source 2 as is.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Modulate">
            <summary>
            	Multiply source 1 and source 2 together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.ModulateX2">
            <summary>
            	Same as Modulate, but brightens as a result.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.ModulateX4">
            <summary>
            	Same as ModuleX2, but brightens even more as a result.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Add">
            <summary>
            	Add source 1 and source 2 together.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.AddSigned">
            <summary>
            	Same as Add, but subtracts 0.5 from the result.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.AddSmooth">
            <summary>
            	Same as Add, but subtracts the product from the sum.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.Subtract">
            <summary>
            	Subtract source 2 from source 1.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendDiffuseAlpha">
            <summary>
            	Use interpolated alpha value from vertices to scale source 1, then add source 2 scaled by 1 - alpha
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendTextureAlpha">
            <summary>
            	Same as BlendDiffuseAlpha, but uses current alpha from the texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendCurrentAlpha">
            <summary>
            	Same as BlendDiffuseAlpha, but uses current alpha from previous stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.BlendManual">
            <summary>
            	Sames as BlendDiffuseAlpha, but uses a constant manual blend value from [0.0,1.0]
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendOperationEx.DotProduct">
            <summary>
            	Takes the dot product of color 1 and color 2.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendSource">
            <summary>
            	Valid sources of values for texture layer blending operations.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Current">
            <summary>
            	The color as built up from previous stages.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Texture">
            <summary>
            	The color derived from the texture assigned to the current layer.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Diffuse">
            <summary>
            	The interpolated diffuse color from the vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Specular">
            <summary>
            	The interpolated specular color from the vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendSource.Manual">
            <summary>
            	A color supplied manually as a seperate argument.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LayerBlendType">
            <summary>
            	Texture blending mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendType.Color">
            <summary>
            	Based on diffuse color of the texture.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LayerBlendType.Alpha">
            <summary>
            	Based on the alpha value of the texture.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.LightType">
            <summary>
            	Defines the types of lights that can be added to a scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.LightType.Point">
            <summary>
            	Point light sources give off light equally in all directions, so require only position not direction.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.LightType.Directional">
            <summary>
            	Directional lights simulate parallel light beams from a distant source, hence have direction but no position.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.LightType.Spotlight">
            <summary>
            	Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.ManualCullingMode">
            <summary>
            	Manual culling modes based on vertex normals.
            	This setting applies to how the software culls triangles before sending them to the 
            	hardware API. This culling mode is used by scene managers which choose to implement it -
            	normally those which deal with large amounts of fixed world geometry which is often 
            	planar (software culling movable variable geometry is expensive).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ManualCullingMode.None">
            <summary>
            	No culling so everything is sent to the hardware.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.ManualCullingMode.Back">
            <summary>
            	Cull triangles whose normal is pointing away from the camera (default).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.ManualCullingMode.Front">
            <summary>
            	Cull triangles whose normal is pointing towards the camera.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.Projection">
            <summary>
            Type of projection used by the camera.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Projection.Orthographic">
            <summary> Things stay the same size no matter where they are in terms of the camera.  Normally only used in 3D HUD elements. </summary>
        </member>
        <member name="F:Axiom.Graphics.Projection.Perspective">
            <summary> Things get smaller when they are furthur away from the camera. </summary>
        </member>
        <member name="T:Axiom.Graphics.OperationType">
            <summary>
            	Types for determining which render operation to do for a series of vertices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.PointList">
            <summary>
            	Render the vertices as individual points.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.LineList">
            <summary>
            	Render the vertices as a series of individual lines.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.LineStrip">
            <summary>
            	Render the vertices as a continuous line.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.TriangleList">
            <summary>
            	Render the vertices as a series of individual triangles.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.TriangleStrip">
            <summary>
            	Render the vertices as a continous set of triangles in a zigzag type fashion.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.OperationType.TriangleFan">
            <summary>
            	Render the vertices as a set of trinagles in a fan like formation.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.RenderTargetPriority">
            <summary>
               Specifies priorities for processing Render Targets.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTargetPriority.Low">
            <summary>
               Will be processed last.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.RenderTargetPriority.High">
            <summary>
               Will be processed first (i.e. RenderTextures).
            </summary>
        </member>
        <member name="T:Axiom.Graphics.SceneBlendFactor">
            <summary>
            	Blending factors for manually blending objects with the scene. If there isn't a predefined
            	SceneBlendType that you like, then you can specify the blending factors directly to affect the
            	combination of object and the existing scene. See Material.SceneBlending for more details.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.One">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.Zero">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.DestColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.SourceColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusDestColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusSourceColor">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.DestAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.SourceAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusDestAlpha">
            <summary></summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendFactor.OneMinusSourceAlpha">
            <summary></summary>
        </member>
        <member name="T:Axiom.Graphics.SceneBlendType">
            <summary>
            	Types of blending that you can specify between an object and the existing contents of the scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.TransparentAlpha">
            <summary>
            	Make the object transparent based on the final alpha values in the texture.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.TransparentColor">
            <summary>
            	Make the object transparent based on the color values in the texture (brighter = more opaque).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.Modulate">
            <summary>
            	Make the object transparent based on the color values in the texture (brighter = more opaque).
             </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneBlendType.Add">
            <summary>
            	Add the texture values to the existing scene content.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.SceneDetailLevel">
            <summary>
            The broad type of detail for rendering.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneDetailLevel.Points">
            <summary>
            	Render subsequent requests drawing only the vertices in the scene.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneDetailLevel.Wireframe">
            <summary>
            	Render subsequent requests drawing only objects using wireframe mode.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.SceneDetailLevel.Solid">
            <summary>
            	Render everything in the scene normally (textures, etc).
            </summary>
        </member>
        <member name="T:Axiom.Graphics.Shading">
            <summary>
            Types for deciding how to shade geometry primitives.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.Shading.Flat">
            <summary>
            	Draw with a single color.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.Shading.Gouraud">
            <summary>
            	Interpolate color across primitive vertices.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.Shading.Phong">
            <summary>
            	Draw everything (2 sided geometry).
             </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowRenderableFlags">
            <summary>
            	A set of flags that can be used to influence <see cref="T:Axiom.Graphics.ShadowRenderable"/> creation.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderableFlags.IncludeLightCap">
            <summary>
            	For shadow volume techniques only, generate a light cap on the volume.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderableFlags.IncludeDarkCap">
            <summary>
            	For shadow volume techniques only, generate a dark cap on the volume.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowRenderableFlags.ExtrudeToInfinity">
            <summary>
            	For shadow volume techniques only, indicates volume is extruded to infinity
            </summary>
        </member>
        <member name="T:Axiom.Graphics.ShadowTechnique">
            <summary>
            An enumeration of broad shadow techniques .
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.None">
            <summary>
            	No shadows.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.StencilModulative">
            <summary>
            	Stencil shadow technique which renders all shadow volumes as
            	a modulation after all the non-transparent areas have been 
            	rendered. This technique is considerably less fillrate intensive 
            	than the additive stencil shadow approach when there are multiple
            	lights, but is not an accurate model. 
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.StencilAdditive">
            <summary>		
            	Stencil shadow technique which renders each light as a separate
            	additive pass to the scene. This technique can be very fillrate
            	intensive because it requires at least 2 passes of the entire
            	scene, more if there are multiple lights. However, it is a more
            	accurate model than the modulative stencil approach and this is
            	especially apparant when using coloured lights or bump mapping.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.ShadowTechnique.TextureModulative">
            <summary>
            	Texture-based shadow technique which involves a monochrome render-to-texture
            	of the shadow caster and a projection of that texture onto the 
            	shadow receivers as a modulative pass.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.StencilOperation">
            <summary>
            	Describes the various actions which can be taken on the stencil buffer.
            </summary> 
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Keep">
            <summary>
            	Leave the stencil buffer unchanged.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Zero">
            <summary>
            	Set the stencil value to zero.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Replace">
            <summary>
            	Set the stencil value to the reference value.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Increment">
            <summary>
            	Increase the stencil value by 1, clamping at the maximum value.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Decrement">
            <summary>
            	Decrease the stencil value by 1, clamping at 0.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.IncrementWrap">
            <summary>
            	Increase the stencil value by 1, wrapping back to 0 when incrementing the maximum value.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.DecrementWrap">
            <summary>
            	Decrease the stencil value by 1, wrapping when decrementing 0.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.StencilOperation.Invert">
            <summary>
            	Invert the bits of the stencil buffer.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureAddressing">
            <summary>
            Texture addressing modes - default is Wrap.
            </summary>
            <remarks>
               These settings are relevant in both the fixed-function and programmable pipeline.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.TextureAddressing.Wrap">
            <summary>
            	Texture wraps at values over 1.0 
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureAddressing.Mirror">
            <summary>
            	Texture mirrors (flips) at joins over 1.0.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureAddressing.Clamp">
            <summary>
            	Texture clamps at 1.0.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TexCoordCalcMethod">
            <summary>
            	Describes the ways to generate texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.None">
            <summary>
            	No calculated texture coordinates.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.EnvironmentMap">
            <summary>
            	Environment map based on vertex normals.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.EnvironmentMapPlanar">
            <summary>
            	Environment map based on vertex positions.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TexCoordCalcMethod.ProjectiveTexture">
            <summary>
            	Projective texture.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureCubeFace">
            <summary>
            Enum identifying the frame indexes for faces of a cube map (not the composite 3D type.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureEffectType">
            <summary>
               Definition of the broad types of texture effect you can apply to a texture layer.
            </summary>
            <remarks>
               Note that these have no effect when using the programmable pipeline, since their
               effect is overridden by the vertex / fragment programs.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.EnvironmentMap">
            <summary>
            	Generate all texture coords based on angle between camera and vertex.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.ProjectiveTexture">
            <summary>
            	Generate texture coords based on a frustum.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.Scroll">
            <summary>
            	Constant u/v scrolling effect.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.Rotate">
            <summary>
            	Constant rotation.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureEffectType.Transform">
            <summary>
            	More complex transform.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureFiltering">
            <summary>
               Texture filtering defining the different minification and magnification.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.None">
            <summary>
            	Equal to: min=Point, mag=Point, mip=None
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.Bilinear">
            <summary>
            	Equal to: min=Linear, mag=Linear, mip=Point
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.Trilinear">
            <summary>
            	Equal to: min=Linear, mag=Linear, mip=Linear
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureFiltering.Anisotropic">
            <summary>
               Equal to: min=Anisotropic, max=Anisotropic, mip=Linear
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureTransform">
            <summary>
            Useful enumeration when dealing with procedural transforms.
            </summary>
            <remarks>
               Note that these have no effect when using the programmable pipeline, since their
               effect is overridden by the vertex / fragment programs.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.TranslateU">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.TranslateV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.ScaleU">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.ScaleV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureTransform.Rotate">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureType">
            <summary>
               Enum identifying the texture type.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.OneD">
            <summary>
               1D texture, used in combination with 1D texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.TwoD">
            <summary>
               2D texture, used in combination with 2D texture coordinates (default).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.ThreeD">
            <summary>
               3D volume texture, used in combination with 3D texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureType.CubeMap">
            <summary>
               3D cube map, used in combination with 3D texture coordinates.
            </summary>
        </member>
        <member name="T:Axiom.Graphics.TextureUsage">
            <summary>
            	Specifies how a texture is to be used in the engine.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUsage.Default">
            <summary>
            	Standard usage.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.TextureUsage.RenderTarget">
            <summary>
            	Target of rendering.  Example would be a billboard in a wrestling or sports game, or rendering a 
            	movie to a texture.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexFlags">
            <summary>
            	Types for definings what information a vertex will hold.
            </summary>
            <remarks>
            	Implemented with the Flags attribute to treat this enum with bitwise addition
            	and comparisons.
            </remarks>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Position">
            <summary>
            	Specifies the 3D coordinates of the vertex.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.BlendWeights">
            <summary>
            	When applying 1 or more world matrices to a vertex, the weight values of a vertex dictate how much
            	of an effect each matrix has in determining its final position.  
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Normals">
            <summary>
            	Normal vector, determines the logical direction the vertex is facing for use in
            	lighting calculations.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.TextureCoords">
            <summary>
            	Texture coordinate for the vertex.
             </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Diffuse">
            <summary>
            	The primary color of the vertex.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexFlags.Specular">
            <summary>
            	Specular color for this vertex.
             </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexElementSemantic">
            <summary>
                Vertex element semantics, used to identify the meaning of vertex buffer contents.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Position">
            <summary>
                Position, 3 reals per vertex.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.BlendWeights">
            <summary>
                Blending weights.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.BlendIndices">
            <summary>
                Blending indices.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Normal">
            <summary>
                Normal, 3 reals per vertex.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Diffuse">
            <summary>
                Diffuse colors.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Specular">
            <summary>
                Specular colors.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.TexCoords">
            <summary>
                Texture coordinates.
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Binormal">
            <summary>
                Binormal (Y axis if normal is Z).
            </summary>
        </member>
        <member name="F:Axiom.Graphics.VertexElementSemantic.Tangent">
            <summary>
                Tangent (X axis if normal is Z).
            </summary>
        </member>
        <member name="T:Axiom.Graphics.VertexElementType">
            <summary>
                Vertex element type, used to identify the base types of the vertex contents.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupListener">
            <summary>
            This abstract class defines an interface which is called back during
            resource group loading to indicate the progress of the load. 
            </summary>
            <remarks>
            Resource group loading is in 2 phases - creating resources from 
            declarations (which includes parsing scripts), and loading
            resources. Note that you don't necessarily have to have both; it
            is quite possible to just parse all the scripts for a group (see
            ResourceGroupManager::initialiseResourceGroup, but not to 
            load the resource group. 
            The sequence of events is (* signifies a repeating item):
            <ul>
                <li>resourceGroupScriptingStarted</li>
                <li>scriptParseStarted (*)</li>
                <li>scriptParseEnded (*)</li>
                <li>resourceGroupScriptingEnded</li>
                <li>resourceGroupLoadStarted</li>
                <li>resourceLoadStarted (*)</li>
                <li>resourceLoadEnded (*)</li>
                <li>worldGeometryStageStarted (*)</li>
                <li>worldGeometryStageEnded (*)</li>
                <li>resourceGroupLoadEnded</li>
            </ul>
            </remarks>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.resourceGroupScriptingStarted(System.String,System.Int32)">
            <summary>
            This event is fired when a resource group begins parsing scripts.
            </summary>
            <param name="groupName">The name of the group</param>
            <param name="scriptCount">The number of scripts which will be parsed</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.scriptParseStarted(System.String)">
            <summary>
            This event is fired when a script is about to be parsed.
            </summary>
            <param name="scriptName">Name of the to be parsed</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.scriptParseEnded">
            <summary>
            This event is fired when the script has been fully parsed.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.resourceGroupScriptingEnded(System.String)">
            <summary>
            This event is fired when a resource group finished parsing scripts.
            </summary>
            <param name="groupName">The name of the group</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.resourceGroupLoadStarted(System.String,System.Int32)">
            <summary>
            This event is fired  when a resource group begins loading.
            </summary>
            <param name="groupName">The name of the group being loaded</param>
            <param name="resourceCount">
            The number of resources which will be loaded, 
            including a number of stages required to load any linked world geometry
            </param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.resourceLoadStarted(Axiom.Core.Resource)">
            <summary>
            This event is fired when a declared resource is about to be loaded. 
            </summary>
            <param name="resource">Weak reference to the resource loaded</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.resourceLoadEnded">
            <summary>
            This event is fired when the resource has been loaded. 
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.worldGeometryStageStarted(System.String)">
            <summary>
            This event is fired when a stage of loading linked world geometry 
            is about to start. The number of stages required will have been 
            included in the resourceCount passed in resourceGroupLoadStarted.
            </summary>
            <param name="description">Text description of what was just loaded</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.worldGeometryStageEnded">
            <summary>
            This event is fired when a stage of loading linked world geometry 
            has been completed. The number of stages required will have been 
            included in the resourceCount passed in resourceGroupLoadStarted.
            </summary>
            <param name="description">Text description of what was just loaded</param>
        </member>
        <member name="M:Axiom.Core.ResourceGroupListener.resourceGroupLoadEnded(System.String)">
            <summary>
            This event is fired when a resource group finished loading.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager">
            This singleton class manages the list of resource groups, and notifying
                    the various resource managers of their obligations to load / unload
                    resources in a group. It also provides facilities to monitor resource
                    loading per group (to do progress bars etc), provided the resources 
                    that are required are pre-registered.
                @par
                    Defining new resource groups,  and declaring the resources you intend to
                    use in advance is optional, however it is a very useful feature. In addition, 
            		if a ResourceManager supports the definition of resources through scripts, 
            		then this is the class which drives the locating of the scripts and telling
            		the ResourceManager to parse them. 
            	@par
            		There are several states that a resource can be in (the concept, not the
            		object instance in this case):
            		<ol>
            		<li><b>Undefined</b>. Nobody knows about this resource yet. It might be
            		in the filesystem, but Ogre is oblivious to it at the moment - there 
            		is no Resource instance. This might be because it's never been declared
            		(either in a script, or using ResourceGroupManager::declareResource), or
            		it may have previously been a valid Resource instance but has been 
            		removed, either individually through ResourceManager::remove or as a group
            		through ResourceGroupManager::clearResourceGroup.</li>
            		<li><b>Declared</b>. Ogre has some forewarning of this resource, either
            		through calling ResourceGroupManager::declareResource, or by declaring
            		the resource in a script file which is on one of the resource locations
            		which has been defined for a group. There is still no instance of Resource,
            		but Ogre will know to create this resource when 
            		ResourceGroupManager::initialiseResourceGroup is called (which is automatic
            		if you declare the resource group before Root::initialise).</li>
            		<li><b>Unloaded</b>. There is now a Resource instance for this resource, 
            		although it is not loaded. This means that code which looks for this
            		named resource will find it, but the Resource is not using a lot of memory
            		because it is in an unloaded state. A Resource can get into this state
            		by having just been created by ResourceGroupManager::initialiseResourceGroup 
            		(either from a script, or from a call to declareResource), by 
            		being created directly from code (ResourceManager::create), or it may 
            		have previously been loaded and has been unloaded, either individually
            		through Resource::unload, or as a group through ResourceGroupManager::unloadResourceGroup.</li>
            		<li><b>Loaded</b>The Resource instance is fully loaded. This may have
            		happened implicitly because something used it, or it may have been 
            		loaded as part of a group.</li>
            		</ol>
            		@see ResourceGroupManager::declareResource
            		@see ResourceGroupManager::initialiseResourceGroup
            		@see ResourceGroupManager::loadResourceGroup
            		@see ResourceGroupManager::unloadResourceGroup
            		@see ResourceGroupManager::clearResourceGroup
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.DefaultResourceGroupName">
            Default resource group name
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.BOOTSTRAP_RESOURCE_GROUP_NAME">
            Bootstrap resource group name (min OGRE resources)
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.mWorldGroupName">
            <summary>Group name for world resources </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.parseResourceGroupScripts(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            <summary>
            Parses all the available scripts found in the resource locations
            for the given group, for all ResourceManagers. 
            </summary>
            <remarks>
            Called as part of initialiseResourceGroup
            </remarks>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.createDeclaredResources(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            <summary>Create all the pre-declared resources.</summary>
            <remarks>Called as part of initialiseResourceGroup</remarks>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.addCreatedResource(Axiom.Core.Resource,Axiom.Core.ResourceGroupManager.ResourceGroup)">
            Adds a created resource to a group. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.getResourceGroup(System.String)">
            Get resource group 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.dropGroupContents(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            Drops contents of a group, leave group there, notify ResourceManagers. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.deleteGroup(Axiom.Core.ResourceGroupManager.ResourceGroup)">
            Delete a group for shutdown - don't notify ResourceManagers. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireResourceGroupScriptingStarted(System.String,System.Int32)">
            <summary>Internal event firing method </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireScriptStarted(System.String)">
            <summary>Internal event firing method </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireScriptEnded">
            Internal event firing method
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireResourceGroupScriptingEnded(System.String)">
            Internal event firing method
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireResourceGroupLoadStarted(System.String,System.Int32)">
            Internal event firing method
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireResourceStarted(Axiom.Core.Resource)">
            Internal event firing method
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireResourceEnded">
            Internal event firing method
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.fireResourceGroupLoadEnded(System.String)">
            Internal event firing method
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.mCurrentGroup">
            Stored current group - optimisation for when bulk loading a group
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.instance">
            <summary>
                Singleton instance of this class.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.#ctor">
            <summary>
                Internal constructor.  This class cannot be instantiated externally.
            </summary>
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.createResourceGroup(System.String)">
            Create a resource group.
                    @remarks
                        A resource group allows you to define a set of resources that can 
                        be loaded / unloaded as a unit. For example, it might be all the 
                        resources used for the level of a game. There is always one predefined
                        resource group called ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
            			which is typically used to hold all resources which do not need to 
            			be unloaded until shutdown. You can create additional ones so that 
            			you can control the life of your resources in whichever way you wish.
                    @par
                        Once you have defined a resource group, resources which will be loaded
            			as part of it are defined in one of 3 ways:
            			<ol>
            			<li>Manually through declareResource(); this is useful for scripted
            				declarations since it is entirely generalised, and does not 
            				create Resource instances right away</li>
            			<li>Through the use of scripts; some ResourceManager subtypes have
            				script formats (e.g. .material, .overlay) which can be used
            				to declare resources</li>
            			<li>By calling ResourceManager::create to create a resource manually.
            			This resource will go on the list for it's group and will be loaded
            			and unloaded with that group</li>
            			</ol>
            			You must remember to call initialiseResourceGroup if you intend to use
            			the first 2 types.
                    @param name The name to give the resource group.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.initialiseResourceGroup(System.String)">
            Initialises a resource group.
            		@remarks
            			After creating a resource group, adding some resource locations, and
            			perhaps pre-declaring some resources using declareResource(), but 
            			before you need to use the resources in the group, you 
            			should call this method to initialise the group. By calling this,
            			you are triggering the following processes:
            			<ol>
            			<li>Scripts for all resource types which support scripting are
            				parsed from the resource locations, and resources within them are
            				created (but not loaded yet).</li>
            			<li>Creates all the resources which have just pre-declared using
            			declareResource (again, these are not loaded yet)</li>
            			</ol>
            			So what this essentially does is create a bunch of unloaded Resource entries
            			in the respective ResourceManagers based on scripts, and resources
            			you've pre-declared. That means that code looking for these resources
            			will find them, but they won't be taking up much memory yet, until
            			they are either used, or they are loaded in bulk using loadResourceGroup.
            			Loading the resource group in bulk is entirely optional, but has the 
            			advantage of coming with progress reporting as resources are loaded.
            		@par
            			Failure to call this method means that loadResourceGroup will do 
            			nothing, and any resources you define in scripts will not be found.
            			Similarly, once you have called this method you won't be able to
            			pick up any new scripts or pre-declared resources, unless you
            			call clearResourceGroup, set up declared resources, and call this
            			method again.
            		@note 
            			When you call Root::initialise, all resource groups that have already been
            			created are automatically initialised too. Therefore you do not need to 
            			call this method for groups you define and set up before you call 
            			Root::initialise. However, since one of the most useful features of 
            			resource groups is to set them up after the main system initialisation
            			has occurred (e.g. a group per game level), you must remember to call this
            			method for the groups you create after this.
            
            		@param name The name of the resource group to initialise
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.initialiseAllResourceGroups">
            Initialise all resource groups which are yet to be initialised.
            		@see ResourceGroupManager::intialiseResourceGroup
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.loadResourceGroup(System.String)">
            Loads a resource group.
                    @remarks
            			Loads any created resources which are part of the named group.
            			Note that resources must have already been created by calling
            			ResourceManager::create, or declared using declareResource() or
            			in a script (such as .material and .overlay). The latter requires
            			that initialiseResourceGroup has been called. 
            		
            			When this method is called, this class will callback any ResourceGroupListeners
            			which have been registered to update them on progress. 
                    @param name The name to of the resource group to load.
            		@param loadMainResources If true, loads normal resources associated 
            			with the group (you might want to set this to false if you wanted
            			to just load world geometry in bulk)
            		@param loadWorldGeom If true, loads any linked world geometry
            			@see ResourceGroupManager::linkWorldGeometryToResourceGroup
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.unloadResourceGroup(System.String)">
            Unloads a resource group.
                    @remarks
                        This method unloads all the resources that have been declared as
                        being part of the named resource group. Note that these resources
                        will still exist in their respective ResourceManager classes, but
                        will be in an unloaded state. If you want to remove them entirely,
                        you should use clearResourceGroup or destroyResourceGroup.
                    @param name The name to of the resource group to unload.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.clearResourceGroup(System.String)">
            Clears a resource group. 
            		@remarks
            			This method unloads all resources in the group, but in addition it
            			removes all those resources from their ResourceManagers, and then 
            			clears all the members from the list. That means after calling this
            			method, there are no resources declared as part of the named group
            			any more. Resource locations still persist though.
                    @param name The name to of the resource group to clear.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.destroyResourceGroup(System.String)">
            Destroys a resource group, clearing it first, destroying the resources
                        which are part of it, and then removing it from
                        the list of resource groups. 
                    @param name The name of the resource group to destroy.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.addResourceLocation(System.String,System.String)">
            Method to add a resource location to for a given resource group. 
                    @remarks
                        Resource locations are places which are searched to load resource files.
                        When you choose to load a file, or to search for valid files to load, 
                        the resource locations are used.
                    @param name The name of the resource location; probably a directory, zip file, URL etc.
                    @param locType The codename for the resource type, which must correspond to the 
                        Archive factory which is providing the implementation.
                    @param resGroup The name of the resource group for which this location is
                        to apply. ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME is the 
            			default group which always exists, and can
                        be used for resources which are unlikely to be unloaded until application
                        shutdown. Otherwise it must be the name of a group; if it
                        has not already been created with createResourceGroup then it is created
                        automatically.
                    @param recursive Whether subdirectories will be searched for files when using 
            			a pattern match (such as *.material), and whether subdirectories will be
            			indexed. This can slow down initial loading of the archive and searches.
            			When opening a resource you still need to use the fully qualified name, 
            			this allows duplicate names in alternate paths.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.removeResourceLocation(System.String)">
            Removes a resource location from the search path. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.declareResource(System.String,System.String)">
            Declares a resource to be a part of a resource group, allowing you 
                        to load and unload it as part of the group.
                    @remarks
                        By declaring resources before you attempt to use them, you can 
                        more easily control the loading and unloading of those resources
                        by their group. Declaring them also allows them to be enumerated, 
                        which means events can be raised to indicate the loading progress
                        (@see ResourceGroupListener). Note that another way of declaring
            			resources is to use a script specific to the resource type, if
            			available (e.g. .material).
            		@par
            			Declared resources are not created as Resource instances (and thus
            			are not available through their ResourceManager) until initialiseResourceGroup
            			is called, at which point all declared resources will become created 
            			(but unloaded) Resource instances, along with any resources declared
            			in scripts in resource locations associated with the group.
                    @param name The resource name. 
                    @param resourceType The type of the resource. Ogre comes preconfigured with 
                        a number of resource types: 
                        <ul>
                        <li>Font</li>
                        <li>Material</li>
                        <li>Mesh</li>
                        <li>Overlay</li>
                        <li>Skeleton</li>
                        </ul>
                        .. but more can be added by plugin ResourceManager classes.
                    @param groupName The name of the group to which it will belong.
            		@param loadParameters A list of name / value pairs which supply custom
            			parameters to the resource which will be required before it can 
            			be loaded. These are specific to the resource type.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.undeclareResource(System.String,System.String)">
            Undeclare a resource.
            		@remarks
            			Note that this will not cause it to be unloaded
                        if it is already loaded, nor will it destroy a resource which has 
            			already been created if initialiseResourceGroup has been called already.
            			Only unloadResourceGroup / clearResourceGroup / destroyResourceGroup 
            			will do that. 
                    @param name The name of the resource. 
            		@param groupName The name of the group this resource was declared in. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.openResource(System.String)">
            Open a single resource by name and return a DataStream
            		 	pointing at the source of the data.
            		@param resourceName The name of the resource to locate.
            			Even if resource locations are added recursively, you
            			must provide a fully qualified name to this method. You 
            			can find out the matching fully qualified names by using the
            			find() method if you need to.
            		@param groupName The name of the resource group; this determines which 
            			locations are searched. 
            		@returns Shared pointer to data stream containing the data, will be
            			destroyed automatically when no longer referenced
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.listResourceNames(System.String)">
            List all file names in a resource group.
                    @note
                    This method only returns filenames, you can also retrieve other
                    information using listFileInfo.
                    @param groupName The name of the group
                    @returns A list of filenames matching the criteria, all are fully qualified
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.findResourceNames(System.String,System.String)">
            Find all file names matching a given pattern in a resource group.
                    @note
                    This method only returns filenames, you can also retrieve other
                    information using findFileInfo.
                    @param groupName The name of the group
                    @param pattern The pattern to search for; wildcards (*) are allowed
                    @returns A list of filenames matching the criteria, all are fully qualified
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.resourceExists(System.String,System.String)">
            Find out if the named file exists in a group. 
                    @param group The name of the resource group
                    @param filename Fully qualified name of the file to test for
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.findResourceFileInfo(System.String,System.String)">
            Find all files matching a given pattern in a group and get 
                    some detailed information about them.
                    @param group The name of the resource group
                    @param pattern The pattern to search for; wildcards (*) are allowed
                    @returns A list of file information structures for all files matching 
                    the criteria.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.addResourceGroupListener(Axiom.Core.ResourceGroupListener)">
            Adds a ResourceGroupListener which will be called back during 
                        resource loading events. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.removeResourceGroupListener(Axiom.Core.ResourceGroupListener)">
            Removes a ResourceGroupListener 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.setWorldResourceGroupName(System.String)">
            Sets the resource group that 'world' resources will use.
                    @remarks
                        This is the group which should be used by SceneManagers implementing
                        world geometry when looking for their resources. Defaults to the 
                        DEFAULT_RESOURCE_GROUP_NAME but this can be altered.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.getWorldResourceGroupName">
            Sets the resource group that 'world' resources will use.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.linkWorldGeometryToResourceGroup(System.String,System.String,Axiom.Core.SceneManager)">
            Associates some world geometry with a resource group, causing it to 
                        be loaded / unloaded with the resource group.
                    @remarks
                        You would use this method to essentially defer a call to 
                        SceneManager::setWorldGeometry to the time when the resource group
                        is loaded. The advantage of this is that compatible scene managers 
                        will include the estimate of the number of loading stages for that
                        world geometry when the resource group begins loading, allowing you
                        to include that in a loading progress report. 
                    @param group The name of the resource group
                    @param worldGeometry The parameter which should be passed to setWorldGeometry
                    @param sceneManager The SceneManager which should be called
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.unlinkWorldGeometryFromResourceGroup(System.String)">
            Clear any link to world geometry from a resource group.
                    @remarks
                        Basically undoes a previous call to linkWorldGeometryToResourceGroup.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.shutdownAll">
            Shutdown all ResourceManagers, performed as part of clean-up. 
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._registerResourceManager(System.String,Axiom.Core.ResourceManager)">
            Internal method for registering a ResourceManager (which should be
                        a singleton). Creators of plugins can register new ResourceManagers
                        this way if they wish.
            		@remarks
            			ResourceManagers that wish to parse scripts must also call 
            			_registerScriptLoader.
                    @param resourceType String identifying the resource type, must be unique.
                    @param rm Pointer to the ResourceManager instance.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._unregisterResourceManager(System.String)">
            Internal method for unregistering a ResourceManager.
            		@remarks
            			ResourceManagers that wish to parse scripts must also call 
            			_unregisterScriptLoader.
                    @param resourceType String identifying the resource type.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.UnregisterScriptLoader(System.Object)">
            Internal method for unregistering a ScriptLoader.
                    @param su Pointer to the ScriptLoader instance.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._getResourceManager(System.String)">
            Internal method for getting a registered ResourceManager.
            		@param resourceType String identifying the resource type.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._notifyResourceCreated(Axiom.Core.Resource)">
            Internal method called by ResourceManager when a resource is created.
            		@param res Weak reference to resource
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._notifyResourceRemoved(Axiom.Core.Resource)">
            Internal method called by ResourceManager when a resource is removed.
            		@param res Weak reference to resource
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._notifyAllResourcesRemoved(Axiom.Core.ResourceManager)">
            Internal method called by ResourceManager when all resources 
            			for that manager are removed.
            		@param manager Pointer to the manager for which all resources are being removed
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._notifyWorldGeometryStageStarted(System.String)">
            Notify this manager that one stage of world geometry loading has been 
                        started.
                    @remarks
                        Custom SceneManagers which load custom world geometry should call this 
                        method the number of times equal to the value they return from 
                        SceneManager::estimateWorldGeometry while loading their geometry.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager._notifyWorldGeometryStageEnded">
            Notify this manager that one stage of world geometry loading has been 
                        completed.
                    @remarks
                        Custom SceneManagers which load custom world geometry should call this 
                        method the number of times equal to the value they return from 
                        SceneManager::estimateWorldGeometry while loading their geometry.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.getResourceGroups">
            Get a list of the currently defined resource groups. 
            		@note This method intentionally returns a copy rather than a reference in
            			order to avoid any contention issues in multithreaded applications.
            		@returns A copy of list of currently defined groups.
        </member>
        <member name="M:Axiom.Core.ResourceGroupManager.getResourceDeclarationList(System.String)">
            Get the list of resource declarations for the specified group name. 
            		@note This method intentionally returns a copy rather than a reference in
            			order to avoid any contention issues in multithreaded applications.
            		@param groupName The name of the group
            		@returns A copy of list of currently defined resources.
        </member>
        <member name="P:Axiom.Core.ResourceGroupManager.Instance">
            <summary>
                Gets the singleton instance of this class.
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceDeclaration">
            Nested struct defining a resource declaration
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceDeclarationList">
            List of resource declarations
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceManagerMap">
            <summary>Map of resource types (strings) to ResourceManagers, used to notify them to load / unload group contents</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ScriptLoaderOrderMap">
            <summary>Map of loading order (Real) to ScriptLoader, used to order script parsing</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupListenerList">
            <summary></summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceLocationIndex">
            <summary>Resource index entry, resourcename->location </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceLocation">
            <summary>Resource location entry</summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceLocation.archive">
            <summary>Pointer to the archive which is the destination</summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceLocation.recursive">
            Whether this location was added recursively
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.LocationList">
            <summary>List of possible file locations</summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.LoadUnLoadResourceList">
            <summary>List of resources which can be loaded / unloaded </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroup">
            Resource group entry
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.name">
            <summary>Group name </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.initialised">
            <summary>Whether group has been initialised </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.locationList">
            <summary>List of possible locations to search </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.resourceIndexCaseSensitive">
            <summary>Index of resource names to locations, built for speedy access (case sensitive archives) </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.resourceIndexCaseInsensitive">
            <summary>Index of resource names to locations, built for speedy access (case insensitive archives) </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.resourceDeclarations">
            <summary>Pre-declared resources, ready to be created </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.worldGeometry">
            <summary>Linked world geometry, as passed to setWorldGeometry </summary>
        </member>
        <member name="F:Axiom.Core.ResourceGroupManager.ResourceGroup.worldGeometrySceneManager">
            <summary>Scene manager to use with linked world geometry </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroup.LoadResourceOrderMap">
            <summary>
            Created resources which are ready to be loaded / unloaded
            Group by loading order of the type (defined by ResourceManager)
            (e.g. skeletons and materials before meshes) 
            </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ResourceGroupMap">
            <summary>Map from resource group names to groups </summary>
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.StreamList">
            Open all resources matching a given pattern (which can contain
            			the character '*' as a wildcard), and return a collection of 
            			DataStream objects on them.
            		@param pattern The pattern to look for. If resource locations have been
            			added recursively, subdirectories will be searched too so this
            			does not need to be fully qualified.
            		@param groupName The resource group; this determines which locations
            			are searched.
            		@returns Shared pointer to a data stream list , will be
            			destroyed automatically when no longer referenced
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.FileInfoList">
            List all files in a resource group with accompanying information.
                    @param groupName The name of the group
                    @returns A list of structures detailing quite a lot of information about
                    all the files in the archive.
        </member>
        <member name="T:Axiom.Core.ResourceGroupManager.ScriptLoader">
            Internal method for registering a ScriptLoader.
            		@remarks ScriptLoaders parse scripts when resource groups are initialised.
                    @param su Pointer to the ScriptLoader instance.
        </member>
        <member name="T:Axiom.Controllers.Canned.MultipyControllerFunction">
            <summary>
            Summary description for MultiplyControllerValue.
            </summary>
        </member>
        <member name="T:Axiom.Configuration.Config">
            <summary>
            Summary description for XConfig.
            </summary>
        </member>
    </members>
</doc>
