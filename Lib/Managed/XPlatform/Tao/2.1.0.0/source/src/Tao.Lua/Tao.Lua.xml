<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tao.Lua</name>
    </assembly>
    <members>
        <member name="T:Tao.Lua.Lua">
            #region Class Documentation
            <summary>
                Lua bindings for .NET, implementing Lua 5.1.1 (http://www.lua.org).
            </summary>
            <remarks>
            	Lua is a powerful light-weight programming language designed for
            	extending applications. Lua is also frequently used as a
            	general-purpose, stand-alone language.
            <p>More information can be found at the official website (http://www.lua.org).</p>
            </remarks>
            #endregion Class Documentation
        </member>
        <member name="F:Tao.Lua.Lua.LUA_VERSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_RELEASE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_VERSION_NUM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_COPYRIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_AUTHORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_SIGNATURE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MULTRET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_REGISTRYINDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_ENVIRONINDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GLOBALSINDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_YIELDSTATUS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_ERRRUN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_ERRSYNTAX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_ERRMEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_ERRERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TNONE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TNIL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TBOOLEAN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TLIGHTUSERDATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TNUMBER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TSTRING">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TTABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TFUNCTION">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TUSERDATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TTHREAD">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MINSTACK">
            <summary>
                Minimum Lua stack available to a C function
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCSTOP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCRESTART">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCCOLLECT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCCOUNT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCCOUNTB">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCSTEP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCSETPAUSE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_GCSETSTEPMUL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_HOOKCALL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_HOOKRET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_HOOKLINE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_HOOKCOUNT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_HOOKTAILRET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MASKCALL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MASKRET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MASKLINE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MASKCOUNT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_FILEHANDLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_COLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_TABLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_IOLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_OSLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_STRLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MATHLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_DBLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_LOADLIBNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_ERRFILE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_NOREF">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_RENIL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_IDSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.UA_PROMPT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_PROMT2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_PROGNAME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MAXINPUT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_GCPAUSE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_GCMUL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_COMPAT_LSTR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_MAXCALLS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_MAXCSTACK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_MAXCCALLS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_MAXVARS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_MAXUPVALUES">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAL_BUFFERSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUA_MAXCAPTURES">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.LUAI_EXTRASPACE">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Lua.Lua.lua_upvalueindex(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_newstate(Tao.Lua.Lua.lua_Alloc,System.IntPtr)">
            <summary>
                Creates a new, independent state.   
            </summary>
            <param name="f">The argument f is the allocator function.</param>
            <param name="ud">The second argument, ud, is an opaque pointer that Lua simply passes to the allocator in every call.</param>
            <returns>Returns NULL if cannot create the state (due to lack of memory).</returns>
            <remarks>Lua does all memory allocation for this state through this function.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_close(System.IntPtr)">
            <summary>
                Destroys all objects in the given Lua state (calling the corresponding
                garbage-collection metamethods, if any) and frees all dynamic memory used
                by this state. On several platforms, you may not need to call this function,
                because all resources are naturally released when the host program ends. On
                the other hand, long-running programs, such as a daemon or a web server, might
                need to release states as soon as they are not needed, to avoid growing too large.
            </summary>
            <param name="L"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_newthread(System.IntPtr)">
            <summary>
                Creates a new thread, pushes it on the stack, and returns a pointer
                to a lua_State that represents this new thread. The new state returned
                by this function shares with the original state all global objects
                (such as tables), but has an independent execution stack.
            </summary>
            <param name="L"></param>
            <returns></returns>
            <remarks>
                There is no explicit function to close or to destroy a thread. Threads
                are subject to garbage collection, like any Lua object.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_atpanic(System.IntPtr,Tao.Lua.Lua.lua_CFunction)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="panicf"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_gettop(System.IntPtr)">
            <summary>
                Returns the index of the top element in the stack. Because indices
                start at 1, this result is equal to the number of elements in the
                stack (and so 0 means an empty stack).
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_settop(System.IntPtr,System.Int32)">
            <summary>
                Accepts any acceptable index, or 0, and sets the stack top to this index. If the new top is larger than the old one, then the new elements are filled with nil. If index is 0, then all stack elements are removed.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushvalue(System.IntPtr,System.Int32)">
            <summary>
                Pushes a copy of the element at the given valid index onto the stack.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_remove(System.IntPtr,System.Int32)">
            <summary>
                Removes the element at the given valid index, shifting down
                the elements above this index to fill the gap. Cannot be called
                with a pseudo-index, because a pseudo-index is not an actual
                stack position.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_insert(System.IntPtr,System.Int32)">
            <summary>
                Moves the top element into the given valid index, shifting up
                the elements above this index to open space. Cannot be called
                with a pseudo-index, because a pseudo-index is not an actual
                stack position.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_replace(System.IntPtr,System.Int32)">
            <summary>
                Moves the top element into the given position (and pops it), without shifting
                any element (therefore replacing the value at the given position).
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_checkstack(System.IntPtr,System.Int32)">
            <summary>
                Ensures that there are at least extra free stack slots in the stack. It returns
                false if it cannot grow the stack to that size. This function never shrinks the
                stack; if the stack is already larger than the new size, it is left unchanged.
            </summary>
            <param name="L"></param>
            <param name="sz"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_xmove(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
                Exchange values between different threads of the same global state.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="n"></param>
            <remarks>
                This function pops n values from the stack from, and pushes them onto the stack to.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isnumber(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is a number
                or a string convertible to a number, and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isstring(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is a
                string or a number (which is always convertible to a string),
                and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_iscfunction(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is
                a C function, and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isuserdata(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is a
                userdata (either full or light), and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_type(System.IntPtr,System.Int32)">
            <summary>
                Returns the type of the value in the given acceptable index, or LUA_TNONE for a non-valid index (that is, an index to an "empty" stack position). The types returned by lua_type are coded by the following constants defined in lua.h: LUA_TNIL, LUA_TNUMBER, LUA_TBOOLEAN, LUA_TSTRING, LUA_TTABLE, LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREAD, and LUA_TLIGHTUSERDATA.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_typename(System.IntPtr,System.Int32)">
            <summary>
                Returns the name of the type encoded by the value tp, which must be one the values returned by lua_type.
            </summary>
            <param name="L"></param>
            <param name="tp"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_equal(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Returns 1 if the two values in acceptable indices index1
                and index2 are equal, following the semantics of the Lua == operator
                (that is, may call metamethods). Otherwise returns 0. Also returns
                0 if any of the indices is non valid.
            </summary>
            <param name="L"></param>
            <param name="idx1"></param>
            <param name="idx2"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_rawequal(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Returns 1 if the two values in acceptable indices index1 and index2 
                are primitively equal (that is, without calling metamethods). Otherwise
                returns 0. Also returns 0 if any of the indices are non valid.
            </summary>
            <param name="L"></param>
            <param name="idx1"></param>
            <param name="idx2"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_lessthan(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Returns 1 if the value at acceptable index index1 is smaller
                than the value at acceptable index index2, following the semantics
                of the Lua less then operator (that is, may call metamethods).
                Otherwise returns 0. Also returns 0 if any of the indices is non valid.
            </summary>
            <param name="L"></param>
            <param name="idx1"></param>
            <param name="idx2"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_tonumber(System.IntPtr,System.Int32)">
            <summary>
                Converts the Lua value at the given acceptable index to a number (see lua_Number). The Lua value must be a number or a string convertible to a number (see §2.2.1); otherwise, lua_tonumber returns 0.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_tointeger(System.IntPtr,System.Int32)">
            <summary>
                Converts the Lua value at the given acceptable index to the signed integral type lua_Integer. The Lua value must be a number or a string convertible to a number (see §2.2.1); otherwise, lua_tointeger returns 0.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
            <remarks>
                If the number is not an integer, it is truncated in some non-specified way.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_toboolean(System.IntPtr,System.Int32)">
            <summary>
                Converts the Lua value at the given acceptable index to a C boolean value (0 or 1). Like all tests in Lua, lua_toboolean returns 1 for any Lua value different from false and nil; otherwise it returns 0. It also returns 0 when called with a non-valid index. (If you want to accept only actual boolean values, use lua_isboolean to test the value's type.)
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_tolstring(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
                Converts the Lua value at the given acceptable index to a string (const char*). If len is not NULL, it also sets *len with the string length. The Lua value must be a string or a number; otherwise, the function returns NULL. If the value is a number, then lua_tolstring also changes the actual value in the stack to a string. (This change confuses lua_next when lua_tolstring is applied to keys during a table traversal.)
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <param name="len"></param>
            <returns>
                lua_tolstring returns a fully aligned pointer to a string inside the Lua state. This string always has a zero ('\0') after its last character (as in C), but may contain other zeros in its body. Because Lua has garbage collection, there is no guarantee that the pointer returned by lua_tolstring will be valid after the corresponding value is removed from the stack.
            </returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_objlen(System.IntPtr,System.Int32)">
            <summary>
                Returns the "length" of the value at the given acceptable
                index: for strings, this is the string length; for tables,
                this is the result of the length operator ('#'); for userdata,
                this is the size of the block of memory allocated for the
                userdata; for other values, it is 0.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_tocfunction(System.IntPtr,System.Int32)">
            <summary>
                Converts a value at the given acceptable index to a C function. That value must be a C function; otherwise, returns NULL.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_touserdata(System.IntPtr,System.Int32)">
            <summary>
                If the value at the given acceptable index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns NULL.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_tothread(System.IntPtr,System.Int32)">
            <summary>
                Converts the value at the given acceptable index to a Lua thread (represented as lua_State*). This value must be a thread; otherwise, the function returns NULL.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_topointer(System.IntPtr,System.Int32)">
            <summary>
                Converts the value at the given acceptable index to a generic C pointer (void*). The value may be a userdata, a table, a thread, or a function; otherwise, lua_topointer returns NULL. Different objects will give different pointers. There is no way to convert the pointer back to its original value.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns></returns>
            <remarks>
                Typically this function is used only for debug information.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushnil(System.IntPtr)">
            <summary>
                Pushes a nil value onto the stack.
            </summary>
            <param name="L"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushnumber(System.IntPtr,System.Double)">
            <summary>
                Pushes a number with value n onto the stack.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushinteger(System.IntPtr,System.Int32)">
            <summary>
                Pushes a number with value n onto the stack.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushlstring(System.IntPtr,System.String,System.UInt32)">
            <summary>
                Pushes the string pointed to by s with size len onto the stack. Lua
                makes (or reuses) an internal copy of the given string, so the
                memory at s can be freed or reused immediately after the function
                returns. The string can contain embedded zeros.
            </summary>
            <param name="L"></param>
            <param name="s"></param>
            <param name="l"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushstring(System.IntPtr,System.String)">
            <summary>
                Pushes the zero-terminated string pointed to by s onto the stack. Lua
                makes (or reuses) an internal copy of the given string, so the memory
                at s can be freed or reused immediately after the function returns. The
                string cannot contain embedded zeros; it is assumed to end at the first zero.
            </summary>
            <param name="L"></param>
            <param name="s"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushcclosure(System.IntPtr,Tao.Lua.Lua.lua_CFunction,System.Int32)">
            <summary>
                Pushes a new C closure onto the stack.
            </summary>
            <param name="L"></param>
            <param name="fn"></param>
            <param name="n"></param>
            <remarks>
                When a C function is created, it is possible to associate some values
                with it, thus creating a C closure (see §3.4); these values are then
                accessible to the function whenever it is called. To associate values
                with a C function, first these values should be pushed onto the stack
                (when there are multiple values, the first value is pushed first).
                Then lua_pushcclosure is called to create and push the C function onto
                the stack, with the argument n telling how many values should be
                associated with the function. lua_pushcclosure also pops these values
                from the stack.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushboolean(System.IntPtr,System.Int32)">
            <summary>
                Pushes a boolean value with value b onto the stack.
            </summary>
            <param name="L"></param>
            <param name="b"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushlightuserdata(System.IntPtr,System.IntPtr)">
            <summary>
                Pushes a light userdata onto the stack.
            </summary>
            <param name="L"></param>
            <param name="p"></param>
            <remarks>
                Userdata represents C values in Lua. A light userdata represents
                a pointer. It is a value (like a number): you do not create it, it has
                no individual metatable, and it is not collected (as it was never
                created). A light userdata is equal to "any" light userdata with
                the same C address.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushthread(System.IntPtr)">
            <summary>
                Pushes the thread represented by L onto the stack. 
            </summary>
            <param name="L"></param>
            <returns>
                Returns 1 if this thread is the main thread of its state.
            </returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_gettable(System.IntPtr,System.Int32)">
            <summary>
                Pushes onto the stack the value t[k], where t is the value at the given
                valid index index and k is the value at the top of the stack.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <remarks>
                This function pops the key from the stack (putting the resulting value in
                its place). As in Lua, this function may trigger a metamethod for the
                "index" event.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getfield(System.IntPtr,System.Int32,System.String)">
            <summary>
                Pushes onto the stack the value t[k], where t is the value at the
                given valid index index. As in Lua, this function may trigger a
                metamethod for the "index" event
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <param name="k"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_rawget(System.IntPtr,System.Int32)">
            <summary>
                Similar to lua_gettable, but does a raw access (i.e., without
                metamethods).
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_rawgeti(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Pushes onto the stack the value t[n], where t is the value at the given
                valid index index. The access is raw; that is, it does not invoke metamethods.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_createtable(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Creates a new empty table and pushes it onto the stack. The new table
                has space pre-allocated for narr array elements and nrec non-array elements.
                This pre-allocation is useful when you know exactly how many elements the table
                will have. Otherwise you can use the function lua_newtable.
            </summary>
            <param name="L"></param>
            <param name="narr"></param>
            <param name="nrec"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_newuserdata(System.IntPtr,System.UInt32)">
            <summary>
                This function allocates a new block of memory with the given
                size, pushes onto the stack a new full userdata with the block
                address, and returns this address.
            </summary>
            <param name="L"></param>
            <param name="sz"></param>
            <returns></returns>
            <remarks>
                Userdata represents C values in Lua. A full userdata represents
                a block of memory. It is an object (like a table): you must create it,
                it can have its own metatable, and you can detect when it is being
                collected. A full userdata is only equal to itself (under raw equality).
                
                When Lua collects a full userdata with a gc metamethod, Lua calls the
                metamethod and marks the userdata as finalized. When this userdata is
                collected again then Lua frees its corresponding memory.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getmetatable(System.IntPtr,System.Int32)">
            <summary>
                Pushes onto the stack the metatable of the value at the given
                acceptable index. If the index is not valid, or if the value
                does not have a metatable, the function returns 0 and pushes
                nothing on the stack.
            </summary>
            <param name="L"></param>
            <param name="objindex"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getfenv(System.IntPtr,System.Int32)">
            <summary>
                Pushes onto the stack the environment table of the value at the given index.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_settable(System.IntPtr,System.Int32)">
            <summary>
                Does the equivalent to t[k] = v, where t is the value at the given valid index index, v is the value at the top of the stack, and k is the value just below the top.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <remarks>
                This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the "newindex" event
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_setfield(System.IntPtr,System.Int32,System.String)">
            <summary>
                Does the equivalent to t[k] = v, where t is the value at the
                given valid index index and v is the value at the top of the stack,
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <param name="k"></param>
            <remarks>
                This function pops the value from the stack. As in Lua, this
                function may trigger a metamethod for the "newindex" event
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_rawset(System.IntPtr,System.Int32)">
            <summary>
                Similar to lua_settable, but does a raw assignment (i.e., without
                metamethods).
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_rawseti(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Does the equivalent of t[n] = v, where t is the value at the given valid index index and v
                is the value at the top of the stack,
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <param name="n"></param>
            <remarks>
                This function pops the value from the stack. The assignment is
                raw; that is, it does not invoke metamethods.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_setmetatable(System.IntPtr,System.Int32)">
            <summary>
                Pops a table from the stack and sets it as the new metatable for the value at the given acceptable index.
            </summary>
            <param name="L"></param>
            <param name="objindex"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_setfenv(System.IntPtr,System.Int32)">
            <summary>
                Pops a table from the stack and sets it as the new
                environment for the value at the given index.
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns>
                If the value at the given index is neither a function nor a
                thread nor a userdata, lua_setfenv returns 0. Otherwise it returns 1.
            </returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_call(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="nargs"></param>
            <param name="nresults"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pcall(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
                Calls a function in protected mode.
            </summary>
            <param name="L"></param>
            <param name="nargs">
                Both nargs and nresults have the same meaning as in lua_call. If there are
                no errors during the call, lua_pcall behaves exactly like lua_call. However,
                if there is any error, lua_pcall catches it, pushes a single value on the
                stack (the error message), and returns an error code. Like lua_call,
                lua_pcall always removes the function and its arguments from the stack.
            </param>
            <param name="nresults">
                Both nargs and nresults have the same meaning as in lua_call. If there are
                no errors during the call, lua_pcall behaves exactly like lua_call. However,
                if there is any error, lua_pcall catches it, pushes a single value on the
                stack (the error message), and returns an error code. Like lua_call,
                lua_pcall always removes the function and its arguments from the stack.
            </param>
            <param name="errfunc">
                If errfunc is 0, then the error message returned on the stack is exactly
                the original error message. Otherwise, errfunc is the stack index of an error
                handler function. (In the current implementation, this index cannot be a
                pseudo-index.) In case of runtime errors, this function will be called with
                the error message and its return value will be the message returned on the
                stack by lua_pcall.
            </param>
            <returns>
                The lua_pcall function returns 0 in case of success or one of the following error codes (defined in lua.h):
                    LUA_ERRRUN: a runtime error.
                    LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the error handler function.
                    LUA_ERRERR: error while running the error handler function.
            </returns>
            <remarks>
                Typically, the error handler function is used to add more debug information
                to the error message, such as a stack traceback. Such information cannot
                be gathered after the return of lua_pcall, since by then the stack has unwound.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_cpcall(System.IntPtr,Tao.Lua.Lua.lua_CFunction,System.IntPtr)">
            <summary>
                Calls the C function func in protected mode. func starts with only one
                element in its stack, a light userdata containing ud. In case of errors,
                lua_cpcall returns the same error codes as lua_pcall, plus the error object
                on the top of the stack; otherwise, it returns zero, and does not change
                the stack. All values returned by func are discarded.
            </summary>
            <param name="L"></param>
            <param name="func"></param>
            <param name="ud"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_load(System.IntPtr,Tao.Lua.Lua.lua_Reader,System.IntPtr,System.String)">
            <summary>
                Loads a Lua chunk. If there are no errors, lua_load pushes the compiled
                chunk as a Lua function on top of the stack. Otherwise, it pushes an
                error message.
            </summary>
            <param name="L"></param>
            <param name="reader"></param>
            <param name="data">The data argument is an opaque value passed to the reader function.</param>
            <param name="chunkname">The chunkname argument gives a name to the chunk, which is used for error messages and in debug information.</param>
            <returns>0: no errors.  LUA_ERRSYNTAX: syntax error during pre-compilation. LUA_ERRMEM: memory allocation error.</returns>
            <remarks>This function only loads a chunk; it does not run it. lua_load automatically detects whether the chunk is text or binary, and loads it accordingly (see program luac). lua_load uses a user-supplied reader function to read the chunk (see lua_Reader).</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_dump(System.IntPtr,Tao.Lua.Lua.lua_Writer,System.IntPtr)">
            <summary>
                Dumps a function as a binary chunk. Receives a Lua function on the
                top of the stack and produces a binary chunk that, if loaded again,
                results in a function equivalent to the one dumped. As it produces
                parts of the chunk, lua_dump calls function writer (see lua_Writer)
                with the given data to write them.
            </summary>
            <param name="L"></param>
            <param name="writer"></param>
            <param name="data"></param>
            <returns>
                The value returned is the error code returned by the last call to
                the writer; 0 means no errors.
            </returns>
            <remarks>
                This function does not pop the Lua function from the stack.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_yield(System.IntPtr,System.Int32)">
            <summary>
                Yields a coroutine.
            </summary>
            <param name="L"></param>
            <param name="nresults"></param>
            <returns></returns>
            <remarks>
                When a C function calls lua_yield in that way, the running coroutine suspends its execution, and the call to lua_resume that started this coroutine returns. The parameter nresults is the number of values from the stack that are passed as results to lua_resume.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_resume(System.IntPtr,System.Int32)">
            <summary>
                Starts and resumes a coroutine in a given thread.
            </summary>
            <param name="L"></param>
            <param name="narg"></param>
            <returns>
                When it returns, the stack contains all values passed to lua_yield, or
                all values returned by the body function. lua_resume returns LUA_YIELD
                if the coroutine yields, 0 if the coroutine finishes its execution without
                errors, or an error code in case of errors (see lua_pcall). In case of 
                errors, the stack is not unwound, so you can use the debug API over it. The
                error message is on the top of the stack.
            </returns>
            <remarks>
                To start a coroutine, you first create a new thread (see lua_newthread);
                then you push onto its stack the main function plus any arguments;
                then you call lua_resume, with narg being the number of arguments.
                This call returns when the coroutine suspends or finishes its execution.
                To restart a coroutine, you put on its stack only the values to be passed
                as results from yield, and then call lua_resume.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_status(System.IntPtr)">
            <summary>
                Returns the status of the thread L.
            </summary>
            <param name="L"></param>
            <returns></returns>
            <remarks>
                The status can be 0 for a normal thread, an error code if the thread finished its execution with an error, or LUA_YIELD if the thread is suspended.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_gc(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Controls the garbage collector.
            </summary>
            <param name="L"></param>
            <param name="what"></param>
            <param name="data"></param>
            <returns></returns>
            <remarks>
                This function performs several tasks, according to the value of the parameter what:
                    LUA_GCSTOP: stops the garbage collector.
                    LUA_GCRESTART: restarts the garbage collector.
                    LUA_GCCOLLECT: performs a full garbage-collection cycle.
                    LUA_GCCOUNT: returns the current amount of memory (in Kbytes) in use by Lua.
                    LUA_GCCOUNTB: returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024.
                    LUA_GCSTEP: performs an incremental step of garbage collection. The step "size" is controlled by data (larger values mean more steps) in a non-specified way. If you want to control the step size you must experimentally tune the value of data. The function returns 1 if the step finished a garbage-collection cycle.
                    LUA_GCSETPAUSE: sets data/100 as the new value for the pause of the collector (see §2.10). The function returns the previous value of the pause.
                    LUA_GCSETSTEPMUL: sets arg/100 as the new value for the step multiplier of the collector (see §2.10). The function returns the previous value of the step multiplier.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_error(System.IntPtr)">
            <summary>
                Generates a Lua error. The error message (which can actually
                be a Lua value of any type) must be on the stack top. This function
                does a long jump, and therefore never returns. (see luaL_error).
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_next(System.IntPtr,System.Int32)">
            <summary>
                Pops a key from the stack, and pushes a key-value pair from the
                table at the given index (the "next" pair after the given key).
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <returns>
                If there are no more elements in the table, then lua_next
                returns 0 (and pushes nothing).
            </returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_concat(System.IntPtr,System.Int32)">
            <summary>
                Concatenates the n values at the top of the stack, pops them, and leaves
                the result at the top. If n is 1, the result is the single string on
                the stack (that is, the function does nothing); if n is 0, the result
                is the empty string. Concatenation is done following the usual semantics
                of Lua.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getallocf(System.IntPtr,System.IntPtr)">
            <summary>
                Returns the memory-allocation function of a given state.
                If ud is not NULL, Lua stores in *ud the opaque pointer
                passed to lua_newstate.
            </summary>
            <param name="L"></param>
            <param name="ud"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_setallocf(System.IntPtr,Tao.Lua.Lua.lua_Alloc,System.IntPtr)">
            <summary>
                Changes the allocator function of a given state to f with
                user data ud.
            </summary>
            <param name="L"></param>
            <param name="f"></param>
            <param name="ud"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pop(System.IntPtr,System.Int32)">
            <summary>
                Pops n elements from the stack.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_newtable(System.IntPtr)">
            <summary>
                Creates a new empty table and pushes it onto the stack. 
            </summary>
            <param name="L"></param>
            <remarks>It is equivalent to lua_createtable(L, 0, 0).</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_register(System.IntPtr,System.String,Tao.Lua.Lua.lua_CFunction)">
            <summary>
                Sets the C function f as the new value of global name.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <param name="f"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushcfunction(System.IntPtr,Tao.Lua.Lua.lua_CFunction)">
            <summary>
                Pushes a C function onto the stack. This function receives a pointer
                to a C function and pushes onto the stack a Lua value of type function
                that, when called, invokes the corresponding C function.
            </summary>
            <param name="L"></param>
            <param name="f"></param>
            <remarks>
                Any function to be registered in Lua must follow the correct protocol
                to receive its parameters and return its results
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_strlen(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isfunction(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is a
                function (either C or Lua), and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_istable(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is a
                table, and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_islightuserdata(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is a light
                userdata, and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isnil(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is nil,
                and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isboolean(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index has type boolean, and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isthread(System.IntPtr,System.Int32)">
            <summary>
                Returns 1 if the value at the given acceptable index is a
                thread, and 0 otherwise.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isnone(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_isnoneornil(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_pushliteral(System.IntPtr,System.String)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="s"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_setglobal(System.IntPtr,System.String)">
            <summary>
                Pops a value from the stack and sets it as the new value of global name.
            </summary>
            <param name="L"></param>
            <param name="s"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getglobal(System.IntPtr,System.String)">
            <summary>
                Pushes onto the stack the value of the global name.
            </summary>
            <param name="L"></param>
            <param name="s"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_tostring(System.IntPtr,System.Int32)">
            <summary>
                Equivalent to lua_tolstring with len equal to NULL.
            </summary>
            <param name="L"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_open">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getregistry(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getgccount(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getstack(System.IntPtr,System.Int32,Tao.Lua.Lua.lua_Debug@)">
            <summary>
                Get information about the interpreter runtime stack.
            </summary>
            <param name="L"></param>
            <param name="level"></param>
            <param name="ar"></param>
            <returns>When there are no errors, lua_getstack returns 1; when called with a level greater than the stack depth, it returns 0.</returns>
            <remarks>This function fills parts of a lua_Debug structure with an identification of the activation record of the function executing at a given level. Level 0 is the current running function, whereas level n+1 is the function that has called level n.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getinfo(System.IntPtr,System.String,Tao.Lua.Lua.lua_Debug@)">
            <summary>
                Returns information about a specific function or function invocation.
            </summary>
            <param name="L"></param>
            <param name="what"></param>
            <param name="ar"></param>
            <returns></returns>
            <remarks>
                To get information about a function invocation, the parameter ar must be a valid activation record that was filled by a previous call to lua_getstack or given as argument to a hook (see lua_Hook).
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getlocal(System.IntPtr,Tao.Lua.Lua.lua_Debug@,System.Int32)">
            <summary>
                Gets information about a local variable of a given activation record.
            </summary>
            <param name="L"></param>
            <param name="ar">The parameter ar must be a valid activation record that was filled by a previous call to lua_getstack or given as argument to a hook (see lua_Hook).</param>
            <param name="n">The index n selects which local variable to inspect (1 is the first parameter or active local variable, and so on, until the last active local variable). lua_getlocal pushes the variable's value onto the stack and returns its name.</param>
            <returns>Returns NULL (and pushes nothing) when the index is greater than the number of active local variables.</returns>
            <remarks>
                Variable names starting with '(' (open parentheses) represent internal variables (loop control variables, temporaries, and C function locals).
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_setlocal(System.IntPtr,Tao.Lua.Lua.lua_Debug@,System.Int32)">
            <summary>
                Sets the value of a local variable of a given activation record
            </summary>
            <param name="L"></param>
            <param name="ar">Parameters ar and n are as in lua_getlocal (see lua_getlocal). lua_setlocal assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack.</param>
            <param name="n">Parameters ar and n are as in lua_getlocal (see lua_getlocal). lua_setlocal assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack.</param>
            <returns>Returns NULL (and pops nothing) when the index is greater than the number of active local variables.</returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getupvalue(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Gets information about a closure's upvalue. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.) lua_getupvalue gets the index n of an upvalue, pushes the upvalue's value onto the stack, and returns its name. funcindex points to the closure in the stack. (Upvalues have no particular order, as they are active through the whole function. So, they are numbered in an arbitrary order.)
            </summary>
            <param name="L"></param>
            <param name="funcindex"></param>
            <param name="n"></param>
            <returns>Returns NULL (and pushes nothing) when the index is greater than the number of upvalues. For C functions, this function uses the empty string "" as a name for all upvalues.</returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_setupvalue(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                Sets the value of a closure's upvalue. Parameters funcindex and n are as in lua_getupvalue (see lua_getupvalue). It assigns the value at the top of the stack to the upvalue and returns its name. It also pops the value from the stack.
            </summary>
            <param name="L"></param>
            <param name="funcindex"></param>
            <param name="n"></param>
            <returns>Returns NULL (and pops nothing) when the index is greater than the number of upvalues.</returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_sethook(System.IntPtr,Tao.Lua.Lua.lua_Hook,System.Int32,System.Int32)">
            <summary>
                Sets the debugging hook function.
            </summary>
            <param name="L"></param>
            <param name="func">func is the hook function.</param>
            <param name="mask">mask specifies on which events the hook will be called: it is formed by a bitwise or of the constants LUA_MASKCALL, LUA_MASKRET, LUA_MASKLINE, and LUA_MASKCOUNT.</param>
            <param name="count">The count argument is only meaningful when the mask includes LUA_MASKCOUNT.</param>
            <returns></returns>
            <remarks>
                For each event, the hook is called as explained below:
                * The call hook: is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments.
                * The return hook: is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. You have no access to the values to be returned by the function.
                * The line hook: is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.)
                * The count hook: is called after the interpreter executes every count instructions. (This event only happens while Lua is executing a Lua function.)
                A hook is disabled by setting mask to zero. 
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.lua_gethook(System.IntPtr)">
            <summary>
                Returns the current hook function.
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_gethookmask(System.IntPtr)">
            <summary>
                Returns the current hook mask.
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_gethookcount(System.IntPtr)">
            <summary>
                Returns the current hook count.
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_base(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_table(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_io(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_os(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_string(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_math(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_debug(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaopen_package(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_openlibs(System.IntPtr)">
            <summary>
            Opens all standard Lua libraries into the given state.
            </summary>
            <param name="L"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_asset(System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_getn(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_setn(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="t"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaI_openlib(System.IntPtr,System.String,Tao.Lua.Lua.luaL_Reg@,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="libname"></param>
            <param name="l"></param>
            <param name="nup"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_register(System.IntPtr,System.String,Tao.Lua.Lua.luaL_Reg@)">
            <summary>
            Opens a library.
            </summary>
            <param name="L"></param>
            <param name="libname"></param>
            <param name="l"></param>
            <remarks>When called with libname equal to NULL, it simply registers all functions in the list l (see luaL_Reg) into the table on the top of the stack.
            When called with a non-null libname, creates a new table t, sets it as the value of the global variable libname, sets it as the value of package.loaded[libname], and registers on it all functions in the list l. If there is a table in package.loaded[libname] or in variable libname, reuses this table instead of creating a new one.
            In any case the function leaves the table on the top of the stack. </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_getmetafield(System.IntPtr,System.Int32,System.String)">
            <summary>
            Pushes onto the stack the field e from the metatable of the object at index obj. If the object does not have a metatable, or if the metatable does not have this field, returns 0 and pushes nothing.
            </summary>
            <param name="L"></param>
            <param name="obj"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_callmeta(System.IntPtr,System.Int32,System.String)">
            <summary>
            Calls a metamethod.
            </summary>
            <param name="L"></param>
            <param name="obj"></param>
            <param name="e"></param>
            <returns></returns>
            <remarks>
            If the object at index obj has a metatable and this metatable has a field e, this function calls this field and passes the object as its only argument. In this case this function returns 1 and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns 0 (without pushing any value on the stack).
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_typerror(System.IntPtr,System.Int32,System.String)">
            <summary>
            Generates an error with a message.
            </summary>
            <param name="L"></param>
            <param name="narg"></param>
            <param name="tname"></param>
            <returns></returns>
            <remarks>Generates an error with a message like:
            [location]: bad argument [narg] to [function] ([tname] expected, got [realt])
            where [location] is produced by luaL_where, [function] is the name of the current function, and [realt] is the type name of the actual argument. </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_argerror(System.IntPtr,System.Int32,System.String)">
            <summary>
            Raises an error with the following message, where func is retrieved from the call stack:
            <code>bad argument #[numarg] to [func] ([extramsg])</code>
            </summary>
            <param name="L"></param>
            <param name="numarg"></param>
            <param name="extramsg"></param>
            <returns>This function never returns, but it is an idiom to use it in C functions as return luaL_argerror(args).</returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checklstring(System.IntPtr,System.Int32,System.UInt32@)">
            <summary>
            Checks whether the function argument narg is a string and returns this string; if l is not NULL fills *l with the string's length.
            </summary>
            <param name="L"></param>
            <param name="numArg"></param>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_optlstring(System.IntPtr,System.Int32,System.String,System.UInt32@)">
            <summary>
            If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error. If l is not NULL, fills the position *l with the results's length. 
            </summary>
            <param name="L"></param>
            <param name="numArg"></param>
            <param name="def"></param>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checknumber(System.IntPtr,System.Int32)">
            <summary>
            Checks whether the function argument narg is a number and returns this number.
            </summary>
            <param name="L"></param>
            <param name="numArg"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_optnumber(System.IntPtr,System.Int32,System.Double)">
            <summary>
            If the function argument narg is a number, returns this number. If this argument is absent or is nil, returns d. Otherwise, raises an error.
            </summary>
            <param name="L"></param>
            <param name="nArg"></param>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checkinteger(System.IntPtr,System.Int32)">
            <summary>
            Checks whether the function argument narg is a number and returns this number cast to a lua_Integer.
            </summary>
            <param name="L"></param>
            <param name="numArg"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_optinteger(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            If the function argument narg is a number, returns this number cast to a lua_Integer. If this argument is absent or is nil, returns d. Otherwise, raises an error.
            </summary>
            <param name="L"></param>
            <param name="nArg"></param>
            <param name="def"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checkstack(System.IntPtr,System.Int32,System.String)">
            <summary>
            Grows the stack size to top + sz elements, raising an error if the stack cannot grow to that size. msg is an additional text to go into the error message.
            </summary>
            <param name="L"></param>
            <param name="sz"></param>
            <param name="msg"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checktype(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Checks whether the function argument narg has type t.
            </summary>
            <param name="L"></param>
            <param name="narg"></param>
            <param name="t"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checkany(System.IntPtr,System.Int32)">
            <summary>
            Checks whether the function has an argument of any type (including nil) at position narg.
            </summary>
            <param name="L"></param>
            <param name="narg"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_newmetatable(System.IntPtr,System.String)">
            <summary>
            If the registry already has the key tname, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds it to the registry with key tname, and returns 1.
            </summary>
            <param name="L"></param>
            <param name="tname"></param>
            <returns></returns>
            <remarks>In both cases pushes onto the stack the final value associated with tname in the registry.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checkudata(System.IntPtr,System.Int32,System.String)">
            <summary>
            Checks whether the function argument narg is a userdata of the type tname (see luaL_newmetatable).
            </summary>
            <param name="L"></param>
            <param name="ud"></param>
            <param name="tname"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_where(System.IntPtr,System.Int32)">
            <summary>
            Pushes onto the stack a string identifying the current position of the control at level lvl in the call stack. Typically this string has the format {chunkname}:{currentline}:. Level 0 is the running function, level 1 is the function that called the running function, etc.
            </summary>
            <param name="L"></param>
            <param name="lvl"></param>
            <remarks>This function is used to build a prefix for error messages.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checkoption(System.IntPtr,System.Int32,System.String,System.String[])">
            <summary>
            Checks whether the function argument narg is a string and searches for this string in the array lst (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found.
            </summary>
            <param name="L"></param>
            <param name="narg"></param>
            <param name="def"></param>
            <param name="lst"></param>
            <returns></returns>
            <remarks>
            If def is not NULL, the function uses def as a default value when there is no argument narg or if this argument is nil.
            This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.) 
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_ref(System.IntPtr,System.Int32)">
            <summary>
            Creates and returns a reference, in the table at index t, for the object at the top of the stack (and pops the object).
            </summary>
            <param name="L"></param>
            <param name="t"></param>
            <returns></returns>
            <remarks>A reference is a unique integer key. As long as you do not manually add integer keys into table t, luaL_ref ensures the uniqueness of the key it returns. You can retrieve an object referred by reference r by calling lua_rawgeti(L, t, r). Function luaL_unref frees a reference and its associated object.
            If the object at the top of the stack is nil, luaL_ref returns the constant LUA_REFNIL. The constant LUA_NOREF is guaranteed to be different from any reference returned by luaL_ref.
            </remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_unref(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table, so that the referred object can be collected. The reference ref is also freed to be used again.
            </summary>
            <param name="L"></param>
            <param name="t"></param>
            <param name="rf">If rf is LUA_NOREF or LUA_REFNIL, luaL_unref does nothing.</param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_loadfile(System.IntPtr,System.String)">
            <summary>
            Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename. If filename is NULL, then it loads from the standard input. The first line in the file is ignored if it starts with a #.
            </summary>
            <param name="L"></param>
            <param name="filename"></param>
            <returns></returns>
            <remarks>This function returns the same results as lua_load, but it has an extra error code LUA_ERRFILE if it cannot open/read the file. As lua_load, this function only loads the chunk; it does not run it.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_loadbuffer(System.IntPtr,System.String,System.UInt32,System.String)">
            <summary>
            Loads a buffer as a Lua chunk. This function uses lua_load to load the chunk in the buffer pointed to by buff with size sz.
            </summary>
            <param name="L"></param>
            <param name="buff"></param>
            <param name="sz"></param>
            <param name="name"></param>
            <returns></returns>
            <remarks>This function returns the same results as lua_load. name is the chunk name, used for debug information and error messages.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_loadstring(System.IntPtr,System.String)">
            <summary>
            Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the zero-terminated string s.
            </summary>
            <param name="L"></param>
            <param name="s"></param>
            <returns></returns>
            <remarks>This function returns the same results as lua_load. Also as lua_load, this function only loads the chunk; it does not run it.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_newstate">
            <summary>
            Creates a new Lua state, calling lua_newstate with an allocation function based on the standard C realloc function and setting a panic function (see lua_atpanic) that prints an error message to the standard error output in case of fatal errors.
            </summary>
            <returns>Returns the new state, or NULL if there is a memory allocation error.</returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_gsub(System.IntPtr,System.String,System.String,System.String)">
            <summary>
            Creates a copy of string s by replacing any occurrence of the string p with the string r. Pushes the resulting string on the stack and returns it.
            </summary>
            <param name="L"></param>
            <param name="s"></param>
            <param name="p"></param>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_findtable(System.IntPtr,System.Int32,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="idx"></param>
            <param name="fname"></param>
            <param name="szhint"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_argcheck(System.IntPtr,System.Int32,System.Int32,System.String)">
            <summary>
            Checks whether cond is true. If not, raises an error with the following message, where func is retrieved from the call stack:
            <code>bad argument #[numarg] to [func] ([extramsg])</code>
            </summary>
            <param name="L"></param>
            <param name="cond"></param>
            <param name="numarg"></param>
            <param name="extramsg"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checkstring(System.IntPtr,System.Int32)">
            <summary>
            Checks whether the function argument narg is a string and returns this string.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_optstring(System.IntPtr,System.Int32,System.String)">
            <summary>
            If the function argument narg is a string, returns this string. If this argument is absent or is nil, returns d. Otherwise, raises an error.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checkint(System.IntPtr,System.Int32)">
            <summary>
            Checks whether the function argument narg is a number and returns this number cast to an int.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_optint(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            If the function argument narg is a number, returns this number cast to an int. 
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <param name="d"></param>
            <returns>If this argument is absent or is nil, returns d. Otherwise, raises an error.</returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_checklong(System.IntPtr,System.Int32)">
            <summary>
            Checks whether the function argument narg is a number and returns this number cast to a long.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_optlong(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            If the function argument narg is a number, returns this number cast to a long. If this argument is absent or is nil, returns d. Otherwise, raises an error.
            </summary>
            <param name="L"></param>
            <param name="n"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_typename(System.IntPtr,System.Int32)">
            <summary>
            Returns the name of the type of the value at index idx.
            </summary>
            <param name="L"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_dofile(System.IntPtr,System.String)">
            <summary>
            Loads and runs the given file.
            </summary>
            <param name="L"></param>
            <param name="fn"></param>
            <returns>It returns 0 if there are no errors or 1 in case of errors.</returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_dostring(System.IntPtr,System.String)">
            <summary>
            Loads and runs the given string.
            </summary>
            <param name="L"></param>
            <param name="s"></param>
            <returns>It returns 0 if there are no errors or 1 in case of errors.</returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_getmetatable(System.IntPtr,System.String)">
            <summary>
            Pushes onto the stack the metatable associated with name tname in the registry (see luaL_newmetatable).
            </summary>
            <param name="L"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_opt(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="f"></param>
            <param name="n"></param>
            <param name="d"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_addchar(Tao.Lua.Lua.luaL_Buffer@,System.Char)">
            <summary>
                Adds the character c to the buffer B (see luaL_Buffer).
            </summary>
            <param name="B"></param>
            <param name="c"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_putchar(Tao.Lua.Lua.luaL_Buffer@,System.Char)">
            <summary>
            
            </summary>
            <param name="B"></param>
            <param name="c"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_addsize(Tao.Lua.Lua.luaL_Buffer,System.Int32)">
            <summary>
                Adds a string of length n previously copied to the buffer area (see luaL_prepbuffer) to the buffer B (see luaL_Buffer).
            </summary>
            <param name="B"></param>
            <param name="n"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_buffinit(System.IntPtr,Tao.Lua.Lua.luaL_Buffer@)">
            <summary>
            Initializes a buffer B. This function does not allocate any space; the buffer must be declared as a variable (see luaL_Buffer).
            </summary>
            <param name="L"></param>
            <param name="B"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_prepbuffer(Tao.Lua.Lua.luaL_Buffer@)">
            <summary>
            Returns an address to a space of size LUAL_BUFFERSIZE where you can copy a string to be added to buffer B (see luaL_Buffer). After copying the string into this space you must call luaL_addsize with the size of the string to actually add it to the buffer.
            </summary>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_addlstring(Tao.Lua.Lua.luaL_Buffer@,System.String,System.UInt32)">
            <summary>
            Adds the string pointed to by s with length l to the buffer B (see luaL_Buffer). The string may contain embedded zeros.
            </summary>
            <param name="B"></param>
            <param name="s"></param>
            <param name="l"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_addstring(Tao.Lua.Lua.luaL_Buffer@,System.String)">
            <summary>
                Adds the zero-terminated string pointed to by s to the buffer B (see luaL_Buffer). The string may not contain embedded zeros.
            </summary>
            <param name="B"></param>
            <param name="s"></param>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_addvalue(Tao.Lua.Lua.luaL_Buffer@)">
            <summary>
            Adds the value at the top of the stack to the buffer B (see luaL_Buffer). Pops the value.
            </summary>
            <param name="B"></param>
            <remarks>This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer.</remarks>
        </member>
        <member name="M:Tao.Lua.Lua.luaL_pushresult(Tao.Lua.Lua.luaL_Buffer@)">
            <summary>
            Finishes the use of buffer B leaving the final string on the top of the stack.
            </summary>
            <param name="B"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_ref(System.IntPtr,System.Boolean)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="lockit"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Lua.Lua.lua_unref(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="reference"></param>
        </member>
        <member name="M:Tao.Lua.Lua.lua_getref(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="L"></param>
            <param name="reference"></param>
        </member>
        <member name="T:Tao.Lua.Lua.lua_CFunction">
            <summary>
                Type for C functions.
            </summary>
            <param name="L"></param>
            <remarks>
                In order to communicate properly with Lua, a C function must use the following
                protocol, which defines the way parameters and results are passed: a C function
                receives its arguments from Lua in its stack in direct order (the first argument
                is pushed first). So, when the function starts, lua_gettop(L) returns the number
                of arguments received by the function. The first argument (if any) is at index 1
                and its last argument is at index lua_gettop(L). To return values to Lua, a C
                function just pushes them onto the stack, in direct order (the first result is
                pushed first), and returns the number of results. Any other value in the stack
                below the results will be properly discarded by Lua. Like a Lua function, a C
                function called by Lua can also return many results.
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Tao.Lua.Lua.lua_Reader">
            <summary>
                The reader function used by lua_load.
            </summary>
            <param name="L"></param>
            <param name="ud"></param>
            <param name="sz"></param>
            <returns>
                To signal the end of the chunk, the reader must return NULL. The reader
                function may return pieces of any size greater than zero.
            </returns>
            <remarks>
                Every time it needs another piece of the chunk, lua_load calls the reader,
                passing along its data parameter. The reader must return a pointer to a
                block of memory with a new piece of the chunk and set size to the block size.
                The block must exist until the reader function is called again.
            </remarks>
        </member>
        <member name="T:Tao.Lua.Lua.lua_Writer">
            <summary>
                The writer function used by lua_dump. Every time it produces another piece of chunk, lua_dump calls the writer, passing along the buffer to be written (p), its size (sz), and the data parameter supplied to lua_dump.
            </summary>
            <param name="L"></param>
            <param name="p"></param>
            <param name="sz"></param>
            <param name="ud"></param>
            <returns>
                The writer returns an error code: 0 means no errors; any other value means an error and stops lua_dump from calling the writer again.
            </returns>
        </member>
        <member name="T:Tao.Lua.Lua.lua_Alloc">
            <summary>
            
            </summary>
            <param name="ud"></param>
            <param name="ptr"></param>
            <param name="osize"></param>
            <param name="nsize"></param>
            <returns></returns>
        </member>
        <member name="T:Tao.Lua.Lua.lua_Hook">
            <summary>
                Type for debugging hook functions.
            </summary>
            <param name="L"></param>
            <param name="ar"></param>
            <remarks>
                Whenever a hook is called, its ar argument has its field event set to the specific event that triggered the hook. Lua identifies these events with the following constants: LUA_HOOKCALL, LUA_HOOKRET, LUA_HOOKTAILRET, LUA_HOOKLINE, and LUA_HOOKCOUNT. Moreover, for line events, the field currentline is also set. To get the value of any other field in ar, the hook must call lua_getinfo. For return events, event may be LUA_HOOKRET, the normal value, or LUA_HOOKTAILRET. In the latter case, Lua is simulating a return from a function that did a tail call; in this case, it is useless to call lua_getinfo.
                While Lua is running a hook, it disables other calls to hooks. Therefore, if a hook calls back Lua to execute a function or a chunk, this execution occurs without any calls to hooks.
            </remarks>
        </member>
        <member name="T:Tao.Lua.Lua.lua_Debug">
            <summary>
                A structure used to carry different pieces of information about an active function. lua_getstack fills only the private part of this structure, for later use. To fill the other fields of lua_Debug with useful information, call lua_getinfo.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.Event">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.name">
            <summary>
                a reasonable name for the given function. Because functions in Lua are first-class values, they do not have a fixed name: some functions may be the value of multiple global variables, while others may be stored only in a table field. The lua_getinfo function checks how the function was called to find a suitable name. If it cannot find a name, then name is set to NULL.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.namewhat">
            <summary>
                explains the name field. The value of namewhat can be "global", "local", "method", "field", "upvalue", or "" (the empty string), according to how the function was called. (Lua uses the empty string when no other option seems to apply.)
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.what">
            <summary>
            the string "Lua" if the function is a Lua function, "C" if it is a C function, "main" if it is the main part of a chunk, and "tail" if it was a function that did a tail call. In the latter case, Lua has no other information about the function.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.source">
            <summary>
            If the function was defined in a string, then source is that string. If the function was defined in a file, then source starts with a '@' followed by the file name.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.currentline">
            <summary>
            the current line where the given function is executing. When no line information is available, currentline is set to -1.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.nups">
            <summary>
                the number of upvalues of the function.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.linedefined">
            <summary>
            the line number where the definition of the function starts.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.short_src">
            <summary>
            a "printable" version of source, to be used in error messages.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.lua_Debug.i_ci">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Lua.Lua.luaL_Reg">
            <summary>
            Type for arrays of functions to be registered by luaL_register. name is the function name and func is a pointer to the function. Any array of luaL_Reg must end with an sentinel entry in which both name and func are NULL.
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.luaL_Reg.name">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.luaL_Reg.func">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Lua.Lua.luaL_Buffer">
            <summary>
            Type for a string buffer.
            </summary>
            <remarks>
            A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows:
                * First you declare a variable b of type luaL_Buffer.
                * Then you initialize it with a call luaL_buffinit(L, &amp;b).
                * Then you add string pieces to the buffer calling any of the luaL_add* functions.
                * You finish by calling luaL_pushresult(&amp;b). This call leaves the final string on the top of the stack.
            During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is luaL_addvalue.) After calling luaL_pushresult the stack is back to its level when the buffer was initialized, plus the final string on its top.
            </remarks>
        </member>
        <member name="F:Tao.Lua.Lua.luaL_Buffer.p">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.luaL_Buffer.lvl">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.luaL_Buffer.L">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Lua.Lua.luaL_Buffer.buffer">
            <summary>
            
            </summary>
        </member>
    </members>
</doc>
