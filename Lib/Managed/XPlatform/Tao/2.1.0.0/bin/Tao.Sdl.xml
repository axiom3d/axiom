<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tao.Sdl</name>
    </assembly>
    <members>
        <member name="T:Tao.Sdl.SdlGfx">
             <summary>
             SDL graphics drawing primitives and other support functions
             The SDL_gfx library evolved out of the SDL_gfxPrimitives code which
             provided basic drawing routines such as lines, circles or polygons
             and SDL_rotozoom which implemented a interpolating rotozoomer for
             SDL surfaces.
             <p>
             The current components of the SDL_gfx library are:
            
             <br>Graphic Primitives (SDL_gfxPrimitves.h)</br>
             <br>Rotozoomer (SDL_rotozoom.h) </br>
             <br>Framerate control (SDL_framerate.h) </br>
             MMX image filters (SDL_imageFilter.h)</p>
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.SDL_GFX_NATIVE_LIBRARY">
            <summary>
            Specifies SdlTtf's native library archive.
            </summary>
            <remarks>
            Specifies SDL_gfx.dll everywhere; will be mapped via .config for mono.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.CALLING_CONVENTION">
            <summary>
            Specifies the calling convention.
            </summary>
            <remarks>
            Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/>
            for Windows and Linux.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.SDL_GFXPRIMITIVES_MAJOR">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.SDL_GFXPRIMITIVES_MINOR">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.SDL_GFXPRIMITIVES_MICRO">
            <summary>
            Micro Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.SMOOTHING_OFF">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.SMOOTHING_ON">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.FPS_UPPER_LIMIT">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.FPS_LOWER_LIMIT">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.FPS_DEFAULT">
             <summary>
            
             </summary>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.pixelColor(System.IntPtr,System.Int16,System.Int16,System.Int32)">
            <summary>
            Pixel
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.pixelRGBA(System.IntPtr,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Pixel
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.hlineColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Horizontal line
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="y"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.hlineRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Horizontal line
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="y"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.vlineColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Vertical line
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y1"></param>
            <param name="y2"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.vlineRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Vertical Line
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y1"></param>
            <param name="y2"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.rectangleColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Rectangle
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.rectangleRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Rectangle
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.boxColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Filled rectangle (Box)
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.boxRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Filled rectangle (Box)
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.lineColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Line
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.lineRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Line
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aalineColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            AA Line
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aalineRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            AA Line
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.circleColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int32)">
             <summary>
             Circle
             </summary>
             <remarks>
            
             <p>Binds to C-function in SDL_gfx.h
             <code>
             int circleColor(IntPtr dst, short x, short y, short r, int color);
             </code></p>
             </remarks>
             <example>
             <code>
            
             </code>
             </example>
             <returns>
            
             </returns>
             <param name="color"></param>
             <param name="dst"></param>
             <param name="r"></param>
             <param name="x"></param>
             <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.circleRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
             <summary>
             Circle
             </summary>
             <remarks>
            
             <p>Binds to C-function in SDL_gfx.h
             <code>
             int circleRGBA(IntPtr dst, short x, short y, short rad, byte r, byte g, byte b, byte a)
             </code></p>
             </remarks>
             <example>
             <code>
            
             </code>
             </example>
             <returns>
            
             </returns>
             <param name="a"></param>
             <param name="b"></param>
             <param name="g"></param>
             <param name="rad"></param>
             <param name="dst"></param>
             <param name="r"></param>
             <param name="x"></param>
             <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledCircleColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int32)">
             <summary>
             Filled Circle
             </summary>
             <remarks>
            
             <p>Binds to C-function in SDL_gfx.h
             <code>
             int filledCircleColor(IntPtr dst, short x, short y, short r, int color);
             </code></p>
             </remarks>
             <example>
             <code>
            
             </code>
             </example>
             <returns>
            
             </returns>
             <param name="color"></param>
             <param name="dst"></param>
             <param name="r"></param>
             <param name="x"></param>
             <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledCircleRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
             <summary>
             Filled Circle
             </summary>
             <remarks>
            
             <p>Binds to C-function in SDL_gfx.h
             <code>
             int filledCircleRGBA(IntPtr dst, short x, short y, short rad, byte r, byte g, byte b, byte a)
             </code></p>
             </remarks>
             <example>
             <code>
            
             </code>
             </example>
             <returns>
            
             </returns>
             <param name="a"></param>
             <param name="b"></param>
             <param name="g"></param>
             <param name="rad"></param>
             <param name="dst"></param>
             <param name="r"></param>
             <param name="x"></param>
             <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aacircleColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            AA Circle
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="r"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aacircleRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            AA Circle
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rad"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.ellipseColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Ellipse
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rx"></param>
            <param name="ry"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.ellipseRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Ellipse
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rx"></param>
            <param name="ry"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aaellipseColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            AA Ellipse
            </summary>
            <param name="dst"></param>
            <param name="xc"></param>
            <param name="yc"></param>
            <param name="rx"></param>
            <param name="ry"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aaellipseRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            AA Ellipse
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rx"></param>
            <param name="ry"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledEllipseColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Filled Ellipse
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rx"></param>
            <param name="ry"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledEllipseRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Filled Ellipse
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rx"></param>
            <param name="ry"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.pieColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Pie
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rad"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.pieRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Pie
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rad"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledPieColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Filled Pie
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rad"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledPieRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Filled Pie
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rad"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.trigonColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Trigon
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.trigonRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Trigon
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aatrigonColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            AA-Trigon
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aatrigonRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            AA-Trigon
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledTrigonColor(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int32)">
            <summary>
            Filled Trigon
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledTrigonRGBA(System.IntPtr,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Filled Trigon
            </summary>
            <param name="dst"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.polygonColor(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Int32)">
            <summary>
            Polygon
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.polygonRGBA(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Polygon
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aapolygonColor(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Int32)">
            <summary>
            AA-Polygon
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.aapolygonRGBA(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            AA-Polygon
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledPolygonColor(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Int32)">
            <summary>
            Filled Polygon
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.filledPolygonRGBA(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Filled Polygon
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.texturedPolygon(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Textured Polygon
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="texture"></param>
            <param name="texture_dx"></param>
            <param name="texture_dy"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.bezierColor(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Bezier
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="s">number of steps</param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.bezierRGBA(System.IntPtr,System.Int16[],System.Int16[],System.Int32,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Bezier
            </summary>
            <param name="dst"></param>
            <param name="vx"></param>
            <param name="vy"></param>
            <param name="n"></param>
            <param name="s">number of steps</param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.characterColor(System.IntPtr,System.Int16,System.Int16,System.Char,System.Int32)">
            <summary>
            Character
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="c"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.characterRGBA(System.IntPtr,System.Int16,System.Int16,System.Char,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Character
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="c"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.stringColor(System.IntPtr,System.Int16,System.Int16,System.String,System.Int32)">
            <summary>
            String
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="c"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.stringRGBA(System.IntPtr,System.Int16,System.Int16,System.String,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            String
            </summary>
            <param name="dst"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="c"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.gfxPrimitivesSetFont(System.Object,System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="fontdata"></param>
             <param name="cw">Width</param>
             <param name="ch">Height</param>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.rotozoomSurface(System.IntPtr,System.Double,System.Double,System.Int32)">
            <summary>
            Rotates and zoomes a 32bit or 8bit 'src' surface to newly created 'dst' surface.
            'angle' is the rotation in degrees. 'zoom' a scaling factor. If 'smooth' is 1
            then the destination 32bit surface is anti-aliased. If the surface is not 8bit
            or 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.
            </summary>
            <param name="src"></param>
            <param name="angle"></param>
            <param name="zoom"></param>
            <param name="smooth"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.rotozoomSurfaceXY(System.IntPtr,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Rotates and zoomes a 32bit or 8bit 'src' surface to newly created 'dst' surface. 
            'angle' is the rotation in degrees. 
            'zoomx' and 'zoomy' are scaling factors that  can also be negative. 
            In this case the corresponding axis is flipped.  
            If 'smooth'   is 1 then the destination 32bit surface is anti-aliased. 
            If the surface is not 8bit  or 32bit RGBA/ABGR it will be converted into 
            a 32bit RGBA format on the fly.   
            Note: Flipping currently only works with antialiasing turned off.
            </summary>
            <param name="src"></param>
            <param name="angle"></param>
            <param name="zoomx"></param>
            <param name="zoomy"></param>
            <param name="smooth"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.rotozoomSurfaceSize(System.Int32,System.Int32,System.Double,System.Double,System.Int32@,System.Int32@)">
            <summary>
            Returns the size of the target surface for a rotozoomSurface() call
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="angle"></param>
            <param name="zoom"></param>
            <param name="dstheight"></param>
            <param name="dstwidth"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.rotozoomSurfaceSizeXY(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Int32@,System.Int32@)">
            <summary>
            Returns the size of the target surface for a rotozoomSurface() call
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="angle"></param>
            <param name="zoomx"></param>
            <param name="zoomy"></param>
            <param name="dstheight"></param>
            <param name="dstwidth"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.zoomSurface(System.IntPtr,System.Double,System.Double,System.Int32)">
            <summary>
            Zooms a 32bit or 8bit 'src' surface to newly created 'dst' surface.
            'zoomx' and 'zoomy' are scaling factors for width and height. If 'smooth' is 1
            then the destination 32bit surface is anti-aliased. If the surface is not 8bit
            or 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.
            </summary>
            <param name="src"></param>
            <param name="zoomx"></param>
            <param name="zoomy"></param>
            <param name="smooth"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.zoomSurfaceSize(System.Int32,System.Int32,System.Double,System.Double,System.Int32@,System.Int32@)">
            <summary>
            Returns the size of the target surface for a zoomSurface() call
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="zoomx"></param>
            <param name="zoomy"></param>
            <param name="dstheight"></param>
            <param name="dstwidth"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.shrinkSurface(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Shrinks a 32bit or 8bit 'src' surface ti a newly created 'dst' surface.
            'factorx' and 'factory' are the shrinking ratios (i.e. 2=1/2 the size,
            3=1/3 the size, etc.) The destination surface is antialiased by averaging
            the source box RGBA or Y information. If the surface is not 8bit
            or 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.
            </summary>
            <param name="src"></param>
            <param name="factorx"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_initFramerate(System.IntPtr)">
             <summary>
            
             </summary>
             <remarks>
             <p>
             Binds to C-function call in SDL_framerate.h.
             <code>
             void SDL_initFramerate(FPSmanager * manager)
             </code>
             </p>
             </remarks>
             <param name="manager">IntPtr to FPSmanager struct</param>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_setFramerate(System.IntPtr,System.Int32)">
             <summary>
            
             </summary>
             <remarks>
             <p>
             Binds to C-function call in SDL_framerate.h.
             <code>
             int SDL_setFramerate(FPSmanager * manager, int rate)
             </code>
             </p>
             </remarks>
             <param name="manager">IntPtr to FPSmanager struct</param>
             <param name="rate"></param>
             <returns>Returns 0 for success and -1 for error</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_getFramerate(System.IntPtr)">
             <summary>
            
             </summary>
             <remarks>
             <p>
             Binds to C-function call in SDL_framerate.h.
             <code>
             int SDL_getFramerate(FPSmanager * manager)
             </code>
             </p>
             </remarks>
             <param name="manager">IntPtr to FPSmanager struct</param>
             <returns>Returns value for success and -1 for error</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_framerateDelay(System.IntPtr)">
             <summary>
            
             </summary>
             <remarks>
             <p>
             Binds to C-function call in SDL_framerate.h.
             <code>
             void SDL_framerateDelay(FPSmanager * manager)
             </code>
             </p>
             </remarks>
             <param name="manager">IntPtr to FPSmanager struct</param>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMMXdetect">
            <summary>
            Detect MMX capability in CPU
            </summary>
            <remarks>
            <p>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterMMXdetect(void)
            </code>
            </p>
            </remarks>
            <returns>
            Returns 0 for success and -1 for Error.
            </returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMMXoff">
            <summary>
            Force use of MMX off.
            </summary>
            <remarks>
            <p>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            void SDL_imageFilterMMXoff(void)
            </code>
            </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMMXon">
            <summary>
            Turn possible use of MMX back on
            </summary>
            <remarks>
            <p>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            void SDL_imageFilterMMXon(void)
            </code>
            </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterAdd(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterAdd: D = saturation255(S1 + S2)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterAdd(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMean(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterMean: D = S1/2 + S2/2
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterMean(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterSub(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterSub: D = saturation0(S1 - S2)
            </summary>
            <remarks>
            Binds to C-function call in SDL_framerate.h.
            <code>
            int SDL_imageFilterSub(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterAbsDiff(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterAbsDiff: D = | S1 - S2 |
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterAbsDiff(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMult(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterMult: D = saturation(S1 * S2)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterMult(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMultNor(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterMultNor: D = S1 * S2 (non-MMX)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterMultNor(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMultDivby2(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterMultDivby2: D = saturation255(S1/2 * S2)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterMultDivby2(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMultDivby4(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterMultDivby4: D = saturation255(S1/2 * S2)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterMultDivby4(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterBitAnd(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterBitAnd: D = S1 &amp; S2
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterBitAnd(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterBitOr(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterBitOr: D = S1 | S2
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterBitAnd(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterDiv(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterDiv: D = S1 / S2 (non-MMX)
            </summary>
            <remarks>
            int SDL_imageFilterDiv(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Src2">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterBitNegation(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            SDL_imageFilterBitNegation: D = !S
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterNegation(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterAddByte(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterAddByte: D = saturation255(S + C)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterAddByte(unsigned char *Src1, unsigned char *Dest, int length, unsigned char C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="C">Byte to add</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterAddUint(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            SDL_imageFilterAddUint: D = saturation255(S + (uint)C)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterAddUint(unsigned char *Src1, unsigned char *Dest, int length, unsigned int C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="C">int to add</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterAddByteToHalf(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterAddByteToHalf: D = saturation255(S/2 + C)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterAddByteToHalf(unsigned char *Src1, unsigned char *Dest, int length, unsigned char C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="C">Byte to add</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterSubByte(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterSubByte: D = saturation0(S - C)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterSubByte(unsigned char *Src1, unsigned char *Dest, int length, unsigned char C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="C">Byte to add</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterSubUint(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            SDL_imageFilterSubUint: D = saturation0(S - (uint)C)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterSubUint(unsigned char *Src1, unsigned char *Dest, int length, unsigned int C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="C">int to add</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterShiftRight(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterShiftRight: D = saturation0(S >> N)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterShiftRight(unsigned char *Src1, unsigned char *Dest, int length, unsigned char C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="N">Shift</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterShiftRightUint(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterShiftRightUint: D = saturation0((uint)S >> N)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterShiftRightUint(unsigned char *Src1, unsigned char *Dest, int length, unsigned char C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="N">Shift</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterMultByByte(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterMultByByte: D = saturation255(S * C)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterMultByByte(unsigned char *Src1, unsigned char *Dest, int length, unsigned char C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="C">Byte</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterShiftRightAndMultByByte(System.Byte[],System.Byte[],System.Int32,System.Byte,System.Byte)">
            <summary>
            SDL_imageFilterShiftRightAndMultByByte: D = saturation255((S >> N) * C)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterShiftRightAndMultByByte(unsigned char *Src1, unsigned char *Dest, int length, unsigned char N, unsigned char C)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="C">Byte</param>
            <param name="N">Shift</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterShiftLeftByte(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterShiftLeftByte: D = (S &lt;&lt; N)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterShiftLeftByte(unsigned char *Src1, unsigned char *Dest, int length, unsigned char N)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="N">Shift</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterShiftLeft(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterShiftLeft: D = saturation255(S &lt;&lt; N)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterShiftLeft(unsigned char *Src1, unsigned char *Dest, int length, unsigned char N)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="N">Shift</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterShiftLeftUint(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterShiftLeftUint: D = ((uint)S &lt;&lt; N)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterShiftLeftUint(unsigned char *Src1, unsigned char *Dest, int length, unsigned char N)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="N">Shift</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterBinarizeUsingThreshold(System.Byte[],System.Byte[],System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterBinarizeUsingThreshold: D = S >= T ? 255:0
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterBinarizeUsingThreshold(unsigned char *Src1, unsigned char *Dest, int length, unsigned char T);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="T">Threshold</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterClipToRange(System.Byte[],System.Byte[],System.Int32,System.Byte,System.Byte)">
            <summary>
            SDL_imageFilterClipToRange: D = (S &gt;= Tmin) &amp; (S &lt;= Tmax) 255:0
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterClipToRange(unsigned char *Src1, unsigned char *Dest, int length, unsigned char Tmin, unsigned char Tmax);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="Tmin">Threshold</param>
            <param name="Tmax">Threshold</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterNormalizeLinear(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            SDL_imageFilterNormalizeLinear: D = saturation255((Nmax - Nmin)/(Cmax - Cmin)*(S - Cmin) + Nmin)
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterNormalizeLinear(unsigned char *Src1, unsigned char *Dest, int length, int Cmin, int Cmax, int Nmin, int Nmax);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="Nmin">Threshold</param>
            <param name="Nmax">Threshold</param>
            <param name="Cmin">Threshold</param>
            <param name="Cmax">Threshold</param>
            <param name="length">Size of array</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel3x3Divide(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel3x3Divide: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel3x3Divide(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char Divisor);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="rows">Threshold</param>
            <param name="columns">Threshold</param>
            <param name="Kernel">Size of array</param>
            <param name="Divisor"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel5x5Divide(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel5x5Divide: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel5x5Divide(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char Divisor);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="columns"></param>
            <param name="Divisor"></param>
            <param name="Kernel"></param>
            <param name="rows"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel7x7Divide(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel7x7Divide: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel7x7Divide(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char Divisor);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="columns"></param>
            <param name="Divisor"></param>
            <param name="Kernel"></param>
            <param name="rows"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel9x9Divide(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel9x9Divide: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel9x9Divide(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char Divisor);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="columns"></param>
            <param name="Divisor"></param>
            <param name="Kernel"></param>
            <param name="rows"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel3x3ShiftRight(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel3x3ShiftRight: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel3x3ShiftRight(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char NRightShift);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="columns"></param>
            <param name="NRightShift"></param>
            <param name="Kernel"></param>
            <param name="rows"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel5x5ShiftRight(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel5x5ShiftRight: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel5x5ShiftRight(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char NRightShift);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="columns"></param>
            <param name="NRightShift"></param>
            <param name="Kernel"></param>
            <param name="rows"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel7x7ShiftRight(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel7x7ShiftRight: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel7x7ShiftRight(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char NRightShift);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="rows">Threshold</param>
            <param name="columns">Threshold</param>
            <param name="Kernel">Size of array</param>
            <param name="NRightShift"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterConvolveKernel9x9ShiftRight(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int16[],System.Byte)">
            <summary>
            SDL_imageFilterConvolveKernel9x9ShiftRight: Dij = saturation0and255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterConvolveKernel9x9ShiftRight(unsigned char *Src, unsigned char *Dest, int rows, int columns, signed short *Kernel, unsigned char NRightShift);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="rows">Threshold</param>
            <param name="columns">Threshold</param>
            <param name="Kernel">Size of array</param>
            <param name="NRightShift"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterSobelX(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            SDL_imageFilterSobelX: Dij = saturation255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterSobelX(unsigned char *Src, unsigned char *Dest, int rows, int columns)
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="rows">Threshold</param>
            <param name="columns">Threshold</param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterSobelXShiftRight(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Byte)">
            <summary>
            SDL_imageFilterSobelXShiftRight: Dij = saturation255( ... ). For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            int SDL_imageFilterSobelXShiftRight(unsigned char *Src, unsigned char *Dest, int rows, int columns, unsigned char NRightShift);
            </code>
            </remarks>
            <param name="Src1">Array of bytes</param>
            <param name="Dest">Array of bytes returned after operation.</param>
            <param name="rows">Threshold</param>
            <param name="columns">Threshold</param>
            <param name="NRightShift"></param>
            <returns>Returns 0 for success and -1 for Error.</returns>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterAlignStack">
            <summary>
            Align stack to 32 byte boundary -- Functionality untested! --. For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            void SDL_imageFilterAlignStack(void)
            </code>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_imageFilterRestoreStack">
            <summary>
            Restore stack to 32 byte boundary -- Functionality untested! --. For MMX processors only.
            </summary>
            <remarks>
            Binds to C-function call in SDL_imageFilter.h.
            <code>
            void SDL_imageFilterRestoreStack(void)
            </code>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_gfxBlitRGBA(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect)">
            <summary>
            
            </summary>
            <remarks>
            Binds to C-function call in SDL_gfxBlitFunc.h.
            <code>
            int  SDL_gfxBlitRGBA(SDL_Surface * src, SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect);
            </code>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlGfx.SDL_gfxSetAlpha(System.IntPtr,System.Byte)">
            <summary>
            
            </summary>
            <remarks>
            Binds to C-function call in SDL_gfxBlitFunc.h.
            <code>
            int SDL_gfxSetAlpha(SDL_Surface * src, Uint8 a);
            </code>
            </remarks>
        </member>
        <member name="T:Tao.Sdl.SdlGfx.tColorRGBA">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.tColorRGBA.r">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.tColorRGBA.g">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.tColorRGBA.b">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.tColorRGBA.a">
             <summary>
            
             </summary>
        </member>
        <member name="T:Tao.Sdl.SdlGfx.tColorY">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.tColorY.y">
             <summary>
            
             </summary>
        </member>
        <member name="T:Tao.Sdl.SdlGfx.FPSmanager">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.FPSmanager.framecount">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.FPSmanager.rateticks">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.FPSmanager.lastticks">
             <summary>
            
             </summary>
        </member>
        <member name="F:Tao.Sdl.SdlGfx.FPSmanager.rate">
             <summary>
            
             </summary>
        </member>
        <member name="T:Tao.Sdl.SdlTtf">
            <summary>
            This library supports Sdl_ttf 2.0.8.
            This library is a wrapper around the excellent FreeType 1.2 library,
             available at: http://www.freetype.org
            <p>
            WARNING: There may be patent issues with using the FreeType library.
             Check the FreeType website for up-to-date details. 
             </p>
             <p>
            This library allows you to use TrueType fonts to render text in SDL
             applications. 
            </p>
            <p>
            Be careful when including fonts with your application, as many of 
            them are copyrighted. 
            The Microsoft fonts, for example, are not freely redistributable 
            and even the free "web" 
            fonts they provide are only redistributable in their special 
            executable installer form (May 1998). 
            There are plenty of freeware and shareware fonts available on the 
            Internet though, and may suit your purposes. 
            </p>
            </summary>
            <remarks>
            SDL_ttf supports loading fonts from TrueType font files, 
            normally ending in .ttf, though some .fon files are also valid for 
            use. Note that most fonts are copyrighted, check the license on the 
            font before you use and redistribute
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.SDL_TTF_NATIVE_LIBRARY">
            <summary>
                Specifies SdlTtf's native library archive.
            </summary>
            <remarks>
                Specifies SDL_ttf.dll everywhere; will be mapped via .config for mono.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/> 
                for Windows and Linux.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.TTF_MAJOR_VERSION">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.TTF_MINOR_VERSION">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.TTF_PATCHLEVEL">
            <summary>
            Patch Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.TTF_STYLE_NORMAL">
            <summary>
            Used to indicate regular, normal, plain rendering style.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.TTF_STYLE_BOLD">
            <summary>
            Used to indicate bold rendering style. 
            This is used a bitmask along with other styles.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.TTF_STYLE_ITALIC">
            <summary>
            Used to indicate italicized rendering style. 
            This is used a bitmask along with other styles.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.TTF_STYLE_UNDERLINE">
            <summary>
            Used to indicate underlined rendering style. 
            This is used a bitmask along with other styles.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.UNICODE_BOM_NATIVE">
            <summary>
            This allows you to switch byte-order of UNICODE text data 
            to native order, meaning the mode of your CPU. This is meant
            to be used in a UNICODE string that you are using with the 
            SDL_ttf API.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlTtf.UNICODE_BOM_SWAPPED">
            <summary>
            This allows you to switch byte-order of UNICODE text data to
             swapped order, meaning the reversed mode of your CPU. 
             So if your CPU is LSB, then the data will be interpreted
              as MSB. This is meant to be used in a UNICODE string 
              that you are using with the SDL_ttf API.
            </summary>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_VERSION">
            <summary>
            This method can be used to fill a version structure with the compile-time
            version of the SDL_ttf library.
            </summary>
            <returns>
                This function returns a <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct containing the
                compiled version number
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_ttf.h:
                <code>#define SDL_TTF_VERSION(X)
            {
            (X)-&gt;major = SDL_TTF_MAJOR_VERSION;
            (X)-&gt;minor = SDL_TTF_MINOR_VERSION;
            (X)-&gt;patch = SDL_TTF_PATCHLEVEL;
            }</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_Linked_Version">
            <summary>
                Using this you can compare the runtime version to the 
            version that you compiled with.
            </summary>
            <returns>
                This function gets the version of the dynamically 
            linked SDL_ttf library in an <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_ttf.h:
                <code>const SDL_version * TTF_Linked_Version(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_ByteSwappedUNICODE(System.Int32)">
            <summary>
            This function tells the library whether UNICODE text is generally
            byteswapped.  A UNICODE BOM character in a string will override
            this setting for the remainder of that string.
            </summary>
            <remarks>
            This function tells SDL_ttf whether UNICODE (Uint16 per character)
             text is generally byteswapped. A UNICODE_BOM_NATIVE or 
             UNICODE_BOM_SWAPPED character in a string will temporarily 
             override this setting for the remainder of that string, 
             however this setting will be restored for the next one. 
             The default mode is non-swapped, native endianess of the CPU. 
             <p>Binds to C-function in SDL_ttf.h
             <code>
             void TTF_ByteSwappedUNICODE(int swapped)
             </code></p>
            </remarks>
            <param name="swapped">
            if non-zero then UNICODE data is byte swapped relative to the 
            CPU's native endianess.<p>
            if zero, then do not swap UNICODE data, 
            use the CPU's native endianess.</p>
            </param>
            <example>
            <code>
            // Turn on byte swapping for UNICODE text
            TTF_ByteSwappedUNICODE(1);
            </code>
            </example>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_Init">
            <summary>
            Initialize the TTF engine - returns 0 if successful, -1 on error
            </summary>
            <remarks>
            Initialize the truetype font API.
            <p>
            This must be called before using other functions in this 
            library, excepting TTF_WasInit.</p>
            <p>
            SDL does not have to be initialized before this call.</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int TTF_Init()
             </code></p>
            </remarks>
            <example>
            <code>
            if(TTF_Init()==-1) {
            	printf("TTF_Init: %s\n", TTF_GetError());
            	exit(2);
            }
            </code>
            </example>
            <returns>
            0 on success, -1 on errors 
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_WasInit"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_Quit"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_OpenFont(System.String,System.Int32)">
            <summary>
            Open a font file and create a font of the specified point size.
            Some .fon fonts will have several sizes embedded in the file, so the
            point size becomes the index of choosing which size.  
            If the value
            is too high, the last indexed size will be the default.
            </summary>
            <param name="file">File name to load font from.</param>
            <param name="ptsize">Point size (based on 72DPI) to load font as.
             This basically translates to pixel height.</param>
             <remarks>
             Load file for use as a font, at ptsize size. 
             This is actually TTF_OpenFontIndex(file, ptsize, 0). 
             This can load TTF and FON files.
             <p>Binds to C-function in SDL_ttf.h
             <code>
             TTF_Font *TTF_OpenFont(const char *file, int ptsize)
             </code></p>
             </remarks>
             <example>
            <code>
            // load font.ttf at size 16 into font
            	TTF_Font *font;
            	font=TTF_OpenFont("font.ttf", 16);
            	if(!font) 
            {
            	printf("TTF_OpenFont: %s\n", TTF_GetError());
            	// handle error
            }
            </code>
            </example>
            <returns>
            a pointer to the font as a TTF_Font. NULL is returned on errors.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndex(System.String,System.Int32,System.Int64)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontRW(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_CloseFont(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndex(System.String,System.Int32,System.Int64)">
            <summary>
            Open a font file and create a font of the specified point size.
            Some .fon fonts will have several sizes embedded in the file, so the
            point size becomes the index of choosing which size.  
            If the value
            is too high, the last indexed size will be the default.
            </summary>
            <param name="file">File name to load font from.</param>
            <param name="ptsize">
            Point size (based on 72DPI) to load font as.
            This basically translates to pixel height.
            </param>
            <param name="index">
            choose a font face from a multiple font face containing file. 
            The first face is always index 0.
            </param>
            <remarks>
            Load file, face index, for use as a font, at ptsize size. 
            This is actually TTF_OpenFontIndexRW(SDL_RWFromFile(file), 
            ptsize, index), but checks that the RWops it creates is 
            not NULL. This can load TTF and FON files.
            <p>Binds to C-function in SDL_ttf.h
             <code>
             TTF_Font *TTF_OpenFontIndex(const char *file, int ptsize, long index)
             </code></p>
            </remarks>
            <example>
            <code>
            // load font.ttf, face 0, at size 16 into font
            	TTF_Font *font;
            	font=TTF_OpenFontIndex("font.ttf", 16, 0);
            	if(!font) 
            {
            	printf("TTF_OpenFontIndex: %s\n", TTF_GetError());
            	// handle error
            }
            </code>
            </example>
            <returns>
            a pointer to the font as a TTF_Font. NULL is returned on errors.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndexRW(System.IntPtr,System.Int32,System.Int32,System.Int64)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFont(System.String,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_CloseFont(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_OpenFontRW(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Open a font file suing RWOps and create a font of the specified point size.
            Some .fon fonts will have several sizes embedded in the file, so the
            point size becomes the index of choosing which size.  
            If the value
            is too high, the last indexed size will be the default.
            </summary>
            <param name="src">The font is loaded from this.</param>
            <param name="freesrc">
            A non-zero value mean is will automatically close/free the 
            src for you.
            </param>
            <param name="ptsize">
            Point size (based on 72DPI) to load font as. 
            This basically translates to pixel height.
            </param>
            <remarks>
            Load src for use as a font, at ptsize size. 
            This is actually TTF_OpenFontIndexRW(src, freesrc, ptsize, 0).
            This can load TTF and FON formats.
            Using SDL_RWops is not covered here, 
            but they enable you to load from almost any source.
            <p>
            NOTE: src is not checked for NULL, so be careful.</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             TTF_Font *TTF_OpenFontRW(SDL_RWops *src, int freesrc, int ptsize)
             </code></p>
            </remarks>
            <example>
            <code>
            // load font.ttf at size 16 into font
            	TTF_Font *font;
            	font=TTF_OpenFontRW(SDL_RWFromFile("font.ttf"), 1, 16);
            	if(!font) 
            {
            	printf("TTF_OpenFontRW: %s\n", TTF_GetError());
            	// handle error
            }
            </code>
            </example>
            <returns>
            a pointer to the font as a TTF_Font. NULL is returned on errors.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndexRW(System.IntPtr,System.Int32,System.Int32,System.Int64)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFont(System.String,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_CloseFont(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndexRW(System.IntPtr,System.Int32,System.Int32,System.Int64)">
            <summary>
            Open a font file using RWOps with an index and create 
            a font of the specified point size.
            Some .fon fonts will have several sizes embedded in the file, so the
            point size becomes the index of choosing which size.  
            If the value
            is too high, the last indexed size will be the default.
            </summary>
            <param name="freesrc">
            A non-zero value mean is will automatically close/free 
            the src for you.
            </param>
            <param name="index">
            choose a font face from a multiple font face containing file. 
            The first face is always index 0.
            </param>
            <param name="src">The font is loaded from this.</param>
            <param name="ptsize">
            Point size (based on 72DPI) to load font as. 
            This basically translates to pixel height.
            </param>
            <remarks>
            Load src, face index, for use as a font, at ptsize size. 
            This can load TTF and FON formats.
            Using SDL_RWops is not covered here, 
            but they enable you to load from almost any source.
            
            NOTE: src is not checked for NULL, so be careful.
            <p>Binds to C-function in SDL_ttf.h
             <code>
             TTF_Font *TTF_OpenFontIndexRW(SDL_RWops *src, int freesrc, int ptsize, long index)
             </code></p>
            </remarks>
            <example>
            <code>
            // load font.ttf, face 0, at size 16 into font
            	TTF_Font *font;
            	font=TTF_OpenFontRW(SDL_RWFromFile("font.ttf"), 1, 16, 0);
            	if(!font) 
            {
            	printf("TTF_OpenFontIndexRW: %s\n", TTF_GetError());
            	// handle error
            }
            </code>
            </example>
            <returns>
            a pointer to the font as a TTF_Font. NULL is returned on errors.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndex(System.String,System.Int32,System.Int64)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontRW(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_CloseFont(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_SetFontStyle(System.IntPtr,System.Int32)">
             <summary>
             Set the font style
             This font style is implemented by modifying the font glyphs, and
             doesn't reflect any inherent properties of the truetype font file.
             </summary>
             <param name="font">The loaded font to get the style of </param>
             <param name="style">
             A bitmask of the desired style composed 
             from the TTF_STYLE_* defined values
             </param>
             <remarks>
             Set the rendering style of the loaded font.
             <p>
             NOTE: Passing a NULL font into this function will cause a segfault.
             </p>
             <p>
             NOTE: This will flush the internal cache of previously rendered
              glyphs, even if there is no change in style, so it may be best 
              to check the current style using TTF_GetFontStyle first.
              </p>
             <p>
             NOTE: I've seen that combining TTF_STYLE_UNDERLINE with anything 
             can cause a segfault, other combinations may also do this. 
             Some brave soul may find the cause of this and fix it...
             </p>
             <p>Binds to C-function in SDL_ttf.h
              <code>
              void TTF_SetFontStyle(TTF_Font *font, int style)
              </code></p>
             </remarks>
             <example>
             <code>
             // set the loaded font's style to bold italics
            		//TTF_Font *font;
            		TTF_SetFontStyle(font, TTF_STYLE_BOLD|TTF_STYLE_ITALIC);
            
            		// render some text in bold italics...
            
            		// set the loaded font's style back to normal
            		TTF_SetFontStyle(font, TTF_STYLE_NORMAL);
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_GetFontStyle(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_GetFontStyle(System.IntPtr)">
             <summary>
             Retrieve the font style
             This font style is implemented by modifying the font glyphs, and
             doesn't reflect any inherent properties of the truetype font file.
             </summary>
             <remarks>
             Get the rendering style of the loaded font.
            <p>
             NOTE: Passing a NULL font into this function will cause a segfault.
             </p>
             </remarks>
             <param name="font">The loaded font to get the style of </param>
             <returns>
             The style as a bitmask composed of the following masks:
             <br>TTF_STYLE_BOLD</br>
             <br>TTF_STYLE_ITALIC</br>
             <br>TTF_STYLE_UNDERLINE</br>
             <p>If no style is set then TTF_STYLE_NORMAL is returned.</p>
             <p>Binds to C-function in SDL_ttf.h
              <code>
              int TTF_GetFontStyle(TTF_Font *font)
              </code></p>
             </returns>
             <example>
             <code>
             // get the loaded font's style
            		//TTF_Font *font;
            		int style;
            		style=TTF_GetFontStyle(font);
            		printf("The font style is:");
            		if(style==TTF_STYLE_NORMAL)
            		printf(" normal");
            		else 
            	{
            		if(style&amp;TTF_STYLE_BOLD)
            		printf(" bold");
            		if(style&amp;TTF_STYLE_ITALIC)
            		printf(" italic");
            		if(style&amp;TTF_STYLE_UNDERLINE)
            		printf(" underline");
            	}
            	printf("\n");
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SetFontStyle(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontHeight(System.IntPtr)">
            <summary>
            Get the total height of the font - usually equal to point size
            </summary>
            <param name="font">
            The loaded font to get the max height of 
            </param>
            <remarks>
            Get the maximum pixel height of all glyphs of the loaded font. 
            You may use this height for rendering text as close together 
            vertically as possible, though adding at least one pixel height
             to it will space it so they can't touch. Remember that SDL_ttf 
             doesn't handle multiline printing, so you are responsible for 
             line spacing, see the TTF_FontLineSkip as well.
            <p>
            NOTE: Passing a NULL font into this function will cause a segfault.</p>
            </remarks>
            <returns>
            The maximum pixel height of all glyphs in the font.
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int TTF_FontHeight(TTF_Font *font)
             </code></p>
            </returns>
            <example>
            <code>
            // get the loaded font's max height
            	//TTF_Font *font;
            	printf("The font max height is: %d\n", TTF_FontHeight(font));
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontAscent(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontDescent(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontLineSkip(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontAscent(System.IntPtr)">
             <summary>
             Get font max ascent (y above origin).
             Get the offset from the baseline to the top of the font
             This is a positive value, relative to the baseline.
             </summary>
             <param name="font">The loaded font to get the ascent 
             (height above baseline) of </param>
             <remarks>
             Get the maximum pixel ascent of all glyphs of the loaded font. 
             This can also be interpreted as the distance from the top of 
             the font to the baseline.
             <p>
             It could be used when drawing an individual glyph relative to 
             a top point, by combining it with the glyph's maxy metric to 
             resolve the top of the rectangle used when blitting the glyph 
             on the screen.</p>
             <p>
             rect.y = top + TTF_FontAscent(font) - glyph_metric.maxy;
             </p>
             <p>NOTE: Passing a NULL font into this function will 
             cause a segfault.</p>
             <p>Binds to C-function in SDL_ttf.h
              <code>
              int TTF_FontAscent(TTF_Font *font)
              </code></p>
             </remarks>
             <example>
             <code>
             // get the loaded font's max ascent
            		//TTF_Font *font;
            
            		printf("The font ascent is: %d\n", TTF_FontAscent(font));
             </code>
             </example>
             <returns>
             The maximum pixel ascent of all glyphs in the font.
             </returns>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontHeight(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontDescent(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontLineSkip(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontDescent(System.IntPtr)">
             <summary>
             Get font min descent (y below origin).
             Get the offset from the baseline to the bottom of the font
             This is a negative value, relative to the baseline.
             </summary>
             <param name="font">
             The loaded font to get the descent (height below baseline) of 
             </param>
             <remarks>
             Get the maximum pixel descent of all glyphs of the loaded font. 
             This can also be interpreted as the distance from the baseline 
             to the bottom of the font.
             It could be used when drawing an individual glyph relative to a 
             bottom point, by combining it with the glyph's maxy metric 
             to resolve the top of the rectangle used when blitting the 
             glyph on the screen.
             <p>
             rect.y = bottom - TTF_FontDescent(font) - glyph_metric.maxy;
             </p>
             <p>NOTE: Passing a NULL font into this function will cause a segfault.</p>
             <p>Binds to C-function in SDL_ttf.h
              <code>
              int TTF_FontDescent(TTF_Font *font)
              </code></p>
             </remarks>
             <example>
             <code>
             // get the loaded font's max descent
            		//TTF_Font *font;
            
            		printf("The font descent is: %d\n", TTF_FontDescent(font));
             </code>
             </example>
             <returns>
             The maximum pixel height of all glyphs in the font.
             </returns>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontHeight(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontAscent(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontLineSkip(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontLineSkip(System.IntPtr)">
             <summary>
             Get the recommended spacing between lines of text for this font.
             </summary>
             <param name="font">
             The loaded font to get the line skip height of 
             </param>
             <remarks>
             Get the reccomended pixel height of a rendered line of text 
             of the loaded font. This is usually larger than the 
             TTF_FontHeight of the font.
             <p>
             NOTE: Passing a NULL font into this function will cause a segfault.
             </p>
             <p>Binds to C-function in SDL_ttf.h
              <code>
              int TTF_FontLineSkip(TTF_Font *font)
              </code></p>
             </remarks>
             <example>
             <code>
             // get the loaded font's max descent
            		//TTF_Font *font;
            
            		printf("The font descent is: %d\n", TTF_FontDescent(font));
             </code>
             </example>
             <returns>
             The maximum pixel height of all glyphs in the font.
             </returns>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontHeight(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontAscent(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontDescent(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontFaces(System.IntPtr)">
            <summary>
            Get the number of faces of the font
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             long TTF_FontFaces(TTF_Font *font)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <returns>Number of faces in a font</returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceIsFixedWidth(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceFamilyName(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceStyleName(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontFaceIsFixedWidth(System.IntPtr)">
            <summary>
            Get whether font is monospaced or not.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int TTF_FontFaceIsFixedWidth(TTF_Font *font)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <returns>1 if true, 0 if false</returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaces(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceFamilyName(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceStyleName(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontFaceFamilyName(System.IntPtr)">
            <summary>
            Get current font face family name string.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             char * TTF_FontFaceFamilyName(TTF_Font *font)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <returns>Name of font family</returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaces(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceIsFixedWidth(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceStyleName(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_FontFaceStyleName(System.IntPtr)">
            <summary>
            Get current font face style name string.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             char * TTF_FontFaceStyleName(TTF_Font *font)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaces(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceIsFixedWidth(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_FontFaceFamilyName(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_GlyphMetrics(System.IntPtr,System.Int16,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Get individual font glyph metrics 
            </summary>
            <remarks>
            To understand what these metrics mean, here is a useful link:
            http://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int TTF_GlyphMetrics(TTF_Font *font, Uint16 ch, int *minx, int *maxx, int *miny, int *maxy, int *advance)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <param name="ch"></param>
            <param name="minx"></param>
            <param name="maxx"></param>
            <param name="miny"></param>
            <param name="maxy"></param>
            <param name="advance"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)">
            <summary>
            Get size of LATIN1 text string as would be rendered 
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int TTF_SizeText(TTF_Font *font, const char *text, int *w, int *h)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <param name="text"></param>
            <param name="w"></param>
            <param name="h"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeUTF8(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeUNICODE(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_SizeUTF8(System.IntPtr,System.String,System.Int32@,System.Int32@)">
            <summary>
            Get size of UTF8 text string as would be rendered
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int SDLCALL TTF_SizeUTF8(TTF_Font *font, const char *text, int *w, int *h)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <param name="text"></param>
            <param name="w"></param>
            <param name="h"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeUNICODE(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_SizeUNICODE(System.IntPtr,System.String,System.Int32@,System.Int32@)">
            <summary>
            Get size of UNICODE text string as would be rendered 
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int SDLCALL TTF_SizeUNICODE(TTF_Font *font, const Uint16 *text, int *w, int *h)
             </code></p>
             </remarks>
             <example>
            <code>
            
            </code>
            </example>
            <param name="font"></param>
            <param name="text"></param>
            <param name="w"></param>
            <param name="h"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeUTF8(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw LATIN1 text in solid mode.
            </summary>
            <param name="font">
            Font to render the text with.
             A NULL pointer is not checked.
             </param>
            <param name="text">
            The LATIN1 null terminated string to render.
            </param>
            <param name="fg">
            The color to render the text in. This becomes colormap index 1.
            </param>
            <returns>
            a pointer to a new SDL_Surface. 
            NULL is returned on errors.
            </returns>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Solid</p>
            <p>Quick and Dirty</p>
            <p>Create an 8-bit palettized surface and render the given
            text at fast quality with the given font and color. 
            The 0 pixel value is the colorkey, giving a transparent
            background, and the 1 pixel value is set to the text
            color. The colormap is set to have the desired 
            foreground color at index 1, this allows you to 
            change the color without having to render the text 
            again. Colormap index 0 is of course not drawn, 
            since it is the colorkey, and thus transparent, 
            though it's actual color is 255 minus each RGB 
            component of the foreground. This is the fastest 
            rendering speed of all the rendering modes. This results in no box 
            around the text, but the text is not as smooth. 
            The resulting surface should blit faster than the Blended one. 
            Use this mode for FPS and other fast changing updating text displays.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderText_Solid(TTF_Font *font, const char *text, SDL_Color fg)
             </code></p>
            </remarks>
            <example>
            <code>
            // Turn on byte swapping for UNICODE text
            	SDL_Surface *text_surface;
            	if(!(text_surface=TTF_RenderText_Solid(font,"Hello World!", &amp;color))) 
            {
            	//handle error here, perhaps print TTF_GetError at least
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Solid(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw UTF8 text in solid mode.
            </summary>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Solid</p>
            <p>Quick and Dirty</p>
            <p>Create an 8-bit palettized surface and render the given
            text at fast quality with the given font and color. 
            The 0 pixel value is the colorkey, giving a transparent
            background, and the 1 pixel value is set to the text
            color. The colormap is set to have the desired 
            foreground color at index 1, this allows you to 
            change the color without having to render the text 
            again. Colormap index 0 is of course not drawn, 
            since it is the colorkey, and thus transparent, 
            though it's actual color is 255 minus each RGB 
            component of the foreground. This is the fastest 
            rendering speed of all the rendering modes. This results in no box 
            around the text, but the text is not as smooth. 
            The resulting surface should blit faster than the Blended one. 
            Use this mode for FPS and other fast changing updating text displays.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderUTF8_Solid(TTF_Font *font,const char *text, SDL_Color fg)
             </code></p>
             </remarks>
            <param name="font">
            Font to render the text with.
             A NULL pointer is not checked.
             </param>
            <param name="text">
            The UTF8 null terminated string to render.
            </param>
            <param name="fg">
            The color to render the text in. This becomes colormap index 1.
            </param>
            <returns>
            a pointer to a new SDL_Surface. 
            NULL is returned on errors.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Solid(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw UNICODE text in solid mode.
            </summary>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Solid</p>
            <p>Quick and Dirty</p>
            <p>Create an 8-bit palettized surface and render the given
            text at fast quality with the given font and color. 
            The 0 pixel value is the colorkey, giving a transparent
            background, and the 1 pixel value is set to the text
            color. The colormap is set to have the desired 
            foreground color at index 1, this allows you to 
            change the color without having to render the text 
            again. Colormap index 0 is of course not drawn, 
            since it is the colorkey, and thus transparent, 
            though it's actual color is 255 minus each RGB 
            component of the foreground. This is the fastest 
            rendering speed of all the rendering modes. This results in no box 
            around the text, but the text is not as smooth. 
            The resulting surface should blit faster than the Blended one. 
            Use this mode for FPS and other fast changing updating text displays.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * SDLCALL TTF_RenderUNICODE_Solid(TTF_Font *font, const Uint16 *text, SDL_Color fg)
             </code></p>
             </remarks>
            <param name="font">
            Font to render the text with.
             A NULL pointer is not checked.
             </param>
            <param name="text">
            The UNICODE null terminated string to render.
            </param>
            <param name="fg">
            The color to render the text in. This becomes colormap index 1.
            </param>
            <returns>
            This function returns the new surface, 
            or NULL if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Solid(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Solid(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw a UNICODE glyph in solid mode.
            </summary>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Solid</p>
            <p>Quick and Dirty</p>
            <p>Create an 8-bit palettized surface and render the given
            text at fast quality with the given font and color. 
            The 0 pixel value is the colorkey, giving a transparent
            background, and the 1 pixel value is set to the text
            color. The colormap is set to have the desired 
            foreground color at index 1, this allows you to 
            change the color without having to render the text 
            again. Colormap index 0 is of course not drawn, 
            since it is the colorkey, and thus transparent, 
            though it's actual color is 255 minus each RGB 
            component of the foreground. This is the fastest 
            rendering speed of all the rendering modes. This results in no box 
            around the text, but the text is not as smooth. 
            The glyph is rendered without any padding or
            centering in the X direction, 
            and aligned normally in the Y direction.
            The resulting surface should blit faster than the Blended one. 
            Use this mode for FPS and other fast changing updating text displays.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * SDLCALL TTF_RenderGlyph_Solid(TTF_Font *font, Uint16 ch, SDL_Color fg)
             </code></p>
             </remarks>
            <param name="font">Font to render glyph with.
             A NULL pointer is not checked.</param>
            <param name="ch">
            The glyph to render
            </param>
            <param name="fg">
            The color to render the text in. 
            This becomes colormap index 1.
            </param>
            <returns>
            This function returns the new surface, 
            or NULL if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw LATIN1 text in shaded mode.
            </summary>
            <remarks>
            <p>Shaded</p> 
            <p>Slow and Nice, but with a Solid Box</p>
            <p>Create an 8-bit palettized surface and render the 
            given text at high quality with the given font and colors.
             The 0 pixel value is background, while other pixels have 
             varying degrees of the foreground color from the background
              color. This results in a box of the background color around
               the text in the foreground color. The text is antialiased.
                This will render slower than Solid, but in about the same
                 time as Blended mode. The resulting surface should blit 
                 as fast as Solid, once it is made. Use this when you need
                  nice text, and can live with a box...</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderText_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)
             </code></p>
            </remarks>
            <param name="font">Font to render the text with.
             A NULL pointer is not checked.</param>
            <param name="fg">
            The color to render the text in. 
            This becomes colormap index 1.
            </param>
            <param name="bg">
            The background color to render in.
            </param>
            <param name="text">
            The LATIN1 null terminated string to render.
            </param>
            <returns>
            This function returns the new surface, 
            or NULL if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Shaded(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw UTF8 text in shaded mode.
            </summary>
            <remarks>
            <p>Shaded</p> 
            <p>Slow and Nice, but with a Solid Box</p>
            <p>Create an 8-bit palettized surface and render the 
            given text at high quality with the given font and colors.
             The 0 pixel value is background, while other pixels have 
             varying degrees of the foreground color from the background
              color. This results in a box of the background color around
               the text in the foreground color. The text is antialiased.
                This will render slower than Solid, but in about the same
                 time as Blended mode. The resulting surface should blit 
                 as fast as Solid, once it is made. Use this when you need
                  nice text, and can live with a box...</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderUTF8_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)
             </code></p>
            </remarks>
            <param name="font">Font to render the text with.
             A NULL pointer is not checked.</param>
            <param name="fg">
            The color to render the text in. 
            This becomes colormap index 1.
            </param>
            <param name="bg">
            The background color to render in.
            </param>
            <param name="text">
            The UTF8 null terminated string to render.
            </param>
            <returns>
            This function returns the new surface, 
            or NULL if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Shaded(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw UNICODE text in shaded mode.
            </summary>
            <remarks>
            <p>Shaded</p> 
            <p>Slow and Nice, but with a Solid Box</p>
            <p>Create an 8-bit palettized surface and render the 
            given text at high quality with the given font and colors.
             The 0 pixel value is background, while other pixels have 
             varying degrees of the foreground color from the background
              color. This results in a box of the background color around
               the text in the foreground color. The text is antialiased.
                This will render slower than Solid, but in about the same
                 time as Blended mode. The resulting surface should blit 
                 as fast as Solid, once it is made. Use this when you need
                  nice text, and can live with a box...</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderUNICODE_Shaded(TTF_Font *font, const Uint16 *text, SDL_Color fg, SDL_Color bg)
             </code></p>
            </remarks>
            <param name="font">Font to render the text with.
             A NULL pointer is not checked.</param>
            <param name="fg">
            The color to render the text in. 
            This becomes colormap index 1.
            </param>
            <param name="bg">
            The background color to render in.
            </param>
            <param name="text">
            The UNICODE string to render.
            </param>
            <returns>
            This function returns the new surface, 
            or NULL if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Shaded(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Shaded(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw a UNICODE glyph in shaded mode.
            </summary>
            <remarks>
            <p>Shaded</p> 
            <p>Slow and Nice, but with a Solid Box</p>
            <p>Create an 8-bit palettized surface and render the 
            given text at high quality with the given font and colors.
             The 0 pixel value is background, while other pixels have 
             varying degrees of the foreground color from the background
              color. This results in a box of the background color around
               the text in the foreground color. The text is antialiased.
                This will render slower than Solid, but in about the same
                 time as Blended mode. The resulting surface should blit 
                 as fast as Solid, once it is made. Use this when you need
                  nice text, and can live with a box...</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderGlyph_Shaded(TTF_Font *font, Uint16 ch, SDL_Color fg, SDL_Color bg)
             </code></p>
            </remarks>
            <param name="font">Font to render the text with.
             A NULL pointer is not checked.</param>
            <param name="fg">
            The color to render the text in. 
            This becomes colormap index 1.
            </param>
            <param name="bg">
            The background color to render in.
            </param>
            <param name="ch">
            The glyph to render.
            </param>
            <returns>
            This function returns the new surface, 
            or NULL if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw LATIN1 text in blended mode.
            </summary>
            <param name="font">
            Font to render the text with.
             A NULL pointer is not checked.
             </param>
            <param name="text">
            The LATIN1 null terminated string to render.
            </param>
            <param name="fg">
            The color to render the text in. This becomes colormap index 1.
            </param>
            <returns>
            a pointer to a new SDL_Surface. 
            NULL is returned on errors.
            </returns>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Blended</p>
            <p>Slow Slow Slow, but Ultra Nice over another image</p>
            <p>Create a 32-bit ARGB surface and render the given text at high
             quality, using alpha blending to dither the font with the given 
             color. This results in a surface with alpha transparency, so you
              don't have a solid colored box around the text. The text is 
              antialiased. This will render slower than Solid, but in about 
              the same time as Shaded mode. The resulting surface will blit 
              slower than if you had used Solid or Shaded. Use this when you
               want high quality, and the text isn't changing too fast.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * SDLCALL TTF_RenderText_Blended(TTF_Font *font, const char *text, SDL_Color fg)
             </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Blended(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw UTF8 text in blended mode.
            </summary>
            <param name="font">
            Font to render the text with.
             A NULL pointer is not checked.
             </param>
            <param name="text">
            The UTF8 null terminated string to render.
            </param>
            <param name="fg">
            The color to render the text in. This becomes colormap index 1.
            </param>
            <returns>
            a pointer to a new SDL_Surface. 
            NULL is returned on errors.
            </returns>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Blended</p>
            <p>Slow Slow Slow, but Ultra Nice over another image</p>
            <p>Create a 32-bit ARGB surface and render the given text at high
             quality, using alpha blending to dither the font with the given 
             color. This results in a surface with alpha transparency, so you
              don't have a solid colored box around the text. The text is 
              antialiased. This will render slower than Solid, but in about 
              the same time as Shaded mode. The resulting surface will blit 
              slower than if you had used Solid or Shaded. Use this when you
               want high quality, and the text isn't changing too fast.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * SDLCALL TTF_RenderUTF8_Blended(TTF_Font *font, const char *text, SDL_Color fg)
             </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Blended(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw UNICODE text in blended mode.
            </summary>
            <param name="font">
            Font to render the text with.
             A NULL pointer is not checked.
             </param>
            <param name="text">
            The UNICODE string to render.
            </param>
            <param name="fg">
            The color to render the text in. This becomes colormap index 1.
            </param>
            <returns>
            a pointer to a new SDL_Surface. 
            NULL is returned on errors.
            </returns>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Blended</p>
            <p>Slow Slow Slow, but Ultra Nice over another image</p>
            <p>Create a 32-bit ARGB surface and render the given text at high
             quality, using alpha blending to dither the font with the given 
             color. This results in a surface with alpha transparency, so you
              don't have a solid colored box around the text. The text is 
              antialiased. This will render slower than Solid, but in about 
              the same time as Shaded mode. The resulting surface will blit 
              slower than if you had used Solid or Shaded. Use this when you
               want high quality, and the text isn't changing too fast.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderUNICODE_Blended(TTF_Font *font, const Uint16 *text, SDL_Color fg)
             </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Blended(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_RenderGlyph_Blended(System.IntPtr,System.Int16,Tao.Sdl.Sdl.SDL_Color)">
            <summary>
            Draw a UNICODE glyph in blended mode.
            </summary>
            <param name="font">
            Font to render the text with.
             A NULL pointer is not checked.
             </param>
            <param name="ch">
            The glyph to render.
            </param>
            <param name="fg">
            The color to render the text in. This becomes colormap index 1.
            </param>
            <returns>
            a pointer to a new SDL_Surface. 
            NULL is returned on errors.
            </returns>
            <remarks>
            <p>This function renders text using a TTF_Font.
            This mode of rendering is:</p>
            <p>Blended</p>
            <p>Slow Slow Slow, but Ultra Nice over another image</p>
            <p>Create a 32-bit ARGB surface and render the given text at high
             quality, using alpha blending to dither the font with the given 
             color. This results in a surface with alpha transparency, so you
              don't have a solid colored box around the text. The text is 
              antialiased. This will render slower than Solid, but in about 
              the same time as Shaded mode. The resulting surface will blit 
              slower than if you had used Solid or Shaded. Use this when you
               want high quality, and the text isn't changing too fast.</p> 
            <p>Binds to C-function in SDL_ttf.h
             <code>
             SDL_Surface * TTF_RenderUNICODE_Blended(TTF_Font *font, const Uint16 *text, SDL_Color fg)
             </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SizeText(System.IntPtr,System.String,System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUTF8_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderUNICODE_Blended(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Shaded(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color,Tao.Sdl.Sdl.SDL_Color)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_RenderText_Solid(System.IntPtr,System.String,Tao.Sdl.Sdl.SDL_Color)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_CloseFont(System.IntPtr)">
            <summary>
            Close an opened font file
            </summary>
            <remarks>
            Free the memory used by font, and free font itself as well. 
            Do not use font after this without loading a new font to it.
            <p>Binds to C-function in SDL_ttf.h
             <code>
             void TTF_CloseFont(TTF_Font *font)
             </code></p>
            </remarks>
            <example>
            <code>
            // free the font
            	// TTF_Font *font;
            	TTF_CloseFont(font);
            	font=NULL; // to be safe...
            </code>
            </example>
            <param name="font">
            Pointer to the TTF_Font to free.
            </param>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFont(System.String,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndex(System.String,System.Int32,System.Int64)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontRW(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_CloseFont(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_OpenFontIndexRW(System.IntPtr,System.Int32,System.Int32,System.Int64)"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_Quit">
            <summary>
            De-initialize the TTF engine
            </summary>
            <remarks>
            Shutdown and cleanup the truetype font API.
            <p>After calling this the SDL_ttf functions should not be used, 
            excepting TTF_WasInit. You may, of course, 
            use TTF_Init to use the functionality again.</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             void TTF_Quit() 
             </code></p>
            </remarks>
            <example>
            <code>
            TTF_Quit();
            // you could SDL_Quit(); here...or not.
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_Init"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_WasInit"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_WasInit">
            <summary>
            Check if the TTF engine is initialized.
            </summary>
            <remarks>
            Query the initilization status of the truetype font API.
            <p>You may, of course, use this before TTF_Init to avoid 
            initilizing twice in a row. Or use this to determine 
            if you need to call TTF_Quit.</p>
            <p>Binds to C-function in SDL_ttf.h
             <code>
             int TTF_WasInit() 
             </code></p>
            </remarks>
            <example>
            <code>
            if(!TTF_WasInit() &amp;&amp; TTF_Init()==-1) {
            	printf("TTF_Init: %s\n", TTF_GetError());
            	exit(1);
            }
            </code>
            </example>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_Init"/>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_Quit"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_SetError(System.String)">
            <summary>
            Set the current error string
            </summary>
            <remarks>
            This is the same as SDL_SetError, which sets the error string
            which may be fetched with TTF_GetError (or SDL_GetError). 
            This functions acts like printf, except that it is limited to
             SDL_ERRBUFIZE(1024) chars in length. It only accepts the 
             following format types: %s, %d, %f, %p. No variations are 
             supported, like %.2f would not work. For any more specifics 
             read the SDL docs.
            <p>Binds to C-function in SDL_image.h
            <code>
            void TTF_SetError(const char *fmt, ...)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            int myfunc(int i) {
            	TTF_SetError("myfunc is not implemented! %d was passed in.",i);
            	return(-1);
            }
            </code></example>
            <param name="message"></param>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_GetError"/>
        </member>
        <member name="M:Tao.Sdl.SdlTtf.TTF_GetError">
            <summary>
            Get the current error string
            </summary>
            <remarks>
            This is the same as SDL_GetError, which returns the last error set 
            as a string which you may use to tell the user what happened when 
            an error status has been returned from an SDL_ttf function call.
            <p>Binds to C-function in SDL_ttf.h
            <code>
            char *TTF_GetError() 
            </code>
            </p>
            </remarks>
            <returns>
            a char pointer (string) containing a humam 
            readable version or the reason for the last error that
             occured.
             </returns>
             <example>
             <code>
             printf("Oh My Goodness, an error : %s", TTF_GetError());
             </code>
             </example>
            <seealso cref="M:Tao.Sdl.SdlTtf.TTF_SetError(System.String)"/>
        </member>
        <member name="T:Tao.Sdl.SdlTtf.TTF_Font">
            <summary>
            The opaque holder of a loaded font
            </summary>
            <remarks>
            The opaque holder of a loaded font. You should always be using 
            a pointer of this type, as in TTF_Font*, and not just plain 
            TTF_Font. This stores the font data in a struct that is exposed
            only by using the API functions to get information. 
            You should not try to access the struct data directly, 
            since the struct may change in different versions of the API, 
            and thus your program would be unreliable.
            <p>Struct in SDL_ttf.h
            <code>struct _TTF_Font TTF_Font;
            </code></p>
            </remarks>
        </member>
        <member name="T:Tao.Sdl.SdlNet">
            <summary>
            SDL_net is a portable network library for use with SDL.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.SDL_NET_NATIVE_LIBRARY">
            <summary>
                Specifies SdlNet's native library archive.
            </summary>
            <remarks>
                Specifies SDL_net.dll everywhere; will be mapped via 
                .config for mono.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlNet.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/> 
                for Windows and Linux.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlNet.SDL_NET_MAJOR_VERSION">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.SDL_NET_MINOR_VERSION">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.SDL_NET_PATCHLEVEL">
            <summary>
            Patch Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.INADDR_ANY">
            <summary>
            Used for listening on all network interfaces.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.INADDR_NONE">
            <summary>
            Which has limited applications.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.INADDR_BROADCAST">
            <summary>
            Used as destination when sending a message to all clients on 
            a subnet that allows broadcasts.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.SDLNET_MAX_UDPCHANNELS">
            <summary>
            The maximum number of channels on a UDP socket.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.SDLNET_MAX_UDPADDRESSES">
            <summary>
            The maximum number of addresses bound to a single UDP socket
             channel.
            </summary>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDL_NET_VERSION">
            <summary>
            This method can be used to fill a version structure with the compile-time
            version of the SDL_net library.
            </summary>
            <returns>
                This function returns a <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct containing the
                compiled version number
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_net.h:
                <code>#define SDL_NET_VERSION(X)
            {
            (X)-&gt;major = SDL_NET_MAJOR_VERSION;
            (X)-&gt;minor = SDL_NET_MINOR_VERSION;
            (X)-&gt;patch = SDL_NET_PATCHLEVEL;
            }</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_Linked_Version">
            <summary>
                Using this you can compare the runtime version to the 
            version that you compiled with.
            </summary>
            <returns>
                This function gets the version of the dynamically 
            linked SDL_net library in an <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_net.h:
                <code>const SDL_version * SDLNet_Linked_Version(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_Init">
            <summary>
            Initialize the network API.
            </summary>
            <remarks>
            This must be called before using other functions in this library.
            SDL must be initialized before this call because this 
            library uses utility functions from the SDL library.
            <p>Binds to C-function call in SDL_net.h:
                <code>extern DECLSPEC int  SDLCALL SDLNet_Init(void);</code>
            </p>
            </remarks>
            <returns>0 on success, -1 on errors</returns>
            <example>
            <code>
            if(SDL_Init(0)==-1) {
                printf("SDL_Init: %s\n", SDL_GetError());
                exit(1);
            }
            if(SDLNet_Init()==-1) {
                printf("SDLNet_Init: %s\n", SDLNet_GetError());
            	exit(2);
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Quit"/>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_Quit">
            <summary>
            Shutdown and cleanup the network API.
            </summary>
            <remarks>
            After calling this all sockets are closed, and the SDL_net 
            functions should not be used. You may, of course, use SDLNet_Init
            to use the functionality again.
            <p>Binds to C-function call in SDL_net.h:
                <code>extern DECLSPEC void SDLCALL SDLNet_Quit(void);</code>
            </p>
            </remarks>
            <example>
            <code>
            SDLNet_Quit();
            // you could SDL_Quit(); here...or not.
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Init"/>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_GetError">
            <summary>
            Get the current error string
            </summary>
            <remarks>
            This is the same as SDL_GetError, which returns the 
            last error set as a string which you may use to tell 
            the user what happened when an error status has been returned 
            from an SDLNet_function.
            <p>Binds to C-function call in SDL_error.h:
                <code>#define SDLNet_GetError	SDL_GetError</code>
            </p>
            </remarks>
            <returns>
            A string containing a human readable version 
            or the reason for the last error that occured.
            </returns>
            <example>
            <code>
            printf("Oh My Goodness, an error : %s", SDLNet_GetError());
            </code>
            </example>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_SetError(System.String)">
            <summary>
            This is the same as SDL_SetError, which sets an SDL error message
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_error.h:
                <code>#define SDLNet_SetError	SDL_SetError</code>
            </p>
            </remarks>
            <param name="message">
            The error message to set.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_Write16(System.Int16,System.IntPtr)">
            <summary>
            Put the 16bit (a short on 32bit systems) value 
            into the data buffer area in network byte order.
            </summary>
            <remarks>
            This helps avoid byte order differences 
            between two systems that are talking over the network.
             The value can be a signed number, the unsigned parameter 
             type doesn't affect the data. The area pointer need not 
             be at the beginning of a buffer, but must have at 
             least 2 bytes of space left, 
             including the byte currently pointed at.
            <p>Binds to C-function call in SDL_error.h:
                <code>extern DECLSPEC void SDLCALL SDLNet_Write16(Uint16 value, void *area)</code>
            </p>
             </remarks>
            <example>
            <code>
            // put my number into a data buffer to prepare for 
            // sending to a remote host
            char data[1024];
            Sint16 number=12345;
            SDLNet_Write16((Uint16)number,data);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Write32(System.Int32,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Read16(System.IntPtr)"/>
            <param name="value">
            The 16bit number to put into the 
            area buffer.
            </param>
            <param name="area">
            The pointer into a data buffer, at which to put the number.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_Write32(System.Int32,System.IntPtr)">
            <summary>
            Put the 32bit (a long on 32bit systems) value into 
            the data buffer area in network byte order.
            </summary>
            <remarks>
            This helps avoid byte order differences between two 
            systems that are talking over the network. 
            The value can be a signed number, the unsigned 
            parameter type doesn't affect the data. 
            The area pointer need not be at the beginning of a buffer,
            but must have at least 4 bytes of space left, 
            including the byte currently pointed at.
            <p>Binds to C-function call in SDL_error.h:
                <code>extern DECLSPEC void SDLCALL SDLNet_Write32(Uint32 value, void *area)</code>
            </p>
             </remarks>
            <example>
            <code>
            // put my number into a data buffer to prepare 
            // for sending to a remote host
            char data[1024];
            Uint32 number=0xDEADBEEF;
            SDLNet_Write32(number,data);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Write16(System.Int16,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Read32(System.IntPtr)"/>
            <param name="value">
            The 32bit number to put into the area buffer.
            </param>
            <param name="area">
            The pointer into a data buffer, at which to put the number.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_Read16(System.IntPtr)">
            <summary>
            Get a 16bit (a short on 32bit systems) value from 
            the data buffer area which is in network byte order.
            </summary>
            <remarks>
            This helps avoid byte order differences between 
            two systems that are talking over the network. 
            The returned value can be a signed number, 
            the unsigned parameter type doesn't affect the data. 
            The area pointer need not be at the beginning of a buffer,
            but must have at least 2 bytes of space left, 
            including the byte currently pointed at.
            <p>Binds to C-function call in SDL_error.h:
                <code>extern DECLSPEC Uint16 SDLCALL SDLNet_Read16(void *area)</code>
            </p>
            </remarks>
            <example>
            <code>
            // get a number from a data buffer to use on this host
            //char *ptr; //this points into a previously received data buffer
            Sint16 number;
            number=(Sint16) SDLNet_Read16(ptr);
            // number is now in your hosts byte order, ready to use.
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Write16(System.Int16,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Read32(System.IntPtr)"/>
            <param name="area">The pointer into a data buffer, at which to get the number from.</param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_Read32(System.IntPtr)">
            <summary>
            Get a 32bit (a long on 32bit systems) value from the data buffer area which is in network byte order.
            </summary>
            <remarks>
            This helps avoid byte order differences between two 
            systems that are talking over the network. The 
            returned value can be a signed number, the unsigned
            parameter type doesn't affect the data. The area 
            pointer need not be at the beginning of a buffer,
            but must have at least 4 bytes of space left,
            including the byte currently pointed at.
            <p>Binds to C-function call in SDL_error.h:
                <code>extern DECLSPEC Uint32 SDLCALL SDLNet_Read32(void *area)</code>
            </p>
            </remarks>
            <example>
            <code>
            // get a number from a data buffer to use on this host
            //char *ptr; //this points into a previously received data buffer
            Uint32 number;
            number=SDLNet_Read32(ptr);
            // number is now in your hosts byte order, ready to use.
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Write32(System.Int32,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_Read16(System.IntPtr)"/>
            <param name="area">The pointer into a data buffer, at which to get the number from.</param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_ResolveHost(Tao.Sdl.SdlNet.IPaddress@,System.String,System.Int16)">
            <summary>
            Resolve the string host, and fill in the IPaddress pointed to by address with the resolved IP and the port number passed in through port.
            </summary>
            <remarks>
            This is the best way to fill in the IPaddress struct for later use. This function does not actually open any sockets, it is used to prepare the arguments for the socket opening functions.
            WARNING: this function will put the host and port into Network Byte Order into the address fields, so make sure you pass in the data in your hosts byte order. (normally not an issue)
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC int SDLCALL SDLNet_ResolveHost(IPaddress *address, const char *host, Uint16 port)
                </code>
            </p>
            </remarks>
            <returns>0 on success. -1 on errors, plus address.host will be INADDR_NONE. An error would likely be that the address could not be resolved. If 'host' is NULL, the resolved host will be set to INADDR_ANY.</returns>
            <example>For a server listening on all interfaces, on port 1234:
            <code>
            // create a server type IPaddress on port 1234
            IPaddress ipaddress;
            SDLNet_ResolveHost(ipaddress, NULL, 1234);
            </code>
            For a client connecting to "host.domain.ext", at port 1234:
            <code>
            // create an IPaddress for host name "host.domain.ext" on port 1234
            // this is used by a client
            IPaddress ipaddress;
            SDLNet_ResolveHost(ipaddress, "host.domain.ext", 1234);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResolveIP(Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
            <param name="address">This points to the IPaddress that will be filled in. It doesn't need to be set before calling this, but it must be allocated in memory.</param>
            <param name="host">For connecting to a server, this is the hostname or IP in a string. For becoming a server, this is NULL. If you do use NULL, all network interfaces would be listened to for incoming connections, using the INADDR_ANY address.</param>
            <param name="port">For connecting to a server, this is the the servers listening port number. For becoming a server, this is the port to listen on. If you are just doing Domain Name Resolution functions, this can be 0.</param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_ResolveIP(Tao.Sdl.SdlNet.IPaddress@)">
            <summary>
            Resolve the IPv4 numeric address in address-&gt;host, and return the hostname as a string. 
            </summary>
            <remarks>
            This is the best way to fill in the IPaddress struct for later use. This function does not actually open any sockets, it is used to prepare the arguments for the socket opening functions.
            WARNING: this function will put the host and port into Network Byte Order into the address fields, so make sure you pass in the data in your hosts byte order. (normally not an issue)
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC const char * SDLCALL SDLNet_ResolveIP(IPaddress *ip);
                </code>
            </p>
            </remarks>
            <returns>a valid char pointer (string) on success. the returned hostname will have host and domain, as in "host.domain.ext". NULL is returned on errors, such as when it's not able to resolve the host name. The returned pointer is not to be freed. Each time you call this function the previous pointer's data will change to the new value, so you may have to copy it into a local buffer to keep it around longer.</returns>
            <example>
            <code>
            // resolve the host name of the address in ipaddress
            //IPaddress ipaddress;
            char *host;
            if(!(host=SDLNet_ResolveIP(IPaddress))) {
            	printf("SDLNet_ResolveIP: %s\n", SDLNet_GetError());
                exit(1);
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResolveHost(Tao.Sdl.SdlNet.IPaddress@,System.String,System.Int16)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
            <param name="address">This points to the IPaddress that will be resolved to a host name. The address-&gt;port is ignored.</param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_Open(Tao.Sdl.SdlNet.IPaddress@)">
             <summary>
             Open a TCP client or server socket 
             </summary>
             <remarks>
             Connect to the host and port contained in ip using a TCP connection.
             If the host is INADDR_ANY, then only the port number is used, and a socket is created that can be used to later accept incoming TCP connections.
             <p>Binds to C-function call in SDL_net.h:
                 <code>
                 extern DECLSPEC TCPsocket SDLCALL SDLNet_TCP_Open(IPaddress *ip)
                 </code>
             </p>
             </remarks>
             <returns>a valid TCPsocket on success, which indicates a successful connection has been established, or a socket has been created that is valid to accept incoming TCP connections. NULL is returned on errors, such as when it's not able to create a socket, or it cannot connect to host and/or port contained in ip.</returns>
             <example>
             <code>
             // connect to localhost at port 9999 using TCP (client)
             IPaddress ip;
             TCPsocket tcpsock;
             
             if(SDLNet_ResolveHost(&amp;ip,"localhost",9999)==-1) {
                 printf("SDLNet_ResolveHost: %s\n", SDLNet_GetError());
                 exit(1);
             }
             
             tcpsock=SDLNet_TCP_Open(&amp;ip);
             if(!tcpsock) {
                 printf("SDLNet_TCP_Open: %s\n", SDLNet_GetError());
                 exit(2);
             }
             </code>
            
             <code>
             // create a listening TCP socket on port 9999 (server)
             IPaddress ip;
             TCPsocket tcpsock;
             
             if(SDLNet_ResolveHost(&amp;ip,NULL,9999)==-1) {
                 printf("SDLNet_ResolveHost: %s\n", SDLNet_GetError());
                 exit(1);
             }
             
             tcpsock=SDLNet_TCP_Open(&amp;ip);
             if(!tcpsock) {
                 printf("SDLNet_TCP_Open: %s\n", SDLNet_GetError());
                 exit(2);
             }
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Accept(Tao.Sdl.SdlNet.TCPsocket)"/>
             <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Close(System.IntPtr)"/>
             <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
             <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
             
             <param name="ip">This points to the IPaddress that contains the resolved IP address and port number to use.</param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_Accept(Tao.Sdl.SdlNet.TCPsocket)">
             <summary>
             Accept a connection on a server socket 
             </summary>
             <remarks>
             Accept an incoming connection on the server TCPsocket.
             Do not use this function on a connected socket. 
             Server sockets are never connected to a remote host. 
             What you get back is a new TCPsocket that is connected to the remote host.
             This is a non-blocking call, so if no connections are there to be accepted,
             you will get a NULL
             TCPsocket and the program will continue going.
            
             Accept an incoming connection on the given server socket.
             The newly created socket is returned, or NULL if there was an error.
             <p>Binds to C-function call in SDL_net.h:
                 <code>
                 extern DECLSPEC TCPsocket SDLCALL SDLNet_TCP_Accept(TCPsocket server)
                 </code>
             </p>
             </remarks>
             <returns>a valid TCPsocket on success, which indicates a successful connection has been established. NULL is returned on errors, such as when it's not able to create a socket, or it cannot finish connecting to the originating host and port. There also may not be a connection attempt in progress, so of course you cannot accept nothing, and you get a NULL in this case as well.</returns>
             <example>
             <code>
             // accept a connection coming in on server_tcpsock
             TCPsocket new_tcpsock;
             
             new_tcpsock=SDLNet_TCP_Accept(server_tcpsock);
             if(!new_tcpsock) {
                 printf("SDLNet_TCP_Accept: %s\n", SDLNet_GetError());
             }
             else {
                 // communicate over new_tcpsock
             }
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Open(Tao.Sdl.SdlNet.IPaddress@)"/>
             <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Close(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_GetPeerAddress(Tao.Sdl.SdlNet.TCPsocket)"/>
             <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
             <param name="server">
             This is the server TCPsocket which was previously created by
             SDLNet_TCP_Open.
             </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_GetPeerAddress(Tao.Sdl.SdlNet.TCPsocket)">
            <summary>
            Get the remote host address and port number 
            </summary>
            <remarks>
            Get the Peer's (the other side of the connection, 
            the remote side, not the local side) IP address and port number.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC IPaddress * SDLCALL SDLNet_TCP_GetPeerAddress(TCPsocket sock)
                </code>
            </p>
            </remarks>
            <returns>
            an IPaddress. NULL is returned on errors, or when sock is a server socket.
            </returns>
            <example>
            <code>
            // get the remote IP and port
            //TCPsocket new_tcpsock;
            IPaddress *remote_ip;
            
            remote_ip=SDLNet_TCP_GetPeerAddress(new_tcpsock);
            if(!remote_ip) {
                printf("SDLNet_TCP_GetPeerAddress: %s\n", SDLNet_GetError());
                printf("This may be a server socket.\n");
            }
            else {
                // print the info in IPaddress or something else...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Open(Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Accept(Tao.Sdl.SdlNet.TCPsocket)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="sock">
            This is a valid TCPsocket.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_Send(Tao.Sdl.SdlNet.TCPsocket,System.IntPtr,System.Int32)">
            <summary>
            Send data over a connected socket 
            </summary>
            <remarks>
            Send data of length len over the socket sock.
            This routine is not used for server sockets.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC int SDLCALL SDLNet_TCP_Send(TCPsocket sock, const void *data, int len)
                </code>
            </p>
            </remarks>
            <returns>
            the number of bytes sent. If the number returned is less than len,
            then an error occured, such as the client disconnecting.
            </returns>
            <example>
            <code>
            // send a hello over sock
            //TCPsocket sock;
            int len,result;
            char *msg="Hello!";
            
            len=strlen(msg)+1; // add one for the terminating NULL
            result=SDLNet_TCP_Send(sock,msg,len);
            if(result&lt;len) {
                printf("SDLNet_TCP_Send: %s\n", SDLNet_GetError());
                // It may be good to disconnect sock because it is likely invalid now.
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Open(Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Close(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Accept(Tao.Sdl.SdlNet.TCPsocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Recv(Tao.Sdl.SdlNet.TCPsocket,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_GetPeerAddress(Tao.Sdl.SdlNet.TCPsocket)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="sock">
            This is a valid, connected, TCPsocket.
            </param>
            <param name="data">
            This is a pointer to the data to send over sock.
            </param>
            <param name="len">
            This is the length (in bytes) of the data.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_Recv(Tao.Sdl.SdlNet.TCPsocket,System.IntPtr,System.Int32)">
            <summary>
            Receive data from a connected socket 
            </summary>
            <remarks>Receive data of exactly length maxlen bytes from the socket sock, into the memory pointed to by data. This routine is not used for server sockets. Unless there is an error, or the connection is closed, the buffer will read maxlen bytes. If you read more than is sent from the other end, then it will wait until the full requested length is sent, or until the connection is closed from the other end. You may have to read 1 byte at a time for some applications, for instance, text applications where blocks of text are sent, but you want to read line by line. In that case you may want to find the newline characters yourself to break the lines up, instead of reading some inordinate amount of text which may contain many lines, or not even a full line of text.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC int SDLCALL SDLNet_TCP_Recv(TCPsocket sock, void *data, int maxlen)
                </code>
            </p>
            </remarks>
            <returns>
            the number of bytes received. If the number returned is less than or equal to zero, then an error occured, or the remote host has closed the connection.
            </returns>
            <example>
            <code>
            // receive some text from sock
            //TCPsocket sock;
            #define MAXLEN 1024
            int result;
            char msg[MAXLEN];
            
            result=SDLNet_TCP_Recv(sock,msg,MAXLEN);
            if(result&lt;=0) {
                // An error may have occured, but sometimes you can just ignore it
                // It may be good to disconnect sock because it is likely invalid now.
            }
            printf("Received: \"%s\"\n",msg);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Open(Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Close(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Accept(Tao.Sdl.SdlNet.TCPsocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Send(Tao.Sdl.SdlNet.TCPsocket,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_GetPeerAddress(Tao.Sdl.SdlNet.TCPsocket)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="sock">
            This is a valid, connected, TCPsocket.
            </param>
            <param name="data">
            This is a pointer to the buffer that receives the data from sock.
            </param>
            <param name="maxlen">
            This is the maximum length (in bytes) that will be read into data.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_Close(System.IntPtr)">
            <summary>
            Close a TCP socket 
            </summary>
            <remarks>
            This shutsdown, disconnects, and closes the TCPsocket sock. After this, you can be assured that this socket is not in use anymore. You can reuse the sock variable after this to open a new connection with SDLNet_TCP_Open. Do not try to use any other functions on a closed socket, as it is now invalid.
            
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC void SDLCALL SDLNet_TCP_Close(TCPsocket sock)
                </code>
            </p>
            </remarks>
            <returns>
            nothing, this always succeeds for all we need to know.
            </returns>
            <example>
            <code>
            // close the connection on sock
            //TCPsocket sock;
            
            SDLNet_TCP_Close(sock);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Close(System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="sock">
            A valid TCPsocket. This can be a server or client type socket.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_AllocPacket(System.Int32)">
            <summary>
            Allocate a new UDP packet with a data buffer 
            </summary>
            <remarks>
            Create (via malloc) a new UDPpacket with a data buffer of size bytes. The new packet should be freed using SDLNet_FreePacket when you are done using it.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC UDPpacket * SDLCALL SDLNet_AllocPacket(int size)
                </code>
            </p>
            </remarks>
            <returns>
            a pointer to a new empty UDPpacket. NULL is returned on errors, such as out-of-memory.
            </returns>
            <example>
            <code>
            // create a new UDPpacket to hold 1024 bytes of data
            UDPpacket *packet;
            
            packet=SDLNet_AllocPacket(1024);
            if(!packet) {
                printf("SDLNet_AllocPacket: %s\n", SDLNet_GetError());
                // perhaps do something else since you can't make this packet
            }
            else {
                // do stuff with this new packet
                // SDLNet_FreePacket this packet when finished with it
            }
            </code>
            </example>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacketV(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResizePacket(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreePacket(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Send(System.IntPtr,System.Int32,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_SendV(System.IntPtr,System.IntPtr,System.Int32)"/>
            <param name="size">
            Size, in bytes, of the data buffer to be allocated in the new UDPpacket. Zero is invalid.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_ResizePacket(System.IntPtr,System.Int32)">
            <summary>
            Resize the data buffer in a UDPpacket 
            </summary>
            <remarks>
            Resize a UDPpackets data buffer to size bytes. The old data buffer will not be retained, so the new buffer is invalid after this call.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC int SDLCALL SDLNet_ResizePacket(UDPpacket *packet, int newsize)
                </code>
            </p>
            </remarks>
            <returns>
            the new size of the data in the packet. If the number returned is less than what you asked for, that's an error.
            </returns>
            <example>
            <code>
            // Resize a UDPpacket to hold 2048 bytes of data
            //UDPpacket *packet;
            int newsize;
            
            newsize=SDLNet_ResizePacket(packet, 2048);
            if(newsize&lt;2048) {
                printf("SDLNet_ResizePacket: %s\n", SDLNet_GetError());
                // perhaps do something else since you didn't get the buffer you wanted
            }
            else {
                // do stuff with the resized packet
            }
            </code>
            </example>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacket(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacketV(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreePacket(System.IntPtr)"/>
            <param name="packet">
            A pointer to the UDPpacket to be resized.
            </param>
            <param name="newsize">
            The new desired size, in bytes, of the data buffer to be allocated in the UDPpacket.
            Zero is invalid.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_FreePacket(System.IntPtr)">
            <summary>
            Free a previously allocated UDPpacket 
            </summary>
            <remarks>
            Free a UDPpacket from memory. Do not use this UDPpacket after this function is called on it.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC void SDLCALL SDLNet_FreePacket(UDPpacket *packet)
                </code>
            </p>
            </remarks>
            <returns>
            nothing, this always succeeds.
            </returns>
            <example>
            <code>
            // Free a UDPpacket
            //UDPpacket *packet;
            
            SDLNet_FreePacket(packet);
            packet=NULL; //just to help you know that it is freed
            </code>
            </example>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacket(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacketV(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreePacketV(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResizePacket(System.IntPtr,System.Int32)"/>
            <param name="packet">
            A pointer to the UDPpacket to be freed from memory.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_AllocPacketV(System.Int32,System.Int32)">
            <summary>
            Allocate a vector of UDPpackets 
            </summary>
            <remarks>
            Create (via malloc) a vector of new UDPpackets, each with data buffers of size bytes. The new packet vector should be freed using SDLNet_FreePacketV when you are done using it. The returned vector is one entry longer than requested, for a terminating NULL.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC UDPpacket ** SDLCALL SDLNet_AllocPacketV(int howmany, int size)
                </code>
            </p>
            </remarks>
            <returns>
            a pointer to a new empty UDPpacket vector. NULL is returned on errors, such as out-of-memory.
            </returns>
            <example>
            <code>
            // create a new UDPpacket vector to hold 1024 bytes of data in 10 packets
            UDPpacket **packetV;
            
            packetV=SDLNet_AllocPacketV(10, 1024);
            if(!packetV) {
                printf("SDLNet_AllocPacketV: %s\n", SDLNet_GetError());
                // perhaps do something else since you can't make this packet
            }
            else {
                // do stuff with this new packet vector
                // SDLNet_FreePacketV this packet vector when finished with it
            }
            </code>
            </example>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacketV(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResizePacket(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreePacket(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Send(System.IntPtr,System.Int32,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_SendV(System.IntPtr,System.IntPtr,System.Int32)"/>
            <param name="howmany">
            The number of UDPpackets to allocate.
            </param>
            <param name="size">
            Size, in bytes, of the data buffers to be allocated in the new UDPpackets.
            Zero is invalid.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_FreePacketV(System.IntPtr)">
            <summary>
            Free a vector of UDPpackets 
            </summary>
            <remarks>
            Free a UDPpacket vector from memory. Do not use this UDPpacket vector, or any UDPpacket in it, after this function is called on it.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC void SDLCALL SDLNet_FreePacketV(UDPpacket **packetV)
                </code>
            </p>
            </remarks>
            <returns>
            nothing, this always succeeds.
            </returns>
            <example>
            <code>
            // Free a UDPpacket vector
            //UDPpacket **packet;
            
            SDLNet_FreePacketV(packetV);
            packetV=NULL; //just to help you know that it is freed
            </code>
            </example>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacket(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacketV(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreePacket(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResizePacket(System.IntPtr,System.Int32)"/>
            <param name="packetV">
            A pointer to the UDPpacket to be freed from memory.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_Open(System.Int16)">
             <summary>
             Create a UDP socket 
             </summary>
             <remarks>Open a socket to be used for UDP packet sending and/or receiving. 
             If a non-zero port is given it will be used, otherwise any open port
             number will be used automatically. Unlike TCP sockets, this socket
             does not require a remote host IP to connect to, this is because UDP
             ports are never actually connected like TCP ports are. This socket
             is able to send and receive directly after this simple creation.
            
             If 'port' is non-zero, the UDP socket is bound to a local port. 
             The 'port' should be given in native byte order, but is used
             internally in network (big endian) byte order, in addresses, etc.
             This allows other systems to send to this socket via a known port.
             <p>Binds to C-function call in SDL_net.h:
                 <code>
                 extern DECLSPEC UDPsocket SDLCALL SDLNet_UDP_Open(Uint16 port)
                 </code>
             </p>
             </remarks>
             <returns>
             a valid UDPsocket on success. NULL is returned on errors, 
             such as when it's not able to create a socket,
             or it cannot assign the non-zero port as requested.
             </returns>
             <example>
             Note that below I say server, but clients may also open
             a specific port, though it is prefered that a client be
             more flexible, given that the port may be already allocated
             by another process, such as a server. In such a case you 
             will not be able to open the socket, and your program 
             will be stuck, so it is better to just use whatever port
             you are given by using a specified port of zero. 
             Then the client will always work. The client can inform 
             the server what port to talk back to, or the server can
             just look at the source of the packets it is receiving 
             to know where to respond to.
             <code>
             // create a UDPsocket on port 6666 (server)
             UDPsocket udpsock;
             
             udpsock=SDLNet_UDP_Open(6666);
             if(!udpsock) {
                 printf("SDLNet_UDP_Open: %s\n", SDLNet_GetError());
                 exit(2);
             }
             </code>
            
             <code>
             // create a UDPsocket on any available port (client)
             UDPsocket udpsock;
             
             udpsock=SDLNet_UDP_Open(0);
             if(!udpsock) {
                 printf("SDLNet_UDP_Open: %s\n", SDLNet_GetError());
                 exit(2);
             }
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Close(System.IntPtr)"/>
             <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
             <param name="port">
             This is the port number (in native byte order) on which to receive UDP
             packets. Most servers will want to use a known port number here so that
             clients can easily communicate with the server. This can also be zero,
             which then opens an anonymous unused port number, to most likely be
             used to send UDP packets from.
             </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_Bind(System.IntPtr,System.Int32,Tao.Sdl.SdlNet.IPaddress@)">
            <summary>
            Assign an IP address number to a socket channel 
            </summary> 
            <remarks>
            Bind an address to a channel on a socket. 
            Incoming packets are only allowed from bound addresses for the socket channel.
            All outgoing packets on that channel,
            regardless of the packets internal address, 
            will attempt to send once on each bound address on that channel.
            You may assign up to SDLNET_MAX_UDPADDRESSES to each channel. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
               	extern DECLSPEC int SDLCALL SDLNet_UDP_Bind(UDPsocket sock, int channel, IPaddress *address)
                </code>
            </p>
            </remarks>
            <returns>
            The channel number that was bound. -1 is returned on errors, such as no free channels, or this channel has SDLNET_MAX_UDPADDRESSES already assigned to it, or you have used a channel higher or equal to SDLNET_MAX_UDPCHANNELS, or lower than -1.
            </returns>
            <example>
            <code>
            // Bind address to the first free channel
            //UDPsocket udpsock;
            //IPaddress *address;
            int channel;
            
            channel=SDLNet_UDP_Bind(udpsock, -1, address);
            if(channel==-1) {
                printf("SDLNet_UDP_Bind: %s\n", SDLNet_GetError());
                // do something because we failed to bind
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Unbind(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_GetPeerAddress(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Open(System.Int16)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            the UDPsocket on which to assign the address.
            </param>
            <param name="channel">The channel to assign address to. This should be less than SDLNET_MAX_UDPCHANNELS. If -1 is used, then the first unbound channel will be used, this should only be used for incomming packet filtering, as it will find the first channel with less than SDLNET_MAX_UDPADDRESSES assigned to it and use that one.
            </param>
            <param name="address">
            The resolved IPaddress to assign to the socket's channel. 
            The host and port are both used. 
            It is not helpful to bind 0.0.0.0 to a channel.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_Unbind(System.IntPtr,System.Int32)">
            <summary>
            Remove all assigned IP addresses from a socket channel 
            </summary> 
            <remarks>
            This removes all previously assigned (bound) addresses 
            from a socket channel.
            After this you may bind new addresses to the socket 
            channel.
            <p>Binds to C-function call in SDL_net.h:
                <code>
               	extern DECLSPEC void SDLCALL SDLNet_UDP_Unbind(UDPsocket sock, int channel)
                </code>
            </p>
            </remarks>
            <returns>
            nothing, this always succeeds.
            </returns>
            <example>
            <code>
            // unbind all addresses on the UDPsocket channel 0
            //UDPsocket udpsock;
            
            SDLNet_UDP_Unbind(udpsock, 0);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Bind(System.IntPtr,System.Int32,Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Close(System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            A valid UDPsocket to unbind addresses from.
            </param>
            <param name="channel">
            The channel to unbind the addresses from in the UDPsocket.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_GetPeerAddress(System.IntPtr,System.Int32)">
            <summary>
            Get the assigned IP address for a socket channel or get 
            the port you opened the socket with 
            </summary> 
            <remarks>
            Get the primary address assigned to this channel. 
            Only the first bound address is returned.
            When channel is -1, get the port that this socket 
            is bound to on the local computer, 
            this only means something if you opened the socket 
            with a specific port number.
            Do not free the returned IPaddress pointer.
            <p>Binds to C-function call in SDL_net.h:
                <code>
               	extern DECLSPEC IPaddress * SDLCALL SDLNet_UDP_GetPeerAddress(UDPsocket sock, int channel)
                </code>
            </p>
            </remarks>
            <returns>
            a pointer to an IPaddress. 
            NULL is returned for unbound channels and on any errors.
            </returns>
            <example>
            <code>
            // get the primary address bound to UDPsocket channel 0
            
            //UDPsocket udpsock;
            //IPaddress *address;
            
            address=SDLNet_UDP_GetPeerAddress(udpsock, 0);
            if(!address) {
                printf("SDLNet_UDP_GetPeerAddress: %s\n", SDLNet_GetError());
                // do something because we failed to get the address
            }
            else {
                // perhaps print out address-&gt;host and address-&gt;port
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Unbind(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Bind(System.IntPtr,System.Int32,Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            A valid UDPsocket that probably has an address assigned to the channel.
            </param>
            <param name="channel">
            The channel to get the primary address from in the socket. 
            This may also be -1 to get the port which this socket is 
            bound to on the local computer.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_SendV(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Send a UDPpacket vector 
            </summary> 
            <remarks>
            Send npackets of packetV using the specified sock socket. 
            Each packet is sent in the same way as in SDLNet_UDP_Send
            (see section 3.4.6 SDLNet_UDP_Send).
            Don't forget to set the length of the packets in the len
            element of the packets you are sending!
            <p>Binds to C-function call in SDL_net.h:
                <code>
               	extern DECLSPEC int SDLCALL SDLNet_UDP_SendV(UDPsocket sock, UDPpacket **packets, int npackets)
                </code>
            </p>
            </remarks>
            <returns>
            The number of destinations sent to that worked, 
            for each packet in the vector, all summed up. 
            0 is returned on errors.
            </returns>
            <example>
            <code>
            // send a vector of 10 packets using UDPsocket
            //UDPsocket udpsock;
            //UDPpacket **packetV;
            int numsent;
            
            numsent=SDLNet_UDP_SendV(udpsock, packetV, 10);
            if(!numsent) {
                printf("SDLNet_UDP_SendV: %s\n", SDLNet_GetError());
                // do something because we failed to send
                // this may just be because no addresses are bound to the channels...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Bind(System.IntPtr,System.Int32,Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Send(System.IntPtr,System.Int32,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Recv(System.IntPtr,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_RecvV(System.IntPtr,System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            A valid UDPsocket.
            </param>
            <param name="packets">
            The vector of packets to send.
            </param>
            <param name="npackets">
            number of packets in the packetV vector to send.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_Send(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Send a UDPpacket
            </summary> 
            <remarks>
            Send packet using the specified socket sock, using the 
            specified channel or else the packet's address.
            If channel is not -1 then the packet is sent to all the 
            socket channels bound addresses. If socket sock's channel 
            is not bound to any destinations, then the packet is not 
            sent at all!
            If the channel is -1, then the packet's address is used 
            as the destination.
            Don't forget to set the length of the packet in the len 
            element of the packet you are sending! NOTE: the packet-&gt;channel 
            will be set to the channel passed in to this function.
            <p>Binds to C-function call in SDL_net.h:
                <code>
               	extern DECLSPEC int SDLCALL SDLNet_UDP_Send(UDPsocket sock, int channel, UDPpacket *packet)
                </code>
            </p>
            </remarks>
            <returns>
            The number of destinations sent to that worked. 
            0 is returned on errors.Note that since a channel can 
            point to multiple destinations, there should be just as
            many packets sent, so dont assume it will always return 1 
            on success. Unfortunately there's no way to get the number
            of destinations bound to a channel, so either you have to
            remember the number bound, or just test for the zero 
            return value indicating all channels failed.
            </returns>
            <example>
            <code>
            // send a packet using a UDPsocket, using the packet's channel as the channel
            //UDPsocket udpsock;
            //UDPpacket *packet;
            int numsent;
            
            numsent=SDLNet_UDP_Send(udpsock, packet-&gt;channel, packet);
            if(!numsent) {
                printf("SDLNet_UDP_Send: %s\n", SDLNet_GetError());
                // do something because we failed to send
                // this may just be because no addresses are bound to the channel...
            }
            </code>
            Here's a way of sending one packet using it's internal channel setting.
            This is actually what SDLNet_UDP_Send ends up calling for you.
            <code>
            // send a packet using a UDPsocket, using the packet's channel as the channel
            //UDPsocket udpsock;
            //UDPpacket *packet;
            int numsent;
            
            numsent=SDLNet_UDP_SendV(sock, &amp;packet, 1);
            if(!numsent) {
                printf("SDLNet_UDP_SendV: %s\n", SDLNet_GetError());
                // do something because we failed to send
                // this may just be because no addresses are bound to the channel...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Bind(System.IntPtr,System.Int32,Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_SendV(System.IntPtr,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Recv(System.IntPtr,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_RecvV(System.IntPtr,System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            A valid UDPsocket.
            </param>
            <param name="channel">
            what channel to send packet on.
            </param>
            <param name="packet">
            The packet to send.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_RecvV(System.IntPtr,System.IntPtr)">
            <summary>
            Receive into a UDPpacket vector 
            </summary> 
            <remarks>
            Receive into a packet vector on the specified socket sock.
            packetV is a NULL terminated array. Packets will be 
            received until the NULL is reached, or there are none
            ready to be received.
            This call is otherwise the same as SDLNet_UDP_Recv 
            <p>Binds to C-function call in SDL_net.h:
                <code>
               	extern DECLSPEC int SDLCALL SDLNet_UDP_RecvV(UDPsocket sock, UDPpacket **packets)
                </code>
            </p>
            </remarks>
            <returns>
            the number of packets received. 
            0 is returned when no packets are received.
            -1 is returned on errors.
            </returns>
            <example>
            <code>
            // try to receive some waiting udp packets
            //UDPsocket udpsock;
            //UDPpacket **packetV;
            int numrecv, i;
            
            numrecv=SDLNet_UDP_RecvV(udpsock, &amp;packetV);
            if(numrecv==-1) {
                // handle error, perhaps just print out the SDL_GetError string.
            }
            for(i=0; i&lt;numrecv; i++) {
                // do something with packetV[i]
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Bind(System.IntPtr,System.Int32,Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Send(System.IntPtr,System.Int32,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_SendV(System.IntPtr,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Recv(System.IntPtr,System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            A valid UDPsocket.
            </param>
            <param name="packets">
            The packet vector to receive into.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_Recv(System.IntPtr,System.IntPtr)">
            <summary>
            Receive into a UDPpacket 
            </summary> 
            <remarks>
            Receive a packet on the specified sock socket.
            The packet you pass in must have enough of a data size 
            allocated for the incoming packet data to fit into. 
            This means you should have knowledge of your size needs
            before trying to receive UDP packets.
            The packet will have it's address set to the remote 
            sender's address.
            The socket's channels are checked in highest to lowest 
            order, so if an address is bound to multiple channels,
            the highest channel with the source address bound will 
            be retreived before the lower bound channels. So, the 
            packets channel will also be set to the highest numbered
            channel that has the remote address and port assigned to
            it. Otherwise the channel will -1, which you can filter 
            out easily if you want to ignore unbound source address.
            Note that the local and remote channel numbers do not have
            to, and probably won't, match, as they are only local
            settings, they are not sent in the packet.
            This is a non-blocking call, meaning if there's no data
            ready to be received the function will return.
            <p>Binds to C-function call in SDL_net.h:
                <code>
               	extern DECLSPEC int SDLCALL SDLNet_UDP_Recv(UDPsocket sock, UDPpacket *packet)
                </code>
            </p>
            </remarks>
            <returns>
            1 is returned when a packet is received.
            0 is returned when no packets are received.
            -1 is returned on errors.
            </returns>
            <example>
            <code>
            // try to receive some waiting udp packets
            //UDPsocket udpsock;
            //UDPpacket packet;
            int numrecv;
            
            numrecv=SDLNet_UDP_Recv(udpsock, &amp;packet);
            if(numrecv) {
                // do something with packet
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Bind(System.IntPtr,System.Int32,Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Send(System.IntPtr,System.Int32,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_SendV(System.IntPtr,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_RecvV(System.IntPtr,System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            A valid UDPsocket.
            </param>
            <param name="packet">
            The packet to receive into.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_Close(System.IntPtr)">
            <summary>
            Close and free a UDP socket 
            </summary>
            <remarks>
            Shutdown, close, and free a UDPsocket.
            Don't use the UDPsocket after calling this, 
            except to open a new one.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC void SDLCALL SDLNet_UDP_Close(UDPsocket sock)
                </code>
            </p>
            </remarks>
            <returns>
            nothing, this always succeeds.
            </returns>
            <example>
            <code>
            // unbind all addresses on the UDPsocket channel 0
            //UDPsocket udpsock;
            
            SDLNet_UDP_Close(udpsock);
            udpsock=NULL; //this helps us know that this UDPsocket is not valid anymore
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_UDP_Open(System.Int16)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <param name="sock">
            A valid UDPsocket to shutdown, close, and free.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_AllocSocketSet(System.Int32)">
            <summary>
            Create a new socket set 
            </summary>
            <remarks>
            Create a socket set that will be able to watch up to 
            maxsockets number of sockets. The same socket set can 
            be used for both UDP and TCP sockets.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC SDLNet_SocketSet SDLCALL SDLNet_AllocSocketSet(int maxsockets)
                </code>
            </p>
            </remarks>
            <returns>
            A new, empty, SDLNet_SocketSet. NULL is returned on errors, such as out-of-memory.
            </returns>
            <example>
            <code>
            // Create a socket set to handle up to 16 sockets
            SDLNet_SocketSet set;
            
            set=SDLNet_AllocSocketSet(16);
            if(!set) {
                printf("SDLNet_AllocSocketSet: %s\n", SDLNet_GetError());
                exit(1); //most of the time this is a major error, but do what you want.
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreeSocketSet(Tao.Sdl.SdlNet.SDLNet_SocketSet)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="maxsockets">
            The maximum number of sockets you will want to watch.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)">
            <summary>
            Add a socket to a socket set 
            </summary>
            <remarks>
            Add a socket to a socket set that will be watched. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC int SDLCALL SDLNet_AddSocket(SDLNet_SocketSet set, SDLNet_GenericSocket sock)
                </code>
            </p>
            </remarks>
            <returns>
            the number of sockets used in the set on success. -1 is returned on errors.
            </returns>
            <example>
            <code>
            // add two sockets to a socket set
            //SDLNet_SocketSet set;
            //UDPsocket udpsock;
            //TCPsocket tcpsock;
            int numused;
            
            numused=SDLNet_UDP_AddSocket(set,udpsock);
            if(numused==-1) {
                printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
                // perhaps you need to restart the set and make it bigger...
            }
            numused=SDLNet_TCP_AddSocket(set,tcpsock);
            if(numused==-1) {
                printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
                // perhaps you need to restart the set and make it bigger...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocSocketSet(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_CheckSockets(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.Int32)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to add this socket to
            </param>
            <param name="sock">
            The socket to add to the socket set
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.IntPtr)">
            <summary>
            Add a socket to a socket set 
            </summary>
            <remarks>
            Add a socket to a socket set that will be watched. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
                #define SDLNet_TCP_AddSocket(set, sock) SDLNet_AddSocket(set, (SDLNet_GenericSocket)sock)
                </code>
            </p>
            </remarks>
            <returns>
            the number of sockets used in the set on success. -1 is returned on errors.
            </returns>
            <example>
            <code>
            // add two sockets to a socket set
            //SDLNet_SocketSet set;
            //UDPsocket udpsock;
            //TCPsocket tcpsock;
            int numused;
            
            numused=SDLNet_UDP_AddSocket(set,udpsock);
            if(numused==-1) {
                printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
                // perhaps you need to restart the set and make it bigger...
            }
            numused=SDLNet_TCP_AddSocket(set,tcpsock);
            if(numused==-1) {
                printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
                // perhaps you need to restart the set and make it bigger...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocSocketSet(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_CheckSockets(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.Int32)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to add this socket to
            </param>
            <param name="sock">
            The socket to add to the socket set
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.IntPtr)">
            <summary>
            Add a socket to a socket set 
            </summary>
            <remarks>
            Add a socket to a socket set that will be watched. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
                #define SDLNet_UDP_AddSocket(set, sock) SDLNet_AddSocket(set, (SDLNet_GenericSocket)sock)
                </code>
            </p>
            </remarks>
            <returns>
            the number of sockets used in the set on success. -1 is returned on errors.
            </returns>
            <example>
            <code>
            // add two sockets to a socket set
            //SDLNet_SocketSet set;
            //UDPsocket udpsock;
            //TCPsocket tcpsock;
            int numused;
            
            numused=SDLNet_UDP_AddSocket(set,udpsock);
            if(numused==-1) {
                printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
                // perhaps you need to restart the set and make it bigger...
            }
            numused=SDLNet_TCP_AddSocket(set,tcpsock);
            if(numused==-1) {
                printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
                // perhaps you need to restart the set and make it bigger...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocSocketSet(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_CheckSockets(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.Int32)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to add this socket to
            </param>
            <param name="sock">
            The socket to add to the socket set
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)">
            <summary>
            Remove a socket from a socket set 
            </summary>
            <remarks>
            Free the socket set from memory.
            Do not reference the set after this call, 
            except to allocate a new one. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC int SDLCALL SDLNet_DelSocket(SDLNet_SocketSet set, SDLNet_GenericSocket sock)
                </code>
            </p>
            </remarks>
            <returns>
            the number of sockets used in the set on success. -1 is returned on errors.
            </returns>
            <example>
            <code>
            // remove two sockets from a socket set
            //SDLNet_SocketSet set;
            //UDPsocket udpsock;
            //TCPsocket tcpsock;
            int numused;
            
            numused=SDLNet_UDP_DelSocket(set,udpsock);
            if(numused==-1) {
                printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
                // perhaps the socket is not in the set
            }
            numused=SDLNet_TCP_DelSocket(set,tcpsock);
            if(numused==-1) {
                printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
                // perhaps the socket is not in the set
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreeSocketSet(Tao.Sdl.SdlNet.SDLNet_SocketSet)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to remove this socket from 
            </param>
            <param name="sock">
            the socket to remove from the socket set  
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_TCP_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.IntPtr)">
            <summary>
            Remove a socket from a socket set 
            </summary>
            <remarks>
            Free the socket set from memory.
            Do not reference the set after this call, 
            except to allocate a new one. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
                #define SDLNet_TCP_DelSocket(set, sock) SDLNet_DelSocket(set, (SDLNet_GenericSocket)sock)
                </code>
            </p>
            </remarks>
            <returns>
            the number of sockets used in the set on success. -1 is returned on errors.
            </returns>
            <example>
            <code>
            // remove two sockets from a socket set
            //SDLNet_SocketSet set;
            //UDPsocket udpsock;
            //TCPsocket tcpsock;
            int numused;
            
            numused=SDLNet_UDP_DelSocket(set,udpsock);
            if(numused==-1) {
                printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
                // perhaps the socket is not in the set
            }
            numused=SDLNet_TCP_DelSocket(set,tcpsock);
            if(numused==-1) {
                printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
                // perhaps the socket is not in the set
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreeSocketSet(Tao.Sdl.SdlNet.SDLNet_SocketSet)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to remove this socket from 
            </param>
            <param name="sock">
            the socket to remove from the socket set  
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_UDP_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.IntPtr)">
            <summary>
            Remove a socket from a socket set 
            </summary>
            <remarks>
            Free the socket set from memory.
            Do not reference the set after this call, 
            except to allocate a new one. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
                #define SDLNet_UDP_DelSocket(set, sock) SDLNet_DelSocket(set, (SDLNet_GenericSocket)sock)
                </code>
            </p>
            </remarks>
            <returns>
            the number of sockets used in the set on success. -1 is returned on errors.
            </returns>
            <example>
            <code>
            // remove two sockets from a socket set
            //SDLNet_SocketSet set;
            //UDPsocket udpsock;
            //TCPsocket tcpsock;
            int numused;
            
            numused=SDLNet_UDP_DelSocket(set,udpsock);
            if(numused==-1) {
                printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
                // perhaps the socket is not in the set
            }
            numused=SDLNet_TCP_DelSocket(set,tcpsock);
            if(numused==-1) {
                printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
                // perhaps the socket is not in the set
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreeSocketSet(Tao.Sdl.SdlNet.SDLNet_SocketSet)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to remove this socket from 
            </param>
            <param name="sock">
            the socket to remove from the socket set  
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_CheckSockets(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.Int32)">
            <summary>
            Check and wait for sockets in a set to have activity 
            </summary>
            <remarks>
            Check all sockets in the socket set for activity. If a non-zero timeout is given then this function will wait for activity, or else it will wait for timeout milliseconds. 
            NOTE: "activity" also includes disconnections and other errors, which would be determined by a failed read/write attempt.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC int SDLCALL SDLNet_CheckSockets(SDLNet_SocketSet set, Uint32 timeout)
                </code>
            </p>
            </remarks>
            <returns>
            the number of sockets with activity. -1 is returned on errors, and you may not get a meaningful error message. -1 is also returned for an empty set (nothing to check). 
            </returns>
            <example>
            <code>
            // Wait for up to 1 second for network activity
            //SDLNet_SocketSet set;
            int numready;
            
            numready=SDLNet_CheckSockets(set, 1000);
            if(numready==-1) {
                printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
                //most of the time this is a system error, where perror might help you.
                perror("SDLNet_CheckSockets");
            }
            else if(numready) {
                printf("There are %d sockets with activity!\n",numready);
                // check all sockets with SDLNet_SocketReady and handle the active ones.
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_SocketReady(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocSocketSet(System.Int32)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to check
            </param>
            <param name="timeout">
            The amount of time (in milliseconds).
            0 means no waiting.
            -1 means to wait over 49 days! (think about it)
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_SocketReady(System.IntPtr)">
            <summary>
            See if a socket has activity 
            </summary>
            <remarks>
            Check whether a socket has been marked as active. This function should only be used on a socket in a socket set, and that set has to have had SDLNet_CheckSockets (see SDLNet_CheckSockets) called upon it.
            <p>Binds to C-function call in SDL_net.h:
                <code>
                #define SDLNet_SocketReady(sock) ((sock != NULL) &amp;&amp; ((SDLNet_GenericSocket)sock)-&gt;ready)
                </code>
            </p>
            </remarks>
            <returns>
            non-zero for activity. zero is returned for no activity.
            </returns>
            <example>
            <code>
            // Wait forever for a connection attempt
            //SDLNet_SocketSet set;
            //TCPsocket serversock, client;
            int numready;
            
            numready=SDLNet_CheckSockets(set, 1000);
            if(numready==-1) {
                printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
                //most of the time this is a system error, where perror might help you.
                perror("SDLNet_CheckSockets");
            }
            else if(numready) {
                printf("There are %d sockets with activity!\n",numready);
                // check all sockets with SDLNet_SocketReady and handle the active ones.
                if(SDLNet_SocketReady(serversock)) {
                    client=SDLNet_TCP_Accept(serversock);
                    if(client) {
                        // play with the client.
                    }
                }
            }
            </code>
            To just quickly do network handling with no waiting, we do this.
            <code>
            // Check for, and handle UDP data
            //SDLNet_SocketSet set;
            //UDPsocket udpsock;
            //UDPpacket *packet;
            int numready, numpkts;
            
            numready=SDLNet_CheckSockets(set, 0);
            if(numready==-1) {
                printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
                //most of the time this is a system error, where perror might help you.
                perror("SDLNet_CheckSockets");
            }
            else if(numready) {
                printf("There are %d sockets with activity!\n",numready);
                // check all sockets with SDLNet_SocketReady and handle the active ones.
                if(SDLNet_SocketReady(udpsock)) {
                    numpkts=SDLNet_UDP_Recv(udpsock,&amp;packet);
                    if(numpkts) {
                        // process the packet.
                    }
                }
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_CheckSockets(Tao.Sdl.SdlNet.SDLNet_SocketSet,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_DelSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocSocketSet(System.Int32)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="sock">
            The socket to check for activity.
            Both UDPsocket and TCPsocket can be used with this function.
            </param>
        </member>
        <member name="M:Tao.Sdl.SdlNet.SDLNet_FreeSocketSet(Tao.Sdl.SdlNet.SDLNet_SocketSet)">
            <summary>
            Free a socket set 
            </summary>
            <remarks>
            Free the socket set from memory.
            Do not reference the set after this call, 
            except to allocate a new one. 
            <p>Binds to C-function call in SDL_net.h:
                <code>
                extern DECLSPEC void SDLCALL SDLNet_FreeSocketSet(SDLNet_SocketSet set)
                </code>
            </p>
            </remarks>
            <returns>
            nothing, this call always succeeds.
            </returns>
            <example>
            <code>
            // free a socket set
            //SDLNet_SocketSet set;
            
            SDLNet_FreeSocketSet(set);
            set=NULL; //this helps us remember that this set is not allocated
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocSocketSet(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AddSocket(Tao.Sdl.SdlNet.SDLNet_SocketSet,Tao.Sdl.SdlNet.SDLNet_GenericSocket)"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_SocketSet"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <param name="set">
            The socket set to free from memory 
            </param>
        </member>
        <member name="T:Tao.Sdl.SdlNet.IPaddress">
            <summary>
            IP Address and Port number
            </summary>
            <remarks>
            This type contains the information used to 
            form network connections and sockets.
            <p>Binds to C-function call in SDL_net.h:
            <code>
            typedef struct {
            	Uint32 host;
            	Uint16 port;
            } IPaddress;
            </code>
            </p>
            </remarks>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_TCP_Open(Tao.Sdl.SdlNet.IPaddress@)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResolveHost(Tao.Sdl.SdlNet.IPaddress@,System.String,System.Int16)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResolveIP(Tao.Sdl.SdlNet.IPaddress@)"/>
        </member>
        <member name="F:Tao.Sdl.SdlNet.IPaddress.host">
            <summary>
            The 32-bit IPv4 address of a host, encoded in Network Byte
             Order.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.IPaddress.port">
            <summary>
            The 16-bit IPv4 port number of a socket, 
            encoded in Network Byte Order.
            </summary>
        </member>
        <member name="T:Tao.Sdl.SdlNet.UDPpacket">
            <summary>
            UDP packet data encapsulation
            </summary>
            <remarks>
            This struct is used with UDPsockets to send and receive data. 
            It also helps keep track of a packets sending/receiving 
            settings and status. The channels concept helps prioritize,
             or segregate differring types of data packets.
            <p>Binds to C-function call in SDL_net.h:
            <code>
            typedef struct {
            	int channel;
            	Uint8 *data;
            	int len;
            	int maxlen;
            	int status;
            	IPaddress address;
            } UDPpacket;
            </code>
            </p>
            </remarks>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.IPaddress"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacket(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_ResizePacket(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreePacket(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_AllocPacketV(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlNet.SDLNet_FreePacketV(System.IntPtr)"/>
        </member>
        <member name="F:Tao.Sdl.SdlNet.UDPpacket.channel">
            <summary>
            The (software) channel number for this packet. 
            This can also be used as a priority value for the packet.
             If no channel is assigned, the value is -1.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.UDPpacket.data">
            <summary>
            The data contained in this packet, this is the meat.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.UDPpacket.len">
            <summary>
            This is the meaningful length of the data in bytes.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.UDPpacket.maxlen">
            <summary>
            This is size of the data buffer, which may be larger 
            than the meaningful length. This is only used for 
            packet creation on the senders side.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.UDPpacket.status">
            <summary>
            This contains the number of bytes sent, or a -1 on errors,
             after sending. This is useless for a received packet.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlNet.UDPpacket.address">
            <summary>
            This is the resolved IPaddress to be used when sending, 
            or it is the remote source of a received packet.
            </summary>
        </member>
        <member name="T:Tao.Sdl.SdlNet.TCPsocket">
            <summary>
            TCP socket type (opaque)
            </summary>
            <remarks>
            This is an opaque data type used for TCP connections. 
            This is a pointer, and so it could be NULL at times. 
            NULL would indicate no socket has been established.
            <code>
            typedef struct _TCPsocket *TCPsocket
            </code>
            </remarks>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_GenericSocket"/>
        </member>
        <member name="T:Tao.Sdl.SdlNet.UDPsocket">
            <summary>
            UDP socket type (opaque)
            </summary>
            <remarks>
            This is an opaque data type used for UDP sockets. 
            This is a pointer, and so it could be NULL at times. 
            NULL would indicate no socket has been established.
            <code>
            typedef struct _UDPsocket *UDPsocket
            </code>
            </remarks>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPpacket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.SDLNet_GenericSocket"/>
        </member>
        <member name="T:Tao.Sdl.SdlNet.SDLNet_SocketSet">
            <summary>
            Socket Set type (opaque)
            </summary>
            <remarks>
            This is an opaque data type used for socket sets. 
            This is a pointer, and so it could be NULL at times. 
            NULL would indicate no socket set has been created.
            <code>
            typedef struct _SDLNet_SocketSet *SDLNet_SocketSet
            </code>
            </remarks>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
        </member>
        <member name="T:Tao.Sdl.SdlNet.SDLNet_GenericSocket">
            <summary>
            A generic type for UDP and TCP sockets
            </summary>
            <remarks>
            This data type is able to be used for both UDPsocket 
            and TCPsocket types.
            After calling SDLNet_CheckSockets, 
            if this socket is in SDLNet_SocketSet used, 
            the ready will be set according to activity on the socket. 
            This is the only real use for this type, as it doesn't 
            help you know what type of socket it is.
            <code>
            typedef struct {
                int ready;
            } *SDLNet_GenericSocket;
            </code>
            </remarks>
            <seealso cref="T:Tao.Sdl.SdlNet.TCPsocket"/>
            <seealso cref="T:Tao.Sdl.SdlNet.UDPsocket"/>
        </member>
        <member name="F:Tao.Sdl.SdlNet.SDLNet_GenericSocket.ready">
            <summary>
            Non-zero when data is ready to be read, 
            or a server socket has a connection attempt 
            ready to be accepted.
            </summary>
        </member>
        <member name="T:Tao.Sdl.Smpeg">
            <summary>
            SMPEG bindings for .NET. 
            <p></p>
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_NATIVE_LIBRARY">
            <summary>
                Specifies Smpeg's native library archive.
            </summary>
            <remarks>
                Specifies smpeg.dll everywhere; will be mapped via .config for mono.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/> 
                for Windows and Linux.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_FILTER_INFO_MB_ERROR">
            <summary>
            Filter info flag
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_FILTER_INFO_PIXEL_ERROR">
            <summary>
            Filter info flag
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_MAJOR_VERSION">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_MINOR_VERSION">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_PATCHLEVEL">
            <summary>
            Patch Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_ERROR">
            <summary>
            MPEG status code. 
            </summary>
            <remarks>
            Part of SMPEGstatus C-style enum
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_STOPPED">
            <summary>
            MPEG status code. 
            </summary>
            <remarks>
            Part of SMPEGstatus C-style enum
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_PLAYING">
            <summary>
            MPEG status code. 
            </summary>
            <remarks>
            Part of SMPEGstatus C-style enum
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEGfilter_null">
            <summary>
            The null filter (default). 
            It simply copies the source rectangle to the video overlay.
            </summary>
            <remarks>
            <p>Binds to C-function in MPEGfilter.h
            <code>
            SMPEG_Filter * SMPEGfilter_null(void)
            </code></p></remarks>
            <returns>IntPtr to <see cref="T:Tao.Sdl.Smpeg.SMPEG_Filter"/></returns>
            <seealso cref="M:Tao.Sdl.Smpeg.SMPEGfilter_bilinear"/>
            <seealso cref="M:Tao.Sdl.Smpeg.SMPEGfilter_deblocking"/>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEGfilter_bilinear">
            <summary>
            The bilinear filter. 
            A basic low-pass filter that will produce a smoother image.
            </summary>
            <remarks>
            <p>Binds to C-function in MPEGfilter.h
            <code>
            SMPEG_Filter * SMPEGfilter_bilinear(void)
            </code></p></remarks>
            <returns>IntPtr to <see cref="T:Tao.Sdl.Smpeg.SMPEG_Filter"/></returns>
            <seealso cref="M:Tao.Sdl.Smpeg.SMPEGfilter_null"/>
            <seealso cref="M:Tao.Sdl.Smpeg.SMPEGfilter_deblocking"/>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEGfilter_deblocking">
            <summary>
            The deblocking filter. 
            It filters block borders and non-intra coded blocks 
            to reduce blockiness
            </summary>
            <remarks>
            <p>Binds to C-function in MPEGfilter.h
            <code>
            SMPEG_Filter * SMPEGfilter_deblocking(void)
            </code></p></remarks>
            <returns>IntPtr to <see cref="T:Tao.Sdl.Smpeg.SMPEG_Filter"/></returns>
            <seealso cref="M:Tao.Sdl.Smpeg.SMPEGfilter_null"/>
            <seealso cref="M:Tao.Sdl.Smpeg.SMPEGfilter_bilinear"/>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_VERSION">
            <summary>
            This method can be used to fill a version structure with the compile-time
            version of the SMPEG library.
            </summary>
            <returns>
                This function returns a <see cref="T:Tao.Sdl.Smpeg.SMPEG_version"/> struct containing the
                compiled version number
            </returns>
            <remarks>
                <p>
                Binds to C-function call in smpeg.h:
                <code>#define SMPEG_VERSION(X)
            {
            (X)-&gt;major = SMPEG_MAJOR_VERSION;
            (X)-&gt;minor = SMPEG_MINOR_VERSION;
            (X)-&gt;patch = SMPEG_PATCHLEVEL;
            }</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_new(System.String,Tao.Sdl.Smpeg.SMPEG_Info@,System.Int32)">
            <summary>
            Create a new SMPEG object from an MPEG file.
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>SMPEG* SMPEG_new(const char *file, SMPEG_Info* info, int sdl_audio);
            </code></p></remarks>
            <param name="file"></param>
            <param name="info">On return, if 'info' is not NULL, 
            it will be filled with information about the MPEG object.</param>
            <param name="sdl_audio">
            The sdl_audio parameter indicates if SMPEG should 
            initialize the SDL audio
            subsystem. If not, you will have to use the 
            SMPEG_playaudio() function below
            to extract the decoded data. Never set this parameter to false (i.e. 0). 
            This will cause the video playback to run very slowly. 
            To disable audio, 
            use the <see cref="M:Tao.Sdl.Smpeg.SMPEG_enableaudio(System.IntPtr,System.Int32)"/> function.</param>
            <returns>This function returns a new SMPEG object.  
            Use SMPEG_error() to find out whether or not there 
            was a problem building the MPEG stream.</returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_new_descr(System.Int32,Tao.Sdl.Smpeg.SMPEG_Info@,System.Int32)">
            <summary>
            Create a new SMPEG object from a file descriptor.
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>SMPEG* SMPEG_new_descr(int file, SMPEG_Info* info, int sdl_audio)
            </code></p></remarks>
            <param name="file"></param>
            <param name="info">On return, if 'info' is not NULL, 
            it will be filled with information about the MPEG object.</param>
            <param name="sdl_audio">
            The sdl_audio parameter indicates if SMPEG should 
            initialize the SDL audio
            subsystem. If not, you will have to use the 
            SMPEG_playaudio() function below
            to extract the decoded data.</param>
            <returns>This function returns a new SMPEG object.  
            Use SMPEG_error() to find out whether or not there 
            was a problem building the MPEG stream.</returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_new_data(System.Object,System.Int32,Tao.Sdl.Smpeg.SMPEG_Info@,System.Int32)">
            <summary>
            Create a new SMPEG object from for a raw chunk of data.
            </summary>
            <remarks>
            SMPEG makes a copy of the data, so the application is free to 
            delete after a successful call to this function.
            <p>Binds to a C-function call in smpeg.h
            <code>
            SMPEG* SMPEG_new_data(void *data, int size, SMPEG_Info* info, int sdl_audio)
            </code></p></remarks>
            <param name="data">Raw chunck of data</param>
            <param name="size">Size of chunk</param>
            <param name="info">On return, if 'info' is not NULL, 
            it will be filled with information about the MPEG object.</param>
            <param name="sdl_audio">
            The sdl_audio parameter indicates if SMPEG should 
            initialize the SDL audio
            subsystem. If not, you will have to use the 
            SMPEG_playaudio() function below
            to extract the decoded data.</param>
            <returns>This function returns a new SMPEG object.  
            Use SMPEG_error() to find out whether or not there 
            was a problem building the MPEG stream.</returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_new_rwops(System.IntPtr,Tao.Sdl.Smpeg.SMPEG_Info@,System.Int32)">
            <summary>
            Create a new SMPEG object from a generic SDL_RWops structure.
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            SMPEG* SMPEG_new_rwops(SDL_RWops *src, SMPEG_Info* info, int sdl_audio);
            </code></p></remarks>
            <param name="src"></param>
            <param name="info">On return, if 'info' is not NULL, 
            it will be filled with information about the MPEG object.</param>
            <param name="sdl_audio">
            The sdl_audio parameter indicates if SMPEG should 
            initialize the SDL audio
            subsystem. If not, you will have to use the 
            SMPEG_playaudio() function below
            to extract the decoded data.</param>
            <returns>This function returns a new SMPEG object.  
            Use SMPEG_error() to find out whether or not there 
            was a problem building the MPEG stream.</returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_getinfo(System.IntPtr,Tao.Sdl.Smpeg.SMPEG_Info@)">
            <summary>
            Get current information about an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_getinfo( SMPEG* mpeg, SMPEG_Info* info )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="info">On return, if 'info' is not NULL, 
            it will be filled with information about the MPEG object.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_enableaudio(System.IntPtr,System.Int32)">
            <summary>
            Enable or disable audio playback in MPEG stream
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_enableaudio( SMPEG* mpeg, int enable )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="enable"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_enablevideo(System.IntPtr,System.Int32)">
            <summary>
            Enable or disable video playback in MPEG stream
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_enablevideo( SMPEG* mpeg, int enable )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="enable"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_delete(System.IntPtr)">
            <summary>
            Delete an SMPEG object.
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_delete( SMPEG* mpeg )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_status(System.IntPtr)">
            <summary>
            Get the current status of an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            SMPEGstatus SMPEG_status( SMPEG* mpeg )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <returns>
            SMPEG status: SMPEG_ERROR, SMPEG_PLAYING, SMPEG_STOPPED
            </returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_setvolume(System.IntPtr,System.Int32)">
            <summary>
            Set the audio volume of an MPEG stream, in the range 0-100
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_setvolume( SMPEG* mpeg, int volume )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="volume">Range from 0 - 100.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_setdisplay(System.IntPtr,System.IntPtr,System.IntPtr,Tao.Sdl.Smpeg.SMPEG_DisplayCallback)">
            <summary>
            Set the destination surface for MPEG video playback
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_setdisplay(SMPEG* mpeg, SDL_Surface* dst, SDL_mutex* surfLock, SMPEG_DisplayCallback callback);
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="dst"></param>
            <param name="surfLock">
            'surfLock' is a mutex used to synchronize access to 'dst', 
            and can be NULL.
            </param>
            <param name="callback">
            'callback' is a function called when an area of 'dst' needs 
            to be updated.
             If 'callback' is NULL, the default function (SDL_UpdateRect) 
             will be used.
             </param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_loop(System.IntPtr,System.Int32)">
            <summary>
            Set or clear looping play on an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_loop( SMPEG* mpeg, int repeat )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="repeat"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_scaleXY(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Scale pixel display on an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_scaleXY( SMPEG* mpeg, int width, int height )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_scale(System.IntPtr,System.Int32)">
            <summary>
            Scale pixel display on an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_scale( SMPEG* mpeg, int scale )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="scale"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_double(System.IntPtr,System.Int32)">
            <summary>
            Scale pixel display on an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            #define SMPEG_double(mpeg, on) \
            	SMPEG_scale(mpeg, (on) ? 2 : 1)
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="on"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_move(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Move the video display area within the destination surface
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_move( SMPEG* mpeg, int x, int y )
            </code>
            </p>
            </remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_setdisplayregion(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the region of the video to be shown
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_setdisplayregion(SMPEG* mpeg, int x, int y, int w, int h)
            </code>
            </p>
            </remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="h"></param>
            <param name="w"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_play(System.IntPtr)">
            <summary>
            Play an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_play( SMPEG* mpeg )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_pause(System.IntPtr)">
            <summary>
            Pause/Resume playback of an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_pause( IntPtr mpeg )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_stop(System.IntPtr)">
            <summary>
            Stop playback of an SMPEG object
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_stop( SMPEG* mpeg )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_rewind(System.IntPtr)">
            <summary>
            Rewind the play position of an SMPEG object 
            to the beginning of the MPEG
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_rewind( SMPEG* mpeg )
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_seek(System.IntPtr,System.Int32)">
            <summary>
            Seek 'bytes' bytes in the MPEG stream
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_seek( SMPEG* mpeg, int bytes)
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="bytes">Bytes in the MPEG stream.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_skip(System.IntPtr,System.Single)">
            <summary>
            Skip 'seconds' seconds in the MPEG stream
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_skip( SMPEG* mpeg, float seconds );
            </code></p></remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="seconds">Seconds in the MPEG stream.</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_renderFrame(System.IntPtr,System.Int32)">
            <summary>
            Render a particular frame in the MPEG video
            </summary>
            <remarks>
            API CHANGE: This function no longer takes a target surface and position.
            Use SMPEG_setdisplay() and SMPEG_move() to set this information.
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_renderFrame( SMPEG* mpeg, int framenum )
            </code>
            </p>
            </remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="framenum">Frame number</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_renderFinal(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Render the last frame of an MPEG video
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_renderFinal( SMPEG* mpeg, SDL_Surface* dst, int x, int y )
            </code>
            </p>
            </remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="dst">SDL_Surface pointer</param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_filter(System.IntPtr,System.IntPtr)">
            <summary>
            Set video filter
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            SMPEG_Filter * SMPEG_filter( SMPEG* mpeg, SMPEG_Filter * filter )
            </code>
            </p>
            </remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="filter">IntPtr to SPEG_Filter</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_error(System.IntPtr)">
            <summary>
            SMPEG errors messages.
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            char *SMPEG_error( SMPEG* mpeg );
            </code></p></remarks>
            <param name="mpeg">MPEG file pointer</param>
            <returns>
            Return NULL if there is no error in the MPEG stream, 
            or an error message
            if there was a fatal error in the MPEG stream for the SMPEG object..
            </returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_playAudio(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            Exported callback function for audio playback.
            </summary>
            <remarks>
            The function takes a buffer and the amount of data to fill, and returns
            	   the amount of data in bytes that was actually written.  This will be the
            	   amount requested unless the MPEG audio has finished.
            <p>Binds to a C-function call in smpeg.h
            <code>
            int SMPEG_playAudio( SMPEG *mpeg, Uint8 *stream, int len )
            </code>
            </p>
            </remarks>
            <param name="mpeg">Handle to MPEG file.</param>
            <param name="stream">Bytestream of data</param>
            <param name="len">Amount of data to fill</param>
            <returns>Amount of data in bytes that was actually written</returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_playAudioSDL(System.IntPtr,System.Byte[],System.Int32)">
            <summary>
            Wrapper for SMPEG_playAudio() that can be passed to SDL and SDL_mixer. 
            Exported callback function for audio playback.
            </summary>
            <remarks>
            The function takes a buffer and the amount of data to fill, and returns
            	   the amount of data in bytes that was actually written.  This will be the
            	   amount requested unless the MPEG audio has finished.
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_playAudioSDL( void *mpeg, Uint8 *stream, int len )
            </code>
            </p>
            </remarks>
            <param name="mpeg">MPEG object.</param>
            <param name="stream">Bytestream of data</param>
            <param name="len">Amount of data to fill</param>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_wantedSpec(System.IntPtr,System.IntPtr)">
            <summary>
            Get the best SDL audio spec for the audio stream 
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            int SMPEG_wantedSpec( SMPEG *mpeg, SDL_AudioSpec *wanted )
            </code>
            </p>
            </remarks>
            <param name="mpeg">MPEG object.</param>
            <param name="wanted">SDL_AudioSpec</param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_actualSpec(System.IntPtr,Tao.Sdl.Sdl.SDL_AudioSpec@)">
            <summary>
            Inform SMPEG of the actual SDL audio spec used for sound playback
            </summary>
            <remarks>
            <p>Binds to a C-function call in smpeg.h
            <code>
            void SMPEG_actualSpec( SMPEG *mpeg, SDL_AudioSpec *spec )
            </code>
            </p>
            </remarks>
            <param name="mpeg">MPEG object.</param>
            <param name="spec">SDL_AudioSpec</param>
            <returns></returns>
        </member>
        <member name="T:Tao.Sdl.Smpeg.SMPEG_FilterInfo">
            <summary>
            Filter info from SMPEG
            </summary>
            <remarks>
            <p>Struct in MPEGfilter.h
            <code>
            typedef struct SMPEG_FilterInfo {
            	Uint16* yuv_mb_square_error;
            	Uint16* yuv_pixel_square_error;
            }
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_FilterInfo.yuv_mb_square_error">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_FilterInfo.yuv_pixel_square_error">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Smpeg.SMPEG_Filter">
            <summary>
            The filter definition itself
            </summary>
            <remarks>
            <p>Struct in MPEGfilter.h
            <code>
            typedef struct SMPEG_Filter {
            	Uint32 flags;
            	void * data;
            	SMPEG_FilterCallback callback;
            	SMPEG_FilterDestroy destroy;
            }
            </code></p></remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Filter.flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Filter.data">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Filter.callback">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Filter.destroy">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Smpeg.SMPEG_version">
            <summary>
            Structure to hold version number of the SMPEG library
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_version.major">
            <summary>
            Major version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_version.minor">
            <summary>
            Minor version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_version.patch">
            <summary>
            Patch version
            </summary>
        </member>
        <member name="M:Tao.Sdl.Smpeg.SMPEG_version.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tao.Sdl.Smpeg.SMPEG_Info">
            <summary>
            Used to get information about the SMPEG object
            </summary>
            <remarks>
            <p>
            <code>
            typedef struct _SMPEG_Info {
            	int has_audio;
            	int has_video;
            	int width;
            	int height;
            	int current_frame;
            	double current_fps;
            	char audio_string[80];
            	int  audio_current_frame;
            	Uint32 current_offset;
            	Uint32 total_size;
            	double current_time;
            	double total_time;
            } SMPEG_Info;
            </code></p></remarks>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.has_audio">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.has_video">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.width">
            <summary>
            Width of movie file
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.height">
            <summary>
            Height of movie file
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.current_frame">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.current_fps">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.audio_string">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.audio_current_frame">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.current_offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.total_size">
            <summary>
            Movie file size in bytes
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.current_time">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Smpeg.SMPEG_Info.total_time">
            <summary>
            Length of movie file in seconds.
            </summary>
        </member>
        <member name="T:Tao.Sdl.Smpeg.SMPEG_FilterCallback">
            <summary>
            Callback function for the filter
            </summary>
            <remarks>
            <p>
            <code>
            typedef void (* SMPEG_FilterCallback)( SDL_Overlay * dest, SDL_Overlay * source, SDL_Rect * region, SMPEG_FilterInfo * filter_info, void * data );
            </code></p></remarks>
        </member>
        <member name="T:Tao.Sdl.Smpeg.SMPEG_FilterDestroy">
            <summary>
            Callback function for the filter
            </summary>
            <remarks>
            <p>Binds to a callback function in MPEGfilter.h
            <code>
            typedef void (* SMPEG_FilterDestroy)( struct SMPEG_Filter * filter )
            </code></p></remarks>
        </member>
        <member name="T:Tao.Sdl.Smpeg.SMPEG_DisplayCallback">
            <summary>
            Matches the declaration of SDL_UpdateRect()
            </summary>
            <remarks>
            <p>Binds to a callback function in smpeg.h
            <code>
            typedef void(*SMPEG_DisplayCallback)(SDL_Surface* dst, int x, int y, unsigned int w, unsigned int h);
            </code>
            </p>
            </remarks>
        </member>
        <member name="T:Tao.Sdl.SdlMixer">
            <summary>
            <p>SdlMixer is a simple multi-channel audio mixer. 
            It supports 8 channels of 16 bit stereo audio, plus a 
            single channel of music, mixed by the popular MikMod MOD, 
            Timidity MIDI and SMPEG MP3 libraries.</p> 
            <p>
            The mixer can currently load Microsoft WAVE files and 
            Creative Labs VOC files as audio samples, and can load MIDI 
            files via Timidity and the following music formats via 
            MikMod: .MOD .S3M .IT .XM. It can load Ogg Vorbis streams 
            as music if built with the Ogg Vorbis libraries, and 
            finally it can load MP3 music using the SMPEG library.</p> 
            <p>
            The process of mixing MIDI files to wave output is very CPU 
            intensive, so if playing regular WAVE files sound great, but
             playing MIDI files sound choppy, try using 8-bit audio, 
             mono audio, or lower frequencies.</p>
            </summary>
            <remarks>
            This assumes you have gotten SDL_mixer and installed it 
            on your system. SDL_mixer has an INSTALL document in the
             source distribution to help you get it compiled and installed. 
            SDL_mixer supports playing music and sound samples from 
            the following formats:
            <code>
            - WAVE/RIFF (.wav)
            - AIFF (.aiff)
            - VOC (.voc)
            - MOD (.mod .xm .s3m .669 .it .med and more) using included mikmod
            - MIDI (.mid) using timidity or native midi hardware
            - OggVorbis (.ogg) requiring ogg/vorbis libraries on system
            - MP3 (.mp3) requiring SMPEG library on system
            - also any command-line player, which is not mixed by SDL_mixer...
            </code>
            <p>
            When using SDL_mixer functions you need to avoid the 
            following functions from SDL:</p>
            <p><code>
            SDL_OpenAudio 
            Use Mix_OpenAudio instead. 
            SDL_CloseAudio 
            Use Mix_CloseAudio instead. 
            SDL_PauseAudio 
            Use Mix_Pause(-1) and Mix_PauseMusic instead, to pause.
            Use Mix_Resume(-1) and Mix_ResumeMusic instead, to unpause. 
            SDL_LockAudio 
            This is just not needed since SDL_mixer handles this for you.
            Using it may cause problems as well. 
            SDL_UnlockAudio 
            This is just not needed since SDL_mixer handles this for you.
            Using it may cause problems as well. </code></p>
            <p>You may call the following functions freely:</p> 
            <code>
            SDL_AudioDriverName 
            This will still work as usual. 
            SDL_GetAudioStatus 
            This will still work, though it will likely return 
            SDL_AUDIO_PLAYING even though SDL_mixer is just playing silence. 
            It is also a BAD idea to call SDL_mixer and SDL audio 
            functions from a callback. Callbacks include Effects 
            functions and other SDL_mixer audio hooks. </code>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.SDL_MIXER_NATIVE_LIBRARY">
            <summary>
                Specifies SdlMixer native library archive.
            </summary>
            <remarks>
                Specifies SDL_mixer.dll everywhere; will be mapped via .config for mono.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/> 
                for Windows and Linux.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_MAJOR_VERSION">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_MINOR_VERSION">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_PATCHLEVEL">
            <summary>
            Patch Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_CHANNELS">
            <summary>
            The default mixer has this many simultaneous mixing 
            channels after the first call to Mix_OpenAudio.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_DEFAULT_FREQUENCY">
            <summary>
            Good default sample rate in Hz (samples per second)
             for PC sound cards.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_DEFAULT_CHANNELS">
            <summary>
            Stereo sound is a good default.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_MAX_VOLUME">
            <summary>
            Maximum value for any volume setting.
            </summary>
            <remarks>
            This is currently the same as <see cref="F:Tao.Sdl.Sdl.SDL_MIX_MAXVOLUME"/>.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_CHANNEL_POST">
            <summary>
            This is the channel number used for post processing effects.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_EFFECTSMAXSPEED">
            <summary>
            A convience definition for the string name of the
             environment variable to define when you desire 
             the internal effects to sacrifice quality and/or 
             RAM for speed. The environment variable must be 
             set (else nonexisting) before Mix_OpenAudio is 
             called for the setting to take effect.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_NO_FADING">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_FADING_OUT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MIX_FADING_IN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MUS_NONE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MUS_CMD">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MUS_WAV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MUS_MOD">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MUS_MID">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MUS_OGG">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.MUS_MP3">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.MIX_VERSION">
            <summary>
            This method can be used to fill a version structure with the compile-time
            version of the SDL_mixer library.
            </summary>
            <returns>
                This function returns a <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct containing the
                compiled version number
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mixer.h:
                <code>#define SDL_MIX_VERSION(X)
            {
            (X)-&gt;major = SDL_MIX_MAJOR_VERSION;
            (X)-&gt;minor = SDL_MIX_MINOR_VERSION;
            (X)-&gt;patch = SDL_MIX_PATCHLEVEL;
            }</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_Linked_Version">
            <summary>
                Using this you can compare the runtime version to the 
            version that you compiled with.
            </summary>
            <returns>
                This function gets the version of the dynamically 
            linked SDL_mixer library in an <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mixer.h:
                <code>const SDL_version * Mix_Linked_Version(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_OpenAudio(System.Int32,System.Int16,System.Int32,System.Int32)">
             <summary>
             Open the mixer with a certain audio format
             </summary>
             <remarks>
             Initialize the mixer API.
             <p>
            	This must be called before using other functions in this 
            	library.
            	SDL must be initialized with SDL_INIT_AUDIO before this call. 
            	frequency would be 44100 for 44.1KHz, which is CD audio rate. 
            	Most games use 22050, because 44100 requires too much CPU power
            	 on older computers. chunksize is the size of each mixed sample.
            	  The smaller this is the more your hooks will be called. 
            	  If make this too small on a slow system, sound may skip. 
            	  If made to large, sound effects will lag behind the action more.
            	   You want a happy medium for your target computer.
            	    You also may make this 4096, or larger, if you are
            	     just playing music. MIX_CHANNELS(8) mixing channels
            	      will be allocated by default. You may call this function
            	       multiple times, however you will have to call Mix_CloseAudio
            	        just as many times for the device to actually close.
            	         The format will not changed on subsequent calls. 
            	         So you will have to close all the way before
            	          trying to open with different format parameters.</p>
            	          
            	          <p>format is based on SDL audio support, see SDL_audio.h. Here are the values listed there:</p>
            
             <code>
             AUDIO_U8
             Unsigned 8-bit samples
            
             AUDIO_S8
             Signed 8-bit samples
            
             AUDIO_U16LSB
             Unsigned 16-bit samples, in little-endian byte order
            
             AUDIO_S16LSB
             Signed 16-bit samples, in little-endian byte order
            
             AUDIO_U16MSB
             Unsigned 16-bit samples, in big-endian byte order
            
             AUDIO_S16MSB
             Signed 16-bit samples, in big-endian byte order
            
             AUDIO_U16
             same as AUDIO_U16LSB (for backwards compatability probably)
            
             AUDIO_S16
             same as AUDIO_S16LSB (for backwards compatability probably)
            
             AUDIO_U16SYS
             Unsigned 16-bit samples, in system byte order
            
             AUDIO_S16SYS
             Signed 16-bit samples, in system byte order
             </code>
            
             <p>MIX_DEFAULT_FORMAT is the same as AUDIO_S16SYS.</p>
             <p>Binds to C-funtion in SDL_mixer.h
             <code>
             int Mix_OpenAudio(int frequency, Uint16 format, int channels, int chunksize)
             </code></p>
             </remarks>
             <param name="frequency">
             Output sampling frequency in samples per second (Hz).
             you might use MIX_DEFAULT_FREQUENCY(22050) 
             since that is a good value for most games.
             </param>
             <param name="format">
             Output sample format.
             </param>
             <param name="channels">
             Number of sound channels in output.
             Set to 2 for stereo, 1 for mono. 
             This has nothing to do with mixing channels.
             </param>
             <param name="chunksize">
             Bytes used per output sample.
             </param>
             <returns>
             0 on success, -1 on errors 
             </returns>
             <example>
             <code>
             // start SDL with audio support
            		if(SDL_Init(SDL_INIT_AUDIO)==-1) 
            	{
            		printf("SDL_Init: %s\n", SDL_GetError());
            		exit(1);
            	}
            	// open 44.1KHz, signed 16bit, system byte order,
            	//      stereo audio, using 1024 byte chunks
            	if(Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024)==-1) 
            {
            	printf("Mix_OpenAudio: %s\n", Mix_GetError());
            	exit(2);
            }
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_CloseAudio"/>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_QuerySpec(System.Int32@,System.Int16@,System.Int32@)"/>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_AllocateChannels(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_AllocateChannels(System.Int32)">
            <summary>
            Dynamically change the number of channels managed by the mixer.
            If decreasing the number of channels, the upper channels are
            stopped. 
            <p>This function returns the new number of allocated channels.</p>
            </summary>
            <remarks>
            Set the number of channels being mixed. 
            This can be called multiple times, 
            even with sounds playing. If numchans is less
             than the current number of channels, then the
              higher channels will be stopped, freed, and
               therefore not mixed any longer. It's 
               probably not a good idea to change the
                size 1000 times a second though.
            If any channels are deallocated, 
            any callback set by Mix_ChannelFinished 
            will be called when each channel 
            is halted to be freed. Note: passing 
            in zero WILL free all mixing channels, 
            however music will still play. 
            </remarks>
            <param name="numchans">
            Number of channels to allocate for mixing. 
            A negative number will not do anything, it will tell
             you how many channels are currently allocated.
            </param>
            <returns>
            The number of channels allocated.
            Never fails...but a high number of channels
            can segfault if you run out of memory. We're talking REALLY high!
            </returns>
            <example>
            <code>
            // allocate 16 mixing channels
            Mix_AllocateChannels(16);
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_OpenAudio(System.Int32,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_QuerySpec(System.Int32@,System.Int16@,System.Int32@)">
             <summary>
             Get output format.
             </summary>
             <remarks>
             Get the actual audio format in use by the opened 
             audio device.
              This may or may not match the parameters you
               passed to Mix_OpenAudio.
               <p>Binds to C-function in SDL_mixer.h
               <code>int Mix_QuerySpec(int *frequency, Uint16 *format, int *channels)
               </code></p>
             </remarks>
             <param name="channels">
             A pointer to an int where the 
             number of audio channels will be stored.
             2 will mean stereo, 1 will mean mono.
             </param>
             <param name="format">
             A pointer to a short where the output format actually
              being used by the audio device will be stored.
             </param>
             <param name="frequency">
             A pointer to an int 
             where the frequency actually used by the opened 
             audio device will be stored. 
             </param>
             <returns>
             0 on error. If the device was open the number of times 
             it was opened will be returned. The values of the 
             arguments variables are not set on an error.
             </returns>
             <example>
             <code>
             // get and print the audio format in use
            		int numtimesopened, frequency, channels;
            		Uint16 format;
            		numtimesopened=Mix_QuerySpec(&amp;frequency, &amp;format, &amp;channels);
            		if(!numtimesopened) 
            	{
            		printf("Mix_QuerySpec: %s\n",Mix_GetError());
            	}
            	else 
            {
            	char *format_str="Unknown";
            	switch(format) 
            {
            	case AUDIO_U8: format_str="U8"; break;
            	case AUDIO_S8: format_str="S8"; break;
            	case AUDIO_U16LSB: format_str="U16LSB"; break;
            	case AUDIO_S16LSB: format_str="S16LSB"; break;
            	case AUDIO_U16MSB: format_str="U16MSB"; break;
            	case AUDIO_S16MSB: format_str="S16MSB"; break;
            }
            	printf("opened=%d times  frequency=%dHz  format=%s  channels=%d",
            	numtimesopened, frequency, format, channels);
            }
             </code>
             </example>
              <seealso cref="M:Tao.Sdl.SdlMixer.Mix_OpenAudio(System.Int32,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_LoadWAV_RW(System.IntPtr,System.Int32)">
            <summary>
            Load a wave file or a music (.mod .s3m .it .xm) file
            </summary>
            <remarks>
            Load src for use as a sample. 
            This can load WAVE, AIFF, RIFF, OGG, and VOC formats. 
            Using SDL_RWops is not covered here, but they enable 
            you to load from almost any source.
            <p>Binds to C-function in SDL_mixer.h
              <code>Mix_Chunk *Mix_LoadWAV_RW(SDL_RWops *src, int freesrc)
              </code></p>
            </remarks>
            <param name="src">
            The source SDL_RWops as a pointer. 
            The sample is loaded from this.
            </param>
            <param name="freesrc">
            A non-zero value mean is will automatically 
            close/free the src for you.
            </param>
            <returns>
            a pointer to the sample as a Mix_Chunk. 
            NULL is returned on errors.
            </returns>
            <example>
            <code>
            // load sample.wav in to sample
            	Mix_Chunk *sample;
            	sample=Mix_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1);
            	if(!sample) 
            {
            	printf("Mix_LoadWAV_RW: %s\n", Mix_GetError());
            	// handle error
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_QuickLoad_WAV(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FreeChunk(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_LoadWAV(System.String)">
            <summary>
            Load WAV from a file.
            </summary>
            <param name="file">
            File name to load sample from.
            </param>
            <remarks>
            Load file for use as a sample. 
            This is actually Mix_LoadWAV_RW(SDL_RWFromFile(file, "rb"), 1).
             This can load WAVE, AIFF, RIFF, OGG, and VOC files.
             <p>Binds to C-function in SDL_mixer.h
              <code>Mix_Chunk *Mix_LoadWAV(char *file)
              </code></p>
            </remarks>
            <returns>
            a pointer to the sample as a Mix_Chunk. 
            NULL is returned on errors.
            </returns>
            <example>
            <code>
            // load sample.wav in to sample
            	Mix_Chunk *sample;
            	sample=Mix_LoadWAV("sample.wav");
            	if(!sample) 
            {
            	printf("Mix_LoadWAV: %s\n", Mix_GetError());
            	// handle error
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV_RW(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_QuickLoad_WAV(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FreeChunk(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_LoadMUS(System.String)">
            <summary>
            Load a music file into a Mix_Music
            </summary>
            <param name="file">Name of music file to use.
            </param>
            <returns>
            A pointer to a Mix_Music. NULL is returned on errors.
            </returns>
            <remarks>
            Load music file to use. This can load WAVE, MOD, MIDI, OGG, MP3, 
            and any file that you use a command to play with.
            <p>If you are using an external command to play the music, 
            you must call Mix_SetMusicCMD before this, otherwise the 
            internal players will be used. Alternatively, if you have 
            set an external command up and don't want to use it, you 
            must call Mix_SetMusicCMD(NULL) to use the built-in players 
            again.</p>
            <p>Binds to C-function in SDL_mixer.h
            <code>Mix_Music *Mix_LoadMUS(const char *file)
            </code></p>
            </remarks>
            <example>
            <code>
            // load the MP3 file "music.mp3" to play as music
            	Mix_Music *music;
            	music=Mix_LoadMUS("music.mp3");
            	if(!music) 
            {
            	printf("Mix_LoadMUS(\"music.mp3\"): %s\n", Mix_GetError());
            	// this might be a critical error...
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetMusicCMD(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayMusic(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusic(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusicPos(System.IntPtr,System.Int32,System.Int32,System.Double)"/> 
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_LoadMUS_RW(System.IntPtr)">
            <summary>
            Load a music file from an SDL_RWop object (Ogg and MikMod specific currently)
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_mixer.h
            <code>Mix_Music *Mix_LoadMUS_RW(SDL_RWops *rw)
            </code></p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_QuickLoad_WAV(System.IntPtr)">
            <summary>
            Load a wave file of the mixer format from a memory buffer
            </summary>
            <remarks>
            Load mem as a WAVE/RIFF file into a new sample. 
            The WAVE in mem must be already in the output format.
             It would be better to use Mix_LoadWAV_RW if you aren't sure.
            Note: This function does very little checking. 
            If the format mismatches the output format, or 
            if the buffer is not a WAVE, it will not return an error.
             This is probably a dangerous function to use.
             <p>Binds to C-function in SDL_mixer.h
            <code>Mix_Chunk *Mix_QuickLoad_WAV(Uint8 *mem)
            </code>
            </p>
            </remarks>
            <param name="mem">
            Memory buffer containing a WAVE file in output format. 
            </param>
            <returns>
            a pointer to the sample as a Mix_Chunk. 
            NULL is returned on errors.
            </returns>
            <example>
            <code>
            // quick-load a wave from memory
            	// Uint8 *wave; // I assume you have the wave loaded raw,
            	// or compiled in the program...
            	Mix_Chunk *wave_chunk;
            	if(!(wave_chunk=Mix_QuickLoad_WAV(wave))) 
            {
            	printf("Mix_QuickLoad_WAV: %s\n", Mix_GetError());
            	// handle error
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_QuickLoad_RAW(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FreeChunk(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_QuickLoad_RAW(System.IntPtr,System.Int32)">
            <summary>
            Load raw audio data of the mixer format from a memory buffer 
            </summary>
            <remarks>
            Load mem as a raw sample. The data in mem must be already in 
            the output format. If you aren't sure what you are doing, 
            this is not a good function for you!
            <p>Note: This function does very little checking. 
            If the format mismatches the output format it 
            will not return an error. This is probably a 
            dangerous function to use.</p>
            <p>Binds to C-function in SDL_mixer.h
            <code>Mix_Chunk *Mix_QuickLoad_RAW(Uint8 *mem)
            </code>
            </p> 
            </remarks>
            <param name="len"></param>
            <param name="mem">
            Memory buffer containing a WAVE file in output format. 
            Load mem as a raw sample. 
            The data in mem must be already in the output format. 
            If you aren't sure what you are doing, 
            this is not a good function for you!
            </param>
            <returns>
            a pointer to the sample as a Mix_Chunk. 
            NULL is returned on errors, such as when out of memory.
            </returns>
            <example>
            <code>
            // quick-load a raw sample from memory
            	// Uint8 *raw; // I assume you have the raw data here,
            	// or compiled in the program...
            	Mix_Chunk *raw_chunk;
            	if(!(raw_chunk=Mix_QuickLoad_RAW(raw))) 
            {
            	printf("Mix_QuickLoad_RAW: %s\n", Mix_GetError());
            	// handle error
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_QuickLoad_WAV(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FreeChunk(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FreeChunk(System.IntPtr)">
            <summary>
            Free an audio chunk previously loaded
            </summary>
            <remarks>
            Free the memory used in chunk, and free chunk itself as well. 
            Do not use chunk after this without loading a new sample to 
            it. Note: It's a bad idea to free a chunk that is still 
            being played...
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_FreeChunk(Mix_Chunk *chunk)
            </code>
            </p>
            </remarks>
            <param name="chunk">
            Pointer to the Mix_Chunk to free.
            </param>
            <example>
            <code>
            // free the sample
            	// Mix_Chunk *sample;
            	Mix_FreeChunk(sample);
            	sample=NULL; // to be safe...
            	</code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_QuickLoad_WAV(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV_RW(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FreeMusic(System.IntPtr)">
            <summary>
            Free a Mix_Music
            </summary>
            <remarks>
            Free the loaded music. If music is playing it will be halted. 
            If music is fading out, then this function will wait (blocking)
             until the fade out is complete.
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_FreeMusic(Mix_Music *music)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // free music
            	Mix_Music *music;
            	Mix_FreeMusic(music);
            	music=NULL; // so we know we freed it...
            </code>
            </example>
            <param name="music">Pointer to Mix_Music to free.</param>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadMUS(System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GetMusicType(System.IntPtr)">
            <summary>
            Find out the music format of a mixer music, 
            or the currently playing music, if 'music' is NULL.
            </summary>
            <remarks>
            Tells you the file format encoding of the music. 
            This may be handy when used with Mix_SetMusicPosition,
            and other music functions that vary based on the type 
            of music being played. If you want to know the type of 
            music currently being played, pass in NULL to music.
            <p>Binds to C-function in SDL_mixer.h
            <code>Mix_MusicType Mix_GetMusicType(const Mix_Music *music)
            </code>
            </p>
            </remarks>
            <param name="music">The music to get the type of.
            NULL will get the currently playing music type.
            </param>
            <returns>The type of music or if music is NULL then 
            the currently playing music type, otherwise MUS_NONE
             if no music is playing.</returns>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetPosition(System.Int32,System.Int16,System.Byte)"/>
             <example>
             <code>
             // print the type of music currently playing
            	switch(Mix_GetMusicType(NULL))
            {
            	case MUS_NONE:
            	MUS_CMD:
            	printf("Command based music is playing.\n");
            	break;
            	MUS_WAV:
            	printf("WAVE/RIFF music is playing.\n");
            	break;
            	MUS_MOD:
            	printf("MOD music is playing.\n");
            	break;
            	MUS_MID:
            	printf("MIDI music is playing.\n");
            	break;
            	MUS_OGG:
            	printf("OGG music is playing.\n");
            	break;
            	MUS_MP3:
            	printf("MP3 music is playing.\n");
            	break;
            	default:
            	printf("Unknown music is playing.\n");
            	break;
            }
             </code></example>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetPosition(System.Int32,System.Int16,System.Byte)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetPostMix(Tao.Sdl.SdlMixer.MixFunctionDelegate,System.IntPtr)">
            <summary>
            Hook in a postmix processor
            </summary>
            <remarks>
            Hook a processor function mix_func to the postmix stream for post
             processing effects. You may just be reading the data and 
             displaying it, or you may be altering the stream to add an
             echo. Most processors also have state data that they allocate 
             as they are in use, this would be stored in the arg pointer
              data space. This processor is never really finished, until
               the audio device is closed, or you pass NULL as the mix_func.
            <p>There can only be one postmix function used at a time through 
            this method. Use 
            Mix_RegisterEffect(MIX_CHANNEL_POST, mix_func, NULL, arg) to 
            use multiple postmix processors.</p>
            <p>This postmix processor is run AFTER all the registered 
            postmixers set up by Mix_RegisterEffect.</p>
            <p>
            <code>void Mix_SetPostMix(void (*mix_func)(void *udata, Uint8 *stream, int len), void *arg)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // make a passthru processor function that does nothing...
            	void noEffect(void *udata, Uint8 *stream, int len)
            	{
            		// you could work with stream here...
            	}
            	...
            	// register noEffect as a postmix processor
            	Mix_SetPostMix(noEffect, NULL);
            </code>
            </example>
            <param name="mix_func">The function pointer for the postmix processor.
            NULL unregisters the current postmixer.</param>
            <param name="arg">A pointer to data to pass into the mix_func's 
            udata parameter. It is a good place to keep the state data for 
            the processor, especially if the processor is made to handle 
            multiple channels at the same time.
            This may be NULL, depending on the processor.</param>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_RegisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate,Tao.Sdl.SdlMixer.MixEffectDoneDelegate,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_HookMusic(Tao.Sdl.SdlMixer.MixFunctionDelegate,System.IntPtr)">
             <summary>
             Hook for a custom music player
             </summary>
             <remarks>
             This sets up a custom music player function. The function will 
             be called with arg passed into the udata parameter when the 
             mix_func is called. The stream parameter passes in the audio 
             stream buffer to be filled with len bytes of music. The music 
             player will then be called automatically when the mixer needs 
             it. Music playing will start as soon as this is called. All the 
             music playing and stopping functions have no effect on music 
             after this. Pause and resume will work. Using a custom music 
             player and the internal music player is not possible, the custom 
             music player takes priority. To stop the custom music player call
              Mix_HookMusic(NULL, NULL).
             <p>NOTE: NEVER call SDL_Mixer functions, nor SDL_LockAudio, 
             from a callback function.</p>
             <p>
             <code>void Mix_HookMusic(void (*mix_func)(void *udata, Uint8 *stream, int len), void *arg)
             </code>
             </p>
             </remarks>
             <example>
             <code>
             // make a music play function
            		// it expects udata to be a pointer to an int
            		void myMusicPlayer(void *udata, Uint8 *stream, int len)
            		{
            			int i, pos=*(int*)udata;
            
            			// fill buffer with...uh...music...
            			for(i=0; i&lt;len; i++)
            				stream[i]=(i+pos)&amp;ff;
            
            			// set udata for next time
            			pos+=len;
            			*(int*)udata=pos;
            		}
            		...
            		// use myMusicPlayer for playing...uh...music
            		int music_pos=0;
            		Mix_HookMusic(myMusicPlayer, &amp;music_pos);
             </code>
             </example>
             <param name="mix_func">Function pointer to a music player mixer function.
             NULL will stop the use of the music player, 
             returning the mixer to using the internal music players 
             like usual.</param>
             <param name="arg">
             This is passed to the mix_func's udata parameter when it is called.
             </param>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetMusicCMD(System.String)"/>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GetMusicHookData"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_HookMusicFinished(Tao.Sdl.SdlMixer.MusicFinishedDelegate)">
            <summary>
            Add your own callback when the music has finished playing.
            This callback is only called if the music finishes naturally.
            </summary>
            <remarks>
            This sets up a function to be called when music playback is halted. 
            Any time music stops, the music_finished function will be called. 
            Call with NULL to remove the callback.
            <p>NOTE: NEVER call SDL_Mixer functions, nor SDL_LockAudio, 
            from a callback function.</p>
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_HookMusicFinished(void (*music_finished)())
            </code>
            </p>
            </remarks>
            <param name="music_finished">
            Function pointer to a void function(). 
            NULL will remove the hook.
            </param>
            <example>
            <code>
            // make a music finished function
            	void musicFinished()
            	{
            		printf("Music stopped.\n");
            	}
            	...
            	// use musicFinished for when music stops
            	Mix_HookMusicFinished(musicFinished);
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutMusic(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GetMusicHookData">
            <summary>
            Get a pointer to the user data for the current music hook
            </summary>
            <remarks>
            Get the arg passed into Mix_HookMusic.
            <p>Binds to C-function in SDL_mixer.h
            <code>void *Mix_GetMusicHookData()
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // retrieve the music hook data pointer
            void *data;
            data=Mix_GetMusicHookData();
            </code></example>
            <returns>the arg pointer.</returns>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HookMusic(Tao.Sdl.SdlMixer.MixFunctionDelegate,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)">
             <summary>
             Set callback for when channel finishes playing
             </summary>
             <remarks>
             When channel playback is halted, then the specified 
             channel_finished function is called. The channel parameter 
             will contain the channel number that has finished.
             <p>NOTE: NEVER call SDL_Mixer functions, 
             nor SDL_LockAudio, from a callback function.</p>
             <p>Binds to C-function in SDL_mixer.h
             <code>void Mix_ChannelFinished(void (*channel_finished)(int channel))
             </code>
             </p>
             </remarks>
             <example>
             <code>
             // a simple channel_finished function
            		void channelDone(int channel) 
            		{
            			printf("channel %d finished playback.\n",channel);
            		}
            
            		// make a channelDone function
            		void channelDone(int channel)
            		{
            			printf("channel %d finished playing.\n", channel);
            		}
            		...
            		// set the callback for when a channel stops playing
            		Mix_ChannelFinished(channelDone);
             </code></example>
             <param name="channel_finished">
             Function to call when any channel finishes playback. 
             </param>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)"/>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ExpireChannel(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_RegisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate,Tao.Sdl.SdlMixer.MixEffectDoneDelegate,System.IntPtr)">
            <summary>
            Hook a processor to a channel
            </summary>
            <remarks>
            Hook a processor function f into a channel for post processing
             effects. You may just be reading the data and displaying it, 
             or you may be altering the stream to add an echo. Most 
             processors also have state data that they allocate as they 
             are in use, this would be stored in the arg pointer data space.
              When a processor is finished being used, any function passed 
              into d will be called, which is when your processor should clean
               up the data in the arg data space.
            <p>The effects are put into a linked list, and always appended to 
            the end, meaning they always work on previously registered effects
             output. Effects may be added multiple times in a row. Effects are
              cumulative this way.</p>
            <p>
            <code>int Mix_RegisterEffect(int chan, Mix_EffectFunc_t f, Mix_EffectDone_t d, void *arg)
            </code></p></remarks>
            <param name="f">
            The function pointer for the effects processor.
            </param>
            <param name="arg"></param>
            <param name="chan">channel number to register f and d on.
            Use MIX_CHANNEL_POST to process the postmix stream.</param>
            <param name="d">
            The function pointer for any cleanup routine to be called 
            when the channel is done playing a sample.
            This may be NULL for any processors that don't need to 
            clean up any memory or other dynamic data.
            </param>
            <returns>
            Zero on errors, such as a nonexisting channel
            </returns>
            <example>
            <code>
            // make a passthru processor function that does nothing...
            	void noEffect(int chan, void *stream, int len, void *udata)
            	{
            		// you could work with stream here...
            	}
            	...
            	// register noEffect as a postmix processor
            	if(!Mix_RegisterEffect(MIX_CHANNEL_POST, noEffect, NULL, NULL)) 
            {
            	printf("Mix_RegisterEffect: %s\n", Mix_GetError());
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterAllEffects(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_UnregisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate)">
            <summary>
            Unhook a processor from a channel
            </summary>
            <remarks>
            Remove the oldest (first found) registered effect function 
            f from the effect list for channel. This only removes the 
            first found occurance of that function, so it may need to 
            be called multiple times if you added the same function multiple
             times, just stop removing when Mix_UnregisterEffect returns an
              error, to remove all occurances of f from a channel.
            <p>If the channel is active the registered effect will have its 
            Mix_EffectDone_t function called, if it was specified in 
            Mix_RegisterEffect.</p>
            <p>
            <code>int Mix_UnregisterEffect(int channel, Mix_EffectFunc_t f)
            </code></p></remarks>
            <param name="f">The function to remove from channel.</param>
            <param name="chan">Channel number to remove f from as a post processor.
            <p>Use MIX_CHANNEL_POST for the postmix stream.</p></param>
            <returns>
            Zero on errors, such as invalid channel, 
            or effect function not registered on channel.
            </returns>
            <example>
            <code>
            // unregister the noEffect from the postmix effects
            // this removes all occurances of noEffect registered to the postmix
            while(Mix_UnregisterEffect(MIX_CHANNEL_POST, noEffect));
            // you may print Mix_GetError() if you want to check it.
            // it should say "No such effect registered" after this loop.
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_RegisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate,Tao.Sdl.SdlMixer.MixEffectDoneDelegate,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterAllEffects(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_UnregisterAllEffects(System.Int32)">
            <summary>
            Unhook all processors from a channel
            </summary>
            <remarks>
            This removes all effects registered to channel. 
            If the channel is active all the registered effects will 
            have their Mix_EffectDone_t functions called, if they 
            were specified in Mix_RegisterEffect.
            <p>
            <code>int Mix_UnregisterAllEffects(int channel)
            </code></p></remarks>
            <param name="channel">
            Channel to remove all effects from.
            Use MIX_CHANNEL_POST for the postmix stream.
            </param>
            <returns>
            Zero on errors, such as channel not existing.
            </returns>
            <example>
            <code>
            // remove all effects from channel 0
            	if(!Mix_UnregisterAllEffects(0)) 
            {
            	printf("Mix_UnregisterAllEffects: %s\n", Mix_GetError());
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_RegisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate,Tao.Sdl.SdlMixer.MixEffectDoneDelegate,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetPanning(System.Int32,System.Byte,System.Byte)">
            <summary>
            Stereo panning
            </summary>
            <remarks>
            This effect will only work on stereo audio. Meaning you called 
            Mix_OpenAudio with 2 channels (MIX_DEFAULT_CHANNELS). The easiest
             way to do true panning is to call 
             Mix_SetPanning(channel, left, 254 - left); so that the total 
             volume is correct, if you consider the maximum volume to be 127
              per channel for center, or 254 max for left, this works, but 
              about halves the effective volume.
            <p>This Function registers the effect for you, so don't try to 
            Mix_RegisterEffect it yourself.</p>
            <p>NOTE: Setting both left and right to 255 will unregister the 
            effect from channel. You cannot unregister it any other way, 
            unless you use Mix_UnregisterAllEffects on the channel.</p>
            <p>NOTE: Using this function on a mono audio device will not
            register the effect, nor will it return an error status.</p>
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_SetPanning(int channel, Uint8 left, Uint8 right)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel number to register this effect on.
            Use MIX_CHANNEL_POST to process the postmix stream.
            </param>
            <param name="left">
            Volume for the left channel, range is 0(silence) to 255(loud) 
            </param>
            <param name="right">
            Volume for the left channel, range is 0(silence) to 255(loud)
            </param>
            <returns>
            Zero on errors, such as bad channel, or if Mix_RegisterEffect failed.
            </returns>
            <example>
            <code>
            // pan channel 1 halfway to the left
            	if(!Mix_SetPanning(1, 255, 127)) 
            {
            	printf("Mix_SetPanning: %s\n", Mix_GetError());
            	// no panning, is it ok?
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetPosition(System.Int32,System.Int16,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterAllEffects(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetPosition(System.Int32,System.Int16,System.Byte)">
            <summary>
            Panning(angular) and distance
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_SetPosition(int channel, Sint16 angle, Uint8 distance)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel number to register this effect on.
            Use MIX_CHANNEL_POST to process the postmix stream.
            </param>
            <param name="angle">
            Direction in relation to forward from 0 to 360 degrees. 
            Larger angles will be reduced to this range using angles % 360.
            0 = directly in front.
            90 = directly to the right.
            180 = directly behind.
            270 = directly to the left.
            So you can see it goes clockwise starting at directly in front.
            This ends up being similar in effect to Mix_SetPanning.
            </param>
            <param name="distance">
            The distance from the listener, from 0(near/loud) to 255(far/quiet).
            This is the same as the Mix_SetDistance effect.
            </param>
            <returns>
            Zero on errors, such as an invalid channel, 
            or if Mix_RegisterEffect failed.
            </returns>
            <example>
            <code>
            // set channel 2 to be behind and right, and 100 units away
            	if(!Mix_SetPosition(2, 135, 100)) 
            {
            	printf("Mix_SetPosition: %s\n", Mix_GetError());
            	// no position effect, is it ok?
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetPanning(System.Int32,System.Byte,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetDistance(System.Int32,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterAllEffects(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetDistance(System.Int32,System.Byte)">
            <summary>
            Distance attenuation (volume)
            </summary>
            <remarks>
            This effect simulates a simple attenuation of volume due to distance. 
            The volume never quite reaches silence, even at max distance.
            NOTE: Using a distance of 0 will cause the effect to unregister 
            itself from channel. You cannot unregister it any other way, 
            unless you use Mix_UnregisterAllEffects on the channel.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_SetDistance(int channel, Uint8 distance)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel number to register this effect on.
            Use MIX_CHANNEL_POST to process the postmix stream.
            </param>
            <param name="distance">
            Specify the distance from the listener, 
            from 0(close/loud) to 255(far/quiet). 
            </param>
            <returns>
            Zero on errors, such as an invalid channel, 
            or if Mix_RegisterEffect failed.
            </returns>
            <example>
            <code>
            // distance channel 1 to be farthest away
            	if(!Mix_SetDistance(1, 255)) 
            {
            	printf("Mix_SetDistance: %s\n", Mix_GetError());
            	// no distance, is it ok?
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetPosition(System.Int32,System.Int16,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterAllEffects(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetReverseStereo(System.Int32,System.Int32)">
            <summary>
            Swap stereo left and right
            </summary>
            <remarks>
            Simple reverse stereo, swaps left and right channel sound.
            <p>NOTE: Using a flip of 0, will cause the effect to unregister 
            itself from channel. You cannot unregister it any other way, 
            unless you use Mix_UnregisterAllEffects on the channel.</p>
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_SetReverseStereo(int channel, int flip)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel number to register this effect on.
            Use MIX_CHANNEL_POST to process the postmix stream.
            </param>
            <param name="flip">
            Must be non-zero to work, means nothing to the effect processor itself.
            set to zero to unregister the effect from channel.
            </param>
            <returns>
            Zero on errors, such as an invalid channel, or if Mix_RegisterEffect failed.
            </returns>
            <example>
            <code>
            // set the total mixer output to be reverse stereo
            	if(!Mix_SetReverseStereo(MIX_CHANNEL_POST, 1)) 
            {
            	printf("Mix_SetReverseStereo: %s\n", Mix_GetError());
            	// no reverse stereo, is it ok?
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterAllEffects(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_ReserveChannels(System.Int32)">
            <summary>
            Prevent channels from being used in default group
            </summary>
            <remarks>
            Reserve num channels from being used when playing samples when 
            passing in -1 as a channel number to playback functions. The 
            channels are reserved starting from channel 0 to num-1. Passing
             in zero will unreserve all channels. Normally SDL_mixer starts 
             without any channels reserved.
             <p>
             The following functions are affected by this setting:
             <br><see cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannel(System.Int32,System.IntPtr,System.Int32)"/></br>
             <br><see cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32)"/></br>
             <br><see cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannel(System.Int32,System.IntPtr,System.Int32,System.Int32)"/></br>
             <br><see cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)"/></br>
             </p>
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_ReserveChannels(int num)
            </code>
            </p>
            </remarks>
            <param name="num">
            Number of channels to reserve from default mixing.
            Zero removes all reservations.
            </param>
            <returns>The number of channels reserved. 
            Never fails, but may return less channels than you ask for,
             depending on the number of channels previously allocated.
             </returns>
             <example>
             <code>
             // reserve the first 8 mixing channels
            	int reserved_count;
            	reserved_count=Mix_ReserveChannels(8);
            	if(reserved_count!=8) 
            {
            	printf("reserved %d channels from default mixing.\n",reserved_count);
            	printf("8 channels were not reserved!\n");
            	// this might be a critical error...
            }
             </code></example>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_AllocateChannels(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GroupChannel(System.Int32,System.Int32)">
            <summary>
            Add/remove channel to/from group
            </summary>
            <remarks>
            Add which channel to group tag, or reset 
            it's group to the default group tag (-1).
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_GroupChannel(int which, int tag)
            </code>
            </p>
            </remarks>
            <param name="which">
            Channel number of channels to assign tag to.
            </param>
            <param name="tag">
            A group number Any positive numbers (including zero).
            -1 is the default group. Use -1 to remove a group tag essentially.
            </param>
            <returns>
            True(1) on success. False(0) is returned when 
            the channel specified is invalid.
            </returns>
            <example>
            <code>
            // add channel 0 to group 1
            	if(!Mix_GroupChannel(0,1)) 
            {
            	// bad channel, apparently channel 1 isn't allocated
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannels(System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_AllocateChannels(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GroupChannels(System.Int32,System.Int32,System.Int32)">
            <summary>
            Assign several consecutive channels to a group
            </summary>
            <remarks>
            Add channels starting at from up through to to group tag, 
            or reset it's group to the default group tag (-1). 
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_GroupChannels(int from, int to, int tag)
            </code>
            </p>
            </remarks>
            <param name="from">
            First Channel number of channels to assign tag to. 
            Must be less or equal to to.
            </param>
            <param name="to">
            Last Channel number of channels to assign tag to. Must be greater or equal to from.
            </param>
            <param name="tag">
            A group number. Any positive numbers (including zero).
            -1 is the default group. Use -1 to remove a group tag essentially.
            </param>
            <returns>
            The number of tagged channels on success. If that number is less 
            than to-from+1 then some channels were no tagged because they didn't 
            exist.
            </returns>
            <example>
            <code>
            // add channels 0 through 7 to group 1
            	if(Mix_GroupChannels(0,7,1)!=8) 
            {
            	// some bad channels, apparently some channels aren't allocated
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_AllocateChannels(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GroupAvailable(System.Int32)">
            <summary>
            Get first inactive channel in group.
            </summary>
            <remarks>
            Find the first available (not playing) channel in group tag.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_GroupAvailable(int tag)
            </code>
            </p>
            </remarks>
            <param name="tag">
            A group number Any positive numbers (including zero).
            -1 will search ALL channels.
            </param>
            <returns>
            The channel found on success. -1 is returned when no 
            channels in the group are available.
            </returns>
            <example>
            <code>
            // find the first available channel in group 1
            	int channel;
            	channel=Mix_GroupAvailable(1);
            	if (channel==-1) 
            {
            	// no channel available...
            	// perhaps search for oldest or newest channel in use...
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupOldest(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupNewer(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannels(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GroupCount(System.Int32)">
            <summary>
            Get number of channels in group.
            </summary>
            <remarks>
            Count the number of channels in group tag.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_GroupCount(int tag)
            </code>
            </p>
            </remarks>
            <param name="tag">
            A group number Any positive numbers (including zero).
            -1 will count ALL channels.
            </param>
            <returns>
            The number of channels found in the group. This function never fails.
            </returns>
            <example>
            <code>
            // count the number of channels in group 1
            printf("There are %d channels in group 1\n", Mix_GroupCount(1));
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannels(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GroupOldest(System.Int32)">
            <summary>
            Get oldest busy channel in group
            </summary>
            <remarks>
            Find the oldest actively playing channel in group tag.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_GroupOldest(int tag)
            </code>
            </p>
            </remarks>
            <param name="tag">
            A group number Any positive numbers (including zero).
            -1 will search ALL channels.
            </param>
            <returns>
            The channel found on success. -1 is returned when no channels in
             the group are playing or the group is empty.
            </returns>
            <example>
            <code>
            // find the oldest playing channel in group 1
            	int channel;
            	channel=Mix_GroupOldest(1);
            	if (channel==-1) 
            {
            	// no channel playing or allocated...
            	// perhaps just search for an available channel...
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupNewer(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupAvailable(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannels(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GroupNewer(System.Int32)">
            <summary>
            Get youngest busy channel in group
            </summary>
            <remarks>
            Find the newest, most recently started, actively playing 
            channel in group tag.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_GroupNewer(int tag)
            </code>
            </p>
            </remarks>
            <param name="tag">
            A group number Any positive numbers (including zero).
            -1 will search ALL channels.
            </param>
            <returns>
            The channel found on success. -1 is returned when no channels in 
            the group are playing or the group is empty.
            </returns>
            <example>
            <code>
            // find the newest playing channel in group 1
            	int channel;
            	channel=Mix_GroupNewer(1);
            	if (channel==-1) 
            {
            	// no channel playing or allocated...
            	// perhaps just search for an available channel...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupOldest(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupAvailable(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GroupChannels(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_PlayChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Play loop and limit by time.
            </summary>
            <remarks>
            If the sample is long enough and has enough 
            loops then the sample will stop after ticks milliseconds. 
            Otherwise this function is the same as <see cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannel(System.Int32,System.IntPtr,System.Int32)"/>.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_PlayChannelTimed(int channel, Mix_Chunk *chunk, int loops, int ticks)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to play on, or -1 for the first free unreserved channel.
            </param>
            <param name="chunk">
            Sample to play.
            </param>
            <param name="loops">
            Number of loops, -1 is infinite loops.
            Passing one here plays the sample twice (1 loop).
            </param>
            <param name="ticks">
            Millisecond limit to play sample, at most.
            If not enough loops or the sample chunk is not long enough,
            then the sample may stop before this timeout occurs.
            -1 means play forever.
            </param>
            <returns>
            the channel the sample is played on. 
            On any errors, -1 is returned.
            </returns>
            <example>
            <code>
            // play sample on first free unreserved channel
            	// play it for half a second
            	// Mix_Chunk *sample; //previously loaded
            	if(Mix_PlayChannelTimed(-1, sample, -1 , 500)==-1) 
            {
            	printf("Mix_PlayChannel: %s\n",Mix_GetError());
            	// may be critical error, or maybe just no channels were free.
            	// you could allocated another channel in that case...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannel(System.Int32,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ReserveChannels(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_PlayChannel(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Play loop.
            </summary>
            <remarks>
            Play chunk on channel, or if channel is -1, 
            pick the first free unreserved channel. 
            The sample will play for loops+1 number of times, 
            unless stopped by halt, or fade out, or setting a 
            new expiration time of less time than it would have 
            originally taken to play the loops, or closing the mixer.
            <p>Note: this just calls Mix_PlayChannelTimed() 
            with ticks set to -1.</p>
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_PlayChannel(int channel, Mix_Chunk *chunk, int loops)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to play on, or -1 for the first free unreserved channel. 
            </param>
            <param name="chunk">
            Sample to play. 
            </param>
            <param name="loops">
            Number of loops, -1 is infinite loops.
            Passing one here plays the sample twice (1 loop).
            </param>
            <returns>
            the channel the sample is played on. On any errors,
             -1 is returned.
            </returns>
            <example>
            <code>
            // play sample on first free unreserved channel
            	// play it exactly once through
            	// Mix_Chunk *sample; //previously loaded
            	if(Mix_PlayChannel(-1, sample, 1)==-1) 
            {
            	printf("Mix_PlayChannel: %s\n",Mix_GetError());
            	// may be critical error, or maybe just no channels were free.
            	// you could allocated another channel in that case...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannel(System.Int32,System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ExpireChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ReserveChannels(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_PlayMusic(System.IntPtr,System.Int32)">
            <summary>
            Play music, with looping
            </summary>
            <remarks>
            Play the loaded music loop times through from start to finish. 
            The previous music will be halted, or if fading out it waits
             (blocking) for that to finish.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_PlayMusic(Mix_Music *music, int loops)
            </code>
            </p>
            </remarks>
            <param name="music">
            Pointer to Mix_Music to play.
            </param>
            <param name="loops">
            number of times to play through the music.
            <br>0 plays the music zero times...</br>
            <br>-1 plays the music forever (or as close as it can get to that)</br>
            </param>
            <returns>
            0 on success, or -1 on errors.
            </returns>
            <example>
            <code>
            // play music forever
            	// Mix_Music *music; // I assume this has been loaded already
            	if(Mix_PlayMusic(music, -1)==-1) 
            {
            	printf("Mix_PlayMusic: %s\n", Mix_GetError());
            	// well, there's no music, but most games don't break without music...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusic(System.IntPtr,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadeInMusic(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Play music, with looping, and fade in
            </summary>
            <remarks>
            Fade in over ms milliseconds of time, the loaded music, 
            playing it loop times through from start to finish.
            The fade in effect only applies to the first loop.
            Any previous music will be halted, or if it is fading out i
            t will wait (blocking) for the fade to complete.
            This function is the same as Mix_FadeInMusicPos(music, loops, ms, 0).
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_FadeInMusic(Mix_Music *music, int loops, int ms)
            </code>
            </p>
            </remarks>
            <param name="music">
            Pointer to Mix_Music to play.
            </param>
            <param name="loops">
            number of times to play through the music.
            <br>
            0 plays the music zero times...
            </br>
            <br>
            -1 plays the music forever (or as close as it can get to that)
            </br>
            </param>
            <param name="ms">
            Milliseconds for the fade-in effect to complete.
            </param>
            <returns>
            0 on success, or -1 on errors.
            </returns>
            <example>
            <code>
            // play music forever, fading in over 2 seconds
            	// Mix_Music *music; // I assume this has been loaded already
            	if(Mix_FadeInMusic(music, -1, 2000)==-1) 
            {
            	printf("Mix_FadeInMusic: %s\n", Mix_GetError());
            	// well, there's no music, but most games don't break without music...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayMusic(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusicPos(System.IntPtr,System.Int32,System.Int32,System.Double)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadeInMusicPos(System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            Play music from a start point, with looping, and fade in
            </summary>
            <remarks>
            Fade in over ms milliseconds of time, the loaded music, 
            playing it loop times through from start to finish.
            The fade in effect only applies to the first loop. The first
             time the music is played, it posistion will be set to position,
              which means different things for different types of music files,
               see Mix_SetMusicPosition for more info on that. Any previous 
               music will be halted, or if it is fading out it will wait 
               (blocking) for the fade to complete.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_FadeInMusicPos(Mix_Music *music, int loops, int ms, double position)
            </code>
            </p>
            </remarks>
            <param name="music">
            Pointer to Mix_Music to play.
            </param>
            <param name="loops">
            number of times to play through the music.
            <br>
            0 plays the music zero times...
            </br>
            <br>
            -1 plays the music forever (or as close as it can get to that)
            </br>
            </param>
            <param name="ms">
            Milliseconds for the fade-in effect to complete.
            </param>
            <param name="position">
            Position to play from, see <see cref="M:Tao.Sdl.SdlMixer.Mix_SetMusicPosition(System.Double)"/> for meaning.
            </param>
            <returns>
            0 on success, or -1 on errors.
            </returns>
            <example>
            <code>
            // play music forever, fading in over 2 seconds
            	// Mix_Music *music; // I assume this has been loaded already
            	if(Mix_FadeInMusicPos(music, -1, 2000)==-1) 
            {
            	printf("Mix_FadeInMusic: %s\n", Mix_GetError());
            	// well, there's no music, but most games don't break without music...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayMusic(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusic(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetMusicPosition(System.Double)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadeInChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Play loop with fade in and limit by time
            </summary>
            <remarks>
            If the sample is long enough and has enough loops then the sample
             will stop after ticks milliseconds. Otherwise this function 
             is the same as <see cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannel(System.Int32,System.IntPtr,System.Int32,System.Int32)"/>.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_FadeInChannelTimed(int channel, Mix_Chunk *chunk, int loops, int ms, int ticks)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to play on, or -1 for the first free unreserved channel.
            </param>
            <param name="chunk">
            Sample to play.
            </param>
            <param name="loops">
            Number of loops, -1 is infinite loops.
            </param>
            <param name="ms">
            Milliseconds of time that the fade-in effect should 
            take to go from silence to full volume.
            </param>
            <param name="ticks">Millisecond limit to play sample, at most.
            If not enough loops or the sample chunk is not long enough, 
            then the sample may stop before this timeout occurs.
             -1 means play forever.</param>
            <returns>
            the channel the sample is played on. On any errors, -1 is returned.
            </returns>
            <example>
            <code>
            // play sample on first free unreserved channel
            	// play it for half a second
            	// Mix_Chunk *sample; //previously loaded
            	if(Mix_PlayChannelTimed(-1, sample, -1 , 500)==-1) 
            {
            	printf("Mix_PlayChannel: %s\n",Mix_GetError());
            	// may be critical error, or maybe just no channels were free.
            	// you could allocated another channel in that case...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannel(System.Int32,System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadingChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ReserveChannels(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ExpireChannel(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadeInChannel(System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Play loop with fade in
            </summary>
            <remarks>
            Play chunk on channel, or if channel is -1, 
            pick the first free unreserved channel.
            The channel volume starts at 0 and fades up to 
            full volume over ms milliseconds of time. 
            The sample may end before the fade-in is 
            complete if it is too short or doesn't have enough loops. 
            The sample will play for loops+1 number of times, 
            unless stopped by halt, or fade out, or setting 
            a new expiration time of less time than it would 
            have originally taken to play the loops, or closing the mixer.
            Note: this just calls <see cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)"/> 
            with ticks set to -1.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_FadeInChannel(int channel, Mix_Chunk *chunk, int loops, int ms)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to play on, or -1 for the first free unreserved channel.
            </param>
            <param name="chunk">Sample to play.</param>
            <param name="loops">
            Number of loops, -1 is infinite loops.
            Passing one here plays the sample twice (1 loop).
            </param>
            <param name="ms">
            Milliseconds of time that the fade-in effect 
            should take to go from silence to full volume.
            </param>
            <returns>
            the channel the sample is played on. 
            On any errors, -1 is returned.
            </returns>
            <example>
            <code>
            // play sample on first free unreserved channel
            	// play it exactly 3 times through
            	// fade in over one second
            	// Mix_Chunk *sample; //previously loaded
            	if(Mix_FadeInChannel(-1, sample, 3, 1000)==-1) 
            {
            	printf("Mix_FadeInChannel: %s\n",Mix_GetError());
            	// may be critical error, or maybe just no channels were free.
            	// you could allocated another channel in that case...
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannel(System.Int32,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadingChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ReserveChannels(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_Volume(System.Int32,System.Int32)">
             <summary>
             Set the mix volume of a channel
             </summary>
             <remarks>
             Set the volume for any allocated channel. 
             If channel is -1 then all channels at are set at once. 
             The volume is applied during the final mix, along 
             with the sample volume. So setting this volume to 
             64 will halve the output of all samples played on 
             the specified channel. All channels default to a 
             volume of 128, which is the max. Newly allocated 
             channels will have the max volume set, so setting 
             all channels volumes does not affect subsequent 
             channel allocations.
             <p>Binds to C-function in SDL_mixer.h
             <code>int Mix_Volume(int channel, int volume)
             </code>
             </p>
             </remarks>
             <param name="channel">
             Channel to set mix volume for.
             -1 will set the volume for all allocated channels.
             </param>
             <param name="volume">
             The volume to use from 0 to MIX_MAX_VOLUME(128).
             If greater than MIX_MAX_VOLUME,
             then it will be set to MIX_MAX_VOLUME.
             If less than 0 then the volume will not be set.
             </param>
             <returns>
             current volume of the channel. 
             If channel is -1, the average volume is returned.
             </returns>
             <example>
             <code>
             // set channel 1 to half volume
            		Mix_Volume(1,MIX_MAX_VOLUME/2);
            
            		// print the average volume
            		printf("Average volume is %d\n",Mix_Volume(-1,-1));
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_VolumeChunk(System.IntPtr,System.Int32)"/>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_VolumeMusic(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_VolumeChunk(System.IntPtr,System.Int32)">
            <summary>
            Set mix volume
            </summary>
            <remarks>
            Set chunk-&gt;volume to volume.
            The volume setting will take effect 
            when the chunk is used on a channel, 
            being mixed into the output.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_VolumeChunk(Mix_Chunk *chunk, int volume)
            </code>
            </p>
            </remarks>
            <param name="chunk">
            Pointer to the Mix_Chunk to set the volume in.
            </param>
            <param name="volume">
            The volume to use from 0 to MIX_MAX_VOLUME(128).
            If greater than MIX_MAX_VOLUME,
            then it will be set to MIX_MAX_VOLUME.
            If less than 0 then chunk-&gt;volume will not be set.
            </param>
            <returns>
            previous chunk-&gt;volume setting. 
            if you passed a negative value for volume then this 
            volume is still the current volume for the chunk.
            </returns>
            <example>
            <code>
            // set the sample's volume to 1/2
            	// Mix_Chunk *sample;
            	int previous_volume;
            	previous_volume=Mix_VolumeChunk(sample, MIX_MAX_VOLUME/2);
            	printf("previous_volume: %d\n", previous_volume);
            </code>
            </example>
            <seealso cref="T:Tao.Sdl.SdlMixer.Mix_Chunk"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_VolumeMusic(System.Int32)">
            <summary>
            Set music volume
            </summary>
            <remarks>
            Set the volume to volume, if it is 0 or greater, and return the 
            previous volume setting. Setting the volume during a fade will 
            not work, the faders use this function to perform their effect! 
            Setting volume while using an external music player set by 
            <see cref="M:Tao.Sdl.SdlMixer.Mix_SetMusicCMD(System.String)"/> will have no effect, and 
            <see cref="M:Tao.Sdl.SdlMixer.Mix_GetError"/> will 
            show the reason why not.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_VolumeMusic(int volume)
            </code>
            </p>
            </remarks>
            <param name="volume">
            Music volume, from 0 to MIX_MAX_VOLUME(128).
            Values greater than MIX_MAX_VOLUME will use MIX_MAX_VOLUME.
            -1 does not set the volume, but does return the current volume setting.
            </param>
            <returns>
            The previous volume setting.
            </returns>
            <example>
            <code>
            // set the music volume to 1/2 maximum, and then check it
            	printf("volume was    : %d\n", Mix_VolumeMusic(MIX_MAX_VOLUME/2));
            	printf("volume is now : %d\n", Mix_VolumeMusic(-1));
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusic(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutMusic(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetMusicCMD(System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)">
            <summary>
            Stop playing on a channel
            </summary>
            <remarks>
            Halt channel playback, or all channels if -1 is passed in.
            Any callback set by Mix_ChannelFinished will be called.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_HaltChannel(int channel)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to stop playing, or -1 for all channels.
            </param>
            <returns>
            always returns zero. (kinda silly)
            </returns>
            <example>
            <code>
            // halt playback on all channels
            Mix_HaltChannel(-1);
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ExpireChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_HaltGroup(System.Int32)">
            <summary>
            Stop a group 
            </summary>
            <remarks>
            Halt playback on all channels in group tag.
            Any callback set by Mix_ChannelFinished will be called once for each channel that stops. 
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_HaltGroup(int tag)
            </code>
            </p>
            </remarks>
            <param name="tag">
            Group to fade out.
            NOTE: -1 will NOT halt all channels. Use Mix_HaltChannel(-1) for that instead.
            </param>
            <returns>
            always returns zero. (more silly than <see cref="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)"/>) 
            </returns>
            <example>
            <code>
            // halt playback on all channels in group 1
            Mix_HaltGroup(1);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutGroup(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_HaltMusic">
            <summary>
            Stop music playback
            </summary>
            <remarks>
            Halt playback of music. This interrupts music fader effects. 
            Any callback set by Mix_HookMusicFinished will be called 
            when the music stops.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_HaltMusic()
            </code>
            </p>
            </remarks>
            <returns>always returns zero. (even more silly than Mix_HaltGroup)
            </returns>
            <example>
            <code>
            // halt music playback
            Mix_HaltMusic();
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutMusic(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HookMusicFinished(Tao.Sdl.SdlMixer.MusicFinishedDelegate)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_ExpireChannel(System.Int32,System.Int32)">
            <summary>
            Change the timed stoppage of a channel
            </summary>
            <remarks>
            Halt channel playback, or all channels if -1 is passed in,
             after ticks milliseconds. Any callback set by 
             <see cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/> 
             will be called when the channel expires.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_ExpireChannel(int channel, int ticks)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to stop playing, or -1 for all channels.
            </param>
            <param name="ticks">
            Milliseconds until channel(s) halt playback. 
            </param>
            <returns>
            Number of channels set to expire. Whether or not they are active.
            </returns>
            <example>
            <code>
            // halt playback on all channels in 2 seconds
            Mix_ExpireChannel(-1, 2000);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadeOutChannel(System.Int32,System.Int32)">
            <summary>
            Stop playing channel after timed fade out
            </summary>
            <remarks>
            Gradually fade out which channel over ms milliseconds starting 
            from now. The channel will be halted after the fade out is 
            completed. Only channels that are playing are set to fade out,
             including paused channels. Any callback set by 
             <see cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/> will be called when the channel
              finishes fading out.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_FadeOutChannel(int which, int ms)
            </code>
            </p>
            </remarks>
            <param name="which">
            Channel to fade out, or -1 to fade all channels out.
            </param>
            <param name="ms">
            Milliseconds of time that the fade-out effect 
            should take to go to silence, starting now.
            </param>
            <returns>The number of channels set to fade out.
            </returns>
            <example>
            <code>
            // fade out all channels to finish 3 seconds from now
            printf("starting fade out of %d channels\n", Mix_FadeOutChannel(-1, 3000));
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannel(System.Int32,System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadingChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadeOutGroup(System.Int32,System.Int32)">
            <summary>
            Fade out a group over time
            </summary>
            <remarks>
            Gradually fade out channels in group tag over ms milliseconds
             starting from now. The channels will be halted after the fade
              out is completed. Only channels that are playing are set to 
              fade out, including paused channels. Any callback set by 
              <see cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/> will be called when each 
              channel finishes fading out.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_FadeOutGroup(int tag, int ms)
            </code>
            </p>
            </remarks>
            <param name="tag">
            Group to fade out.
            NOTE: -1 will NOT fade all channels out. 
            Use Mix_FadeOutChannel(-1) for that instead.
            </param>
            <param name="ms">
            Milliseconds of time that the fade-out effect 
            should take to go to silence, starting now.
            </param>
            <returns>
            The number of channels set to fade out.
            </returns>
            <example>
            <code>
            // fade out all channels in group 1 to finish 3 seconds from now
            printf("starting fade out of %d channels\n", Mix_FadeOutGroup(1, 3000));
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltGroup(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutChannel(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadingChannel(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ChannelFinished(Tao.Sdl.SdlMixer.ChannelFinishedDelegate)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadeOutMusic(System.Int32)">
            <summary>
            Stop music, with fade out
            </summary>
            <remarks>
            Gradually fade out the music over ms milliseconds starting from 
            now. The music will be halted after the fade out is completed. 
            Only when music is playing and not fading already are set to 
            fade out, including paused channels. Any callback set by 
            <see cref="M:Tao.Sdl.SdlMixer.Mix_HookMusicFinished(Tao.Sdl.SdlMixer.MusicFinishedDelegate)"/> will be called when 
            the music finishes fading out.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_FadeOutMusic(int ms)
            </code>
            </p>
            </remarks>
            <param name="ms">
            Milliseconds of time that the fade-out effect 
            should take to go to silence, starting now.
            </param>
            <returns>1 on success, 0 on failure.</returns>
            <example>
            <code>
            // fade out music to finish 3 seconds from now
            	while(!Mix_FadeOutMusic(3000) &amp;&amp; Mix_PlayingMusic()) 
            {
            	// wait for any fades to complete
            	SDL_Delay(100);
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadingMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayingMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HookMusicFinished(Tao.Sdl.SdlMixer.MusicFinishedDelegate)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadingMusic">
            <summary>
            Get status of current music fade activity
            </summary>
            <remarks>
            Tells you if music is fading in, out, or not at all. 
            Does not tell you if the channel is playing anything, 
            or paused, so you'd need to test that separately.
            <p>Binds to C-function in SDL_mixer.h
            <code>Mix_Fading Mix_FadingMusic() 
            </code>
            </p>
            </remarks>
            <returns>
            the fading status. Never returns an error.
            </returns>
            <example>
            <code>
            // check the music fade status
            	switch(Mix_FadingMusic()) 
            {
            	case MIX_NO_FADING:
            	printf("Not fading music.\n");
            	break;
            	case MIX_FADING_OUT:
            	printf("Fading out music.\n");
            	break;
            	case MIX_FADING_IN:
            	printf("Fading in music.\n");
            	break;
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PausedMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayingMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusicPos(System.IntPtr,System.Int32,System.Int32,System.Double)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutMusic(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_FadingChannel(System.Int32)">
            <summary>
            Get the fade status of a channel
            </summary>
            <remarks>
            Tells you if which channel is fading in, out, or not. 
            Does not tell you if the channel is playing anything, 
            or paused, so you'd need to test that separately.
            <p>Binds to C-function in SDL_mixer.h
            <code>Mix_Fading Mix_FadingChannel(int which)
            </code>
            </p>
            </remarks>
            <param name="which">
            Channel to get the fade activity status from.
            -1 is not valid, and will probably crash the program.
            </param>
            <returns>the fading status. Never returns an error.
            </returns>
            <example>
            <code>
            // check the fade status on channel 0
            	switch(Mix_FadingChannel(0)) 
            {
            case MIX_NO_FADING:
            	printf("Not fading.\n");
            	break;
            	case MIX_FADING_OUT:
            	printf("Fading out.\n");
            	break;
            	case MIX_FADING_IN:
            	printf("Fading in.\n");
            	break;
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Paused(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Playing(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannel(System.Int32,System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInChannelTimed(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeOutChannel(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_Pause(System.Int32)">
            <summary>
            Pause a particular channel
            </summary>
            <remarks>
            Pause channel, or all playing channels if -1 is passed in. 
            You may still halt a paused channel.
            Note: Only channels which are actively playing will be paused.
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_Pause(int channel)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to pause on, or -1 for all channels.
            </param>
            <example>
            <code>
            // pause all sample playback
            Mix_Pause(-1);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Resume(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Paused(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltChannel(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_Resume(System.Int32)">
            <summary>
            Resume a paused channel
            </summary>
            <remarks>
            Unpause channel, or all playing and 
            paused channels if -1 is passed in.
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_Resume(int channel)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to resume playing, or -1 for all channels.
            </param>
            <example>
            <code>
            // resume playback on all previously active channels
            Mix_Resume(-1);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Pause(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Paused(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_Paused(System.Int32)">
            <summary>
            Get the pause status of a channel
            </summary>
            <remarks>
            Tells you if channel is paused, or not.
            Note: Does not check if the channel has been halted 
            after it was paused, which may seem a little weird.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_Paused(int channel)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to test whether it is paused or not.
            -1 will tell you how many channels are paused.
            </param>
            <returns>
            Zero if the channel is not paused. Otherwise if you passed in -1,
             the number of paused channels is returned. If you passed in a 
             specific channel, then 1 is returned if it is paused.
            </returns>
            <example>
            <code>
            // check the pause status on all channels
            printf("%d channels are paused\n", Mix_Paused(-1));
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Playing(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Pause(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Resume(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_PauseMusic">
            <summary>
            Pause music
            </summary>
            <remarks>
            Pause the music playback. You may halt paused music.
            Note: Music can only be paused if it is actively playing.
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_PauseMusic()
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // pause music playback
            Mix_PauseMusic();
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ResumeMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PausedMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_HaltMusic"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_ResumeMusic">
            <summary>
            Resume paused music
            </summary>
            <remarks>
            Unpause the music. This is safe to use on halted, 
            paused, and already playing music.
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_ResumeMusic() 
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // resume music playback
            Mix_ResumeMusic();
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PauseMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PausedMusic"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_RewindMusic">
            <summary>
            Rewind music to beginning
            </summary>
            <remarks>
            Rewind the music to the start. This is safe to use on halted, 
            paused, and already playing music. It is not useful to rewind
             the music immediately after starting playback, because it 
             starts at the beginning by default.
             <p>This function only works for these streams: 
             MOD, OGG, MP3, Native MIDI.</p>
            <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_RewindMusic() 
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // rewind music playback to the start
            Mix_RewindMusic();
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayMusic(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_PausedMusic">
            <summary>
            Test whether music is paused
            </summary>
            <remarks>
            Tells you if music is paused, or not.
            Note: Does not check if the music was been halted 
            after it was paused, which may seem a little weird.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_PausedMusic()
            </code>
            </p>
            </remarks>
            <returns>
            Zero if music is not paused. 1 if it is paused. 
            </returns>
            <example>
            <code>
            // check the music pause status
            printf("music is%s paused\n", Mix_PausedMusic()?"":" not");
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayingMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PauseMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_ResumeMusic"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetMusicPosition(System.Double)">
            <summary>
            Set position of playback in stream.
            </summary>
            <remarks>
            Set the position of the currently playing music. 
            The position takes different meanings for different music sources.
            It only works on the music sources listed below.
            <code>
            MOD 
            The double is cast to Uint16 and used for a pattern number in the module.
            Passing zero is similar to rewinding the song. 
            OGG 
            Jumps to position seconds from the beginning of the song. 
            MP3 
            Jumps to position seconds from the current position in the stream.
            </code>
            So you may want to call Mix_RewindMusic before this.
            Does not go in reverse...negative values do nothing.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_SetMusicPosition(double position)
            </code>
            </p>
            </remarks>
            <param name="position">Position to play from.</param>
            <returns>
            0 on success, or -1 if the codec doesn't support this function. 
            </returns>
            <example>
            <code>
            // skip one minute into the song, from the start
            // this assumes you are playing an MP3
            	Mix_RewindMusic();
            	if(Mix_SetMusicPosition(60.0)==-1) 
            {
            	printf("Mix_SetMusicPosition: %s\n", Mix_GetError());
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadeInMusicPos(System.IntPtr,System.Int32,System.Int32,System.Double)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_Playing(System.Int32)">
            <summary>
            Get the active playing status of a channel
            </summary>
            <remarks>
            Tells you if channel is playing, or not.
            Note: Does not check if the channel has been paused.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_Playing(int channel)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to test whether it is playing or not.
            -1 will tell you how many channels are playing.
            </param>
            <returns>
            Zero if the channel is not playing. Otherwise if you passed in -1, 
            the number of channels playing is returned. If you passed in a 
            specific channel, then 1 is returned if it is playing.</returns>
            <example>
            <code>
            // check how many channels are playing samples
            printf("%d channels are playing\n", Mix_Playing(-1));
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Paused(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayChannel(System.Int32,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Pause(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_PlayingMusic">
            <summary>
            Test whether music is playing
            </summary>
            <remarks>
            Tells you if music is actively playing, or not.
            Note: Does not check if the channel has been paused.
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_PlayingMusic() 
            </code>
            </p>
            </remarks>
            <returns></returns>
            <example>
            <code>
            // check if music is playing
            printf("music is%s playing.\n", Mix_PlayingMusic()?"":" not");
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PausedMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FadingMusic"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayMusic(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetMusicCMD(System.String)">
             <summary>
             Use external program for music playback
             </summary>
             <remarks>
             Setup a command line music player to use to play music. 
             Any music playing will be halted. The music file to play 
             is set by calling <see cref="M:Tao.Sdl.SdlMixer.Mix_LoadMUS(System.String)"/>(filename), 
             and the filename is appended as the last argument on the 
             commandline. This allows you to reuse the music command 
             to play multiple files. The command will be sent signals 
             SIGTERM to halt, SIGSTOP to pause, and SIGCONT to resume. 
             The command program should react correctly to those signals
              for it to function properly with SDL_Mixer. 
              <see cref="M:Tao.Sdl.SdlMixer.Mix_VolumeMusic(System.Int32)"/> has no effect when using an 
              external music player, and <see cref="M:Tao.Sdl.SdlMixer.Mix_GetError"/> will 
              have an error code set. You should set the music volume in 
              the music player's command if the music player supports that.
               Looping music works, by calling the command again when the 
               previous music player process has ended. Playing music 
               through a command uses a forked process to execute the music command.
             <p>To use the internal music players set the command to NULL.</p>
             <p>NOTE: External music is not mixed by SDL_mixer, 
             so no post-processing hooks will be for music.</p>
             <p>NOTE: Playing music through an external command may not work 
             if the sound driver does not support multiple openings of the 
             audio device, since SDL_Mixer already has the audio device 
             open for playing samples through channels.</p>
             <p>NOTE: Commands are not totally portable, so be careful.</p>
             <p>Binds to C-function in SDL_mixer.h
             <code>int Mix_SetMusicCMD(const char *command)
             </code>
             </p>
             </remarks>
             <param name="command">
             System command to play the music. Should be a complete command,
              as if typed in to the command line, but it should expect the 
              filename to be added as the last argument.
             NULL will turn off using an external command for music, 
             returning to the internal music playing functionality.
             </param>
             <returns>
             0 on success, or -1 on any errors, such as running out of memory.
             </returns>
             <example>
             <code>
             // use mpg123 to play music
            		Mix_Music *music=NULL;
            		if(Mix_SetMusicCMD("mpg123 -q")==-1) 
            	{
            		perror("Mix_SetMusicCMD");
            	} 
            	else 
            {
            	// play some mp3 file
            	music=Mix_LoadMUS("music.mp3");
            	if(music) 
            {
            	Mix_PlayMusic(music,1);
            }
            }
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_PlayMusic(System.IntPtr,System.Int32)"/>
             <seealso cref="M:Tao.Sdl.SdlMixer.Mix_VolumeMusic(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetSynchroValue(System.Int32)">
            <summary>
            Synchro value is set by MikMod from modules while playing
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_SetSynchroValue(int value)
            </code>
            </p>
            </remarks>
            <param name="value"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GetSynchroValue"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GetSynchroValue">
            <summary>
            Synchro value is set by MikMod from modules while playing
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_mixer.h
            <code>int Mix_GetSynchroValue(void)
            </code>
            </p>
            </remarks>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetSynchroValue(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GetChunk(System.Int32)">
            <summary>
            Get the sample playing on a channel
            </summary>
            <remarks>
            Get the most recent sample chunk pointer played on channel. 
            This pointer may be currently playing, or just the last used.
            Note: The actual chunk may have been freed, so this pointer 
            may not be valid anymore.
            <p>Binds to C-function in SDL_mixer.h
            <code>Mix_Chunk *Mix_GetChunk(int channel)
            </code>
            </p>
            </remarks>
            <param name="channel">
            Channel to get the current Mix_Chunk playing.
            -1 is not valid, but will not crash the program.
            </param>
            <returns>
            Pointer to the Mix_Chunk. NULL is returned if the channel is not 
            allocated, or if the channel has not played any samples yet.
            </returns>
            <example>
            <code>
            // get the last chunk used by channel 0
            printf("Mix_Chunk* last in use on channel 0 was: %08p\n", Mix_GetChunk(0));
            </code>
            </example>
            <seealso cref="T:Tao.Sdl.SdlMixer.Mix_Chunk"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_Playing(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_CloseAudio">
            <summary>
            Close sound mixer
            </summary>
            <remarks>
            <p>Shutdown and cleanup the mixer API.</p>
            After calling this all audio is stopped, 
            the device is closed, and the SDL_mixer functions 
            should not be used. You may, of course, 
            use Mix_OpenAudio to start 
            the functionality again.
            <p>Note: This function doesn't do anything until you
            have called it the same number of times that you called
             <see cref="M:Tao.Sdl.SdlMixer.Mix_OpenAudio(System.Int32,System.Int16,System.Int32,System.Int32)"/>. You may use 
             <see cref="M:Tao.Sdl.SdlMixer.Mix_QuerySpec(System.Int32@,System.Int16@,System.Int32@)"/> to find out how many
              times Mix_CloseAudio needs to be called before the device is
               actually closed.</p>
               <p>Binds to C-function in SDL_mixer.h
            <code>void Mix_CloseAudio()
            </code>
            </p>
            </remarks>
            <returns></returns>
            <example>
            <code>
            Mix_CloseAudio();
            // you could SDL_Quit(); here...or not.
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_OpenAudio(System.Int32,System.Int16,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_QuerySpec(System.Int32@,System.Int16@,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_SetError(System.String)">
            <summary>
            Set the current error string
            </summary>
            <remarks>
            This is the same as SDL_SetError, which sets the error string
            which may be fetched with Mix_GetError (or SDL_GetError). 
            This functions acts like printf, except that it is limited to
             SDL_ERRBUFIZE(1024) chars in length. It only accepts the 
             following format types: %s, %d, %f, %p. No variations are 
             supported, like %.2f would not work. For any more specifics 
             read the SDL docs.
            <p>Binds to C-function in SDL_mixer.h
            <code>
            void Mix_SetError(const char *fmt, ...)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            int mymixfunc(int i) {
            	Mix_SetError("mymixfunc is not implemented! %d was passed in.",i);
            	return(-1);
            }
            </code></example>
            <param name="message"></param>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GetError"/>
        </member>
        <member name="M:Tao.Sdl.SdlMixer.Mix_GetError">
            <summary>
            Get the current error string
            </summary>
            <remarks>
            This is the same as SDL_GetError, which returns the last error set 
            as a string which you may use to tell the user what happened when 
            an error status has been returned from an SDL_mixer function call.
            <p>Binds to C-function in SDL_mixer.h
            <code>
            char *Mix_GetError() 
            </code>
            </p>
            </remarks>
            <returns>
            a char pointer (string) containing a humam 
            readable version or the reason for the last error that
             occured.
             </returns>
             <example>
             <code>
             printf("Oh My Goodness, an error : %s", Mix_GetError());
             </code>
             </example>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_SetError(System.String)"/>
        </member>
        <member name="P:Tao.Sdl.SdlMixer.MIX_DEFAULT_FORMAT">
            <summary>
            The suggested default is signed 16bit samples in host byte order.
            </summary>
        </member>
        <member name="T:Tao.Sdl.SdlMixer.Mix_Chunk">
            <summary>
            The internal format for an audio chunk
            </summary>
            <remarks>
            The internal format for an audio chunk. 
            This stores the sample data, the length in bytes of that data,
             and the volume to use when mixing the sample. 
             <p>Struct in SDL_mixer.h
             <code>
             typedef struct Mix_Chunk {
            	int allocated;
            	Uint8 *abuf;
            	Uint32 alen;
            	Uint8 volume;     /* Per-sample volume, 0-128 */
            } Mix_Chunk;
             </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_VolumeChunk(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_GetChunk(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_LoadWAV_RW(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_FreeChunk(System.IntPtr)"/>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.Mix_Chunk.allocated">
            <summary>
            a boolean indicating whether to free abuf when the chunk 
            is freed.
            </summary>
            <remarks>0 if the memory was not allocated and thus not 
            owned by this chunk.
            1 if the memory was allocated and is thus owned by this chunk.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.Mix_Chunk.abuf">
            <summary>
            Pointer to the sample data, which is 
            in the output format and sample rate.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.Mix_Chunk.alen">
            <summary>
            Length of abuf in bytes.
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlMixer.Mix_Chunk.volume">
            <summary>
            0 = silent, 128 = max volume. 
            This takes effect when mixing.
            </summary>
        </member>
        <member name="T:Tao.Sdl.SdlMixer.MusicFinishedDelegate">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.SdlMixer.MixFunctionDelegate">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.SdlMixer.ChannelFinishedDelegate">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.SdlMixer.MixEffectFunctionDelegate">
            <summary>
            Special effect callback function pointer
            </summary>
            <remarks>
            This is the prototype for effect processing functions. 
            These functions are used to apply effects processing on 
            a sample chunk. As a channel plays a sample, the registered 
            effect functions are called. Each effect would then read and
             perhaps alter the len bytes of stream. It may also be 
             advantageous to keep the effect state in the udata, with would 
             be setup when registering the effect function on a channel.
            <p>
            <code>
            void (*Mix_EffectFunc_t)(int chan, void *stream, int len, void *udata)
            </code></p>
            </remarks>
            <param name="chan">
            The channel number that this effect is effecting now.
            MIX_CHANNEL_POST is passed in for post processing effects over the 
            final mix.
            </param>
            <param name="stream">
            The buffer containing the current sample to process.
            </param>
            <param name="len">
            The length of stream in bytes.
            </param>
            <param name="udata">
            User data pointer that was passed in to Mix_RegisterEffect 
            when registering this effect processor function.
            </param>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_RegisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate,Tao.Sdl.SdlMixer.MixEffectDoneDelegate,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate)"/>
        </member>
        <member name="T:Tao.Sdl.SdlMixer.MixEffectDoneDelegate">
            <summary>
            Special effect done callback function pointer
            </summary>
            <remarks>
            This is the prototype for effect processing functions. 
            This is called when a channel has finished playing, or 
            halted, or is deallocated. This is also called when a processor
            is unregistered while processing is active. At that time the effects
             processing function may want to reset some internal variables or 
             free some memory. It should free memory at least, because the 
             processor could be freed after this call.
            <p>
            <code>void (*Mix_EffectDone_t)(int chan, void *udata)
            </code></p></remarks>
            <param name="chan">
            The channel number that this effect is effecting now.
            MIX_CHANNEL_POST is passed in for post processing effects over the 
            final mix.
            </param>
            <param name="udata">
            User data pointer that was passed in to Mix_RegisterEffect 
            when registering this effect processor function.
            </param>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_RegisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate,Tao.Sdl.SdlMixer.MixEffectDoneDelegate,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlMixer.Mix_UnregisterEffect(System.Int32,Tao.Sdl.SdlMixer.MixEffectFunctionDelegate)"/>
        </member>
        <member name="T:Tao.Sdl.SdlImage">
             <summary>
             SDL_Image bindings for .NET. 
             <p>A simple library to load images of various formats as SDL surfaces.</p>
             </summary>
             <remarks>
             Images provide the basic visual building blocks for any user 
             interface. Colors and fun shapes are the stuff that we as kids 
             looked at for 
              hours at a time while trying to shoot down big aliens and rescue 
              pixelated princesses. Now it's our turn to make the images that 
              others will remember later in life perhaps. Now how do we get 
              this dang images into our SDL programs, and be flexible in the 
              handling of the images so that we don't even have to worry about 
              what various formats they may be in? This is where SDLimage makes 
              all of our lives easier. This document doesn't help you make 
              artwork, but it will give you the functional knowledge on how to 
              get that art into your game. Now go forth and make your Stick Figure 
              of Justice, someone else might fill in for your lack of artistry, 
              at least you won't have to make much of an effort to include the 
              new and better art into your code. 
              <p>
            	This is a simple library to load images of various formats as 
            	SDL surfaces.</p>
            	<p>This library supports BMP, PNM (PPM/PGM/PBM), XPM, LBM, PCX, 
            	GIF, JPEG, PNG,
            	TGA, and TIFF formats.</p>
            <p>
            	<br>JPEG support requires the JPEG library.</br>
            	<br>PNG support requires the PNG library.
            	and the Zlib library.</br>
            	<br>TIFF support requires the TIFF library.</br>
            	</p>
            	<p>
            	SDL_image supports loading and decoding images from the 
            	following formats:</p>
            	<code>
            	TGA TrueVision Targa (MUST have .tga) 
            	
            	BMP Windows Bitmap(.bmp) 
            	
            	PNM Portable Anymap (.pnm)
            	
            		.pbm = Portable BitMap (mono)
            		.pgm = Portable GreyMap (256 greys)
            		.ppm = Portable PixMap (full color) 
            		
            	XPM X11 Pixmap (.xpm) can be #included directly in code
            		This is NOT the same as XBM(X11 Bitmap) format, which is for monocolor
            		images. 
            		
            	XCF 
            	
            	GIMP native (.xcf) (XCF = eXperimental Computing Facility?)
            	This format is always changing, and since there's no library supplied
            	by the GIMP project to load XCF, the loader may frequently fail to 
            	load much of any image from an XCF file. It's better to load this 
            	in GIMP and convert to a better supported image format. 
            	
            	PCX ZSoft IBM PC Paintbrush (.pcx) 
            	GIF CompuServe Graphics Interchange Format (.gif) 
            	JPG Joint Photographic Experts Group JFIF format (.jpg or .jpeg) 
            	TIF Tagged Image File Format (.tif or .tiff) 
            	LBM Interleaved Bitmap (.lbm or .iff) FORM : ILBM or PBM(packed bitmap)
            	HAM6, HAM8, and 24bit types are not supported. 
            	PNG Portable Network Graphics (.png) 
            	</code>
             </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlImage.SDL_IMAGE_NATIVE_LIBRARY">
            <summary>
                Specifies SdlImage's native library archive.
            </summary>
            <remarks>
                Specifies SDL_image.dll everywhere; will be mapped via .config for mono.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlImage.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/> 
                for Windows and Linux.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.SdlImage.SDL_IMAGE_MAJOR_VERSION">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlImage.SDL_IMAGE_MINOR_VERSION">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.SdlImage.SDL_IMAGE_PATCHLEVEL">
            <summary>
            Patch Version
            </summary>
        </member>
        <member name="M:Tao.Sdl.SdlImage.SDL_IMAGE_VERSION">
            <summary>
            This method can be used to fill a version structure with the compile-time
            version of the SDL_image library.
            </summary>
            <returns>
                This function returns a <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct containing the
                compiled version number
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_image.h:
                <code>#define SDL_IMAGE_VERSION(X)
            {
            (X)-&gt;major = SDL_IMAGE_MAJOR_VERSION;
            (X)-&gt;minor = SDL_IMAGE_MINOR_VERSION;
            (X)-&gt;patch = SDL_IMAGE_PATCHLEVEL;
            }</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_Linked_Version">
            <summary>
                Using this you can compare the runtime version to the 
            version that you compiled with.
            </summary>
            <returns>
                This function gets the version of the dynamically 
            linked SDL_image library in an <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_image.h:
                <code>const SDL_version * IMG_Linked_Version(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)">
            <summary>
            Load an image from an SDL data source.
            The 'type' may be one of: "BMP", "GIF", "PNG", etc.
            If the image format supports a transparent pixel, SDL will set the
            colorkey for the surface.  You can enable RLE acceleration on the
            surface afterwards by calling:
            SDL_SetColorKey(image, SDL_RLEACCEL, image.format.colorkey);
            </summary>
            <param name="freesrc">
            A non-zero value mean is will automatically close/free 
            the src for you. 
            </param>
            <param name="src">
            The image is loaded from this. 
            </param>
            <param name="type">
            A string that indicates which format type to interpret the image 
            as.
            <p>Here is a list of the currently recognized strings 
            (case is not important):</p>
            <br>"TGA"</br>
            <br>"BMP"</br>
            <br>"PNM"</br>
            <br>"XPM"</br>
            <br>"XCF"</br>
            <br>"PCX"</br>
            <br>"GIF"</br>
            <br>"JPG"</br>
            <br>"TIF"</br>
            <br>"LBM"</br>
            <br>"PNG"</br>
            </param>
            <remarks>
            Load src for use as a surface. 
            This can load all supported image formats. 
            This method does not guarantee that the format 
            specified by type is the format of the loaded image, 
            except in the case when TGA format is specified 
            (or any other non-magicable format). 
            Using SDL_RWops is not covered here, 
            but they enable you to load from almost any source. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadTyped_RW(SDL_RWops *src, int freesrc, char *type)
            </code>
            </p>
            </remarks>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors. 
            </returns>
            <example>
            <code>
            // load sample.tga into image
            	SDL_Surface *image;
            	image=IMG_Load_RW(SDL_RWFromFile("sample.tga", "rb"), 1, "TGA");
            	if(!image) 
            {
            	printf("IMG_Load_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_Load(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_Load_RW(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_Load(System.String)">
            <summary>
            Load from a file.
            </summary>
            <remarks>
            Load file for use as an image in a new surface. 
            This actually calls IMG_LoadTyped_RW, with the file extension 
            used as the type string. This can load all supported image files,
            including TGA as long as the filename ends with ".tga". 
            It is best to call this outside of event loops, and rather 
            keep the loaded images around until you are really done with 
            them, as disk speed and image conversion to a surface is not 
            that speedy. Don't forget to SDL_FreeSurface the returned 
            surface pointer when you are through with it. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_Load(const char *file)
            </code>
            </p>
            </remarks>
            <param name="file">
            Image file name to load a surface from. 
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, such as no support 
            built for the image, or a file reading error. 
            </returns>
            <example>
            <code>
            // load sample.png into image
            	SDL_Surface *image;
            	image=IMG_Load("sample.png");
            	if(!image) 
            {
            	printf("IMG_Load: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_Load_RW(System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_Load_RW(System.IntPtr,System.Int32)">
            <summary>
            Load an image of an unspecified format
            </summary>
            <param name="freesrc">
            A non-zero value mean is will automatically close/free 
            the src for you. 
            </param>
            <param name="src">
            The image is loaded from pointer. 
            </param>
            <remarks>
            Load src for use as a surface. 
            This can load all supported image formats, except TGA. 
            Using SDL_RWops is not covered here, 
            but they enable you to load from almost any source. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_Load_RW(SDL_RWops *src, int freesrc)
            </code>
            </p>
            </remarks>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors. 
            </returns>
            <example>
            <code>
            // load sample.png in to image
            	SDL_Surface *image;
            image=IMG_Load_RW(SDL_RWFromFile("sample.png", "rb"), 1);
            	if(!image) 
            {
            	printf("IMG_Load_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_Load(System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isBMP(System.IntPtr)">
            <summary>
            Test for valid, supported BMP file.
            </summary>
            <remarks>
            If the BMP format is supported, 
            then the image data is tested to see if it is readable as a BMP,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isBMP(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a BMP and the BMP format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.bmp to see if it is a BMP
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.bmp", "rb");
            	if(IMG_isBMP(rwop))
            	printf("sample.bmp is a BMP file.\n");
            	else
            	printf("sample.bmp is not a BMP file, or BMP support is not available.\n");
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isPNM(System.IntPtr)">
            <summary>
            Test for valid, supported PNM file.
            </summary>
            <remarks>
            If the PNM format is supported, 
            then the image data is tested to see if it is readable as a PNM,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isPNM(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a PNM and the PNM format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.pnm to see if it is a PNM
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.pnm", "rb");
            	if(IMG_isPNM(rwop))
            	printf("sample.pnm is a PNM file.\n");
            	else
            	printf("sample.pnm is not a PNM file, or PNM support is not available.\n");
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isXPM(System.IntPtr)">
            <summary>
            Test for valid, supported XPM file.
            </summary>
            <remarks>
            If the XPM format is supported, 
            then the image data is tested to see if it is readable as a XPM,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isXPM(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a XPM and the XPM format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.xpm to see if it is a XPM
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.xpm", "rb");
            	if(IMG_isXPM(rwop))
            	printf("sample.xpm is a XPM file.\n");
            	else
            	printf("sample.xpm is not a XPM file, or XPM support is not available.\n");
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isXV(System.IntPtr)">
            <summary>
            Test for valid, supported XV file.
            </summary>
            <remarks>
            If the XV format is supported, 
            then the image data is tested to see if it is readable as a XV,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isXV(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a XV and the XV format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.xv to see if it is a XV
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.xv", "rb");
            	if(IMG_isXV(rwop))
            	printf("sample.xpm is a XV file.\n");
            	else
            	printf("sample.xpm is not a XV file, or XV support is not available.\n");
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isXCF(System.IntPtr)">
            <summary>
            Test for valid, supported XCF file.
            </summary>
            <remarks>
            If the XCF format is supported, 
            then the image data is tested to see if it is readable as a XCF,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isXCF(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a XCF and the XCF format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.xcf to see if it is a XCF
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.xcf", "rb");
            	if(IMG_isXCF(rwop))
            	printf("sample.xcf is a XCF file.\n");
            	else
            	printf("sample.xcf is not a XCF file, or XCF support is not available.\n");
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isPCX(System.IntPtr)">
            <summary>
            Test for valid, supported PCX file.
            </summary>
            <remarks>
            If the PCX format is supported, 
            then the image data is tested to see if it is readable as a PCX,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isPCX(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a PCX and the PCX format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.pcx to see if it is a PCX
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.pcx", "rb");
            	if(IMG_isPCX(rwop))
            	printf("sample.pcx is a PCX file.\n");
            	else
            	printf("sample.pcx is not a PCX file, or PCX support is not available.\n");
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isGIF(System.IntPtr)">
            <summary>
            Test for valid, supported GIF file.
            </summary>
            <remarks>
            If the GIF format is supported, 
            then the image data is tested to see if it is readable as a GIF,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isGIF(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a GIF and the GIF format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.gif to see if it is a GIF
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.gif", "rb");
            	if(IMG_isGIF(rwop))
            	printf("sample.gif is a GIF file.\n");
            	else
            	printf("sample.gif is not a GIF file, or GIF support is not available.\n");
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isJPG(System.IntPtr)">
            <summary>
            Test for valid, supported JPG file.
            </summary>
            <remarks>
            If the JPG format is supported, 
            then the image data is tested to see if it is readable as a JPG,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isJPG(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a JPG and the JPG format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.jpg to see if it is a JPG
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.jpg", "rb");
            	if(IMG_isJPG(rwop))
            	printf("sample.jpg is a JPG file.\n");
            	else
            	printf("sample.jpg is not a JPG file, or JPG support is not available.\n");
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isTIF(System.IntPtr)">
            <summary>
            Test for valid, supported TIF file.
            </summary>
            <remarks>
            If the TIF format is supported, 
            then the image data is tested to see if it is readable as a TIF,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isTIF(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a TIF and the TIF format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.tif to see if it is a TIF
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.tif", "rb");
            	if(IMG_isTIF(rwop))
            	printf("sample.tif is a TIF file.\n");
            	else
            	printf("sample.tif is not a TIF file, or TIF support is not available.\n");
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isPNG(System.IntPtr)">
            <summary>
            Test for valid, supported PNG file.
            </summary>
            <remarks>
            If the PNG format is supported, 
            then the image data is tested to see if it is readable as a PNG,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isPNG(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a PNG and the PNG format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.png to see if it is a PNG
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.png", "rb");
            	if(IMG_isPNG(rwop))
            	printf("sample.png is a PNG file.\n");
            	else
            	printf("sample.png is not a PNG file, or PNG support is not available.\n");
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_isLBM(System.IntPtr)">
            <summary>
            Test for valid, supported LBM file.
            </summary>
            <remarks>
            If the LBM format is supported, 
            then the image data is tested to see if it is readable as a LBM,
             otherwise it returns false (Zero). 
             <p>Binds to C-function in SDL_image.h
            <code>
            int IMG_isLBM(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <param name="src"></param>
            <returns>
            1 if the image is a LBM and the LBM format support is
             compiled into SDL_image. 0 is returned otherwise. 
            </returns>
            <example>
            <code>
            // Test sample.lbm to see if it is a LBM
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.lbm", "rb");
            	if(IMG_isLBM(rwop))
            	printf("sample.lbm is a LBM file.\n");
            	else
            	printf("sample.lbm is not a LBM file, or LBM support is not available.\n");
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadBMP_RW(System.IntPtr)">
            <summary>
            Load a .BMP image.
            </summary>
            <param name="src">
            The BMP image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if BMP is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a BMP image for use as a surface, 
            if BMP support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadBMP_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.bmp into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.bmp", "rb");
            	image=IMG_LoadBMP_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadBMP_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isBMP(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadPNM_RW(System.IntPtr)">
            <summary>
            Load a .PNM image.
            </summary>
            <param name="src">
            The PNM image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if PNM is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a PNM image for use as a surface, 
            if PNM support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadPNM_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.pnm into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.pnm", "rb");
            	image=IMG_LoadPNM_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadPNM_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isPNM(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadXPM_RW(System.IntPtr)">
            <summary>
            Load a .XPM image.
            </summary>
            <param name="src">
            The XPM image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if XPM is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a XPM image for use as a surface, 
            if XPM support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadXPM_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.xpm into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.xpm", "rb");
            	image=IMG_LoadXPM_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadXPM_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isXPM(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_ReadXPMFromArray(System.String[])"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadXCF_RW(System.IntPtr)">
            <summary>
            Load a .XCF image.
            </summary>
            <param name="src">
            The XCF image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if XCF is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a XCF image for use as a surface, 
            if XCF support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadXCF_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.xcf into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.xcf", "rb");
            	image=IMG_LoadXCF_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadXCF_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isXCF(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadXV_RW(System.IntPtr)">
            <summary>
            Load a .XV image.
            </summary>
            <param name="src">
            The XV image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if XV is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a XV image for use as a surface, 
            if XV support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadXV_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.xv into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.xv", "rb");
            	image=IMG_LoadXV_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadXV_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isXV(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadPCX_RW(System.IntPtr)">
            <summary>
            Load a .PCX image.
            </summary>
            <param name="src">
            The PCX image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if PCX is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a PCX image for use as a surface, 
            if PCX support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadPCX_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.pcx into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.pcx", "rb");
            	image=IMG_LoadPCX_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadPCX_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isPCX(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadGIF_RW(System.IntPtr)">
            <summary>
            Load a .GIF image.
            </summary>
            <param name="src">
            The GIF image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if GIF is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a GIF image for use as a surface, 
            if GIF support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadGIF_RW(SDL_RWops *src)
            </code></p>
            </remarks>
            <example>
            <code>
            // load sample.gif into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.gif", "rb");
            	image=IMG_LoadGIF_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadGIF_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isGIF(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadJPG_RW(System.IntPtr)">
            <summary>
            Load a .JPG image.
            </summary>
            <param name="src">
            The JPG image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if JPG is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a JPG image for use as a surface, 
            if JPG support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadJPG_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.jpg into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.jpg", "rb");
            	image=IMG_LoadJPG_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadJPG_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isJPG(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadTIF_RW(System.IntPtr)">
            <summary>
            Load a .TIF image.
            </summary>
            <param name="src">
            The TIF image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if TIF is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a TIF image for use as a surface, 
            if TIF support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadTIF_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.tif into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.tif", "rb");
            	image=IMG_LoadTIF_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadTIF_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isTIF(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadPNG_RW(System.IntPtr)">
            <summary>
            Load a .PNG image.
            </summary>
            <param name="src">
            The PNG image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if PNG is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a PNG image for use as a surface, 
            if PNG support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadPNG_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.png into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.png", "rb");
            	image=IMG_LoadPNG_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadPNG_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isPNG(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadTGA_RW(System.IntPtr)">
            <summary>
            Load a .TGA image.
            </summary>
            <param name="src">
            The BMP image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if BMP is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a TGA image for use as a surface, 
            if TGA support is compiled into the SDL_image library. 
            If you try to load a non TGA image, 
            you might succeed even when it's not TGA image formatted data, 
            this is because the TGA has no magic, 
            which is a way of identifying a filetype from a 
            signature in it's contents. So be careful with this. 
            <p>Binds to C-function in SDL_image.h
            <code>SDL_Surface *IMG_LoadTGA_RW(SDL_RWops *src)
            </code></p>
            </remarks>
            <example>
            <code>
            // load sample.tga into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.tga", "rb");
            	image=IMG_LoadTGA_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadTGA_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_LoadLBM_RW(System.IntPtr)">
            <summary>
            Load a .LBM image.
            </summary>
            <param name="src">
            The LBM image is loaded from this
            </param>
            <returns>
            a pointer to the image as a new SDL_Surface. 
            NULL is returned on errors, like if LBM is not supported, 
            or a read error. 
            </returns>
            <remarks>
            Load src as a LBM image for use as a surface, 
            if LBM support is compiled into the SDL_image library. 
            <p>Binds to C-function in SDL_image.h
            <code>
            SDL_Surface *IMG_LoadLBM_RW(SDL_RWops *src)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            // load sample.lbm into image
            	SDL_Surface *image;
            	SDL_RWops *rwop;
            	rwop=SDL_RWFromFile("sample.lbm", "rb");
            	image=IMG_LoadLBM_RW(rwop);
            	if(!image) 
            {
            	printf("IMG_LoadLBM_RW: %s\n", IMG_GetError());
            	// handle error
            }
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadTyped_RW(System.IntPtr,System.Int32,System.String)"/>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_isLBM(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_ReadXPMFromArray(System.String[])">
             <summary>
             Load a .XPM image from an array.
             </summary>
             <param name="src">
             The source xpm data. The XPM image is loaded from this.
             </param>
             <returns>
             a pointer to the image as a new SDL_Surface. 
             NULL is returned on errors, like if XPM is not supported, 
             or a read error. 
             </returns>
             <remarks>
             Load src as a XPM image for use as a surface, 
             if XPM support is compiled into the SDL_image library. 
             <p>Binds to C-function in SDL_image.h
             <code>
             SDL_Surface *IMG_ReadXPMFromArray(char **xpm)
             </code>
             </p>
             </remarks>
             <example>
             <code>
             // load sample.xpm into image
            #include "sample.xpm"
            		SDL_Surface *image;
            		image=IMG_ReadXPMFromArray(sample_xpm);
            		if(!image) 
            	{
            		printf("IMG_ReadXPMFromArray: %s\n", IMG_GetError());
            		// handle error
            	}
             </code></example>
             <seealso cref="M:Tao.Sdl.SdlImage.IMG_LoadXPM_RW(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_SetError(System.String)">
            <summary>
            Set the current error string
            </summary>
            <remarks>
            This is the same as SDL_SetError, which sets the error string
             which may be fetched with IMG_GetError (or SDL_GetError). 
             This functions acts like printf, except that it is limited 
             to SDL_ERRBUFIZE(1024) chars in length. It only accepts the
              following format types: %s, %d, %f, %p. No variations are 
              supported, like %.2f would not work. For any more specifics
               read the SDL docs.
            <p>Binds to C-function in SDL_image.h
            <code>
            void IMG_SetError(const char *fmt, ...)
            </code>
            </p>
            </remarks>
            <example>
            <code>
            int myimagefunc(int i) {
            	IMG_SetError("myimagefunc is not implemented! %d was passed in.",i);
            	return(-1);
            }
            </code></example>
            <param name="message"></param>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_GetError"/>
        </member>
        <member name="M:Tao.Sdl.SdlImage.IMG_GetError">
            <summary>
            Get the current error string
            </summary>
            <remarks>
            This is the same as SDL_GetError, which returns the last 
            error set as a string which you may use to tell the user 
            what happened when an error status has been returned from
             an SDL_image function call.
            <p>Binds to C-function in SDL_image.h
            <code>
            char *IMG_GetError() 
            </code>
            </p>
            </remarks>
            <returns>
            a char pointer (string) containing a humam 
            readable version or the reason for the last error that
             occured.
             </returns>
            <seealso cref="M:Tao.Sdl.SdlImage.IMG_SetError(System.String)"/>
        </member>
        <member name="T:Tao.Sdl.Sdl">
            <summary>
                Simple DirectMedia Layer binding for .NET, implementing SDL 1.2.13.
            </summary>
            <remarks>
            This library is designed to make it easy to write games that run 
            the .NET runtime using the various native high-performance media 
            interfaces, (for video, audio, etc) and presenting a single
             source-code level API to your application. This is a fairly 
             low level API, but using this, completely portable applications 
             can be written with a great deal of flexibility.
            <p>An introduction to SDL can be found online at: http://www.libsdl.org/intro/ </p>
            <p>Binds to functions and definitions in SDL.dll or libSDL.so.</p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_NATIVE_LIBRARY">
            <summary>
                Specifies SDL's native library archive.
            </summary>
            <remarks>
                Specifies SDL.dll everywhere; will be mapped via .config for mono.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Cdecl"/> 
                for Windows and Linux.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_TIMER">
            <summary>
                The timer subsystem.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO">
            <summary>
                The audio subsystem.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO">
            <summary>
                The video subsystem.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_CDROM">
            <summary>
                The CD-ROM subsystem.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK">
            <summary>
                The joystick subsystem.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE">
            <summary>
                Prevents SDL from catching fatal signals.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD">
            <summary>
                Not supported on all OS's.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING">
            <summary>
                All subsystems. 
                These are the flags which may be passed to SDL_Init()
                -- you should specify the subsystems which you will be
                using in your application..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_APPMOUSEFOCUS">
            <summary>
            The app has mouse coverage
            </summary>
            <remarks>
            The available application states
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_APPINPUTFOCUS">
            <summary>
            The app has input focus
            </summary>
            <remarks>
            The available application states
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_APPACTIVE">
            <summary>
            The application is active
            </summary>
            <remarks>
            The available application states
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_U8">
            <summary>
            Unsigned 8-bit samples.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_S8">
            <summary>
            Signed 8-bit samples.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_U16LSB">
            <summary>
            Unsigned 16-bit little-endian samples.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_S16LSB">
            <summary>
            Signed 16-bit little-endian samples
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_U16MSB">
            <summary>
            Unsigned 16-bit big-endian samples
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_S16MSB">
            <summary>
            Signed 16-bit big-endian samples
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MIX_MAXVOLUME">
            <summary>
            Full audio volume
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MAX_TRACKS">
            <summary>
            The maximum number of CD-ROM tracks on a disk
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AUDIO_TRACK">
            <summary>
            The types of CD-ROM track possible
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_DATA_TRACK">
            <summary>
            The types of CD-ROM track possible
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.CD_FPS">
            <summary>
            Frames per second.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_LIL_ENDIAN">
            <summary>
            Little Endian
            </summary>
            <remarks>
            e.g. i386 machines</remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BIG_ENDIAN">
            <summary>
            Big Endian
            </summary>
            <remarks>
            e.g. Macs
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PRESSED">
            <summary>
            Button in pressed state.
            </summary>
            <remarks>
            SDL_events.h defines SDL_PRESSED and <see cref="F:Tao.Sdl.Sdl.SDL_RELEASED"/>
             in a nameless enum. Defining SDL_PRESSED as a const works 
             better for Tao.SDL purposes</remarks>
             <seealso cref="F:Tao.Sdl.Sdl.SDL_RELEASED"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_RELEASED">
            <summary>
            Button in released state.
            </summary>
            <remarks>
            SDL_events.h defines <see cref="F:Tao.Sdl.Sdl.SDL_PRESSED"/> and SDL_RELEASED
             in a nameless enum. Defining SDL_RELEASED as a const works 
             better for Tao.SDL purposes</remarks>
             <seealso cref="F:Tao.Sdl.Sdl.SDL_PRESSED"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ALLEVENTS">
            <summary>
            This is the mask which refers to all hotkey bindings.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_QUERY">
            <summary>
            If 'state' is set to SDL_QUERY, SDL_EventState() 
            will return the 
            current processing state of the specified event.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_IGNORE">
            <summary>
            If 'state' is set to SDL_IGNORE, that event will be 
            automatically dropped
            from the event queue and will not event be filtered.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_DISABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ENABLE">
            <summary>
            If 'state' is set to SDL_ENABLE, that event will 
            be processed normally.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_CENTERED">
            <summary>
            Indicates which position a joystick hat is pressed in
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_UP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_RIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_DOWN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_LEFT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_RIGHTUP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_RIGHTDOWN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_LEFTUP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HAT_LEFTDOWN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ALL_HOTKEYS">
            <summary>
            This is the mask which refers to all hotkey bindings.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_DEFAULT_REPEAT_DELAY">
            <summary>
            Enable/Disable keyboard repeat.  Keyboard repeat defaults to off. 
            'delay' is the initial delay in ms between the time 
            when a key is pressed,
            and keyboard repeat begins.
            </summary>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_EnableKeyRepeat(System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_DEFAULT_REPEAT_INTERVAL">
            <summary>
            Enable/Disable keyboard repeat.  Keyboard repeat defaults to off. 
            'interval' is the time in ms between keyboard repeat events.
            </summary>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_EnableKeyRepeat(System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_CTRL">
            <summary>
            Both CTRL keys.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_SHIFT">
            <summary>
            Both SHIFT keys.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_ALT">
            <summary>
            Both ALT keys.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_META">
            <summary>
            Both META keys.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_LEFT">
            <summary>
            Used as a mask when testing buttons in buttonstate
            Button 1:	Left mouse button
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_MIDDLE">
            <summary>
            Button 2:	Middle mouse button
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_RIGHT">
            <summary>
            Button 3:	Right mouse button
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_WHEELUP">
            <summary>
            Button 4:	Mouse wheel up	 (may also be a real button)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_WHEELDOWN">
            <summary>
            Button 5:	Mouse wheel down (may also be a real button)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_X1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_X2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_LMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_MMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_RMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_X1MASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_BUTTON_X2MASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MUTEX_TIMEDOUT">
            <summary>
            Synchronization functions which can time out return this value
            if they time out.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MUTEX_MAXWAIT">
            <summary>
            This is the timeout value which corresponds to never time out
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.RW_SEEK_SET">
            <summary>
            Seek from the beginning of data
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.RW_SEEK_CUR">
            <summary>
            Seek relative to current read point
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.RW_SEEK_END">
            <summary>
            Seek relative to the end of data
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_TIMESLICE">
            <summary>
                The OS scheduler timeslice, in milliseconds.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.TIMER_RESOLUTION">
            <summary>
                The maximum resolution of the SDL timer on all platforms.
            </summary>
            <remarks>
                Experimentally determined.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MAJOR_VERSION">
            <summary>
            Major Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MINOR_VERSION">
            <summary>
            Minor Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PATCHLEVEL">
            <summary>
            Patch Version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ALPHA_OPAQUE">
            <summary>
            Transparency definition of Opaque
            </summary>
            <remarks>
            Define alpha as the opacity of a surface
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ALPHA_TRANSPARENT">
            <summary>
            Transparency definition of Transparent
            </summary>
            <remarks>
            Define alpha as the opacity of a surface
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SWSURFACE">
            <summary>
            Surface is in system memory
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HWSURFACE">
            <summary>
            Surface is in video memory
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ASYNCBLIT">
            <summary>
            Use asynchronous blits if possible
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ANYFORMAT">
            <summary>
            Allow any video depth/pixel-format
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HWPALETTE">
            <summary>
            Surface has exclusive palette
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_DOUBLEBUF">
            <summary>
            Set up double-buffered video mode
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_FULLSCREEN">
            <summary>
            Full screen display surface.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_OPENGL">
            <summary>
            Create an OpenGL rendering context
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_OPENGLBLIT">
            <summary>
            Create an OpenGL rendering context and use it for blitting
            </summary>	
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_RESIZABLE">
            <summary>
            This video mode may be resized
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_NOFRAME">
            <summary>
            No window caption or edge frame
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_HWACCEL">
            <summary>
            Blit uses hardware acceleration
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SRCCOLORKEY">
            <summary>
            Blit uses a source color key
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_RLEACCELOK">
            <summary>
            Private flag
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_RLEACCEL">
            <summary>
            Surface is RLE encoded
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SRCALPHA">
            <summary>
            Blit uses source alpha blending
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PREALLOC">
            <summary>
            Surface uses preallocated memory
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_YV12_OVERLAY">
             <summary>
            One of the most common video overlay formats.
            For an explanation of these pixel formats, see:
            http://www.webartz.com/fourcc/indexyuv.htm
            
            For information on the relationship between color spaces, see:
            http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html
            
             Planar mode: Y + V + U  (3 planes)
             </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_IYUV_OVERLAY">
             <summary>
            One of the most common video overlay formats.
            For an explanation of these pixel formats, see:
            http://www.webartz.com/fourcc/indexyuv.htm
            
            For information on the relationship between color spaces, see:
            http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html
            
             Planar mode: Y + U + V  (3 planes)
             </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_YUY2_OVERLAY">
             <summary>
            One of the most common video overlay formats.
            For an explanation of these pixel formats, see:
            http://www.webartz.com/fourcc/indexyuv.htm
            
            For information on the relationship between color spaces, see:
            http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html
            
             Packed mode: Y0+U0+Y1+V0 (1 plane)
             </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_UYVY_OVERLAY">
             <summary>
            One of the most common video overlay formats.
            For an explanation of these pixel formats, see:
            http://www.webartz.com/fourcc/indexyuv.htm
            
            For information on the relationship between color spaces, see:
            http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html
            
             Packed mode: U0+Y0+V0+Y1 (1 plane)
             </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_YVYU_OVERLAY">
             <summary>
            One of the most common video overlay formats.
            For an explanation of these pixel formats, see:
            http://www.webartz.com/fourcc/indexyuv.htm
            
            For information on the relationship between color spaces, see:
            http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html
            
             Packed mode: Y0+V0+Y1+U0 (1 plane)
             </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_LOGPAL">
            <summary>
            Flag for SDL_SetPalette() which represents a logical palette, which controls how blits 
            are mapped to/from the surface.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PHYSPAL">
            <summary>
            Flag for SDL_SetPalette() which represents a physical palette, which controls how pixels 
            look on the screen.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AUDIO_STOPPED">
            <summary>
            SDL_audiostatus. Get the current audio state
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AUDIO_PLAYING">
            <summary>
            SDL_audiostatus. Get the current audio state
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AUDIO_PAUSED">
            <summary>
            SDL_audiostatus. Get the current audio state
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.CD_TRAYEMPTY">
            <summary>
            The CD tray is empty.
            </summary>
            <remarks>
            CDstatus enum.
            The possible states which a CD-ROM drive can be in.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.CD_STOPPED">
            <summary>
            The CD has stopped playing.
            </summary>
            <remarks>
            CDstatus enum.
            The possible states which a CD-ROM drive can be in.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.CD_PLAYING">
            <summary>
            The CD is playing.
            </summary>
            <remarks>
            CDstatus enum.
            The possible states which a CD-ROM drive can be in.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.CD_PAUSED">
            <summary>
            The CD has been paused.
            </summary>
            <remarks>
            CDstatus enum.
            The possible states which a CD-ROM drive can be in.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.CD_ERROR">
            <summary>
            An error occured while getting the status.
            </summary>
            <remarks>
            CDstatus enum.
            The possible states which a CD-ROM drive can be in.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_NOEVENT">
            <summary>
            Unused (do not remove)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ACTIVEEVENT">
            <summary>
            Application loses/gains visibility
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KEYDOWN">
            <summary>
            Keys pressed
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KEYUP">
            <summary>
            Keys released
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MOUSEMOTION">
            <summary>
            Mouse moved
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MOUSEBUTTONDOWN">
            <summary>
            Mouse button pressed
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MOUSEBUTTONUP">
            <summary>
            Mouse button released
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYAXISMOTION">
            <summary>
            Joystick axis motion
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYBALLMOTION">
            <summary>
            Joystick trackball motion
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYHATMOTION">
            <summary>
            Joystick hat position change
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYBUTTONDOWN">
            <summary>
            Joystick button pressed
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYBUTTONUP">
            <summary>
            Joystick button released
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_QUIT">
            <summary>
            User-requested quit
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SYSWMEVENT">
            <summary>
            System specific event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVEDA">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVEDB">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VIDEORESIZE">
            <summary>
            User resized video mode
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VIDEOEXPOSE">
            <summary>
            Screen needs to be redrawn
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVED2">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVED3">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVED4">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVED5">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVED6">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_EVENT_RESERVED7">
            <summary>
            Reserved for future use..
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_USEREVENT">
            <summary>
            Events SDL_USEREVENT through SDL_MAXEVENTS-1 are 
            for your use.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_NUMEVENTS">
            <summary>
            This last event is only for bounding internal arrays
            It is the number of bits in the event mask datatype -- Uint32
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ACTIVEEVENTMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KEYDOWNMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KEYUPMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KEYEVENTMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MOUSEMOTIONMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MOUSEBUTTONDOWNMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MOUSEBUTTONUPMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MOUSEEVENTMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYAXISMOTIONMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYBALLMOTIONMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYHATMOTIONMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYBUTTONDOWNMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYBUTTONUPMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JOYEVENTMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VIDEORESIZEMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VIDEOEXPOSEMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_QUITMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SYSWMEVENTMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ADDEVENT">
            <summary>
            If 'action' is SDL_ADDEVENT, up to 'numevents' events will 
            be added to the back of the event queue.
            </summary>
            <remarks>
            enum SDL_eventaction. 
            Various event types.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PEEKEVENT">
            <summary>
            If 'action' is SDL_PEEKEVENT, up to 'numevents' events at 
            the front of the event queue, matching 'mask', will be 
            returned and will not be removed from the queue.
            </summary>
            <remarks>
            enum SDL_eventaction. 
            Various event types.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GETEVENT">
            <summary>
            If 'action' is SDL_GETEVENT, up to 'numevents' events at 
            the front of the event queue, matching 'mask', will be 
            returned and will be removed from the queue.
            </summary>
            <remarks>
            enum SDL_eventaction. 
            Various event types.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_UNKNOWN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_FIRST">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_BACKSPACE">
            <summary>
            backspace. '\b'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_TAB">
            <summary>
            tab. '\t'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_CLEAR">
            <summary>
            clear
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RETURN">
            <summary>
            return. '\r' 
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_PAUSE">
            <summary>
            pause
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_ESCAPE">
            <summary>
            escape. '^['
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_SPACE">
            <summary>
            space. ' '
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_EXCLAIM">
            <summary>
            exclaim. '!'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_QUOTEDBL">
            <summary>
            quotedbl. '"'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_HASH">
            <summary>
            hash. '#'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_DOLLAR">
            <summary>
            dollar. '$'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_AMPERSAND">
            <summary>
            ampersand. '&amp;'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_QUOTE">
            <summary>
            quote. '''
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LEFTPAREN">
            <summary>
            left parenthesis. '('
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RIGHTPAREN">
            <summary>
            right parenthesis. ')'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_ASTERISK">
            <summary>
            asterisk. '*'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_PLUS">
            <summary>
            plus sign. '+'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_COMMA">
            <summary>
            comma. ';'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_MINUS">
            <summary>
            minus sign. '-'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_PERIOD">
            <summary>
            period. '.'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_SLASH">
            <summary>
            forward slash. '/'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_0">
            <summary>
            0
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_1">
            <summary>
            1
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_2">
            <summary>
            2
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_3">
            <summary>
            3
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_4">
            <summary>
            4
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_5">
            <summary>
            5
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_6">
            <summary>
            6
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_7">
            <summary>
            7
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_8">
            <summary>
            8
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_9">
            <summary>
            9
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_COLON">
            <summary>
            colon. ':'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_SEMICOLON">
            <summary>
            semicolon. ';'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LESS">
            <summary>
            less-than sign. '&lt;'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_EQUALS">
            <summary>
            equals sign. '='
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_GREATER">
            <summary>
            greater-than sign. '&gt;'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_QUESTION">
            <summary>
            question mark. '?'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_AT">
            <summary>
            at. '@'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LEFTBRACKET">
            <summary>
            left bracket. '['
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_BACKSLASH">
            <summary>
            backslash. '\'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RIGHTBRACKET">
            <summary>
            right bracket. ']'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_CARET">
            <summary>
            caret. '^'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_UNDERSCORE">
            <summary>
            underscore.'_'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_BACKQUOTE">
            <summary>
            grave. '`'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_a">
            <summary>
            a
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_b">
            <summary>
            b
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_c">
            <summary>
            c
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_d">
            <summary>
            d
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_e">
            <summary>
            e
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_f">
            <summary>
            f
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_g">
            <summary>
            g
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_h">
            <summary>
            h
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_i">
            <summary>
            i
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_j">
            <summary>
            j
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_k">
            <summary>
            k
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_l">
            <summary>
            l
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_m">
            <summary>
            m
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_n">
            <summary>
            n
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_o">
            <summary>
            o
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_p">
            <summary>
            p
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_q">
            <summary>
            q
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_r">
            <summary>
            r
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_s">
            <summary>
            s
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_t">
            <summary>
            t
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_u">
            <summary>
            u
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_v">
            <summary>
            v
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_w">
            <summary>
            w
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_x">
            <summary>
            x
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_y">
            <summary>
            y
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_z">
            <summary>
            z
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_DELETE">
            <summary>
            delete. '^?'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_0">
            <summary>
            0xA0
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_3">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_4">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_5">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_6">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_7">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_8">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_9">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_10">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_11">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_12">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_13">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_14">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_15">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_16">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_17">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_18">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_19">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_20">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_21">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_22">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_23">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_24">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_25">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_26">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_27">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_28">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_29">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_30">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_31">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_32">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_33">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_34">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_35">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_36">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_37">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_38">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_39">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_40">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_41">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_42">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_43">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_44">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_45">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_46">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_47">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_48">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_49">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_50">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_51">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_52">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_53">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_54">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_55">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_56">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_57">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_58">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_59">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_60">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_61">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_62">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_63">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_64">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_65">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_66">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_67">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_68">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_69">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_70">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_71">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_72">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_73">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_74">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_75">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_76">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_77">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_78">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_79">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_80">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_81">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_82">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_83">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_84">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_85">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_86">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_87">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_88">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_89">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_90">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_91">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_92">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_93">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_94">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_WORLD_95">
            <summary>
            0xFF
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP0">
            <summary>
            keypad 0
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP1">
            <summary>
            keypad 1
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP2">
            <summary>
            keypad 2
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP3">
            <summary>
            keypad 3
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP4">
            <summary>
            keypad 4
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP5">
            <summary>
            keypad 5
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP6">
            <summary>
            keypad 6
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP7">
            <summary>
            keypad 7
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP8">
            <summary>
            keypad 8
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP9">
            <summary>
            keypad 9
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP_PERIOD">
            <summary>
            keypad period. '.'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP_DIVIDE">
            <summary>
            keypad divide. '/'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP_MULTIPLY">
            <summary>
            keypad multiply. '*'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP_MINUS">
            <summary>
            keypad minus. '-'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP_PLUS">
            <summary>
            keypad plus. '+'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP_ENTER">
            <summary>
            keypad enter. '\r'
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_KP_EQUALS">
            <summary>
            keypad equals. '='
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_UP">
            <summary>
            up arrow
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_DOWN">
            <summary>
            down arrow
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RIGHT">
            <summary>
            right arrow
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LEFT">
            <summary>
            left arrow
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_INSERT">
            <summary>
            insert
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_HOME">
            <summary>
            home
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_END">
            <summary>
            end
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_PAGEUP">
            <summary>
            page up
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_PAGEDOWN">
            <summary>
            page down
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F1">
            <summary>
            F1
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F2">
            <summary>
            F2
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F3">
            <summary>
            F3
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F4">
            <summary>
            F4
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F5">
            <summary>
            F5
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F6">
            <summary>
            F6
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F7">
            <summary>
            F7
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F8">
            <summary>
            F8
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F9">
            <summary>
            F9
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F10">
            <summary>
            F10
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F11">
            <summary>
            F11
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F12">
            <summary>
            F12
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F13">
            <summary>
            F13
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F14">
            <summary>
            F14
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_F15">
            <summary>
            F15
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_NUMLOCK">
            <summary>
            numlock
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_CAPSLOCK">
            <summary>
            capslock
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_SCROLLOCK">
            <summary>
            scrollock
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RSHIFT">
            <summary>
            right shift
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LSHIFT">
            <summary>
            left shift
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RCTRL">
            <summary>
            right ctrl
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LCTRL">
            <summary>
            left ctrl
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RALT">
            <summary>
            right alt
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LALT">
            <summary>
            left alt
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RMETA">
            <summary>
            right meta
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LMETA">
            <summary>
            left meta
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LSUPER">
            <summary>
            Left "Windows" key
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_RSUPER">
            <summary>
            Right "Windows" key
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_MODE">
            <summary>
            "Alt Gr" key. Mode key
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_COMPOSE">
            <summary>
            Multi-key compose key
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_HELP">
            <summary>
            help
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_PRINT">
            <summary>
            print-screen
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_SYSREQ">
            <summary>
            SysRq
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_BREAK">
            <summary>
            break
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_MENU">
            <summary>
            menu
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_POWER">
            <summary>
            Power Macintosh power key
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_EURO">
            <summary>
            Some european keyboards
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_UNDO">
            <summary>
            Atari keyboard has Undo
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDLK_LAST">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_NONE">
            <summary>
            No modifiers applicable
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_LSHIFT">
            <summary>
            Left Shift is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_RSHIFT">
            <summary>
            Right Shift is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_LCTRL">
            <summary>
            Left Control is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_RCTRL">
            <summary>
            Right Control is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_LALT">
            <summary>
            Left Alt is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_RALT">
            <summary>
            Right Alt is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_LMETA">
            <summary>
            Left Meta is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_RMETA">
            <summary>
            Right Meta is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_NUM">
            <summary>
            Numlock is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_CAPS">
            <summary>
            Capslock is down
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_MODE">
            <summary>
            
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.KMOD_RESERVED">
            <summary>
            
            </summary>
            <remarks>
            Enumeration of valid key mods (possibly OR'd together) 
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_FALSE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_TRUE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SYSWM_X11">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_RED_SIZE">
            <summary>
            Size of the framebuffer red component, in bits
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_GREEN_SIZE">
            <summary>
            Size of the framebuffer green component, in bits
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_BLUE_SIZE">
            <summary>
            Size of the framebuffer blue component, in bits
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_ALPHA_SIZE">
            <summary>
            Size of the framebuffer alpha component, in bits
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            Public enumeration for setting the OpenGL window Attributes
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_BUFFER_SIZE">
            <summary>
            Size of the framebuffer, in bits
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_DOUBLEBUFFER">
            <summary>
            0 or 1, enable or disable double buffering
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_DEPTH_SIZE">
            <summary>
            Size of the depth buffer, in bits
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_STENCIL_SIZE">
            <summary>
            Size of the stencil buffer, in bits.
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_ACCUM_RED_SIZE">
            <summary>
            Size of the accumulation buffer red component, in bits.
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_ACCUM_GREEN_SIZE">
            <summary>
            Size of the accumulation buffer green component, in bits.
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_ACCUM_BLUE_SIZE">
            <summary>
            Size of the accumulation buffer blue component, in bits.
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_ACCUM_ALPHA_SIZE">
            <summary>
            Size of the accumulation buffer alpha component, in bits.
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_STEREO">
            <summary>
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_MULTISAMPLEBUFFERS">
            <summary>
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_MULTISAMPLESAMPLES">
            <summary>
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_ACCELERATED_VISUAL">
            <summary>
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GL_SWAP_CONTROL">
            <summary>
            Public enumeration for setting the OpenGL window Attributes
            </summary>
            <remarks>
            While you can set most OpenGL attributes normally, 
            the attributes list above must be known before SDL 
            sets the video mode. These attributes a set and read 
            with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/> and 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>.
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GRAB_QUERY">
            <summary>
            Input grab state.
            </summary>
            <remarks>
            enum SDL_GrabMode. 
            </remarks>
            <see cref="M:Tao.Sdl.Sdl.SDL_WM_GrabInput(System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GRAB_OFF">
            <summary>
            Input grab state.
            </summary>
            <remarks>
            enum SDL_GrabMode. 
            </remarks>
            <see cref="M:Tao.Sdl.Sdl.SDL_WM_GrabInput(System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GRAB_ON">
            <summary>
            Input grab state.
            </summary>
            <remarks>
            enum SDL_GrabMode. 
            </remarks>
            <see cref="M:Tao.Sdl.Sdl.SDL_WM_GrabInput(System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_GRAB_FULLSCREEN">
            <summary>
            Input grab state.
            </summary>
            <remarks>
            enum SDL_GrabMode. 
            </remarks>
            <see cref="M:Tao.Sdl.Sdl.SDL_WM_GrabInput(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.objc_getClass(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.sel_registerName(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.objc_msgSend(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="self"></param>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_U16">
            <summary>
            Unsigned 16-bit little-endian samples
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.AUDIO_S16">
            <summary>
            Signed 16-bit little-endian samples
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.keyboardState">
            <summary>
            	Private byte array holding the internal keyboard state.
            </summary>
            <remarks>
            	Used for <see cref="M:Tao.Sdl.Sdl.SDL_GetKeyState(System.Int32@)"/>.
            	Array is sized to fit all the known Key enums.
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)">
            <summary>
                Initializes SDL and the specified subsystems.
            </summary>
            <param name="flags">
                <para>
                    Specifies what part(s) of SDL to initialize:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>Initializes the timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>Initializes the audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>Initializes the video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>Initializes the CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>Initializes the joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>Initializes all subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                Returns -1 on an error or 0 on success.
            </returns>
            <remarks>
                <para>
                    Unless the <see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/> flag is set, it will install
                    cleanup signal handlers for some commonly ignored fatal signals (like
                    SIGSEGV).
                </para>
                <p>
            		Binds to C-function call in SDL.h:
                <code>extern DECLSPEC int SDLCALL SDL_Init(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Quit"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Init(System.UInt32)">
            <summary>
                Initializes SDL and the specified subsystems.
            </summary>
            <param name="flags">
                <para>
                    Specifies what part(s) of SDL to initialize:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>Initializes the timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>Initializes the audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>Initializes the video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>Initializes the CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>Initializes the joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>Initializes all subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                Returns -1 on an error or 0 on success.
            </returns>
            <remarks>
                <para>
                    Unless the <see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/> flag is set, it will install
                    cleanup signal handlers for some commonly ignored fatal signals (like
                    SIGSEGV).
                </para>
                <p>
            		Binds to C-function call in SDL.h:
                <code>extern DECLSPEC int SDLCALL SDL_Init(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Quit"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)">
            <summary>
                Initializes specified subsystems.
            </summary>
            <param name="flags">
                <para>
                    Specifies what part(s) of SDL to initialize:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>Initializes the timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>Initializes the audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>Initializes the video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>Initializes the CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>Initializes the joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>Initializes all subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                Returns -1 on an error or 0 on success.
            </returns>
            <remarks>
                After SDL has been initialized with <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/> you may initialize
                any uninitialized subsystems with <b>SDL_InitSubSystem</b>.
                 <p>
                Binds to C-function call in SDL.h:
                <code>extern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Quit"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_QuitSubSystem(System.Int32)"/>
            
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.UInt32)">
            <summary>
                Initializes specified subsystems.
            </summary>
            <param name="flags">
                <para>
                    Specifies what part(s) of SDL to initialize:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>Initializes the timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>Initializes the audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>Initializes the video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>Initializes the CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>Initializes the joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>Initializes all subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                Returns -1 on an error or 0 on success.
            </returns>
            <remarks>
                After SDL has been initialized with <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/> you may initialize
                any uninitialized subsystems with <b>SDL_InitSubSystem</b>.
                 <p>
                Binds to C-function call in SDL.h:
                <code>extern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Quit"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_QuitSubSystem(System.Int32)"/>
            
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_QuitSubSystem(System.Int32)">
            <summary>
                Shuts down specified subsystems.
            </summary>
            <param name="flags">
                <para>
                    Specifies what part(s) of SDL to shut down:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>Shuts down the timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>Shuts down the audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>Shuts down the video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>Shuts down the CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>Shuts down the joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>Shuts down all subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <remarks>
                <b>SDL_QuitSubSystem</b> allows you to shut down a subsystem that has been
                previously initialized by <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/> or
                <see cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>.
                <p>
                Binds to C-function call in SDL.h:
                <code>extern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Quit"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_QuitSubSystem(System.UInt32)">
            <summary>
                Shuts down specified subsystems.
            </summary>
            <param name="flags">
                <para>
                    Specifies what part(s) of SDL to shut down:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>Shuts down the timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>Shuts down the audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>Shuts down the video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>Shuts down the CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>Shuts down the joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>Shuts down all subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <remarks>
                <b>SDL_QuitSubSystem</b> allows you to shut down a subsystem that has been
                previously initialized by <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/> or
                <see cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>.
                <p>
                Binds to C-function call in SDL.h:
                <code>extern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Quit"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WasInit(System.Int32)">
            <summary>
                Checks which SDL subsystems are initialized.
            </summary>
            <param name="flags">
                <para>
                    Specifies the subsystems you wish to check:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>The timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>The audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>The video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>The CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>The joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>All subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                A bitwised OR'd combination of the initialized subsystems.
            </returns>
            <remarks>
                <b>SDL_WasInit</b> allows you to see which SDL subsytems have been initialized.
                <p>
                Binds to C-function call in SDL.h:
                <code>extern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WasInit(System.UInt32)">
            <summary>
                Checks which SDL subsystems are initialized.
            </summary>
            <param name="flags">
                <para>
                    Specifies the subsystems you wish to check:
                </para>
                <para>
                    <list type="table">
                        <listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/></term>
                            <description>The timer subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_AUDIO"/></term>
                            <description>The audio subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_VIDEO"/></term>
                            <description>The video subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_CDROM"/></term>
                            <description>The CD-ROM subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_JOYSTICK"/></term>
                            <description>The joystick subsystem.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVERYTHING"/></term>
                            <description>All subsystems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_NOPARACHUTE"/></term>
                            <description>Prevents SDL from catching fatal signals.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_INIT_EVENTTHREAD"/></term>
                            <description>Not supported on all OS's.</description>
                        </item>
                    </list>
                </para>
            </param>
            <returns>
                A bitwised OR'd combination of the initialized subsystems.
            </returns>
            <remarks>
                <b>SDL_WasInit</b> allows you to see which SDL subsytems have been initialized.
                <p>
                Binds to C-function call in SDL.h:
                <code>extern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Quit">
            <summary>
                Shuts down SDL.
            </summary>
            <remarks>
                <b>SDL_Quit</b> shuts down all SDL subsystems and frees the resources allocated
                to them.  This should always be called before you exit.
                <p>
                Binds to C-function call in SDL.h:
                <code>extern DECLSPEC void SDLCALL SDL_Quit(void)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_QuitSubSystem(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetAppState">
            <summary>
            This function returns the current state of the application, 
            which is a bitwise combination of SDL_APPMOUSEFOCUS, 
            SDL_APPINPUTFOCUS, and SDL_APPACTIVE.  
            </summary>
            <remarks>
            If SDL_APPACTIVE is set, then the user is able to see 
            your application, 
            otherwise it has been iconified or disabled.
            </remarks>
            <returns>Returns the current state of the application, 
            which is a bitwise combination of SDL_APPMOUSEFOCUS, 
            SDL_APPINPUTFOCUS, and SDL_APPACTIVE
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AudioInit(System.String)">
            <summary>
            This function is used internally, 
            and should not be used unless you
            have a specific need to specify the audio driver you want to use.
            You should normally use 
            <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/> or <see cref="M:Tao.Sdl.Sdl.SDL_InitSubSystem(System.Int32)"/>.
            </summary>
            <remarks>
            Binds to C-function call in SDL_audio.h:
            <code>int SDL_AudioInit(const char *driver_name)
            </code></remarks>
            <param name="driver_name">
            </param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AudioQuit">
            <summary>
            This function is used internally, 
            and should not be used unless you
            have a specific need to specify the audio driver you want to use.
            You should normally use SDL_Init() or SDL_InitSubSystem().
            </summary>
            <remarks>
            Binds to C-function call in SDL_audio.h:
            <code>void SDL_AudioQuit()
            </code></remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AudioDriverName(System.String,System.Int32)">
            <summary>
            This function fills the given character buffer with the name of the
            current audio driver, and returns a pointer to it if the audio
             driver has	been initialized.  
            </summary>
            <remarks>
            Binds to C-function call in SDL_audio.h:
            <code>char * SDL_AudioDriverName(char *namebuf, int maxlen)
            </code>
            </remarks>
            <returns>It returns NULL if no driver has been initialized.
            </returns>
            <param name="namebuf"></param>
            <param name="maxlen"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)">
             <summary>
             Opens the audio device with the desired parameters.
             </summary>
             <remarks>
             This function opens the audio device with the desired parameters, 
             and returns 0 if successful, placing the actual hardware 
             parameters in the structure pointed to by obtained. If obtained
              is NULL, the audio data passed to the callback function will 
              be guaranteed to be in the requested format, and will be 
              automatically converted to the hardware audio format if 
              necessary. This function returns -1 if it failed to open
               the audio device, or couldn't set up the audio thread.
               <p>To open the audio device a desired 
               <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/> must be created.</p>
               <code>
             SDL_AudioSpec *desired;
             .
             .
             desired = malloc(sizeof(SDL_AudioSpec)); </code>
             <p>You must then fill this structure with 
             your desired audio specifications.</p>
             <p>desired-&gt;freq</p>
             The desired audio frequency in samples-per-second.
             <p>desired-&gt;format</p>
             The desired audio format (see <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>)
             <p>desired-&gt;samples</p>
             The desired size of the audio buffer in samples. 
             This number should be a power of two, and may be adjusted by the
              audio driver to a value more suitable for the hardware. Good
               values seem to range between 512 and 8192 inclusive, depending
                on the application and CPU speed. Smaller values yield faster
                 response time, but can lead to underflow if the application
                  is doing heavy processing and cannot fill the audio buffer
                   in time. A stereo sample consists of both right and left
                    channels in LR ordering. Note that the number of samples
                     is directly related to time by the following formula: 
                     ms = (samples*1000)/freq
             <p>desired-&gt;callback</p>
             This should be set to a function that will be called when the
              audio device is ready for more data. It is passed a pointer 
              to the audio buffer, and the length in bytes of the audio 
              buffer. This function usually runs in a separate thread, and 
              so you should protect data structures that it accesses by 
              calling <see cref="M:Tao.Sdl.Sdl.SDL_LockAudio"/> and 
              <see cref="M:Tao.Sdl.Sdl.SDL_UnlockAudio"/> in your code. The callback 
              prototype is: 
             <code>
             void callback(void *userdata, Uint8 *stream, int len);
             </code>
             <p>userdata is the pointer stored in userdata field of the
              SDL_AudioSpec. stream is a pointer to the audio buffer you
               want to fill with information and len is the length of the
                audio buffer in bytes.</p>
             <p> desired-&gt;userdata</p>
            <p> This pointer is passed as the first parameter to the 
            callback function.</p>
            <p> SDL_OpenAudio reads these fields from the desired 
            SDL_AudioSpec structure pass to the function and attempts to find 
            an audio configuration matching your desired. As mentioned above, 
            if the obtained parameter is NULL then SDL with convert from your
             desired audio settings to the hardware settings as it plays.</p>
            <p>If obtained is NULL then the desired SDL_AudioSpec is your
             working specification, otherwise the obtained SDL_AudioSpec 
             becomes the working specification and the desirec specification
              can be deleted. The data in the working specification is used 
              when building SDL_AudioCVT's for converting loaded data to the
               hardware format.</p>
            <p>SDL_OpenAudio calculates the size and silence fields for both 
            the desired and obtained specifications. The size field stores 
            the total size of the audio buffer in bytes, while the silence
             stores the value used to represent silence in the audio buffer.
             </p>									
             <p>The audio device starts out playing silence when it's opened,
             and should be enabled for playing by calling 
             <see cref="M:Tao.Sdl.Sdl.SDL_PauseAudio(System.Int32)"/>(0) when you are ready for your 
             audio callback function to be called. Since the audio driver 
             may modify the requested size of the audio buffer, you should
              allocate any local mixing buffers after you open the audio 
              device.</p>
              <p>Binds to C-function call in SDL_audio.h:
              <code>int SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained);
              </code></p>
             </remarks>
             <example>
             <code>
            
             /* Prototype of our callback function */
            		void my_audio_callback(void *userdata, Uint8 *stream, int len);
            
            		/* Open the audio device */
            		SDL_AudioSpec *desired, *obtained;
            		SDL_AudioSpec *hardware_spec;
            
            		/* Allocate a desired SDL_AudioSpec */
            		desired = malloc(sizeof(SDL_AudioSpec));
            
            		/* Allocate space for the obtained SDL_AudioSpec */
            		obtained = malloc(sizeof(SDL_AudioSpec));
            
            		/* 22050Hz - FM Radio quality */
            		desired-&gt;freq=22050;
            
            		/* 16-bit signed audio */
            		desired-&gt;format=AUDIO_S16LSB;
            
            		/* Mono */
            		desired-&gt;channels=0;
            
            	/* Large audio buffer reduces risk of dropouts but 
            	increases response time */
            		desired-&gt;samples=8192;
            
            		/* Our callback function */
            		desired-&gt;callback=my_audio_callback;
            
            		desired-&gt;userdata=NULL;
            
            		/* Open the audio device */
            		if ( SDL_OpenAudio(desired, obtained) &lt; 0 )
            	{
            		fprintf(stderr, "Couldn't open audio: %s\n", SDL_GetError());
            		exit(-1);
            	}
            	/* desired spec is no longer needed */
            	free(desired);
            	hardware_spec=obtained;
            	.
            	.
            	/* Prepare callback for playing */
            	.
            	.
            	.
            	/* Start playing */
            	SDL_PauseAudio(0);</code>
            </example>
             <param name="desired">IntPtr to SDL_AudioSpec</param>
             <param name="obtained">IntPtr to SDL_AudioSpec</param>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_LockAudio"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_UnlockAudio"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PauseAudio(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetAudioStatus">
            <summary>
            Get the current audio state.
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_audio.h:
            <code>SDL_audiostatus SDL_GetAudioStatus(void)
            </code></p>
            </remarks>
            <returns>Returns either SDL_AUDIO_STOPPED, 
            SDL_AUDIO_PAUSED or SDL_AUDIO_PLAYING (SDLaudiostatus enum)
            depending on the current audio state.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_PauseAudio(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_PauseAudio(System.Int32)">
            <summary>
            Pauses and unpauses the audio callback processing.
            </summary>
            <remarks>
            This function pauses and unpauses the audio callback processing. 
            It should be called with pause_on=0 after opening the audio device 
            to start playing sound. This is so you can safely initialize data 
            for your callback function after opening the audio device. 
            Silence will be written to the audio device during the pause.
            <p>Binds to C-function call in SDL_audio.h:
            <code>void SDL_PauseAudio(int pause_on)
            </code></p>
            </remarks>
            <param name="pause_on"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetAudioStatus"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadWAV_RW(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@,System.Int32@)">
            <summary>
            This function loads a WAVE from the data source, 
            automatically freeing
            that source if 'freesrc' is non-zero.  
            For example, to load a WAVE file,
            you could do:
            SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
            </summary>
            <remarks>If this function succeeds, it returns the given SDL_AudioSpec,
            filled with the audio data format of the wave data, and sets
            'audio_buf' to a malloc()'d buffer containing the audio data,
            and sets 'audio_len' to the length of that audio buffer, in bytes.
            You need to free the audio buffer with SDL_FreeWAV() when you are 
            done with it.
            <p>This function returns NULL and sets the SDL error message if the 
            wave file cannot be opened, uses an unknown data format, or is 
            corrupt.  Currently raw and MS-ADPCM WAVE files are supported.</p>
            <p>Binds to C-function call in SDL_audio.h:
            <code>SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len)
            </code>
            </p></remarks>
            <param name="audio_buf"></param>
            <param name="audio_len"></param>
            <param name="freesrc"></param>
            <param name="spec"></param>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadWAV_RW(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@,System.UInt32@)">
            <summary>
            This function loads a WAVE from the data source, 
            automatically freeing
            that source if 'freesrc' is non-zero.  
            For example, to load a WAVE file,
            you could do:
            SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
            </summary>
            <remarks>If this function succeeds, it returns the given SDL_AudioSpec,
            filled with the audio data format of the wave data, and sets
            'audio_buf' to a malloc()'d buffer containing the audio data,
            and sets 'audio_len' to the length of that audio buffer, in bytes.
            You need to free the audio buffer with SDL_FreeWAV() when you are 
            done with it.
            <p>This function returns NULL and sets the SDL error message if the 
            wave file cannot be opened, uses an unknown data format, or is 
            corrupt.  Currently raw and MS-ADPCM WAVE files are supported.</p>
            <p>Binds to C-function call in SDL_audio.h:
            <code>SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len)
            </code>
            </p></remarks>
            <param name="audio_buf"></param>
            <param name="audio_len"></param>
            <param name="freesrc"></param>
            <param name="spec"></param>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadWAV(System.String,System.IntPtr@,System.IntPtr@,System.Int32@)">
             <summary>
             Load a WAVE file.
             </summary>
             <remarks>
             SDL_LoadWAV This function loads a WAVE file into memory.
             <p>If this function succeeds, it returns the given 
             <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>,
              filled with the audio data format of the wave data, and sets 
              audio_buf to a malloc'd buffer containing the audio data, and
               sets audio_len to the length of that audio buffer, in bytes.
                You need to free the audio buffer with 
                <see cref="M:Tao.Sdl.Sdl.SDL_FreeWAV(System.IntPtr@)"/> when you are done with it.</p>
             <p>This function returns NULL and sets the SDL error message if the
              wave file cannot be opened, uses an unknown data format, or is 
              corrupt. Currently raw, MS-ADPCM and IMA-ADPCM WAVE files are 
              supported.</p>
             <p>Binds to C-function call in SDL_audio.h:
             <code>
             #define SDL_LoadWAV(file, spec, audio_buf, audio_len) 
             SDL_LoadWAV_RW(SDL_RWFromFile(file, "rb"),1, spec,audio_buf,audio_len)
             
             SDL_AudioSpec *SDL_LoadWAV(const char *file, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
             </code></p>
             </remarks>
             <example>
             <code>
             SDL_AudioSpec wav_spec;
            		Uint32 wav_length;
            		Uint8 *wav_buffer;
            
            		/* Load the WAV */
            		if( SDL_LoadWAV("test.wav", wav_spec, wav_buffer, wav_length) == NULL )
            																			{
            		fprintf(stderr, "Could not open test.wav: %s\n", SDL_GetError());
            		exit(-1);
            	}
            	.
            	.
            	.
            	/* Do stuff with the WAV */
            	.
            	.
            	/* Free It */
            	SDL_FreeWAV(wav_buffer);
            	</code>
             </example>
             <param name="file"></param>
             <param name="spec"></param>
             <param name="audio_buf"></param>
             <param name="audio_len"></param>
             <returns>IntPtr to SDL_AudioApec</returns>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeWAV(System.IntPtr@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadWAV(System.String,System.IntPtr@,System.IntPtr@,System.UInt32@)">
             <summary>
             Load a WAVE file.
             </summary>
             <remarks>
             SDL_LoadWAV This function loads a WAVE file into memory.
             <p>If this function succeeds, it returns the given 
             <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>,
              filled with the audio data format of the wave data, and sets 
              audio_buf to a malloc'd buffer containing the audio data, and
               sets audio_len to the length of that audio buffer, in bytes.
                You need to free the audio buffer with 
                <see cref="M:Tao.Sdl.Sdl.SDL_FreeWAV(System.IntPtr@)"/> when you are done with it.</p>
             <p>This function returns NULL and sets the SDL error message if the
              wave file cannot be opened, uses an unknown data format, or is 
              corrupt. Currently raw, MS-ADPCM and IMA-ADPCM WAVE files are 
              supported.</p>
             <p>Binds to C-function call in SDL_audio.h:
             <code>
             #define SDL_LoadWAV(file, spec, audio_buf, audio_len) 
             SDL_LoadWAV_RW(SDL_RWFromFile(file, "rb"),1, spec,audio_buf,audio_len)
             
             SDL_AudioSpec *SDL_LoadWAV(const char *file, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
             </code></p>
             </remarks>
             <example>
             <code>
             SDL_AudioSpec wav_spec;
            		Uint32 wav_length;
            		Uint8 *wav_buffer;
            
            		/* Load the WAV */
            		if( SDL_LoadWAV("test.wav", wav_spec, wav_buffer, wav_length) == NULL )
            																			{
            		fprintf(stderr, "Could not open test.wav: %s\n", SDL_GetError());
            		exit(-1);
            	}
            	.
            	.
            	.
            	/* Do stuff with the WAV */
            	.
            	.
            	/* Free It */
            	SDL_FreeWAV(wav_buffer);
            	</code>
             </example>
             <param name="file"></param>
             <param name="spec"></param>
             <param name="audio_buf"></param>
             <param name="audio_len"></param>
             <returns>IntPtr to SDL_AudioApec</returns>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeWAV(System.IntPtr@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_FreeWAV(System.IntPtr@)">
            <summary>
            Frees previously opened WAV data.
            </summary>
            <remarks>
            After a WAVE file has been opened with <see cref="M:Tao.Sdl.Sdl.SDL_LoadWAV(System.String,System.IntPtr@,System.IntPtr@,System.Int32@)"/>
             its data can eventually be freed with SDL_FreeWAV. audio_buf is 
             a pointer to the buffer created by SDL_LoadWAV.
             <p>
            <code>
            void SDL_FreeWAV(Uint8 *audio_buf)
            </code></p>
            </remarks>
            <param name="audio_buf"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LoadWAV(System.String,System.IntPtr@,System.IntPtr@,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_BuildAudioCVT(System.IntPtr,System.Int16,System.Byte,System.Int32,System.Int16,System.Byte,System.Int32)">
            <summary>
            Initializes a SDL_AudioCVT structure for conversion
            </summary>
            <remarks>
            Before an <see cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/> structure can be used to 
            convert audio data it must be initialized with source and 
            destination information. 
            <p>src_format and dst_format are the source and destination 
            format of the conversion. (For information on audio formats 
            see <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>). src_channels and dst_channels
             are the number of channels in the source and destination formats.
              Finally, src_rate and dst_rate are the frequency or 
              samples-per-second of the source and destination formats.
               Once again, see <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>.</p>
               <p>
            <code>
            int SDL_BuildAudioCVT(SDL_AudioCVT *cvt, Uint16 src_format, Uint8 src_channels, int src_rate, Uint16 dst_format, Uint8 dst_channels, int dst_rate)
            </code></p>
            </remarks>
            <example>
            See <see cref="M:Tao.Sdl.Sdl.SDL_ConvertAudio(System.IntPtr)"/>.
            </example>
            <param name="cvt"></param>
            <param name="src_format"></param>
            <param name="src_channels"></param>
            <param name="src_rate"></param>
            <param name="dst_format"></param>
            <param name="dst_channels"></param>
            <param name="dst_rate"></param>
            <returns>
            Returns -1 if the filter could not be built or 1 if it could.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_ConvertAudio(System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_BuildAudioCVT(System.IntPtr,System.UInt16,System.Byte,System.Int32,System.UInt16,System.Byte,System.Int32)">
            <summary>
            Initializes a SDL_AudioCVT structure for conversion
            </summary>
            <remarks>
            Before an <see cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/> structure can be used to 
            convert audio data it must be initialized with source and 
            destination information. 
            <p>src_format and dst_format are the source and destination 
            format of the conversion. (For information on audio formats 
            see <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>). src_channels and dst_channels
             are the number of channels in the source and destination formats.
              Finally, src_rate and dst_rate are the frequency or 
              samples-per-second of the source and destination formats.
               Once again, see <see cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>.</p>
               <p>
            <code>
            int SDL_BuildAudioCVT(SDL_AudioCVT *cvt, Uint16 src_format, Uint8 src_channels, int src_rate, Uint16 dst_format, Uint8 dst_channels, int dst_rate)
            </code></p>
            </remarks>
            <example>
            See <see cref="M:Tao.Sdl.Sdl.SDL_ConvertAudio(System.IntPtr)"/>.
            </example>
            <param name="cvt"></param>
            <param name="src_format"></param>
            <param name="src_channels"></param>
            <param name="src_rate"></param>
            <param name="dst_format"></param>
            <param name="dst_channels"></param>
            <param name="dst_rate"></param>
            <returns>
            Returns -1 if the filter could not be built or 1 if it could.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_ConvertAudio(System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ConvertAudio(System.IntPtr)">
             <summary>
             Convert audio data to a desired audio format.
             </summary>
             <remarks>
             SDL_ConvertAudio takes one parameter, cvt, which was previously 
             initialized. Initilizing a <see cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/> is a two 
             step process. First of all, the structure must be passed to 
             <see cref="M:Tao.Sdl.Sdl.SDL_BuildAudioCVT(System.IntPtr,System.Int16,System.Byte,System.Int32,System.Int16,System.Byte,System.Int32)"/> along with source and destination 
             format parameters. Secondly, the cvt-&gt;buf and cvt-&gt;len fields must
              be setup. cvt-&gt;buf should point to the audio data and cvt-&gt;len 
              should be set to the length of the audio data in bytes. 
              Remember, the length of the buffer pointed to by buf show be 
              len*len_mult bytes in length.
             <p>Once the SDL_AudioCVTstructure is initilized then we can pass 
             it to SDL_ConvertAudio, which will convert the audio data pointer
              to by cvt-&gt;buf. If SDL_ConvertAudio returned 0 then the conversion
               was completed successfully, otherwise -1 is returned.</p>
             <p>If the conversion completed successfully then the converted
              audio data can be read from cvt-&gt;buf. The amount of valid, 
              converted, audio data in the buffer is equal to 
              cvt-&gt;len*cvt-&gt;len_ratio.</p>
             <p>
             <code>
             int SDL_ConvertAudio(SDL_AudioCVT *cvt)
             </code></p>
             </remarks>
             <example>
             <code>
             /* Converting some WAV data to hardware format */
            		void my_audio_callback(void *userdata, Uint8 *stream, int len);
            
            		SDL_AudioSpec *desired, *obtained;
            		SDL_AudioSpec wav_spec;
            		SDL_AudioCVT  wav_cvt;
            		Uint32 wav_len;
            		Uint8 *wav_buf;
            		int ret;
            
            		/* Allocated audio specs */
            		desired = malloc(sizeof(SDL_AudioSpec));
            		obtained = malloc(sizeof(SDL_AudioSpec));
            
            		/* Set desired format */
            		desired-&gt;freq=22050;
            		desired-&gt;format=AUDIO_S16LSB;
            		desired-&gt;samples=8192;
            		desired-&gt;callback=my_audio_callback;
            		desired-&gt;userdata=NULL;
            
            		/* Open the audio device */
            		if ( SDL_OpenAudio(desired, obtained) &lt; 0 )
            	{
            		fprintf(stderr, "Couldn't open audio: %s\n", SDL_GetError());
            		exit(-1);
            	}
                   
            	free(desired);
            
            	/* Load the test.wav */
            	if( SDL_LoadWAV("test.wav", &amp;wav_spec, &amp;wav_buf, &amp;wav_len) == NULL )
            {
            	fprintf(stderr, "Could not open test.wav: %s\n", SDL_GetError());
            	SDL_CloseAudio();
            	free(obtained);
            	exit(-1);
                                                       
            	/* Build AudioCVT */
            	ret = SDL_BuildAudioCVT(&amp;wav_cvt,
            	wav_spec.format, wav_spec.channels, wav_spec.freq,
            	obtained-&gt;format, obtained-&gt;channels, obtained-&gt;freq);
            
            	/* Check that the convert was built */
            	if(ret==-1)
            {
            	fprintf(stderr, "Couldn't build converter!\n");
            	SDL_CloseAudio();
            	free(obtained);
            	SDL_FreeWAV(wav_buf);
            }
            
            	/* Setup for conversion */
            	wav_cvt.buf = malloc(wav_len * wav_cvt.len_mult);
            	wav_cvt.len = wav_len;
            	memcpy(wav_cvt.buf, wav_buf, wav_len);
            
            	/* We can delete to original WAV data now */
            	SDL_FreeWAV(wav_buf);
            
            	/* And now we're ready to convert */
            	SDL_ConvertAudio(&amp;wav_cvt);
            
            	/* do whatever */
            	.
            	.
            	.
            	.
             </code>
             </example>
             <param name="cvt">
             IntPtr to <see cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/> struct.
             </param>
             <returns>
             If SDL_ConvertAudio returned 0 then the conversion 
             was completed successfully, otherwise -1 is returned.
             </returns>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_BuildAudioCVT(System.IntPtr,System.Int16,System.Byte,System.Int32,System.Int16,System.Byte,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_MixAudio(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Mix audio data.
            </summary>	
            <remarks>
            This function takes two audio buffers of len bytes each of the 
            playing audio format and mixes them, performing addition, 
            volume adjustment, and overflow clipping. The volume ranges
             from 0 to SDL_MIX_MAXVOLUME and should be set to the maximum
              value for full audio volume. Note this does not change hardware
               volume. This is provided for convenience -- you can mix your 
               own audio data.
            <p>Note: Do not use this function for mixing together more than two
             streams of sample data. The output from repeated application of 
             this function may be distorted by clipping, because there is no 
             accumulator with greater range than the input (not to mention this
              being an inefficient way of doing it). Use mixing functions from 
              SDL_mixer, OpenAL, or write your own mixer instead.</p>
            <p>
            <code>
            void SDL_MixAudio(Uint8 *dst, Uint8 *src, Uint32 len, int volume)
            </code></p>
            </remarks>	
            <param name="dst"></param>
            <param name="src"></param>
            <param name="len"></param>
            <param name="volume"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_MixAudio(System.IntPtr,System.IntPtr,System.UInt32,System.Int32)">
            <summary>
            Mix audio data.
            </summary>	
            <remarks>
            This function takes two audio buffers of len bytes each of the 
            playing audio format and mixes them, performing addition, 
            volume adjustment, and overflow clipping. The volume ranges
             from 0 to SDL_MIX_MAXVOLUME and should be set to the maximum
              value for full audio volume. Note this does not change hardware
               volume. This is provided for convenience -- you can mix your 
               own audio data.
            <p>Note: Do not use this function for mixing together more than two
             streams of sample data. The output from repeated application of 
             this function may be distorted by clipping, because there is no 
             accumulator with greater range than the input (not to mention this
              being an inefficient way of doing it). Use mixing functions from 
              SDL_mixer, OpenAL, or write your own mixer instead.</p>
            <p>
            <code>
            void SDL_MixAudio(Uint8 *dst, Uint8 *src, Uint32 len, int volume)
            </code></p>
            </remarks>	
            <param name="dst"></param>
            <param name="src"></param>
            <param name="len"></param>
            <param name="volume"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LockAudio">
            <summary>
            Lock out the callback function.
            </summary>
            <remarks>
            The lock manipulated by these functions protects the callback 
            function. During a LockAudio period, you can be guaranteed 
            that the callback function is not running. Do not call these 
            from the callback function or you will cause deadlock.
            <p>Binds to C-function call in SDL_audio.h:
            <code>
            void SDL_LockAudio(void);
            </code>
            </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UnlockAudio">
            <summary>
            Unlock the callback function
            </summary>
            <remarks>
            Unlocks a previous <see cref="M:Tao.Sdl.Sdl.SDL_LockAudio"/> call.
            <p>Binds to C-function call in SDL_audio.h:
            <code>
            void SDL_UnlockAudio(void)
            </code>
            </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CloseAudio">
            <summary>
            Shuts down audio processing and closes the audio device.
            </summary>
            <remarks>
            This function shuts down audio processing and closes the audio 
            device.
            <p>Binds to C-function call in SDL_audio.h:
            <code>
            void SDL_CloseAudio(void)
            </code>
            </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.CD_INDRIVE(System.Int32)">
            <summary>
            Given a status, returns true if there's a disk in the drive.
            </summary>
            <remarks>
            <p>Binds to C-macro call in SDL_cdrom.h:
            <code>#define CD_INDRIVE(status)	((int)status > 0)
            </code></p>
            </remarks>
            <param name="status">CDstatus enum</param>
            <returns>Returns 1 if true and 0 if false</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.FRAMES_TO_MSF(System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Conversion function from frames to Minute/Second/Frames.
            </summary>
            <remarks>
            <p>Binds to C-macro call in SDL_cdrom.h:
            <code>#define FRAMES_TO_MSF(f, M,S,F)	{
            int value = f;							
            	*(F) = value%CD_FPS;						
            	value /= CD_FPS;						
            	*(S) = value%60;						
            	value /= 60;							
            	*(M) = value;							
            }
            </code></p>
            </remarks>
            <param name="frames">Frames</param>
            <param name="M">Minutes</param>
            <param name="S">Seconds</param>
            <param name="F">Frames (remainder)</param>
            <seealso cref="F:Tao.Sdl.Sdl.CD_FPS"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.MSF_TO_FRAMES(System.Int32,System.Int32,System.Int32)">
            <summary>
            Conversion function from Minute/Second/Frames to frames.
            </summary>
            <remarks>
            <p>Binds to C-macro call in SDL_cdrom.h:
            <code>#define MSF_TO_FRAMES(M, S, F)	((M)*60*CD_FPS+(S)*CD_FPS+(F))
            </code></p>
            </remarks>
            <param name="M">Minutes</param>
            <param name="S">Seconds</param>
            <param name="F">Frames</param>
            <seealso cref="F:Tao.Sdl.Sdl.CD_FPS"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDNumDrives">
            <summary>
            Returns the number of CD-ROM drives on the 
            system.
            </summary>
            <remarks>
            Returns the number of CD-ROM drives on the system, 
            or -1 if SDL_Init() has not been called with the SDL_INIT_CDROM 
            flag.
            <p>Binds to C-function call in SDL_cdrom.h:
            <code>int SDL_CDNumDrives(void)
            </code></p>
            </remarks>
            <returns>Returns the number of CD-ROM drives on the system, 
            or -1 if SDL_Init() has not been called with the SDL_INIT_CDROM 
            flag.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDOpen(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDName(System.Int32)">
            <summary>
            Returns a human-readable, system-dependent identifier for the 
            CD-ROM.
            </summary>
            <remarks>
            Drive is the index of the drive. Drive indices start to 0 and end 
            at SDL_CDNumDrives()-1.
            <p>Binds to C-function in SDL_cdrom.h
            <code>const char *SDL_CDName(int drive);
            </code></p>
            </remarks>
            <example>
            Example:
            "/dev/cdrom"
            "E:"
            "/dev/disk/ide/1/master"
            </example>
            <param name="drive"></param>
            <returns>
            Returns a human-readable, system-dependent identifier for the 
            CD-ROM.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDNumDrives"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDOpen(System.Int32)">
             <summary>
             Opens a CD-ROM drive for access.
             </summary>
             <remarks>
             Opens a CD-ROM drive for access. It returns a 
             <see cref="T:Tao.Sdl.Sdl.SDL_CD"/> structure
              on success, or NULL if the drive was invalid or busy. This 
              newly opened CD-ROM becomes the default CD used when other 
              CD functions are passed a NULL CD-ROM handle. 
             <p>Drives are numbered starting with 0. Drive 0 is the system
              default CD-ROM.</p>
              <p>Binds to C-function in SDL_cdrom.h
              <code>SDL_CD *SDL_CDOpen(int drive)
              </code></p>
             </remarks>
             <example>
             <code>
             SDL_CD *cdrom;
            		int cur_track;
            		int min, sec, frame;
            		SDL_Init(SDL_INIT_CDROM);
            		atexit(SDL_Quit);
            
            		/* Check for CD drives */
            		if(!SDL_CDNumDrives())
            			{
            		/* None found */
            		fprintf(stderr, "No CDROM devices available\n");
            		exit(-1);
            	}
            
            	/* Open the default drive */
            	cdrom=SDL_CDOpen(0);
            
            	/* Did if open? Check if cdrom is NULL */
            	if(!cdrom)
            {
            	fprintf(stderr, "Couldn't open drive: %s\n", SDL_GetError());
            	exit(-1);
            }
            
            	/* Print Volume info */
            	printf("Name: %s\n", SDL_CDName(0));
            	printf("Tracks: %d\n", cdrom-&gt;numtracks);
            	for(cur_track=0;cur_track &lt; cdrom-&gt;numtracks; cur_track++)
            {
            	FRAMES_TO_MSF(cdrom-&gt;track[cur_track].length, &amp;min, &amp;sec, &amp;frame);
            	printf("\tTrack %d: Length %d:%d\n", cur_track, min, sec);
            }
            
            SDL_CDClose(cdrom);
            </code>
             </example>
             <param name="drive"></param>
             <returns>It returns a SDL_CD structure
              on success, or NULL if the drive was invalid or busy.
              </returns>
              <seealso cref="T:Tao.Sdl.Sdl.SDL_CD"/>
              <seealso cref="T:Tao.Sdl.Sdl.SDL_CDtrack"/>
              <seealso cref="M:Tao.Sdl.Sdl.SDL_CDClose(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDStatus(System.IntPtr)">
             <summary>
             This function returns the current status of the given drive.
             </summary>
             <remarks>
             If the drive has a CD in it, 
             the table of contents of the CD and current play position 
             of the CD will be stored in the SDL_CD structure.
             <p>
             The macro CD_INDRIVE is provided for convenience, 
             and given a status returns true if there's a disk 
             in the drive.</p>
             <p>Note: SDL_CDStatus also updates the <see cref="T:Tao.Sdl.Sdl.SDL_CD"/> 
             structure passed to it.</p>
             <p>Binds to C-function in SDL_cdrom.h
             <code>CDstatus SDL_CDStatus(SDL_CD *cdrom);
             </code></p>
             </remarks>
             <example>
             <code>
             int playTrack(int track)
            	{
            		int playing = 0;
            
            		if ( CD_INDRIVE(SDL_CDStatus(cdrom)) ) 
            	{
            		/* clamp to the actual number of tracks on the CD */
            		if (track &gt;= cdrom-&gt;numtracks) 
            	{
            		track = cdrom-&gt;numtracks-1;
            	}
            
            	if ( SDL_CDPlayTracks(cdrom, track, 0, 1, 0) == 0 ) 
            {
            	playing = 1;
            }
            }
            return playing;
            }
            </code>
             </example>
             <param name="cdrom"></param>
             <returns>CDstatus enum</returns>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_CD"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDPlay(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Play a CD. 
            </summary>
            <remarks>
            Plays the given cdrom, starting a frame start for length frames.
            <p>Binds to C-function in SDL_cdrom.h
            <code>int SDL_CDPlay(SDL_CD *cdrom, int start, int length)
            </code></p>
            </remarks>
            <param name="cdrom"></param>
            <param name="start"></param>
            <param name="length"></param>
            <returns>It returns 0, or -1 if there was an error.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDPlayTracks(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDStop(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDPlayTracks(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Play the given CD track(s).
             </summary>
             <remarks>
             SDL_CDPlayTracks plays the given CD starting at track start_track,
              for ntracks tracks. 
             <p>start_frame is the frame offset, from the beginning of the 
             start_track, at which to start. nframes is the frame offset, 
             from the beginning of the last track (start_track+ntracks), at
              which to end playing.</p>
             <p>SDL_CDPlayTracks should only be called after calling 
             <see cref="M:Tao.Sdl.Sdl.SDL_CDStatus(System.IntPtr)"/> to get track information about 
             the CD.</p>
             <p>Note: Data tracks are ignored.</p>
             <p>Binds to C-function in SDL_cdrom.h
             <code>int SDL_CDPlayTracks(SDL_CD *cdrom, int start_track, int start_frame, int ntracks, int nframes))
             </code></p>
             </remarks>
             <example>
             <code>
            		/* assuming cdrom is a previously opened device */
            		/* Play the entire CD */
            		if(CD_INDRIVE(SDL_CDStatus(cdrom)))
            		SDL_CDPlayTracks(cdrom, 0, 0, 0, 0);
            
            		/* Play the first track */
            		if(CD_INDRIVE(SDL_CDStatus(cdrom)))
            		SDL_CDPlayTracks(cdrom, 0, 0, 1, 0);
            
            		/* Play first 15 seconds of the 2nd track */
            		if(CD_INDRIVE(SDL_CDStatus(cdrom)))
            		SDL_CDPlayTracks(cdrom, 1, 0, 0, CD_FPS*15);
            	</code>
             </example>
             <param name="cdrom"></param>
             <param name="start_track"></param>
             <param name="start_frame"></param>
             <param name="ntracks"></param>
             <param name="nframes"></param>
             <returns>Returns 0, or -1 if there was an error.</returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_CDPlay(System.IntPtr,System.Int32,System.Int32)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_CDStatus(System.IntPtr)"/>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_CD"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDPause(System.IntPtr)">
            <summary>
            Pauses a CDROM.
            </summary>
            <remarks>
            Pauses play on the given cdrom.
            <p>Binds to C-function in SDL_cdrom.h
            <code>int SDL_CDPause(SDL_CD *cdrom)
            </code></p>
            </remarks>
            <param name="cdrom"></param>
            <returns>Returns 0, or -1 on error.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDPlay(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDResume(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDResume(System.IntPtr)">
            <summary>
            Resumes a CDROM.
            </summary>
            <remarks>
            Resumes play on the given cdrom.
            <p>Binds to C-function in SDL_cdrom.h
            <code>int SDL_CDResume(SDL_CD *cdrom)
            </code></p>
            </remarks>
            <param name="cdrom"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDPlay(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDPause(System.IntPtr)"/>
            <returns>Returns 0, or -1 on error.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDStop(System.IntPtr)">
            <summary>
            Stops a CDROM.
            </summary>
            <remarks>
            Stops play on the given cdrom.
            <p>Binds to C-function in SDL_cdrom.h
            <code>int SDL_CDStop(SDL_CD *cdrom)
            </code></p>
            </remarks>
            <param name="cdrom"></param>
            <returns>Returns 0, or -1 on error.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDPlay(System.IntPtr,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDEject(System.IntPtr)">
            <summary>
            Ejects a CDROM.
            </summary>
            <remarks>
            Ejects the given cdrom.
            <p>Binds to C-function in SDL_cdrom.h
            <code>int SDL_CDEject(SDL_CD *cdrom)
            </code></p>
            </remarks>
            <param name="cdrom"></param>
            <returns>Returns 0, or -1 on error.</returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_CD"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDClose(System.IntPtr)">
            <summary>
            Closes a SDL_CD handle.
            </summary>
            <remarks>
            Closes the given cdrom handle.
            <p>Binds to C-function in SDL_cdrom.h
            <code>void SDL_CDClose(SDL_CD *cdrom);
            </code></p>
            </remarks>
            <param name="cdrom"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CDOpen(System.Int32)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_CD"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_HasRDTSC">
            <summary>
                This function returns true if the CPU has the RDTSC instruction.
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_cpuinfo.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_HasRDTSC(void)</code>
                </p>
            </remarks>
            <returns>Returns SDL_TRUE if the CPU has the RDTSC instruction.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_HasMMX">
            <summary>
                This function returns true if the CPU has MMX features.
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_cpuinfo.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_HasMMX(void)</code>
                </p>
            </remarks>
            <returns>Returns SDL_TRUE if the CPU has MMX features.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_HasMMXExt">
            <summary>
                This function returns true if the CPU has MMX Ext. features.
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_cpuinfo.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_HasMMXExt(void)</code>
                </p>
            </remarks>
            <returns>Returns SDL_TRUE if the CPU has MMX Ext. features.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Has3DNow">
            <summary>
                This function returns true if the CPU has 3DNow features
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_cpuinfo.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_SDL_Has3DNow(void)</code>
                </p>
            </remarks>
            <returns>Returns SDL_TRUE if the CPU has 3DNow features.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_HasSSE">
            <summary>
                This function returns true if the CPU has SSE features
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_cpuinfo.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_SDL_HasSSE(void)</code>
                </p>
            </remarks>
            <returns>Returns SDL_TRUE if the CPU has SSE features.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_HasSSE2">
            <summary>
                This function returns true if the CPU has SSE2 features
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_cpuinfo.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_SDL_HasSSE2void()</code>
                </p>
            </remarks>
            <returns>Returns SDL_TRUE if the CPU has SSE2 features.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_HasAltiVec">
            <summary>
                This function returns true if the CPU has AltiVec features
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_cpuinfo.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_SDL_HasAltiVec(void)</code>
                </p>
            </remarks>
            <returns>Returns SDL_TRUE if the CPU has AltiVec features.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetError(System.String)">
            <summary>
                Sets an SDL error string.
            </summary>
            <param name="message">
                The error message to set.
            </param>
            <remarks>
            <p>Binds to C-function call in SDL_error.h:
                <code>extern DECLSPEC void SDLCALL SDL_SetError(const char *fmt, ...)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetError">
            <summary>
                Gets an SDL error string.
            </summary>
            <returns>
                A string containing information about the last internal SDL error.
            </returns>
            <remarks>
            <p>Binds to C-function call in SDL_error.h:
                <code>extern DECLSPEC char * SDLCALL SDL_GetError(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ClearError">
            <summary>
                Clears the SDL error.
            </summary>
            <remarks>
            <p>
            Binds to C-function call in SDL_error.h:
            <code>extern DECLSPEC void SDLCALL SDL_ClearError(void)</code>
            </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_PumpEvents">
            <summary>
            Pumps the event loop, gathering events from the input devices.
            </summary>
            <remarks>
            Pumps the event loop, gathering events from the input devices.
            <p>SDL_PumpEvents gathers all the pending input information from
             devices and places it on the event queue. Without calls to 
             SDL_PumpEvents no events would ever be placed on the queue. 
             Often calls the need for SDL_PumpEvents is hidden from the user 
             since <see cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/> and <see cref="M:Tao.Sdl.Sdl.SDL_WaitEvent(Tao.Sdl.Sdl.SDL_Event@)"/> 
             implicitly call SDL_PumpEvents. However, if you are not polling or
              waiting for events (e.g. you are filtering them), then you must 
              call SDL_PumpEvents to force an event queue update.
            </p>
            <p>Note: You can only call this function in the thread that set the video mode.</p>
            <p>Binds to C-function in SDL_events.h
            <code>
            void SDL_PumpEvents(void);
            </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks the event queue for messages and optionally returns them.
            </summary>
            <remarks>
            Checks the event queue for messages and optionally returns them.
            <p>If action is SDL_ADDEVENT, up to numevents events will be added
             to the back of the event queue.</p>
            <p>If action is SDL_PEEKEVENT, up to numevents events at the front
             of the event queue, matching mask, will be returned and 			
            will not be removed from the queue.</p>
            <p>If action is SDL_GETEVENT, up to numevents events at the front
             of the event queue, matching mask, will be returned and 			
            will be removed from the queue.</p>
            <p>
            The mask parameter is an bitwise OR of SDL_EVENTMASK(event_type),
             for all event types you are interested in.
            </p>
            <p>This function is thread-safe.</p>
            <p>Binds to C-function in SDL_events.h
            <code>
            int SDL_PeepEvents(SDL_Event *events, int numevents, SDL_eventaction action, Uint32 mask);
            </code></p>
            </remarks>
            <param name="events"></param>
            <param name="numevents"></param>
            <param name="action">SDL_eventaction enum</param>
            <param name="mask"></param>
            <returns>
            This function returns the number of events actually stored,
             or -1 if there was an error.
             </returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.UInt32)">
            <summary>
            Checks the event queue for messages and optionally returns them.
            </summary>
            <remarks>
            Checks the event queue for messages and optionally returns them.
            <p>If action is SDL_ADDEVENT, up to numevents events will be added
             to the back of the event queue.</p>
            <p>If action is SDL_PEEKEVENT, up to numevents events at the front
             of the event queue, matching mask, will be returned and 			
            will not be removed from the queue.</p>
            <p>If action is SDL_GETEVENT, up to numevents events at the front
             of the event queue, matching mask, will be returned and 			
            will be removed from the queue.</p>
            <p>
            The mask parameter is an bitwise OR of SDL_EVENTMASK(event_type),
             for all event types you are interested in.
            </p>
            <p>This function is thread-safe.</p>
            <p>Binds to C-function in SDL_events.h
            <code>
            int SDL_PeepEvents(SDL_Event *events, int numevents, SDL_eventaction action, Uint32 mask);
            </code></p>
            </remarks>
            <param name="events"></param>
            <param name="numevents"></param>
            <param name="action">SDL_eventaction enum</param>
            <param name="mask"></param>
            <returns>
            This function returns the number of events actually stored,
             or -1 if there was an error.
             </returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)">
             <summary>
             Polls for currently pending events.
             </summary>
             <remarks>
             Polls for currently pending events, 
             and returns 1 if there are any pending events, or 0 if there 
             are none available. 
             <p>If event is not NULL, the next event is removed from the 
             queue and stored in that area.</p>
             <p>Binds to C-function in SDL_events.h
             <code>int SDL_PollEvent(SDL_Event *event);
             </code>
             </p>
             </remarks>
             <example>
             <code>
             SDL_Event event; /* Event structure */
            
            		.
            		.
            		.
            		/* Check for events */
            		while(SDL_PollEvent(&amp;event))
            	{  /* Loop until there are no events left on the queue */
            		switch(event.type)
            					 {  /* Process the appropiate event type */
            		case SDL_KEYDOWN:  /* Handle a KEYDOWN event */         
            		printf("Oh! Key press\n");
            		break;
            		case SDL_MOUSEMOTION:
            		.
            		.
            		.
            		default: /* Report an unhandled event */
            		printf("I don't know what this event is!\n");
            	}
            }
             </code>
             </example>
             <param name="sdlEvent"></param>
             <returns>Returns 1 if there are any pending events, 
             or 0 if there 
             are none available</returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_WaitEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
              <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
              <seealso cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WaitEvent(Tao.Sdl.Sdl.SDL_Event@)">
            <summary>
            Waits indefinitely for the next available event.
            </summary>
            <remarks>
            Waits indefinitely for the next available event, returning 1,
             or 0 if there
            was an error while waiting for events.  
            <p>If 'event' is not NULL, 
            the next
            event is removed from the queue and stored in that area.</p>
            <p>Binds to C-function in SDL_events.h
            <code>int SDL_WaitEvent(SDL_Event *event);
            </code></p>
            </remarks>
            <param name="evt"></param>
            <returns>Returns 1, or 0 if there was an 
            error while waiting for events</returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)">
            <summary>
            Pushes an event onto the event queue.
            </summary>
            <remarks>
            The event queue can actually be used as a two way communication 
            channel. Not only can events be read from the queue, but the user
             can also push their own events onto it. event is a pointer to the
              event structure you wish to push onto the queue.
            <p>Note: Pushing device input events onto the queue doesn't modify
             the state of the device within SDL.</p>
            <p>Binds to C-function in SDL_events.h
            <code>int SDL_PushEvent(SDL_Event *event)
            </code></p></remarks>
            <param name="evt"></param>
            <returns>
            Returns 0 on success or -1 if the event couldn't be pushed.
            </returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetEventFilter(Tao.Sdl.Sdl.SDL_EventFilter)">
            <summary>
            Sets up a filter to process all events before 
            they are posted to the event queue.
            </summary>
            <remarks>
            This function sets up a filter to process all events 
            before they are posted to the event queue. This is a very powerful
             and flexible feature. The filter is prototyped as: 
            <p><code>typedef int (*SDL_EventFilter)(const SDL_Event *event);
            </code></p>
            <p>If the filter returns 1, then the event will be added to the 
            internal queue. If it returns 0, then the event will be dropped 
            from the queue. This allows selective filtering of dynamically.
            </p>
            <p>There is one caveat when dealing with the SDL_QUITEVENT event 
            type. The event filter is only called when the window manager 
            desires to close the application window. If the event filter returns
             1, then the window will be closed, otherwise the window will remain
              open if possible. If the quit event is generated by an interrupt 
              signal, it will bypass the internal queue and be delivered to the
               application at the next event poll.</p>
            <p>Note: Events pushed onto the queue with 
            <see cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/> or <see cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/> 
            do not get passed through the event filter.</p>
            <p>Note: Be Careful! The event filter function may run in a 
            different thread so be careful what you do within it.</p>
            <p>Binds to C-function in SDL_events.h
            <code>void SDL_SetEventFilter(SDL_EventFilter filter);
            </code></p>
            </remarks>
            <param name="filter"></param>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_GetEventFilter"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetEventFilter">
            <summary>
            Retrieves a pointer to the event filter
            </summary>
            <remarks>
            This function retrieces a pointer to the event filter that was 
            previously set using <see cref="M:Tao.Sdl.Sdl.SDL_SetEventFilter(Tao.Sdl.Sdl.SDL_EventFilter)"/>.
             An SDL_EventFilter function is defined as:
             <p>
             <code>
             typedef int (*SDL_EventFilter)(const SDL_Event *event);
             </code></p>
            <p>Binds to C-function in SDL_events.h
            <code>SDL_EventFilter SDL_GetEventFilter(void);
            </code></p></remarks>
            <returns>
            Returns a pointer to the event filter or 
            NULL if no filter has been set.
            </returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetEventFilter(Tao.Sdl.Sdl.SDL_EventFilter)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_EventState(System.Byte,System.Int32)">
            <summary>
            This function allows you to set the state of processing certain 
            events.
            </summary>
            <remarks>
            This function allows you to set the state of 
            processing certain event type's.
            <p>If 'state' is set to SDL_IGNORE, that event will be 
            automatically
             dropped
            from the event queue and will not be filtered.</p>
            <p>
            If 'state' is set to SDL_ENABLE, that event will be processed 
            normally.</p>
            <p>If 'state' is set to SDL_QUERY, SDL_EventState will return the 
            current processing state of the specified event type.</p>
            <p>A list of event type's can be found in the 
            <see cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             section.</p>
            </remarks>
            <param name="type"></param>
            <param name="state"></param>
            <returns>
            Returns 0 on success or -1 if the event couldn't be pushed.
            </returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_NumJoysticks">
            <summary>
            Count the number of joysticks attached to the system.
            </summary>
            <remarks>
            Counts the number of joysticks attached to the system.
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_NumJoysticks(void)
            </code></p>
            </remarks>
            <returns>
            Returns the number of attached joysticks
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickName(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickName(System.Int32)">
            <summary>
            Get joystick name.
            </summary>
            <remarks>
            Get the implementation dependent name of joystick. 
            The index parameter refers to the N'th joystick on the system.
            <p>Binds to C-function in SDL_joystick.h
            <code>const char *SDL_JoystickName(int index)
            </code></p>
            </remarks>
            <param name="device_index"></param>
            <returns>
            Returns a string containing the joystick name.
            </returns>
            <example>
            <code>
            /* Print the names of all attached joysticks */
            	int num_joy, i;
            	num_joy=SDL_NumJoysticks();
            	printf("%d joysticks found\n", num_joy);
            	for(i=0;i&lt;num_joy;i++)
            	printf("%s\n", SDL_JoystickName(i));
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)">
             <summary>
             Open a joystick for use.
             </summary>
             <remarks>
             Opens a joystick for use within SDL. 
             The index refers to the N'th joystick in the system. 
             A joystick must be opened before it game be used.
             <p>Binds to C-function in SDL_joystick.h
             <code>
             </code></p>
             </remarks>
             <param name="device_index"></param>
             <returns>
             Returns a IntPtr to a SDL_Joystick structure on success. 
             NULL on failure.
             </returns>
             <example>
             <code>
             SDL_Joystick *joy;
             Check for joystick
            		if(SDL_NumJoysticks()&gt;0)
            	{
            		// Open joystick
            		joy=SDL_JoystickOpen(0);
              
            		if(joy)
            	{
            		printf("Opened Joystick 0\n");
            		printf("Name: %s\n", SDL_JoystickName(0));
            		printf("Number of Axes: %d\n", SDL_JoystickNumAxes(joy));
            		printf("Number of Buttons: %d\n", SDL_JoystickNumButtons(joy));
            		printf("Number of Balls: %d\n", SDL_JoystickNumBalls(joy));
            	}
            	else
            	printf("Couldn't open Joystick 0\n");
              
            	// Close if opened
            	if(SDL_JoystickOpened(0))
            	SDL_JoystickClose(joy);
            }
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickClose(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickOpened(System.Int32)">
            <summary>
            Determine if a joystick has been opened.
            </summary>
            <remarks>
            Determines whether a joystick has already been opened 
            within the application. index refers to the N'th joystick
             on the system.
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickOpened(int index)
            </code></p>
            </remarks>
            <param name="device_index"></param>
            <returns>
            Returns 1 if the joystick has been opened, or 0 if it has not.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickClose(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickIndex(System.IntPtr)">
            <summary>
            Get the index of an SDL_Joystick.
            </summary>
            <remarks>
            Returns the index of a given SDL_Joystick structure.
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickIndex(SDL_Joystick *joystick)
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <returns>
            Index number of the joystick.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickNumAxes(System.IntPtr)">
            <summary>
            Get the number of joystick axes
            </summary>
            <remarks>
            Return the number of axes available from a 
            previously opened SDL_Joystick.
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickNumAxes(SDL_Joystick *joystick)
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <returns>
            Number of axes.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetAxis(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickNumBalls(System.IntPtr)">
            <summary>
            Get the number of joystick trackballs
            </summary>
            <remarks>
            Return the number of trackballs available from a 
            previously opened SDL_Joystick.
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickNumBalls(SDL_Joystick *joystick)
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <returns>
            Number of trackballs.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetBall(System.IntPtr,System.Int32,System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickNumHats(System.IntPtr)">
            <summary>
            Get the number of joystick hats.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickNumHats(SDL_Joystick *joystick);
            </code></p>
            </remarks>
            Return the number of hats available from a previously 
            opened SDL_Joystick.
            <param name="joystick"></param>
            <returns>
            Number of hats.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetHat(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickNumButtons(System.IntPtr)">
            <summary>
            Get the number of joystick buttons.
            </summary>
            <remarks>
            Return the number of buttons available from a 
            previously opened SDL_Joystick.
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickNumButtons(SDL_Joystick *joystick)
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <returns>
            Number of buttons.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetButton(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickUpdate">
            <summary>
            Updates the state of all joysticks.
            </summary>
            <remarks>
            Updates the state(position, buttons, etc.) of all open joysticks.
             If joystick events have been enabled with 
             <see cref="M:Tao.Sdl.Sdl.SDL_JoystickEventState(System.Int32)"/>
              then this is called automatically in the event loop.
            <p>Binds to C-function in SDL_joystick.h
            <code>void SDL_JoystickUpdate(void)
            </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetButton(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickEventState(System.Int32)">
            <summary>
            Enable/disable joystick event polling
            </summary>
            <remarks>
            This function is used to enable or disable joystick event 
            processing. With joystick event processing disabled you will
             have to update joystick states with SDL_JoystickUpdate and 
             read the joystick information manually. state is either 
             SDL_QUERY, SDL_ENABLE or SDL_IGNORE.
             <p>
             Note: Joystick event handling is preferred
             </p>
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickEventState(int state)
            </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetButton(System.IntPtr,System.Int32)"/>
            <returns>
            If state is SDL_QUERY then the current state is returned,
             otherwise the new processing state is returned.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickUpdate"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_JoyAxisEvent"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_JoyBallEvent"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_JoyButtonEvent"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_JoyHatEvent"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickGetAxis(System.IntPtr,System.Int32)">
            <summary>
            Get the current state of an axis.
            </summary>
            <remarks>
            SDL_JoystickGetAxis returns the current state of the 
            given axis on the given joystick.
            <p>On most modern joysticks the X axis is usually represented 
            by axis 0 and the Y axis by axis 1. The value returned by 
            SDL_JoystickGetAxis is a signed integer (-32768 to 32768) 
            representing the current position of the axis, it maybe necessary
             to impose certain tolerances on these values to account for 
             jitter. It is worth noting that some joysticks use axes 2 and
              3 for extra buttons.</p>
            <p>Binds to C-function in SDL_joystick.h
            <code>Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <param name="axis"></param>
            <returns>
            Returns a short representing the current position of the axis.
            </returns>
            <example>
            <code>
            Sint16 x_move, y_move;
            	SDL_Joystick *joy1;
            	.
            	.
            	x_move=SDL_JoystickGetAxis(joy1, 0);
            	y_move=SDL_JoystickGetAxis(joy1, 1);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickNumAxes(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickGetHat(System.IntPtr,System.Int32)">
            <summary>
            Get the current state of a joystick hat
            </summary>
            <remarks>
            SDL_JoystickGetHat returns the current 
            state of the given hat on the given joystick.
            <p>Binds to C-function in SDL_joystick.h
            <code>Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat)
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <param name="hat"></param>
            <returns>
            The current state is returned as a byte which 
            is defined as an OR'd combination of one or more of the following:
            <code>
            SDL_HAT_CENTERED 
            SDL_HAT_UP 
            SDL_HAT_RIGHT 
            SDL_HAT_DOWN 
            SDL_HAT_LEFT 
            SDL_HAT_RIGHTUP 
            SDL_HAT_RIGHTDOWN 
            SDL_HAT_LEFTUP 
            SDL_HAT_LEFTDOWN 
            </code>
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickNumHats(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickGetBall(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Get relative trackball motion. 
            </summary>
            <remarks>
            Get the ball axis change.
            <p>Trackballs can only return relative motion since 
            the last call to SDL_JoystickGetBall, these motion 
            deltas a placed into dx and dy.
            </p>
            <p>Binds to C-function in SDL_joystick.h
            <code>int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <param name="ball"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns>
            Returns 0 on success or -1 on failure
            </returns>
            <example>
            <code>
            int delta_x, delta_y;
            	SDL_Joystick *joy;
            	.
            	.
            	.
            	SDL_JoystickUpdate();
            	if(SDL_JoystickGetBall(joy, 0, &amp;delta_x, &amp;delta_y)==-1)
            	printf("TrackBall Read Error!\n");
            	printf("Trackball Delta- X:%d, Y:%d\n", delta_x, delta_y);
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickNumBalls(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickGetButton(System.IntPtr,System.Int32)">
            <summary>
            Get the current state of a given button on a given joystick.
            </summary>
            <remarks>
            SDL_JoystickGetButton returns the current 
            state of the given button on the given joystick.
            <p>Binds to C-function in SDL_joystick.h
            <code>Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button);
            </code></p>
            </remarks>
            <param name="joystick"></param>		
            <param name="button"></param>
            <returns>
            1 if the button is pressed. Otherwise, 0.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickNumButtons(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_JoystickClose(System.IntPtr)">
            <summary>
            Closes a previously opened joystick.
            </summary>
            <remarks>
            Close a joystick that was previously opened with 
            <see cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>.
            <p>Binds to C-function in SDL_joystick.h
            <code>void SDL_JoystickClose(SDL_Joystick *joystick);
            </code></p>
            </remarks>
            <param name="joystick"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpen(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickOpened(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_EnableUNICODE(System.Int32)">
            <summary>
            Enable UNICODE translation
            </summary>
            <remarks>
            Enables/Disables Unicode keyboard translation.
            <p>To obtain the character codes corresponding to received 
            keyboard events, Unicode translation must first be turned 
            on using this function. The translation incurs a slight overhead
             for each keyboard event and is therefore disabled by default. 
             For each subsequently received key down event, the unicode member
              of the SDL_keysym structure will then contain the corresponding 
              character code, or zero for keysyms that do not correspond to 
              any character code.</p>
            <p>A value of 1 for enable enables Unicode translation; 0 disables
             it, and -1 leaves it unchanged (useful for querying the current 
             translation mode).</p>
            <p>Note that only key press events will be translated, not 
            release events.</p>
            <p>Binds to C-function in SDL_keyboard.h
            <code>int SDL_EnableUNICODE(int enable);
            </code></p>
            </remarks>
            <param name="enable"></param>
            <returns>
            Returns the previous translation mode (0 or 1).
            </returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_keysym"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_EnableKeyRepeat(System.Int32,System.Int32)">
             <summary>
             Set keyboard repeat rate. 
             </summary>
             <remarks>
             Enables or disables the keyboard repeat rate. 
             delay specifies how long the key must be pressed before it 
             begins repeating, it then repeats at the speed specified by 
             interval. Both delay and interval are expressed in milliseconds.
             <p>Setting delay to 0 disables key repeating completely. Good 
             default values are SDL_DEFAULT_REPEAT_DELAY and 
             SDL_DEFAULT_REPEAT_INTERVAL.</p>
            <p>Binds to C-function in SDL_keyboard.h
            <code>int SDL_EnableKeyRepeat(int delay, int interval);
            </code></p>
             </remarks>
             <param name="rate"></param>
             <param name="delay"></param>
             <returns>Returns 0 on success and -1 on failure.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetKeyRepeat(System.Int32@,System.Int32@)">
             <summary>
             Get keyboard repeat rate. 
             </summary>
             <remarks>
             Gets the keyboard repeat rate. 
             delay specifies how long the key must be pressed before it 
             begins repeating, it then repeats at the speed specified by 
             interval. Both delay and interval are expressed in milliseconds.
             <p>Setting delay to 0 disables key repeating completely. Good 
             default values are SDL_DEFAULT_REPEAT_DELAY and 
             SDL_DEFAULT_REPEAT_INTERVAL.</p>
            <p>Binds to C-function in SDL_keyboard.h
            <code>int SDL_GetKeyRepeat(int delay, int interval);
            </code></p>
             </remarks>
             <param name="rate"></param>
             <param name="delay"></param>
             <returns>Returns 0 on success and -1 on failure.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetKeyStateInternal(System.Int32@)">
            <summary>
            Get a snapshot of the current keyboard state. 
            </summary>
            <remarks>
            Returns an array of keystates, indexed by the SDLK_* syms.
            Used:
            Uint8 *keystate = SDL_GetKeyState(NULL);
            if ( keystate[SDLK_RETURN] ) ...  _RETURN_ is pressed.
            <p>Binds to C-function in SDL_keyboard.h
            <code>Uint8 *SDL_GetKeyState(int *numkeys);
            </code></p>
            </remarks>
            <param name="numkeys"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetKeyState(System.Int32@)">
            <summary>
            Get a snapshot of the current keyboard state. 
            </summary>
            <remarks>
            Gets a snapshot of the current keyboard state. The current state 
            is return as a pointer to an array, the size of this array is 
            stored in numkeys. The array is indexed by the SDLK_* symbols. 
            A value of 1 means the key is pressed and a value of 0 means its 
            not. The pointer returned is a pointer to an internal SDL array 
            and should not be freed by the caller.
            <p>Note: Use <see cref="M:Tao.Sdl.Sdl.SDL_PumpEvents"/> to update the state 
            array.</p>
            <p>Binds to C-function in SDL_keyboard.h
            <code>Uint8 *SDL_GetKeyState(int *numkeys);
            </code></p>
            </remarks>
            <example>
            <code>
            Uint8 *keystate = SDL_GetKeyState(NULL);
            if ( keystate[SDLK_RETURN] ) printf("Return Key Pressed.\n");
            </code>
            </example>
            <param name="numkeys"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_PumpEvents"/> 
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetModState">
            <summary>
            Get the state of modifier keys. 
            </summary>
            <remarks>
            Returns the current state of the modifier keys (CTRL, ALT, etc.).
            <p>Binds to C-function in SDL_keyboard.h
            <code>SDLMod SDL_GetModState(void)
            </code></p>
            </remarks>
            <returns>The return value can be an OR'd combination of the 
            SDLMod enum.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetKeyState(System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetModState(System.Int32)">
            <summary>
            Set the current key modifier state. 
            </summary>
            <remarks>
            The inverse of SDL_GetModState, SDL_SetModState allows you to 
            impose modifier key states on your application.
            <p>Simply pass your desired modifier states into modstate. 
            This value my be a logical OR'd combination of 
            SDLMod.</p>
             <p>Binds to C-function in SDL_keyboard.h
             <code>void SDL_SetModState(SDLMod modstate)
             </code></p>
            </remarks>
            <param name="modstate"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetModState"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetKeyName(System.Int32)">
            <summary>
            Get the name of an SDL virtual keysym
            </summary>
            <remarks>
            Returns the SDL-defined name of the SDLKey key.
            <p>Binds to C-function in SDL_keyboard.h
            <code>char *SDL_GetKeyName(SDLKey key);
            </code></p>
            </remarks>
            <returns>
            Returns the SDL-defined name of the SDLKey key.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadObject(System.String)">
            <summary>
            This function dynamically loads a shared object and returns a pointer
            to the object handle (or NULL if there was an error).
            </summary>
            <remarks>
             <p>Binds to C-function in SDL_loadso.h
             <code>extern DECLSPEC void * SDLCALL SDL_LoadObject(const char *sofile)
             </code></p>
            </remarks>
            <param name="sofile">System dependent name of the object file.</param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LoadFunction(System.IntPtr,System.String)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_UnloadObject(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadFunction(System.IntPtr,System.String)">
            <summary>
            Given an object handle, this function looks up the address of the
            named function in the shared object and returns it.  This address
            is no longer valid after calling SDL_UnloadObject().
            </summary>
            <remarks>
             <p>Binds to C-function in SDL_loadso.h
             <code>extern DECLSPEC void * SDLCALL SDL_LoadFunction(void *handle, const char *name)
             </code></p>
            </remarks>
            <param name="handle">Object handle</param>
            <param name="name">Name of function in the shared object.</param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LoadObject(System.String)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_UnloadObject(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UnloadObject(System.IntPtr)">
            <summary>
            Unload a shared object from memory
            </summary>
            <remarks>
             <p>Binds to C-function in SDL_loadso.h
             <code>extern DECLSPEC void * SDLCALL SDL_UnloadObject(void *handle)
             </code></p>
            </remarks>
            <param name="handle">Object handle</param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LoadFunction(System.IntPtr,System.String)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LoadObject(System.String)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetMouseState(System.Int32@,System.Int32@)">
            <summary>
            Retrieve the current state of the mouse.
            </summary>
            <remarks>
            The current button state is returned as a button bitmask, w
            hich can be tested using the SDL_BUTTON(X) macros, 
            and x and y are set to the current mouse cursor position. 
            You can pass NULL for either x or y.
            <p>Binds to C-function call in SDL_mouse.h:
            <code>
            Uint8 SDL_GetMouseState(int *x, int *y)
            </code>
            </p>
            </remarks>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
            <example>
            <code>
            SDL_PumpEvents();
            	if(SDL_GetMouseState(NULL, NULL)&amp;SDL_BUTTON(1))
            	printf("Mouse Button 1(left) is pressed.\n");
            </code>
            </example>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRelativeMouseState(System.Int32@,System.Int32@)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_PumpEvents"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetRelativeMouseState(System.Int32@,System.Int32@)">
            <summary>
            Retrieve the current state of the mouse.
            </summary>
            <remarks>
            The current button state is returned as a button bitmask, 
            which can be tested using the SDL_BUTTON(X) macros, 
            and x and y are set to the change in the mouse position 
            since the last call to SDL_GetRelativeMouseState or 
            since event initialization. You can pass NULL for either x or y.
             <p>Binds to C-function call in SDL_mouse.h:
            <code>
            Uint8 SDL_GetRelativeMouseState(int *x, int *y);
            </code>
            </p> 
            </remarks>
            <param name="x"></param>
            <param name="y"></param>
            <returns>
            The current button state is returned as a button bitmask
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetMouseState(System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WarpMouse(System.Int16,System.Int16)">
            <summary>
            Set the position of the mouse cursor.
            </summary>
            <remarks>
            Set the position of the mouse cursor (generates a mouse 
            motion event).
            <p>Binds to C-function call in SDL_mouse.h:
            <code>
            void SDL_WarpMouse(Uint16 x, Uint16 y);
            </code>
            </p>
            </remarks>
            <param name="x"></param>
            <param name="y"></param>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_MouseMotionEvent"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WarpMouse(System.UInt16,System.UInt16)">
            <summary>
            Set the position of the mouse cursor.
            </summary>
            <remarks>
            Set the position of the mouse cursor (generates a mouse 
            motion event).
            <p>Binds to C-function call in SDL_mouse.h:
            <code>
            void SDL_WarpMouse(Uint16 x, Uint16 y);
            </code>
            </p>
            </remarks>
            <param name="x"></param>
            <param name="y"></param>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_MouseMotionEvent"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateCursor(System.Byte@,System.Byte@,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Creates a new mouse cursor.
             </summary>
             <remarks>
             Create a cursor using the specified data and mask (in MSB format). 
             The cursor width must be a multiple of 8 bits.
             <p>The cursor is created in black and white according to the following:</p>
             <code>
             data  mask    resulting pixel on screen
              0     1       White
              1     1       Black
              0     0       Transparent
              1     0       Inverted color if possible, black if not.
              </code>
             Cursors created with this function must be freed with 
             <see cref="M:Tao.Sdl.Sdl.SDL_FreeCursor(Tao.Sdl.Sdl.SDL_Cursor@)"/>.
             <p>Binds to C-function call in SDL_mouse.h:
             <code>
             SDL_Cursor *SDL_CreateCursor(Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);
             </code>
             </p>
             </remarks>
             <example>
             <code>
             /* Stolen from the mailing list */
            * Creates a new mouse cursor from an XPM */
            
            
             /* XPM */
            static const char *arrow[] = {
              /* width height num_colors chars_per_pixel */
              "    32    32        3            1",
              /* colors */
             "X c #000000",
              ". c #ffffff",
              "  c None",
              /* pixels */
              "X                               ",
              "XX                              ",
              "X.X                             ",
              "X..X                            ",
              "X...X                           ",
              "X....X                          ",
              "X.....X                         ",
              "X......X                        ",
              "X.......X                       ",
              "X........X                      ",
              "X.....XXXXX                     ",
              "X..X..X                         ",
              "X.X X..X                        ",
              "XX  X..X                        ",
              "X    X..X                       ",
              "     X..X                       ",
              "      X..X                      ",
              "      X..X                      ",
              "       XX                       ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "                                ",
              "0,0"
            };
            
            static SDL_Cursor *init_system_cursor(const char *image[])
            {
              int i, row, col;
              Uint8 data[4*32];
              Uint8 mask[4*32];
              int hot_x, hot_y;
            
              i = -1;
              for ( row=0; row&lt;32; ++row ) {
                for ( col=0; col&lt;32; ++col ) {
                  if ( col % 8 ) {
                    data[i] &lt;&lt;= 1;
                    mask[i] &lt;&lt;= 1;
                  } else {
                    ++i;
                    data[i] = mask[i] = 0;
                  }
                  switch (image[4+row][col]) {
                    case 'X':
                      data[i] |= 0x01;
                      mask[i] |= 0x01;
                      break;
                    case '.':
                      mask[i] |= 0x01;
                      break;
                    case ' ':
                      break;
                  }
                }
              }
              sscanf(image[4+row], "%d,%d", &amp;hot_x, &amp;hot_y);
              return SDL_CreateCursor(data, mask, 32, 32, hot_x, hot_y);
            }
             </code>
             </example>
             <param name="data"></param>
             <param name="h"></param>
             <param name="hot_x"></param>
             <param name="hot_y"></param>
             <param name="mask"></param>
             <param name="w"></param>
             <returns></returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeCursor(Tao.Sdl.Sdl.SDL_Cursor@)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetCursor(Tao.Sdl.Sdl.SDL_Cursor@)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_ShowCursor(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetCursor(Tao.Sdl.Sdl.SDL_Cursor@)">
            <summary>
            Set the currently active cursor to the specified one. 
            </summary>
            <remarks>
            Sets the currently active cursor to the specified one. 
            If the cursor is currently visible, the change will 
            be immediately represented on the display.
            <p>Binds to C-function call in SDL_mouse.h:
            <code>
            void *SDL_SetCursor(SDL_Cursor *cursor);
            </code>
            </p>
            </remarks>
            <param name="cursor"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetCursor"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateCursor(System.Byte@,System.Byte@,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_ShowCursor(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetCursor">
            <summary>
            Returns the currently active cursor. 
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_mouse.h:
            <code>
            SDL_Cursor *SDL_GetCursor(void);
            </code>
            </p>
            </remarks>
            <returns>IntPtr to <see cref="T:Tao.Sdl.Sdl.SDL_Cursor"/></returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateCursor(System.Byte@,System.Byte@,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetCursor(Tao.Sdl.Sdl.SDL_Cursor@)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_ShowCursor(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_FreeCursor(Tao.Sdl.Sdl.SDL_Cursor@)">
            <summary>
            Frees a cursor created with SDL_CreateCursor. 
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_mouse.h:
            <code>
            void SDL_FreeCursor(SDL_Cursor *cursor)
            </code>
            </p>
            Frees a SDL_Cursor that was created using 
            <see cref="M:Tao.Sdl.Sdl.SDL_CreateCursor(System.Byte@,System.Byte@,System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            </remarks>
            <param name="cursor"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateCursor(System.Byte@,System.Byte@,System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ShowCursor(System.Int32)">
            <summary>
            Toggle whether or not the cursor is shown on the screen.
            </summary>
            <remarks>
            Toggle whether or not the cursor is shown on the screen. 
            Passing SDL_ENABLE displays the cursor and passing 
            SDL_DISABLE hides it. The current state of the mouse 
            cursor can be queried by passing SDL_QUERY, either 
            SDL_DISABLE or SDL_ENABLE will be returned.
            <p>
            The cursor starts off displayed, but can be turned off.
            </p>
            <p>Binds to C-function call in SDL_mouse.h:
            <code>
            int SDL_ShowCursor(int toggle);
            </code>
            </p>
            </remarks>
            <param name="toggle"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateCursor(System.Byte@,System.Byte@,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetCursor(Tao.Sdl.Sdl.SDL_Cursor@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_BUTTON(System.Byte)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateMutex">
            <summary>
                Create a mutex, initialized unlocked
            </summary>
            <returns>
                IntPtr to mutex
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC SDL_mutex * SDLCALL SDL_CreateMutex(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_mutexP(System.IntPtr)">
            <summary>
                Lock the mutex  (Returns 0, or -1 on error)
            </summary>
            <returns>
                Lock the mutex  (Returns 0, or -1 on error)
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_mutexP(SDL_mutex *mutex)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LockMutex(System.IntPtr)">
            <summary>
                Lock the mutex  (Returns 0, or -1 on error)
            </summary>
            <returns>
                Lock the mutex  (Returns 0, or -1 on error)
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>#define SDL_LockMutex(m)	SDL_mutexP(m)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_mutexV(System.IntPtr)">
            <summary>
                Unlock the mutex  (Returns 0, or -1 on error)
            </summary>
            <returns>
                Unlock the mutex  (Returns 0, or -1 on error)
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_mutexV(SDL_mutex *mutex)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UnlockMutex(System.IntPtr)">
            <summary>
                Unlock the mutex  (Returns 0, or -1 on error)
            </summary>
            <returns>
                unlock the mutex  (Returns 0, or -1 on error)
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>#define SDL_UnlockMutex(m)	SDL_mutexP(m)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_DestroyMutex(System.IntPtr)">
            <summary>
                Destroy a mutex
            </summary>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC void SDLCALL SDL_DestroyMutex(SDL_mutex *mutex)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateSemaphore(System.Int32)">
            <summary>
                Create a semaphore, initialized with value, returns NULL on failure.
            </summary>
            <returns>
            Create a semaphore, initialized with value, returns NULL on failure.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC SDL_sem * SDLCALL SDL_CreateSemaphore(Uint32 initial_value)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateSemaphore(System.UInt32)">
            <summary>
                Create a semaphore, initialized with value, returns NULL on failure.
            </summary>
            <returns>
            Create a semaphore, initialized with value, returns NULL on failure.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC SDL_sem * SDLCALL SDL_CreateSemaphore(Uint32 initial_value)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_DestroySemaphore(System.IntPtr)">
            <summary>
            Destroy a semaphore
            </summary>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC void SDLCALL SDL_DestroySemaphore(SDL_sem *sem)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SemWait(System.IntPtr)">
            <summary>
            This function suspends the calling thread until the semaphore pointed 
            to by sem has a positive count. 
            It then atomically decreases the semaphore count.
            </summary>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_SemWait(SDL_sem *sem)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SemtryWait(System.IntPtr)">
            <summary>
            Non-blocking variant of SDL_SemWait(), 
            returns 0 if the wait succeeds, 
            SDL_MUTEX_TIMEDOUT if the wait would block, and -1 on error.
            </summary>
            <returns>
            Non-blocking variant of SDL_SemWait(), 
            returns 0 if the wait succeeds,
            SDL_MUTEX_TIMEDOUT if the wait would block, and -1 on error.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_SemTryWait(SDL_sem *sem)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SemWaitTimeout(System.IntPtr,System.Int32)">
            <summary>
            Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if
            the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in
            the allotted time, and -1 on error.
            On some platforms this function is implemented by looping with a delay
            of 1 ms, and so should be avoided if possible.
            </summary>
            <returns>
            Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if
            the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in
            the allotted time, and -1 on error.
            On some platforms this function is implemented by looping with a delay
            of 1 ms, and so should be avoided if possible.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_SemWaitTimeout(SDL_sem *sem, Uint32 ms)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SemWaitTimeout(System.IntPtr,System.UInt32)">
            <summary>
            Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if
            the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in
            the allotted time, and -1 on error.
            On some platforms this function is implemented by looping with a delay
            of 1 ms, and so should be avoided if possible.
            </summary>
            <returns>
            Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if
            the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in
            the allotted time, and -1 on error.
            On some platforms this function is implemented by looping with a delay
            of 1 ms, and so should be avoided if possible.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_SemWaitTimeout(SDL_sem *sem, Uint32 ms)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SemPost(System.IntPtr)">
            <summary>
            Atomically increases the semaphore's count (not blocking), 
            returns 0, or -1 on error.
            </summary>
            <returns>
            Atomically increases the semaphore's count (not blocking), 
            returns 0, or -1 on error.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_SemPost(SDL_sem *sem)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SemValue(System.IntPtr)">
            <summary>
            Returns the current count of the semaphore
            </summary>
            <returns>
            Returns the current count of the semaphore
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC Uint32 SDLCALL SDL_SemValue(SDL_sem *sem)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateCond">
            <summary>
            Create a condition variable
            </summary>
            <returns>
            intPtr to variable
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC SDL_cond * SDLCALL SDL_CreateCond(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_DestroyCond(System.IntPtr)">
            <summary>
            Destroy a condition variable
            </summary>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC void SDLCALL SDL_DestroyCond(SDL_cond *cond)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CondSignal(System.IntPtr)">
            <summary>
            Restart one of the threads that are waiting on the condition variable,
            returns 0 or -1 on error.
            </summary>
            <returns>
            Restart one of the threads that are waiting on the condition variable,
            returns 0 or -1 on error.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_CondSignal(SDL_cond *cond)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CondBroadcast(System.IntPtr)">
            <summary>
            Restart all threads that are waiting on the condition variable, 
            returns 0 or -1 on error.
            </summary>
            <returns>
            Restart all threads that are waiting on the condition variable,
            returns 0 or -1 on error.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_CondBroadcast(SDL_cond *cond)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CondWait(System.IntPtr,System.IntPtr)">
            <summary>
            Wait on the condition variable, unlocking the provided mutex.
            The mutex must be locked before entering this function!
            Returns 0 when it is signaled, or -1 on error.
            </summary>
            <returns>
            Wait on the condition variable, unlocking the provided mutex.
            The mutex must be locked before entering this function!
            Returns 0 when it is signaled, or -1 on error.
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_CondWait(SDL_cond *cond, SDL_mutex *mut)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CondWaitTimeout(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Waits for at most 'ms' milliseconds, and returns 0 if the condition 
            variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not
            signaled in the allotted time, and -1 on error.
            On some platforms this function is implemented by looping with a delay
            of 1 ms, and so should be avoided if possible.
            </summary>
            <returns>
            returns 0 if the condition 
            variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not
            signaled in the allotted time, and -1 on error
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CondWaitTimeout(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            Waits for at most 'ms' milliseconds, and returns 0 if the condition 
            variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not
            signaled in the allotted time, and -1 on error.
            On some platforms this function is implemented by looping with a delay
            of 1 ms, and so should be avoided if possible.
            </summary>
            <returns>
            returns 0 if the condition 
            variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not
            signaled in the allotted time, and -1 on error
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_mutex.h:
                <code>extern DECLSPEC int SDLCALL SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_NAME(System.String)">
            <summary>
                Returns SDL name
            </summary>
            <param name="x">input name</param>
            <returns>Returns SDL name</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_QuitRequested">
            <summary>
                Checks if SDL_Quit event has been requested
            </summary>
            <returns>
            Returns 1 if a SDL_Quit Event has been requested. 
            Returns 0 if no SDL_Quit event has been requeted.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_RWFromFile(System.String,System.String)">
            <summary>
            Create SDL_RWops structures from file.
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_rwops.h:
            <code>
            SDL_RWops * SDLCALL SDL_RWFromFile(const char *file, const char *mode)
            </code></p></remarks>
            <param name="file"></param>
            <param name="mode">"rb"</param>
            <returns>IntPtr to SDL_RWops</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_RWFromMem(System.IntPtr,System.Int32)">
            <summary>
            Create SDL_RWops structures from memory.
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_rwops.h:
            <code>
            SDL_RWops * SDLCALL SDL_RWFromMem(void *mem, int size)
            </code></p></remarks>
            <param name="mem"></param>
            <param name="size"></param>
            <returns>IntPtr to SDL_RWops</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_RWFromMem(System.Byte[],System.Int32)">
            <summary>
            Create SDL_RWops structures from memory.
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_rwops.h:
            <code>
            SDL_RWops * SDLCALL SDL_RWFromMem(void *mem, int size)
            </code></p></remarks>
            <param name="mem"></param>
            <param name="size"></param>
            <returns>IntPtr to SDL_RWops</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_RWFromFP(System.IntPtr,System.Int32)">
            <summary>
            SDL_RWFromFP creates a new SDL_RWops structure from a file pointer, opened with stdio. If autoclose is nonzero, the file will be automatically closed when the RWops structure is closed.
            </summary>
            <remarks>This is not available under Win32, since files opened in an application on that platform cannot be used by a dynamically linked library.</remarks>
            <param name="fp"></param>
            <param name="autoclose"></param>
            <returns>Returns pointer to a new RWops structure, or NULL if it fails.</returns>
            <example>
            <code>
            FILE *fp;
            SDL_RWops *rw;
            
            fp = fopen("myfile.dat", "rb");
            rw = SDL_RWFromFP(fp, 1);
            
            // Do things with rw...
            SDL_RWclose(rw); // Automatically does an fclose(fp)
            </code></example>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_RWFromFile(System.String,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_RWFromConstMem(System.IntPtr,System.Int32)">
            <summary>
            Prepares a constant memory area for use with RWops.
            </summary>
            <remarks><see cref="M:Tao.Sdl.Sdl.SDL_RWFromConstMem(System.IntPtr,System.Int32)"/> sets up a RWops struct based on a memory area of a certain size. It assumes the memory area is not writable.</remarks>
            <param name="mem"></param>
            <param name="size"></param>
            <returns>Returns a pointer to a new RWops struct, or NULL if it fails.</returns>
            <example>
            <code>
            char bitmap[] = {
            	66, 77, 86, 2, 0, 0, 0, 0 ...
            }
             SDL_RWops *rw;
             SDL_Surface *img;
             
             rw = SDL_RWFromConstMem(bitmap, sizeof(bitmap));
             img = SDL_LoadBMP_RW(rw, 1); // Automatically frees the RWops struct for us
             
             //Do something with img...
            </code></example>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_RWFromMem(System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AllocRW">
            <summary>
            Allocates an empty, unpopulated SDL_RWops structure.
            </summary>
            <remarks>SDL_AllocRW allocates an empty, unpopulated SDL_RWops structure. You must fill out the fields yourself.</remarks>
            <returns>Returns a pointer to the allocated memory on success, or NULL on error.
            <p>You must free any memory allocated with <see cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/> with <see cref="M:Tao.Sdl.Sdl.SDL_FreeRW(System.IntPtr)"/>. Depending on your operating system and compiler, there may be a difference between the malloc() and free() your program uses and the versions SDL calls internally. Trying to mix the two can cause crashing such as segmentation faults.</p></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_FreeRW(System.IntPtr)">
            <summary>
            Frees an SDL_RWops structure allocated by <see cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>.
            </summary>
            <remarks><see cref="M:Tao.Sdl.Sdl.SDL_FreeRW(System.IntPtr)"/> frees an SDL_RWops structure previously allocated by <see cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>. Only use it on memory allocated by <see cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>. Any extra memory allocated during creation of the RWops is not freed by <see cref="M:Tao.Sdl.Sdl.SDL_FreeRW(System.IntPtr)"/>; the programmer must be responsible for it.</remarks>
            <param name="context"></param>
            <example>
            <code>
            #include "SDL_rwops.h"
            void dumb_example()
            {
                SDL_RWops *rw=SDL_AllocRW();
                if(rw==NULL) return;
                SDL_FreeRW(rw);
            }
            </code></example>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ReadLE16(System.IntPtr)">
            <summary>
            Read an item of the specified endianness and return in native format.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC Uint16 SDLCALL SDL_ReadLE16(SDL_RWops *src)
            </code></p>
            </remarks>
            <param name="src"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ReadBE16(System.IntPtr)">
            <summary>
            Read an item of the specified endianness and return in native format.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC Uint16 SDLCALL SDL_ReadBE16(SDL_RWops *src)
            </code></p>
            </remarks>
            <param name="src"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ReadLE32(System.IntPtr)">
            <summary>
            Read an item of the specified endianness and return in native format.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC Uint32 SDLCALL SDL_ReadLE32(SDL_RWops *src)
            </code></p>
            </remarks>
            <param name="src"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ReadBE32(System.IntPtr)">
            <summary>
            Read an item of the specified endianness and return in native format.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC Uint32 SDLCALL SDL_ReadBE32(SDL_RWops *src)
            </code></p>
            </remarks>
            <param name="src"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ReadLE64(System.IntPtr)">
            <summary>
            Read an item of the specified endianness and return in native format.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC Uint64 SDLCALL SDL_ReadLE64(SDL_RWops *src)
            </code></p>
            </remarks>
            <param name="src"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ReadBE64(System.IntPtr)">
            <summary>
            Read an item of the specified endianness and return in native format.
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC Uint64 SDLCALL SDL_ReadBE64(SDL_RWops *src)
            </code></p>
            </remarks>
            <param name="src"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteLE16(System.IntPtr,System.Int16)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteLE16(SDL_RWops *dst, Uint16 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteLE16(System.IntPtr,System.UInt16)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteLE16(SDL_RWops *dst, Uint16 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteBE16(System.IntPtr,System.Int16)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteBE16(SDL_RWops *dst, Uint16 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteBE16(System.IntPtr,System.UInt16)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteBE16(SDL_RWops *dst, Uint16 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteLE32(System.IntPtr,System.Int32)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteLE32(SDL_RWops *dst, Uint32 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteLE32(System.IntPtr,System.UInt32)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteLE32(SDL_RWops *dst, Uint32 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteBE32(System.IntPtr,System.Int32)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteBE32(SDL_RWops *dst, Uint32 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteBE32(System.IntPtr,System.UInt32)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteBE32(SDL_RWops *dst, Uint32 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteLE64(System.IntPtr,System.Int64)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteLE64(SDL_RWops *dst, Uint64 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WriteBE64(System.IntPtr,System.Int64)">
            <summary>
            Write an item of native format to the specified endianness
            </summary>
            <remarks>
            <p>Binds to C-function in SDL_rwops.h
            <code>
            extern DECLSPEC int SDLCALL SDL_WriteBE64(SDL_RWops *dst, Uint64 value)
            </code></p>
            </remarks>
            <param name="dst"></param>
            <param name="val"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AllocRW"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_putenv(System.String)">
            <summary>
                Puts a variable of the form "name=value" into the environment.
            </summary>
            <param name="variable">
                The "name=value" pair to write to the environment.
            </param>
            <returns>
                Returns -1 on an error or 0 on success.
            </returns>
            <remarks>
                Not all environments have a working putenv(). SDL_putenv() is not available on Windows.
                <p>
                Binds to C-function call in SDL_getenv.h:
                <code>extern DECLSPEC int SDLCALL SDL_putenv(const char *variable)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_getenv(System.String)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_getenv(System.String)">
            <summary>
                Retrieves a variable from the environment.
            </summary>
            <param name="name">
                The name of the environmental variable to retrieve.
            </param>
            <returns>
                The value of the specified environmental variable.
            </returns>
            <remarks>
                Not all environments have a working getenv(). SDL_getenv() is not available on Windows.
                <p>Binds to C-function call in SDL_getenv.h:
                <code>extern DECLSPEC char * SDLCALL SDL_getenv(const char *name)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_putenv(System.String)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetWMInfo(Tao.Sdl.Sdl.SDL_SysWMinfo_Unix@)">
            <summary>
            Gives you custom hooks into the window manager information.
            </summary>
            <remarks>
            This function gives you custom hooks into the window manager information.
            It fills the structure pointed to by 'info' with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0. 
            
            You typically use this function like this:
            SDL_SysWMInfo info;
            SDL_VERSION(&amp;info.version);
            if ( SDL_GetWMInfo(&amp;info) ) { ... }
            <p>Binds to C-function call in SDL_rwops.h:
            <code>extern DECLSPEC int SDLCALL SDL_GetWMInfo(SDL_SysWMinfo *info)</code>
            </p>
            </remarks>
            <param name="info">
            	IntPtr to SDL_SysWMinfo struct
            </param>
            <returns>
            It fills the structure pointed to by 'info' 
            with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetWMInfo(Tao.Sdl.Sdl.SDL_SysWMinfo_Windows@)">
            <summary>
            Gives you custom hooks into the window manager information.
            </summary>
            <remarks>
            This function gives you custom hooks into the window manager information.
            It fills the structure pointed to by 'info' with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0. 
            
            You typically use this function like this:
            SDL_SysWMInfo info;
            SDL_VERSION(&amp;info.version);
            if ( SDL_GetWMInfo(&amp;info) ) { ... }
            <p>Binds to C-function call in SDL_rwops.h:
            <code>extern DECLSPEC int SDLCALL SDL_GetWMInfo(SDL_SysWMinfo *info)</code>
            </p>
            </remarks>
            <param name="info">
            	IntPtr to SDL_SysWMinfo struct
            </param>
            <returns>
            It fills the structure pointed to by 'info' 
            with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetWMInfo(Tao.Sdl.Sdl.SDL_SysWMinfo_RiscOS@)">
            <summary>
            Gives you custom hooks into the window manager information.
            </summary>
            <remarks>
            This function gives you custom hooks into the window manager information.
            It fills the structure pointed to by 'info' with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0. 
            
            You typically use this function like this:
            SDL_SysWMInfo info;
            SDL_VERSION(&amp;info.version);
            if ( SDL_GetWMInfo(&amp;info) ) { ... }
            <p>Binds to C-function call in SDL_rwops.h:
            <code>extern DECLSPEC int SDLCALL SDL_GetWMInfo(SDL_SysWMinfo *info)</code>
            </p>
            </remarks>
            <param name="info">
            	IntPtr to SDL_SysWMinfo struct
            </param>
            <returns>
            It fills the structure pointed to by 'info' 
            with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetWMInfo(Tao.Sdl.Sdl.SDL_SysWMinfo@)">
            <summary>
            Gives you custom hooks into the window manager information.
            </summary>
            <remarks>
            This function gives you custom hooks into the window manager information.
            It fills the structure pointed to by 'info' with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0. 
            
            You typically use this function like this:
            SDL_SysWMInfo info;
            SDL_VERSION(&amp;info.version);
            if ( SDL_GetWMInfo(&amp;info) ) { ... }
            <p>Binds to C-function call in SDL_rwops.h:
            <code>extern DECLSPEC int SDLCALL SDL_GetWMInfo(SDL_SysWMinfo *info)</code>
            </p>
            </remarks>
            <param name="info">
            	IntPtr to SDL_SysWMinfo struct
            </param>
            <returns>
            It fills the structure pointed to by 'info' 
            with custom information and
            returns 1 if the function is implemented.  If it's not implemented, or
            the version member of the 'info' structure is invalid, it returns 0.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateThread(Tao.Sdl.Sdl.ThreadDelegate,System.Object)">
            <summary>
                Create thread
            </summary>
            <returns>
                IntPtr to SDL_Thread struct
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_thread.h:
                <code>extern DECLSPEC SDL_Thread * SDLCALL SDL_CreateThread(int (SDLCALL *fn)(void *), void *data)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ThreadID">
            <summary>
                Get the 32-bit thread identifier for the current thread
            </summary>
            <returns>
                ID
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_thread.h:
                <code>extern DECLSPEC Uint32 SDLCALL SDL_ThreadID(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetThreadID(System.IntPtr)">
            <summary>
                Get the 32-bit thread identifier for the specified thread,
            	equivalent to SDL_ThreadID() if the specified thread is NULL.
            </summary>
            <returns>
                ID
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_thread.h:
                <code>extern DECLSPEC Uint32 SDLCALL SDL_GetThreadID(SDL_Thread *thread)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WaitThread(System.IntPtr,System.Int32@)">
            <summary>
                Wait for a thread to finish.
                The return code for the thread function is placed in the area
                pointed to by 'status', if 'status' is not NULL.
            </summary>
            <remarks>
                <p>
                Binds to C-function call in SDL_thread.h:
                <code>extern DECLSPEC void SDLCALL SDL_WaitThread(SDL_Thread *thread, int *status)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_KillThread(System.IntPtr)">
            <summary>
                Forcefully kill a thread without worrying about its state
            </summary>
            <remarks>
                <p>
                Binds to C-function call in SDL_thread.h:
                <code>extern DECLSPEC void SDLCALL SDL_KillThread(SDL_Thread *thread)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetTicks">
            <summary>
                Get the number of milliseconds since the SDL library initialization.
            </summary>
            <returns>
                The number of milliseconds since SDL was initialized.
            </returns>
            <remarks>
                Note that this value wraps if the program runs for more than ~49 days.
                <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC Uint32 SDLCALL SDL_GetTicks(void)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Delay(System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Delay(System.Int32)">
            <summary>
                Wait a specified number of milliseconds before returning.
            </summary>
            <param name="ms">
                The number of milliseconds to wait.
            </param>
            <remarks>
                <b>SDL_Delay</b> will wait at least the specified time, but possible longer due
                to OS scheduling.  Count on a delay granularity of at least 10 ms.  Some
                platforms have shorter clock ticks but this is the most common.
                <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC void SDLCALL SDL_Delay(Uint32 ms)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Delay(System.UInt32)">
            <summary>
                Wait a specified number of milliseconds before returning.
            </summary>
            <param name="ms">
                The number of milliseconds to wait.
            </param>
            <remarks>
                <b>SDL_Delay</b> will wait at least the specified time, but possible longer due
                to OS scheduling.  Count on a delay granularity of at least 10 ms.  Some
                platforms have shorter clock ticks but this is the most common.
                <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC void SDLCALL SDL_Delay(Uint32 ms)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetTimer(System.Int32,Tao.Sdl.Sdl.SDL_TimerCallback)">
            <summary>
                Set a callback to run after the specified number of milliseconds has elapsed.
            </summary>
            <param name="interval">
                The timer interval.
            </param>
            <param name="callback">
                The callback to run.
            </param>
            <returns>
                The next timer interval.
            </returns>
            <remarks>
                <para>
                    The callback function is passed the current timer interval and returns the
                    next timer interval.  If the returned value is the same as the one passed
                    in, the periodic alarm continues, otherwise a new alarm is scheduled.
                </para>
                <para>
                    To cancel a currently running timer, call <c>Sdl.SDL_SetTimer(0, null);</c>
                </para>
                <para>
                    The timer callback function may run in a different thread than your main
                    constant, and so shouldn't call any functions from within itself.
                </para>
                <para>
                    The maximum resolution of this timer is 10 ms, which means that if you
                    request a 16 ms timer, your callback will run approximately 20 ms later on
                    an unloaded system.  If you wanted to set a flag signaling a frame update at
                    30 frames per second (every 33 ms), you might set a timer for 30 ms.
                </para>
                <para>
                    If you use this function, you need to pass <see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/> to
                    <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>.
                </para>
                <para>
                    This function is kept for compatibility but has been superseded by the new
                    timer functions <see cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/> and
                    <see cref="M:Tao.Sdl.Sdl.SDL_RemoveTimer(Tao.Sdl.Sdl.SDL_TimerID)"/> which support multiple timers.
                </para>
                <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC int SDLCALL SDL_SetTimer(Uint32 interval, 
                SDL_TimerCallback callback)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_TimerCallback"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetTimer(System.UInt32,Tao.Sdl.Sdl.SDL_TimerCallback)">
            <summary>
                Set a callback to run after the specified number of milliseconds has elapsed.
            </summary>
            <param name="interval">
                The timer interval.
            </param>
            <param name="callback">
                The callback to run.
            </param>
            <returns>
                The next timer interval.
            </returns>
            <remarks>
                <para>
                    The callback function is passed the current timer interval and returns the
                    next timer interval.  If the returned value is the same as the one passed
                    in, the periodic alarm continues, otherwise a new alarm is scheduled.
                </para>
                <para>
                    To cancel a currently running timer, call <c>Sdl.SDL_SetTimer(0, null);</c>
                </para>
                <para>
                    The timer callback function may run in a different thread than your main
                    constant, and so shouldn't call any functions from within itself.
                </para>
                <para>
                    The maximum resolution of this timer is 10 ms, which means that if you
                    request a 16 ms timer, your callback will run approximately 20 ms later on
                    an unloaded system.  If you wanted to set a flag signaling a frame update at
                    30 frames per second (every 33 ms), you might set a timer for 30 ms.
                </para>
                <para>
                    If you use this function, you need to pass <see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/> to
                    <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>.
                </para>
                <para>
                    This function is kept for compatibility but has been superseded by the new
                    timer functions <see cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/> and
                    <see cref="M:Tao.Sdl.Sdl.SDL_RemoveTimer(Tao.Sdl.Sdl.SDL_TimerID)"/> which support multiple timers.
                </para>
                <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC int SDLCALL SDL_SetTimer(Uint32 interval, 
                SDL_TimerCallback callback)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_TimerCallback"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)">
            <summary>
                Add a timer which will call a callback after the 
                specified number of milliseconds has elapsed.
            </summary>
            <param name="callback">
            The callback to run.
            </param>
            <param name="interval">
            The timer interval.
            </param>
            <returns>
            Returns an ID value for the added timer or NULL if 
            there was an error.
            </returns>
            <remarks>
            <para>
            Adds a callback function to be run after the specified number of 
            milliseconds has elapsed. The callback function is passed the current 
            timer interval and the user supplied parameter from the SDL_AddTimer 
            call and returns the next timer interval. If the returned value from 
            the callback is the same as the one passed in, the periodic alarm 
            continues, otherwise a new alarm is scheduled.
            </para>
            <para>
            To cancel a currently running timer call <see cref="M:Tao.Sdl.Sdl.SDL_RemoveTimer(Tao.Sdl.Sdl.SDL_TimerID)"/> 
            with the timer ID returned from SDL_AddTimer.
            </para>
            <para>
            The timer callback function may run in a different thread than your main 
            program, and so shouldn't call any functions from within itself.
            You may always call SDL_PushEvent, however.
            </para>
            <para>
            The granularity of the timer is platform-dependent, 
            but you should count on it being at least 10 ms as this is the 
            most common number. This means that if you request a 16 ms timer,
             your callback will run approximately 20 ms later on an unloaded 
             system. If you wanted to set a flag signaling a frame update at 
             30 frames per second (every 33 ms), you might set a timer for 
             30 ms (see example below). If you use this function, you need 
             to pass <see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/> to <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>.
            </para>
            <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC SDL_TimerID SDLCALL 
                SDL_AddTimer(Uint32 interval, 
                SDL_NewTimerCallback callback, void *param)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AddTimer(System.UInt32,Tao.Sdl.Sdl.SDL_NewTimerCallback)">
            <summary>
                Add a timer which will call a callback after the 
                specified number of milliseconds has elapsed.
            </summary>
            <param name="callback">
            The callback to run.
            </param>
            <param name="interval">
            The timer interval.
            </param>
            <returns>
            Returns an ID value for the added timer or NULL if 
            there was an error.
            </returns>
            <remarks>
            <para>
            Adds a callback function to be run after the specified number of 
            milliseconds has elapsed. The callback function is passed the current 
            timer interval and the user supplied parameter from the SDL_AddTimer 
            call and returns the next timer interval. If the returned value from 
            the callback is the same as the one passed in, the periodic alarm 
            continues, otherwise a new alarm is scheduled.
            </para>
            <para>
            To cancel a currently running timer call <see cref="M:Tao.Sdl.Sdl.SDL_RemoveTimer(Tao.Sdl.Sdl.SDL_TimerID)"/> 
            with the timer ID returned from SDL_AddTimer.
            </para>
            <para>
            The timer callback function may run in a different thread than your main 
            program, and so shouldn't call any functions from within itself.
            You may always call SDL_PushEvent, however.
            </para>
            <para>
            The granularity of the timer is platform-dependent, 
            but you should count on it being at least 10 ms as this is the 
            most common number. This means that if you request a 16 ms timer,
             your callback will run approximately 20 ms later on an unloaded 
             system. If you wanted to set a flag signaling a frame update at 
             30 frames per second (every 33 ms), you might set a timer for 
             30 ms (see example below). If you use this function, you need 
             to pass <see cref="F:Tao.Sdl.Sdl.SDL_INIT_TIMER"/> to <see cref="M:Tao.Sdl.Sdl.SDL_Init(System.Int32)"/>.
            </para>
            <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC SDL_TimerID SDLCALL 
                SDL_AddTimer(Uint32 interval, 
                SDL_NewTimerCallback callback, void *param)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_RemoveTimer(Tao.Sdl.Sdl.SDL_TimerID)">
            <summary>
                Remove a timer which was added with <see cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/>.
            </summary>
            <param name="t">
                The timer ID to remove.
            </param>
            <returns>
                A boolean value indicating success. SDL_TRUE or SDL_FALSE.
            </returns>
            <remarks>
            <p>
                Binds to C-function call in SDL_timer.h:
                <code>extern DECLSPEC SDL_bool SDLCALL SDL_RemoveTimer(SDL_TimerID t)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_VERSION">
            <summary>
            This method can be used to fill a version structure with the compile-time
            version of the SDL library.
            </summary>
            <returns>
                This function returns a <see cref="T:Tao.Sdl.Sdl.SDL_version"/> struct containing the
                compiled version number
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_version.h:
                <code>#define SDL_VERSION(X)
            {
            (X)-&gt;major = SDL_MAJOR_VERSION;
            (X)-&gt;minor = SDL_MINOR_VERSION;
            (X)-&gt;patch = SDL_PATCHLEVEL;
            }</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Linked_Version">
            <summary>
                This function gets the version of the dynamically linked SDL library.
            </summary>
            <returns>
                SDL_version struct
            </returns>
            <remarks>
                <p>
                Binds to C-function call in SDL_version.h:
                <code>extern DECLSPEC const SDL_version * SDLCALL SDL_Linked_Version(void)</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_VERSION_ATLEAST(System.Byte,System.Byte,System.Byte)">
            <summary>
            Will evaluate to true if SDL version is at least X.Y.Z
            </summary>
            <param name="major">Major version number</param>
            <param name="minor">Minor version number</param>
            <param name="patch">Patch version number</param>
            <returns>True if the version of SDL is greater or equal to the version numbers passed in.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_MUSTLOCK(System.IntPtr)">
            <summary>
            Evaluates to true if the surface needs to be locked before access
            </summary>
            <param name="surface"></param>
            <returns>
            1 if surface must be locked. 0 if it does not.
            </returns>
            <remarks>
            <p>Binds to C-function call in SDL_video.h:
                <code>#define SDL_MUSTLOCK(surface) (surface->offset ||	((surface->flags &amp; (SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_RLEACCEL)) != 0))</code>
                </p>
            </remarks>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_VideoDriverName(System.String,System.Int32)">
            <summary>
            This function returns a string with the name of the
            video driver.
            </summary>
            <remarks>
            It returns NULL if no driver has been initialized.
            <p>Binds to C-function call in SDL_video.h:
                <code>extern DECLSPEC char * SDLCALL SDL_VideoDriverName(char *namebuf, int maxlen)</code>
                </p>
            </remarks>
            <returns>
            Returns a string containing the driver name. 
            It returns null if no driver has been initialized.
            </returns>
            <param name="maxlen">
            Length of string
            </param>
            <param name="namebuf">
            A dummy string that must be initialized before being passed in.
            </param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetVideoSurface">
            <summary>
            This function returns a pointer to the current display surface.
            </summary>
            <remarks>
            If SDL is doing format conversion on the display surface, this
            function returns the publicly visible surface, not the real video
            surface. 
            <p>Binds to C-function call in SDL_video.h:
                <code>extern DECLSPEC SDL_Surface * SDLCALL SDL_GetVideoSurface(void)</code>
                </p>
            </remarks>
            <returns>
            It returns a pointer to a SDL_Surface struct.
            </returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetVideoInfo">
            <summary>
            This function returns a read-only pointer to information 
            about the video hardware. 
            </summary>
            <remarks>
            If this is called before <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>, the 'vfmt'
            member of the returned structure will contain the pixel 
            format of the "best" video mode.
            <p>Binds to C-function call in SDL_video.h:
                <code>extern DECLSPEC const SDL_VideoInfo * SDLCALL SDL_GetVideoInfo(void)</code>
                </p>
            </remarks>
            <returns>IntPtr to SDL_VideoInfo struct</returns>
            <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <see cref="T:Tao.Sdl.Sdl.SDL_VideoInfo"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_VideoModeOK(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Check to see if a particular video mode is supported.
            </summary>
            <remarks>
            SDL_VideoModeOK returns 0 if the requested mode is not supported under any 
            bit depth,
            or returns the bits-per-pixel of the closest available mode 
            with the
            given width, height and requested <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/> flags. See <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            <p>The bits-per-pixel value returned is only a suggested mode. 
            You can usually request and bpp you want when setting the video mode 
            and SDL will emulate that color depth with a shadow video surface. 
            </p>
            <p>
            The arguments to SDL_VideoModeOK() are the same ones you would 
            pass to
            <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            </p>
            <p>Binds to C-function call in SDL_video.h:
                <code>extern DECLSPEC int SDLCALL SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags)</code>
                </p>
            </remarks>
            <param name="width">Width of mode</param>
            <param name="height">Height of mode</param>
            <param name="bpp">bit depth of Mode</param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_VideoModeOK(System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            Check to see if a particular video mode is supported.
            </summary>
            <remarks>
            SDL_VideoModeOK returns 0 if the requested mode is not supported under any 
            bit depth,
            or returns the bits-per-pixel of the closest available mode 
            with the
            given width, height and requested <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/> flags. See <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            <p>The bits-per-pixel value returned is only a suggested mode. 
            You can usually request and bpp you want when setting the video mode 
            and SDL will emulate that color depth with a shadow video surface. 
            </p>
            <p>
            The arguments to SDL_VideoModeOK() are the same ones you would 
            pass to
            <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            </p>
            <p>Binds to C-function call in SDL_video.h:
                <code>extern DECLSPEC int SDLCALL SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags)</code>
                </p>
            </remarks>
            <param name="width">Width of mode</param>
            <param name="height">Height of mode</param>
            <param name="bpp">bit depth of Mode</param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ListModes(System.IntPtr,System.Int32)">
            <summary> 
            Return a pointer to an array of available screen dimensions for the 
            given format and video flags, sorted largest to smallest.  
            Returns 
            NULL if there are no dimensions available for a particular format, 
            or (SDL_Rect **)-1 if any dimension is okay for the given format. 
            </summary> 
            <remarks> 
            If 'format' is NULL, the mode list will be for the format given 
            by <see cref="M:Tao.Sdl.Sdl.SDL_GetVideoInfo"/>()-&gt;vfmt. 
            The flag parameter is an OR'd combination of <see cref="T:Tao.Sdl.Sdl.SDL_Surface">surface</see> flags. 
            The flags are the same as those used <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/> and they 
            play a strong role in deciding what modes are valid. 
            For instance, if you pass SDL_HWSURFACE as a flag only modes that 
            support hardware video surfaces will be returned.
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC SDL_Rect ** SDLCALL SDL_ListModes(SDL_PixelFormat *format, Uint32 flags)</code>
                </p>
            </remarks> 
            <param name="format"></param> 
            <param name="flags"></param> 
            <returns>Returns null if no modes are available. If all modes are available returns an empty array.</returns> 
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)">SDL_SetVideoMode</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetVideoInfo">SDL_GetVideoInfo</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Rect">SDL_Rect</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ListModes(System.IntPtr,System.UInt32)">
            <summary> 
            Return a pointer to an array of available screen dimensions for the 
            given format and video flags, sorted largest to smallest.  
            Returns 
            NULL if there are no dimensions available for a particular format, 
            or (SDL_Rect **)-1 if any dimension is okay for the given format. 
            </summary> 
            <remarks> 
            If 'format' is NULL, the mode list will be for the format given 
            by <see cref="M:Tao.Sdl.Sdl.SDL_GetVideoInfo"/>()-&gt;vfmt. 
            The flag parameter is an OR'd combination of <see cref="T:Tao.Sdl.Sdl.SDL_Surface">surface</see> flags. 
            The flags are the same as those used <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/> and they 
            play a strong role in deciding what modes are valid. 
            For instance, if you pass SDL_HWSURFACE as a flag only modes that 
            support hardware video surfaces will be returned.
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC SDL_Rect ** SDLCALL SDL_ListModes(SDL_PixelFormat *format, Uint32 flags)</code>
                </p>
            </remarks> 
            <param name="format"></param> 
            <param name="flags"></param> 
            <returns>Returns null if no modes are available. If all modes are available returns an empty array.</returns> 
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)">SDL_SetVideoMode</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetVideoInfo">SDL_GetVideoInfo</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Rect">SDL_Rect</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set up a video mode with the specified width, height 
            and bits-per-pixel.
            </summary>
            <remarks>
            If 'bpp' is 0, it is treated as the current display bits per pixel.
            <p>
            The flags parameter is the same as the flags field of the SDL_Surface 
            structure. OR'd combinations of the following values are valid.
            </p>
            <list type="table">
            	<listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_SWSURFACE"/></term>
                            <description>Create the video surface in system memory.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_HWSURFACE"/></term>
                            <description>Create the video surface in video memory ,if possible, 
                            and you may have to call SDL_LockSurface()
            in order to access the raw framebuffer.  Otherwise, the video
             surface
            will be created in system memory.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_ASYNCBLIT"/></term>
                            <description>Enables the use of asynchronous updates 
                            of the display surface, but you must always lock before 
            accessing pixels.
            SDL will wait for updates to complete before returning from the
             lock. This will usually slow down 
                            blitting on single CPU machines, but may provide a 
                            speed increase on SMP systems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_ANYFORMAT"/></term>
                            <description>Normally, if a video surface of the 
                            requested bits-per-pixel (bpp) is not available, 
                            SDL will emulate one with a shadow surface. 
                            Passing SDL_ANYFORMAT prevents this and causes 
                            SDL to use the video surface, regardless of its 
                            pixel depth.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_HWPALETTE"/></term>
                            <description>Give SDL exclusive palette access. 
                            Without this flag you may not always get the the 
                            colors you request with <see cref="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/> 
                            or <see cref="M:Tao.Sdl.Sdl.SDL_SetPalette(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/>. You should
             look
            at the video surface structure to determine the actual palette.
            If SDL cannot guarantee that the colors you request can be set, 
            i.e. if the colormap is shared, then the video surface may be
             created
            under emulation in system memory, overriding the SDL_HWSURFACE
             flag.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_DOUBLEBUF"/></term>
                            <description>Enable hardware double buffering; 
                            only valid with SDL_HWSURFACE. Calling <see cref="M:Tao.Sdl.Sdl.SDL_Flip(System.IntPtr)"/> 
                            will flip the buffers and update the screen. 
                            All drawing will take place on the surface that 
                            is not displayed at the moment. If double buffering 
                            could not be enabled then SDL_Flip will just 
                            perform a <see cref="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)"/> 
                            on the entire screen. This is usually slower than the normal 
            single-buffering
            scheme, but prevents "tearing" artifacts caused by modifying video 
            memory while the monitor is refreshing.  It should only be used by 
            applications that redraw the entire screen on every update.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_FULLSCREEN"/></term>
                            <description>SDL will attempt to use a fullscreen mode. 
                            If a hardware resolution change is not possible 
                            (for whatever reason), the next higher resolution 
                            will be used and the display window centered 
                            on a black background. The default is to create a windowed mode
            if the current graphics system has a window manager.
            If the SDL library is able to set a fullscreen video mode, this
             flag 
            will be set in the surface that is returned.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_OPENGL"/></term>
                            <description>Create an OpenGL rendering context. 
                            You should have previously set OpenGL 
                            video attributes with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_OPENGLBLIT"/></term>
                            <description>Create an OpenGL rendering context, 
                            like above, but allow normal blitting operations. 
                            The screen (2D) surface may have an alpha channel,
                            and <see cref="M:Tao.Sdl.Sdl.SDL_UpdateRects(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Rect[])"/> must be used for updating changes 
                            to the screen surface. NOTE: This option is kept for 
                            compatibility only, and is not recommended for new code.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_RESIZABLE"/></term>
                            <description>Create a resizable window. 
                            When the window is resized by the user a 
                            <see cref="F:Tao.Sdl.Sdl.SDL_VIDEORESIZE"/> event is generated and 
                            SDL_SetVideoMode can be called again with the new size.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_NOFRAME"/></term>
                            <description>If possible, SDL_NOFRAME causes 
                            SDL to create a window with no title bar or 
                            frame decoration. Fullscreen modes automatically 
                            have this flag set.
                            </description>
                        </item>
                    </list>
            
            If you rely on functionality provided by certain video flags, 
            check the
            flags of the returned surface to make sure that functionality 
            is available.
            SDL will fall back to reduced functionality if the exact flags 
            you wanted
            are not available.
            <p>Whatever flags SDL_SetVideoMode could satisfy are set 
            in the flags member of the returned surface.</p>
            <p>
             The bpp parameter is the number of bits per pixel, 
             so a bpp of 24 uses the packed representation of 3 bytes/pixel. 
             For the more common 4 bytes/pixel mode, use a bpp of 32. 
             Somewhat oddly, both 15 and 16 will request a 2 bytes/pixel mode, 
             but different pixel formats.
            </p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC SDL_Surface * SDLCALL SDL_SetVideoMode
            (int width, int height, int bpp, Uint32 flags);</code>
            </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">SDL_LockSurface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)">SDL_SetColors</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Flip(System.IntPtr)">SDL_Flip</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
            <param name="width"></param>
            <param name="height"></param>
            <param name="bpp"></param>
            <param name="flags"></param>
            <returns>The framebuffer surface, or NULL if it fails. 
            The surface returned is freed by SDL_Quit() and should not be 
            freed by the caller.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            Set up a video mode with the specified width, height 
            and bits-per-pixel.
            </summary>
            <remarks>
            If 'bpp' is 0, it is treated as the current display bits per pixel.
            <p>
            The flags parameter is the same as the flags field of the SDL_Surface 
            structure. OR'd combinations of the following values are valid.
            </p>
            <list type="table">
            	<listheader>
                            <term>Flag</term>
                            <description>Description</description>
                        </listheader>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_SWSURFACE"/></term>
                            <description>Create the video surface in system memory.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_HWSURFACE"/></term>
                            <description>Create the video surface in video memory ,if possible, 
                            and you may have to call SDL_LockSurface()
            in order to access the raw framebuffer.  Otherwise, the video
             surface
            will be created in system memory.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_ASYNCBLIT"/></term>
                            <description>Enables the use of asynchronous updates 
                            of the display surface, but you must always lock before 
            accessing pixels.
            SDL will wait for updates to complete before returning from the
             lock. This will usually slow down 
                            blitting on single CPU machines, but may provide a 
                            speed increase on SMP systems.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_ANYFORMAT"/></term>
                            <description>Normally, if a video surface of the 
                            requested bits-per-pixel (bpp) is not available, 
                            SDL will emulate one with a shadow surface. 
                            Passing SDL_ANYFORMAT prevents this and causes 
                            SDL to use the video surface, regardless of its 
                            pixel depth.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_HWPALETTE"/></term>
                            <description>Give SDL exclusive palette access. 
                            Without this flag you may not always get the the 
                            colors you request with <see cref="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/> 
                            or <see cref="M:Tao.Sdl.Sdl.SDL_SetPalette(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/>. You should
             look
            at the video surface structure to determine the actual palette.
            If SDL cannot guarantee that the colors you request can be set, 
            i.e. if the colormap is shared, then the video surface may be
             created
            under emulation in system memory, overriding the SDL_HWSURFACE
             flag.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_DOUBLEBUF"/></term>
                            <description>Enable hardware double buffering; 
                            only valid with SDL_HWSURFACE. Calling <see cref="M:Tao.Sdl.Sdl.SDL_Flip(System.IntPtr)"/> 
                            will flip the buffers and update the screen. 
                            All drawing will take place on the surface that 
                            is not displayed at the moment. If double buffering 
                            could not be enabled then SDL_Flip will just 
                            perform a <see cref="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)"/> 
                            on the entire screen. This is usually slower than the normal 
            single-buffering
            scheme, but prevents "tearing" artifacts caused by modifying video 
            memory while the monitor is refreshing.  It should only be used by 
            applications that redraw the entire screen on every update.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_FULLSCREEN"/></term>
                            <description>SDL will attempt to use a fullscreen mode. 
                            If a hardware resolution change is not possible 
                            (for whatever reason), the next higher resolution 
                            will be used and the display window centered 
                            on a black background. The default is to create a windowed mode
            if the current graphics system has a window manager.
            If the SDL library is able to set a fullscreen video mode, this
             flag 
            will be set in the surface that is returned.</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_OPENGL"/></term>
                            <description>Create an OpenGL rendering context. 
                            You should have previously set OpenGL 
                            video attributes with <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_OPENGLBLIT"/></term>
                            <description>Create an OpenGL rendering context, 
                            like above, but allow normal blitting operations. 
                            The screen (2D) surface may have an alpha channel,
                            and <see cref="M:Tao.Sdl.Sdl.SDL_UpdateRects(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Rect[])"/> must be used for updating changes 
                            to the screen surface. NOTE: This option is kept for 
                            compatibility only, and is not recommended for new code.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_RESIZABLE"/></term>
                            <description>Create a resizable window. 
                            When the window is resized by the user a 
                            <see cref="F:Tao.Sdl.Sdl.SDL_VIDEORESIZE"/> event is generated and 
                            SDL_SetVideoMode can be called again with the new size.
                            </description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.SDL_NOFRAME"/></term>
                            <description>If possible, SDL_NOFRAME causes 
                            SDL to create a window with no title bar or 
                            frame decoration. Fullscreen modes automatically 
                            have this flag set.
                            </description>
                        </item>
                    </list>
            
            If you rely on functionality provided by certain video flags, 
            check the
            flags of the returned surface to make sure that functionality 
            is available.
            SDL will fall back to reduced functionality if the exact flags 
            you wanted
            are not available.
            <p>Whatever flags SDL_SetVideoMode could satisfy are set 
            in the flags member of the returned surface.</p>
            <p>
             The bpp parameter is the number of bits per pixel, 
             so a bpp of 24 uses the packed representation of 3 bytes/pixel. 
             For the more common 4 bytes/pixel mode, use a bpp of 32. 
             Somewhat oddly, both 15 and 16 will request a 2 bytes/pixel mode, 
             but different pixel formats.
            </p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC SDL_Surface * SDLCALL SDL_SetVideoMode
            (int width, int height, int bpp, Uint32 flags);</code>
            </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">SDL_LockSurface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)">SDL_SetColors</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_Flip(System.IntPtr)">SDL_Flip</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
            <param name="width"></param>
            <param name="height"></param>
            <param name="bpp"></param>
            <param name="flags"></param>
            <returns>The framebuffer surface, or NULL if it fails. 
            The surface returned is freed by SDL_Quit() and should not be 
            freed by the caller.
            </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UpdateRects(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Rect[])">
            <summary>
            Makes sure the given list of rectangles is updated on the given 
            screen.
            </summary>
            <remarks>
            The rectangles must all be confined within the screen boundaries 
            (no clipping is done).
            <p>
            This function should not be called while screen is 
            <see also="SDL_LockSurface">locked</see>.
            </p>
            <p>Note: It is adviced to call this function only once per frame, 
            since each call has some processing overhead. This is no restriction 
            since you can pass any number of rectangles each time.
            </p>
            <p>The rectangles are not automatically merged or checked for overlap. 
            In general, the programmer can use his knowledge about his particular 
            rectangles to merge them in an efficient way, to avoid overdraw.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC void SDLCALL SDL_UpdateRects (SDL_Surface *screen, int numrects, SDL_Rect *rects)</code>
            </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_UpdateRect</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Rect">SDL_Rect</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">SDL_LockSurface</seealso>
            <param name="screen"></param>
            <param name="numrects"></param>
            <param name="rects"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Makes sure the given area is updated on the given screen. 
            </summary>
            <remarks>
            <p>The rectangle must be confined within the screen boundaries (no 
            clipping is done).
            </p>
            <p>If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the 
            entire screen.</p>
            <p>These functions should not be called while 'screen' is 
            <see cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">locked</see>.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC void SDLCALL SDL_UpdateRect (SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h)</code>
            </p>
            </remarks>
            <param name="screen"></param>
            <param name="w"></param>
            <param name="h"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Makes sure the given area is updated on the given screen. 
            </summary>
            <remarks>
            <p>The rectangle must be confined within the screen boundaries (no 
            clipping is done).
            </p>
            <p>If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the 
            entire screen.</p>
            <p>These functions should not be called while 'screen' is 
            <see cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">locked</see>.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC void SDLCALL SDL_UpdateRect (SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h)</code>
            </p>
            </remarks>
            <param name="screen"></param>
            <param name="w"></param>
            <param name="h"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Flip(System.IntPtr)">
            <summary>
            Swaps screen buffers
            </summary>
            <remarks>
            On hardware that supports double-buffering, this function sets up 
            a flip
            and returns.  The hardware will wait for vertical retrace, and 
            then swap
            video buffers before the next video surface blit or lock will
             return.
            On hardware that does not support double-buffering, this is 
            equivalent
            to calling <see cref="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)"/>(screen, 0, 0, 0, 0)
            <p>
            The SDL_DOUBLEBUF flag must have been passed to <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>
             when
            setting the video mode for this function to perform hardware 
            flipping.</p>
            </remarks>
            <param name="screen"></param>
            <returns>
            This function returns 0 if successful, or -1 if there was an 
            error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)">SDL_SetVideoMode</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_UpdateRect</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetGamma(System.Single,System.Single,System.Single)">
            <summary>
            Set the gamma correction for each of the color channels.
            </summary>
            <remarks>
            <p>Sets the "gamma function" for the display of each color component. 
            Gamma controls the brightness/contrast of colors displayed on the screen.
            A gamma value of 1.0 is identity (i.e., no adjustment is made).
            </p>
            <p>This function adjusts the gamma based on the "gamma function" 
            parameter, you can directly specify lookup tables for gamma adjustment
             with SDL_SetGammaRamp.</p>
             <p>Not all display hardware is able to change gamma.</p>
            <p>The gamma values range (approximately) between 0.1 and 10.0.</p>
            <p>If this function isn't supported directly by the hardware, it will
            be emulated using gamma ramps, if available.  If successful, this
            function returns 0, otherwise it returns -1.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC int SDLCALL SDL_SetGamma(float red, float green, float blue)</code>
            </p>
            </remarks>
            <param name="blue"></param>
            <param name="green"></param>
            <param name="red"></param>
            <returns>
            If successful, this
            function returns 0, otherwise it returns -1.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetGammaRamp(System.Int16[],System.Int16[],System.Int16[])">SDL_GetGammaRamp</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetGammaRamp(System.Int16[],System.Int16[],System.Int16[])">SDL_SetGammaRamp</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetGammaRamp(System.Int16[],System.Int16[],System.Int16[])">
            <summary>
            Set the gamma translation table for the red, green, and blue
             channels
            of the video hardware.  
            </summary>
            <remarks>
            Each table is an array of 256 
            16-bit quantities,
            representing a mapping between the input and output for that 
            channel.
            The input is the index into the array, and the output is the 16-bit
            gamma value at that index, scaled to the output color precision.
            You may pass NULL for any of the channels to leave it unchanged.
            </remarks>
            <returns>
            If the call succeeds, it will return 0.  If the display driver or
            hardware does not support gamma translation, or otherwise fails,
            this function will return -1.
            </returns>
            <param name="blue"></param>
            <param name="green"></param>
            <param name="red"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetGamma(System.Single,System.Single,System.Single)">SDL_SetGamma</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetGammaRamp(System.Int16[],System.Int16[],System.Int16[])">SDL_GetGammaRamp</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetGammaRamp(System.Int16[],System.Int16[],System.Int16[])">
            <summary>
            Gets the color gamma lookup tables for the display.
            </summary>
            <remarks>
            Gets the gamma translation lookup tables currently used by the display. 
            Each table is an array of 256 <see cref="T:System.Int16"/> values.
            <p>
            You must pass in valid pointers to arrays of 256 16-bit quantities.
            Any of the pointers may be NULL to ignore that channel.
            </p>
            <p>Not all display hardware is able to change gamma.
            </p>
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDLCALL SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue)</code>
            </p>
            </remarks>
            <returns>
            If the call succeeds, it will return 0.  If the display driver or
            hardware does not support gamma translation, or otherwise fails,
            this function will return -1.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetGamma(System.Single,System.Single,System.Single)">SDL_SetGamma</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetGammaRamp(System.Int16[],System.Int16[],System.Int16[])">SDL_SetGammaRamp</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetGammaRamp(System.UInt16[],System.UInt16[],System.UInt16[])">
            <summary>
            Gets the color gamma lookup tables for the display.
            </summary>
            <remarks>
            Gets the gamma translation lookup tables currently used by the display. 
            Each table is an array of 256 <see cref="T:System.Int16"/> values.
            <p>
            You must pass in valid pointers to arrays of 256 16-bit quantities.
            Any of the pointers may be NULL to ignore that channel.
            </p>
            <p>Not all display hardware is able to change gamma.
            </p>
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDLCALL SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue)</code>
            </p>
            </remarks>
            <returns>
            If the call succeeds, it will return 0.  If the display driver or
            hardware does not support gamma translation, or otherwise fails,
            this function will return -1.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetGamma(System.Single,System.Single,System.Single)">SDL_SetGamma</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetGammaRamp(System.Int16[],System.Int16[],System.Int16[])">SDL_SetGammaRamp</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)">
             <summary>
             Sets a portion of the colormap for the given 8-bit surface.  		
             </summary>
             <remarks>
             <p>When surface is the surface associated with the current display,
              the display colormap will be updated with the requested colors.
               If SDL_HWPALETTE was set in <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/> flags, SDL_SetColors
                will always return 1, and the palette is guaranteed to be set 
                the way you desire, even if the window colormap has to be warped
                 or run under emulation.</p>
                 
             <p>The color components of a SDL_Color structure are 8-bits in size,
              giving you a total of 256^3 =16777216 colors.</p>
              <p>Palettized (8-bit) screen surfaces with the SDL_HWPALETTE 
                 flag have two palettes, a logical palette that is used for 
                 mapping blits to/from the surface and a physical palette (that 
                 determines how the hardware will map the colors to the display).
                  SDL_SetColors modifies both palettes (if present), and is equivalent
                   to calling SDL_SetPalette with the flags set to 
                   (SDL_LOGPAL | SDL_PHYSPAL).
                   </p>
             <p>When 'surface' is the surface associated with the current 
             display, the
             display colormap will be updated with the requested colors.  If 
             SDL_HWPALETTE was set in SDL_SetVideoMode() flags, SDL_SetColors()
             will always return 1, and the palette is guaranteed to be set 
             the way
             you desire, even if the window colormap has to be warped or 
             run under
             emulation.</p>
             <p>Binds to C-function call in SDL_video.h:
             <code>extern DECLSPEC int SDLCALL SDL_SetColors(SDL_Surface *surface, SDL_Color *colors, int firstcolor, int ncolors)</code>
             </p>
             </remarks>
             <example>/* Create a display surface with a grayscale palette */
            		SDL_Surface *screen;
            		SDL_Color colors[256];
            		int i;
            		.
            		.
            		.
            		/* Fill colors with color information */
            		for(i=0;i&lt;256;i++)
            	{
            		colors[i].r=i;
            		colors[i].g=i;
            		colors[i].b=i;
            	}
            
            	/* Create display */
            	screen=SDL_SetVideoMode(640, 480, 8, SDL_HWPALETTE);
            	if(!screen)
            {
            	printf("Couldn't set video mode: %s\n", SDL_GetError());
            	exit(-1);
            }
            
            	/* Set palette */
            	SDL_SetColors(screen, colors, 0, 256);
            	.
            	.
            	.
            	.
            	</example>
             <param name="surface"></param>
             <param name="firstcolor"></param>
             <param name="ncolors"></param>
             <param name="colors"></param>
             <returns>
             If 'surface' is not a palettized surface, this function does nothing, 
             returning 0.
             If all of the colors were set as passed to SDL_SetColors(), it will
             return 1.  If not all the color entries were set exactly as given,
             it will return 0, and you should look at the surface palette to
             determine the actual color palette.
             </returns>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Color">SDL_Color</seealso>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetPalette(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)">SDL_SetPalette</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)">SDL_SetVideoMode</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetPalette(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)">
             <summary>
             Sets the colors in the palette of an 8-bit surface.
             </summary>
             <remarks>Palettized (8-bit) screen surfaces with the SDL_HWPALETTE 
             flag have two palettes, a logical palette that is used for mapping 
             blits to/from the surface and a physical palette (that determines 
             how the hardware will map the colors to the display). SDL_BlitSurface
              always uses the logical palette when blitting surfaces (if it has to
               convert between surface pixel formats). Because of this, it is often
                useful to modify only one or the other palette to achieve various 
                special color effects (e.g., screen fading, color flashes, screen dimming).
                
                <p>This function can modify either the logical or physical palette 
                by specifing SDL_LOGPAL or SDL_PHYSPALthe in the flags parameter.</p>
                
                <p>When surface is the surface associated with the current display, 
                the display colormap will be updated with the requested colors. 
                If SDL_HWPALETTE was set in SDL_SetVideoMode flags, SDL_SetPalette 
                will always return 1, and the palette is guaranteed to be set the 
                way you desire, even if the window colormap has to be warped or run
                 under emulation.</p>
                 <p>The color components of a SDL_Color structure are 8-bits 
                 in size, giving you a total of 2563=16777216 colors.</p>
             <p>
             'flags' is one or both of:
             SDL_LOGPAL  -- set logical palette, which controls how blits 
             are mapped to/from the surface,
             SDL_PHYSPAL -- set physical palette, which controls how pixels 
             look on the screen
             Only screens have physical palettes. Separate change of 
             physical/logical
             palettes is only possible if the screen has SDL_HWPALETTE set.
            </p>
            
             SDL_SetColors() is equivalent to calling this function with
            	flags = (SDL_LOGPAL|SDL_PHYSPAL).
            	<p>Binds to C-function call in SDL_video.h:
             <code>extern DECLSPEC int SDLCALL SDL_SetPalette(SDL_Surface *surface, int flags, SDL_Color *colors, int firstcolor, int ncolors)</code>
             </p>
                 </remarks>
                 <example><code>
                 /* Create a display surface with a grayscale palette */
            		SDL_Surface *screen;
            		SDL_Color colors[256];
            		int i;
            		.
            		.
            		.
            		/* Fill colors with color information */
            		for(i=0;i&lt;256;i++)
            	{
            		colors[i].r=i;
            		colors[i].g=i;
            		colors[i].b=i;
            	}
            
            	/* Create display */
            	screen=SDL_SetVideoMode(640, 480, 8, SDL_HWPALETTE);
            	if(!screen)
            {
            	printf("Couldn't set video mode: %s\n", SDL_GetError());
            	exit(-1);
            }
            
            	/* Set palette */
            	SDL_SetPalette(screen, SDL_LOGPAL|SDL_PHYSPAL, colors, 0, 256);
            	.
            	.
            	.
            	.</code></example>
             <param name="surface"></param>
             <param name="colors"></param>
             <param name="firstcolor"></param>
             <param name="flags"></param>
             <param name="ncolors"></param>
             <returns>
             If surface is not a palettized surface, this function does 
             nothing, returning 0. If all of the colors were set as passed to 
             SDL_SetPalette, it will return 1. If not all the color entries were
              set exactly as given, it will return 0, and you should look at the
               surface palette to determine the actual color palette.
             </returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)">
            <summary>
            Map a RGB color value to a pixel format.
            </summary>
            <remarks>
            Maps the RGB color value to the specified pixel format and returns the pixel
             value as a 32-bit int.
            <p>If the format has a palette (8-bit) the index of the closest 
            matching color in the palette will be returned.</p>
            <p>If the specified pixel format has an alpha component it will be 
            returned as all 1 bits (fully opaque).</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC Uint32 SDLCALL SDL_MapRGB (SDL_PixelFormat *format, Uint8 r, Uint8 g, Uint8 b)</code>
            </p>
            </remarks>
            <param name="format">IntPtr to <see cref="T:Tao.Sdl.Sdl.SDL_PixelFormat"/></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <returns>A pixel value best approximating the given RGB color 
            value for a given pixel format. If the pixel format bpp (color depth)
             is less than 32-bpp then the unused upper bits of the return value 
             can safely be ignored (e.g., with a 16-bpp format the return value 
             can be assigned to a Uint16, and similarly a Uint8 for an 8-bpp 
             format).</returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGB(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGB</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGBA(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGBA</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)">SDL_MapRGBA</seealso>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Map a RGBA color value to a pixel format.
            </summary>
            <remarks>
            Maps the RGBA color value to the specified pixel format and 
            returns the pixel value as a 32-bit int.
            <p>If the format has a palette (8-bit) the index of the closest 
            matching color in the palette will be returned.</p>
            <p>If the specified pixel format has no alpha component the alpha 
            value will be ignored (as it will be in formats with a palette).</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC Uint32 SDLCALL SDL_MapRGBA (SDL_PixelFormat *format, Uint8 r, Uint8 g, Uint8 b, Uint8 a)</code>
            </p>
            </remarks>
            <param name="format"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns>A pixel value best approximating the given RGBA 
            color value for a given pixel format. If the pixel format 
            bpp (color depth) is less than 32-bpp then the unused upper 
            bits of the return value can safely be ignored (e.g., with a 
            16-bpp format the return value can be assigned to a Uint16, 
            and similarly a Uint8 for an 8-bpp format).</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGB(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGB</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGBA(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGBA</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)">SDL_MapRGB</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso> 
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetRGB(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Get RGB values from a pixel in the specified pixel format.
            </summary>
            <remarks>
            Get RGB component values from a pixel stored in the specified pixel format.
            <p>This function uses the entire 8-bit [0..255] range when converting 
            color components from pixel formats with less than 8-bits per RGB component
             (e.g., a completely white pixel in 16-bit RGB565 format would return 
             [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).</p>
             <p>Binds to C-function call in SDL_video.h:
            <code>void SDL_GetRGB(Uint32 pixel, SDL_PixelFormat *fmt, Uint8 *r, Uint8 *g, Uint8 *b);</code>
            </p>
             </remarks>
            <param name="pixel"></param>
            <param name="fmt"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGBA(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGBA</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)">SDL_MapRGB</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)">SDL_MapRGBA</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetRGB(System.UInt32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Get RGB values from a pixel in the specified pixel format.
            </summary>
            <remarks>
            Get RGB component values from a pixel stored in the specified pixel format.
            <p>This function uses the entire 8-bit [0..255] range when converting 
            color components from pixel formats with less than 8-bits per RGB component
             (e.g., a completely white pixel in 16-bit RGB565 format would return 
             [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).</p>
             <p>Binds to C-function call in SDL_video.h:
            <code>void SDL_GetRGB(Uint32 pixel, SDL_PixelFormat *fmt, Uint8 *r, Uint8 *g, Uint8 *b);</code>
            </p>
             </remarks>
            <param name="pixel"></param>
            <param name="fmt"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGBA(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGBA</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)">SDL_MapRGB</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)">SDL_MapRGBA</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetRGBA(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Get RGBA values from a pixel in the specified pixel format.
            </summary>
            <remarks>
            Get RGBA component values from a pixel stored in the specified pixel 
            format.
            <p>This function uses the entire 8-bit [0..255] range when converting 
            color components from pixel formats with less than 8-bits per RGB 
            component (e.g., a completely white pixel in 16-bit RGB565 format would
             return [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).</p>
            <p>If the surface has no alpha component, the alpha will be returned 
            as 0xff (100% opaque).</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>void SDL_GetRGBA(Uint32 pixel, SDL_PixelFormat *fmt, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a)</code>
            </p>
            </remarks>
            <param name="pixel"></param>
            <param name="fmt"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGB(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGB</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)">SDL_MapRGB</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)">SDL_MapRGBA</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Create an empty SDL_Surface
             </summary>
             <remarks>
             Allocate an empty surface (must be called after <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>).
             <p>If depth is 8 bits an empty palette is allocated for the surface, 
             otherwise a 'packed-pixel' <see cref="T:Tao.Sdl.Sdl.SDL_PixelFormat"/> is created using the 
             [RGBA]mask's provided (see SDL_PixelFormat). The flags specifies 
             the type of surface that should be created, it is an OR'd combination
              of the following possible values.</p>
             <list type="table">
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_SWSURFACE"/></term>
                             <description>
                             SDL will create the surface in system memory. 
                             This improves the performance of pixel level access, 
                             however you may not be able to take advantage of 
                             some types of hardware blitting.
                             </description>
                         </item>
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_HWSURFACE"/></term>
                             <description>
                             SDL will attempt to create the surface in
                              video memory. This will allow SDL to take advantage 
                              of Video-&gt;Video blits (which are often accelerated).
                              </description>
                         </item>
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_SRCCOLORKEY"/></term>
                             <description>
                             This flag turns on colourkeying for 
                             blits from this surface. If SDL_HWSURFACE is also 
                             specified and colourkeyed blits are hardware-accelerated,
                              then SDL will attempt to place the surface in video 
                              memory. Use <see cref="M:Tao.Sdl.Sdl.SDL_SetColorKey(System.IntPtr,System.Int32,System.Int32)"/> 
                              to set or clear this flag
                               after surface creation.
                               </description>
                         </item>
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_SRCALPHA"/></term>
                             <description>
                             This flag turns on alpha-blending for 
                             blits from this surface. If SDL_HWSURFACE is also 
                             specified and alpha-blending blits are 
                             hardware-accelerated, then the surface will be placed 
                             in video memory if possible. Use 
                             <see cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)"/> to set 
                             or clear this flag after surface creation.
                             </description>
                         </item>
                     </list>
                     <p><b>Note:</b> If an alpha-channel is specified (that is, 
                     if Amask is nonzero), then the SDL_SRCALPHA flag is 
                     automatically set. You may remove this flag by 
                     calling <see cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)"/> after surface creation.</p>
             <p>Binds to C-function call in SDL_video.h:
             <code>SDL_Surface *SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)</code>
             </p>
             </remarks>
             <example>
             /* Create a 32-bit surface with the bytes of each pixel in R,G,B,A order,
             as expected by OpenGL for textures */
             SDL_Surface *surface;
             Uint32 rmask, gmask, bmask, amask;
            
             /* SDL interprets each pixel as a 32-bit number, so our masks must depend
               on the endianness (byte order) of the machine */
            #if SDL_BYTEORDER == SDL_BIG_ENDIAN
            		rmask = 0xff000000;
            		gmask = 0x00ff0000;
            		bmask = 0x0000ff00;
            		amask = 0x000000ff;
            #else
                rmask = 0x000000ff;
                gmask = 0x0000ff00;
                bmask = 0x00ff0000;
                amask = 0xff000000;
            #endif
            
            		surface = SDL_CreateRGBSurface(SDL_SWSURFACE, width, height, 32,
            		rmask, gmask, bmask, amask);
            		if(surface == NULL) 
            	{
            		fprintf(stderr, "CreateRGBSurface failed: %s\n", SDL_GetError());
            		exit(1);
            	}
             </example>
             <param name="flags"></param>
             <param name="width"></param>
             <param name="height"></param>
             <param name="depth"></param>
             <param name="Rmask"></param>
             <param name="Gmask"></param>
             <param name="Bmask"></param>
             <param name="Amask"></param>
             <returns>IntPtr to <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/>, or NULL upon error.</returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurfaceFrom(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_CreateRGBSurfaceFrom</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeSurface(System.IntPtr)">SDL_FreeSurface</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)">SDL_SetVideoMode</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">SDL_LockSurface</seealso>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)">SDL_SetAlpha</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetColorKey(System.IntPtr,System.Int32,System.Int32)">SDL_SetColorKey</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.UInt32,System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
             <summary>
             Create an empty SDL_Surface
             </summary>
             <remarks>
             Allocate an empty surface (must be called after <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>).
             <p>If depth is 8 bits an empty palette is allocated for the surface, 
             otherwise a 'packed-pixel' <see cref="T:Tao.Sdl.Sdl.SDL_PixelFormat"/> is created using the 
             [RGBA]mask's provided (see SDL_PixelFormat). The flags specifies 
             the type of surface that should be created, it is an OR'd combination
              of the following possible values.</p>
             <list type="table">
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_SWSURFACE"/></term>
                             <description>
                             SDL will create the surface in system memory. 
                             This improves the performance of pixel level access, 
                             however you may not be able to take advantage of 
                             some types of hardware blitting.
                             </description>
                         </item>
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_HWSURFACE"/></term>
                             <description>
                             SDL will attempt to create the surface in
                              video memory. This will allow SDL to take advantage 
                              of Video-&gt;Video blits (which are often accelerated).
                              </description>
                         </item>
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_SRCCOLORKEY"/></term>
                             <description>
                             This flag turns on colourkeying for 
                             blits from this surface. If SDL_HWSURFACE is also 
                             specified and colourkeyed blits are hardware-accelerated,
                              then SDL will attempt to place the surface in video 
                              memory. Use <see cref="M:Tao.Sdl.Sdl.SDL_SetColorKey(System.IntPtr,System.Int32,System.Int32)"/> 
                              to set or clear this flag
                               after surface creation.
                               </description>
                         </item>
                         <item>
                             <term><see cref="F:Tao.Sdl.Sdl.SDL_SRCALPHA"/></term>
                             <description>
                             This flag turns on alpha-blending for 
                             blits from this surface. If SDL_HWSURFACE is also 
                             specified and alpha-blending blits are 
                             hardware-accelerated, then the surface will be placed 
                             in video memory if possible. Use 
                             <see cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)"/> to set 
                             or clear this flag after surface creation.
                             </description>
                         </item>
                     </list>
                     <p><b>Note:</b> If an alpha-channel is specified (that is, 
                     if Amask is nonzero), then the SDL_SRCALPHA flag is 
                     automatically set. You may remove this flag by 
                     calling <see cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)"/> after surface creation.</p>
             <p>Binds to C-function call in SDL_video.h:
             <code>SDL_Surface *SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)</code>
             </p>
             </remarks>
             <example>
             /* Create a 32-bit surface with the bytes of each pixel in R,G,B,A order,
             as expected by OpenGL for textures */
             SDL_Surface *surface;
             Uint32 rmask, gmask, bmask, amask;
            
             /* SDL interprets each pixel as a 32-bit number, so our masks must depend
               on the endianness (byte order) of the machine */
            #if SDL_BYTEORDER == SDL_BIG_ENDIAN
            		rmask = 0xff000000;
            		gmask = 0x00ff0000;
            		bmask = 0x0000ff00;
            		amask = 0x000000ff;
            #else
                rmask = 0x000000ff;
                gmask = 0x0000ff00;
                bmask = 0x00ff0000;
                amask = 0xff000000;
            #endif
            
            		surface = SDL_CreateRGBSurface(SDL_SWSURFACE, width, height, 32,
            		rmask, gmask, bmask, amask);
            		if(surface == NULL) 
            	{
            		fprintf(stderr, "CreateRGBSurface failed: %s\n", SDL_GetError());
            		exit(1);
            	}
             </example>
             <param name="flags"></param>
             <param name="width"></param>
             <param name="height"></param>
             <param name="depth"></param>
             <param name="Rmask"></param>
             <param name="Gmask"></param>
             <param name="Bmask"></param>
             <param name="Amask"></param>
             <returns>IntPtr to <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/>, or NULL upon error.</returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurfaceFrom(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_CreateRGBSurfaceFrom</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeSurface(System.IntPtr)">SDL_FreeSurface</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)">SDL_SetVideoMode</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">SDL_LockSurface</seealso>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)">SDL_SetAlpha</seealso>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_SetColorKey(System.IntPtr,System.Int32,System.Int32)">SDL_SetColorKey</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AllocSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Same as <see cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <param name="flags"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="depth"></param>
            <param name="Rmask"></param>
            <param name="Gmask"></param>
            <param name="Bmask"></param>
            <param name="Amask"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_AllocSurface(System.UInt32,System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Same as <see cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <param name="flags"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="depth"></param>
            <param name="Rmask"></param>
            <param name="Gmask"></param>
            <param name="Bmask"></param>
            <param name="Amask"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateRGBSurfaceFrom(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create an SDL_Surface from pixel data
            </summary>
            <remarks>
            Creates an SDL_Surface from the provided pixel data.
            <p>
            The data stored in pixels is assumed to be of the depth specified 
            in the parameter list. The pixel data is not copied into the SDL_Surface
             structure so it should not be freed until the surface has been freed 
             with a called to <see cref="M:Tao.Sdl.Sdl.SDL_FreeSurface(System.IntPtr)"/>. pitch is the length of each scanline
              in bytes. </p>
              <p>
            See <see cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> for a more detailed description of the other 
            parameters.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_Surface *SDL_CreateRGBSurfaceFrom(void *pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)</code>
            </p>
            </remarks>
            <param name="pixels"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="depth"></param>
            <param name="pitch">length of each scanline in bytes.</param>
            <param name="Rmask"></param>
            <param name="Gmask"></param>
            <param name="Bmask"></param>
            <param name="Amask"></param>
            <returns>Returns the created surface, or NULL upon error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeSurface(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateRGBSurfaceFrom(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Create an SDL_Surface from pixel data
            </summary>
            <remarks>
            Creates an SDL_Surface from the provided pixel data.
            <p>
            The data stored in pixels is assumed to be of the depth specified 
            in the parameter list. The pixel data is not copied into the SDL_Surface
             structure so it should not be freed until the surface has been freed 
             with a called to <see cref="M:Tao.Sdl.Sdl.SDL_FreeSurface(System.IntPtr)"/>. pitch is the length of each scanline
              in bytes. </p>
              <p>
            See <see cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> for a more detailed description of the other 
            parameters.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_Surface *SDL_CreateRGBSurfaceFrom(void *pixels, int width, int height, int depth, int pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)</code>
            </p>
            </remarks>
            <param name="pixels"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="depth"></param>
            <param name="pitch">length of each scanline in bytes.</param>
            <param name="Rmask"></param>
            <param name="Gmask"></param>
            <param name="Bmask"></param>
            <param name="Amask"></param>
            <returns>Returns the created surface, or NULL upon error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeSurface(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_FreeSurface(System.IntPtr)">
            <summary>
            Frees (deletes) a SDL_Surface
            </summary>
            <remarks>
            Frees the resources used by a previously created <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/>.
            If the surface was created using <see cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurfaceFrom(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> 
            then the pixel data is not freed.
            <p>Binds to C-function call in SDL_video.h:
            <code>void SDL_FreeSurface(SDL_Surface *surface)</code>
            </p>
            </remarks>
            <param name="surface"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_CreateRGBSurface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurfaceFrom(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_CreateRGBSurfaceFrom</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">
             <summary>
             Lock a surface for directly access.
             </summary>
             <remarks>
             SDL_LockSurface sets up a surface for directly accessing the pixels. 
             Between calls to SDL_LockSurface and SDL_UnlockSurface, you can write
              to and read from <i>surface.pixels</i>, using the pixel format stored in 
              <i>surface.format</i>. Once you are done accessing the surface, 
              you should use SDL_UnlockSurface to release it.
             <p>Not all surfaces require locking. If SDL_MUSTLOCK(surface) evaluates
              to 0, then you can read and write to the surface at any time, and the 
              pixel format of the surface will not change. </p>
             <p>No operating system or library calls should be made between 
             lock/unlock pairs, as critical system locks may be held during this time.
             </p>
             <p>It should be noted, that since SDL 1.1.8 surface locks are recursive.
              This means that you can lock a surface multiple times, but each lock
               must have a match unlock. </p>
            <code>
            		.
            		SDL_LockSurface( surface );
            		.
            		/* Surface is locked */
            		/* Direct pixel access on surface here */
            		.
            		SDL_LockSurface( surface );
            		.
            		/* More direct pixel access on surface */
            		.
            		SDL_UnlockSurface( surface );
            		/* Surface is still locked */
            		/* Note: Is versions &lt; 1.1.8, the surface would have been */
            		/* no longer locked at this stage                         */
            		.
            		SDL_UnlockSurface( surface );
            		/* Surface is now unlocked */
            		.
            		</code>
            		<p>Binds to C-function call in SDL_video.h:
             <code>int SDL_LockSurface(SDL_Surface *surface)</code>
             </p>
             </remarks>
             <param name="surface"></param>
             <returns>SDL_LockSurface returns 0, or -1 if the surface couldn't be locked.
             </returns>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_UnlockSurface(System.IntPtr)">SDL_UnlockSurface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UnlockSurface(System.IntPtr)">
            <summary>
            Unlocks a previously locked surface.
            </summary>
            <remarks>
            Surfaces that were previously locked using <see cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)"/> 
            must be unlocked with SDL_UnlockSurface. Surfaces should be 
            unlocked as soon as possible.
            <p>It should be noted that since 1.1.8, surface 
            locks are recursive. See <see cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)"/>.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>void SDL_UnlockSurface(SDL_Surface *surface)</code>
            </p>
            </remarks>
            <param name="surface"></param>
            <returns></returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)">SDL_LockSurface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadBMP_RW(System.IntPtr,System.Int32)">
            <summary>
            Load a surface from a seekable SDL data source (memory or file.)
            </summary>
            <remarks>
            If 'freesrc' is non-zero, the source will be closed after being read.
            Returns the new surface, or NULL if there was an error.
            The new surface should be freed with SDL_FreeSurface().
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_Surface * SDLCALL SDL_LoadBMP_RW(SDL_RWops *src, int freesrc)
            </code></p>
            </remarks>
            <param name="src">IntPtr to SDL_Surface</param>
            <param name="freesrc"></param>
            <returns></returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LoadBMP(System.String)">
            <summary>
            Load a Windows BMP file into an SDL_Surface.
            </summary>
            <remarks>
            Loads a surface from a named Windows BMP file.
            <p>Binds to C-function call in SDL_video.h:
            <code>
            SDL_Surface * SDL_LoadBMP(const char *file)
            #define SDL_LoadBMP(file)	SDL_LoadBMP_RW(SDL_RWFromFile(file, "rb"), 1)
            </code></p>
            </remarks>
            <param name="file"></param>
            <returns>Returns the new surface, or NULL if there was an error.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SaveBMP(System.IntPtr,System.String)">SDL_SaveBMP</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SaveBMP_RW(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Save a surface to a seekable SDL data source (memory or file.)
            </summary>
            <remarks>If 'freedst' is non-zero, the source will be closed after 
            being written.
            <p>Binds to C-function call in SDL_video.h:
            <code>
            int SDLCALL SDL_SaveBMP_RW (SDL_Surface *surface, SDL_RWops *dst, int freedst)
            </code>
            </p>
            </remarks>
            <param name="surface"></param>
            <param name="dst"></param>
            <param name="freedst"></param>
            <returns>Returns 0 if successful or -1 if there was an error.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SaveBMP(System.IntPtr,System.String)">
            <summary>
            Save an SDL_Surface as a Windows BMP file.
            </summary>
            <remarks>
            Saves the SDL_Surface surface as a Windows BMP file named file.
            <p>Binds to C-function call in SDL_video.h:
            <code>
            int SDL_SaveBMP(SDL_Surface *surface, const char *file);
            #define SDL_SaveBMP(surface, file) SDL_SaveBMP_RW(surface, SDL_RWFromFile(file, "wb"), 1)
            </code></p>
            </remarks>
            <param name="file"></param>
            <param name="surface"></param>
            <returns>Returns 0 if successful or -1 if there was an error.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SaveBMP(System.IntPtr,System.String)">SDL_LoadBMP</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetColorKey(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.
            </summary>
            <remarks>
            Sets the color key (transparent pixel) in a blittable surface and 
            enables or disables RLE blit acceleration.
            <p>RLE acceleration can substantially speed up blitting of images 
            with large horizontal runs of transparent pixels (i.e., pixels that
             match the key value). The key must be of the same pixel format as 
             the surface, <see cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/> is often useful for obtaining an acceptable 
             value.</p>
            <p>If flag is SDL_SRCCOLORKEY then key is the transparent pixel value 
            in the source image of a blit.</p>		
            <p>If flag is OR'd with SDL_RLEACCEL then the surface will be draw 
            using RLE acceleration when drawn with <see cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>. The surface 
            will actually be encoded for RLE acceleration the first time 
            <see cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/> or <see cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)"/> is called on the surface.</p>
            <p>If flag is 0, this function clears any current color key.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_SetColorKey(SDL_Surface *surface, Uint32 flag, Uint32 key);
            </code></p>
            </remarks>
            <param name="surface"></param>
            <param name="flag"></param>
            <param name="key"></param>
            <returns>
            This function returns 0, or -1 if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_BlitSurface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)">SDL_DisplayFormat</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)">SDL_MapRGB</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)">SDL_SetAlpha</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetColorKey(System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.
            </summary>
            <remarks>
            Sets the color key (transparent pixel) in a blittable surface and 
            enables or disables RLE blit acceleration.
            <p>RLE acceleration can substantially speed up blitting of images 
            with large horizontal runs of transparent pixels (i.e., pixels that
             match the key value). The key must be of the same pixel format as 
             the surface, <see cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/> is often useful for obtaining an acceptable 
             value.</p>
            <p>If flag is SDL_SRCCOLORKEY then key is the transparent pixel value 
            in the source image of a blit.</p>		
            <p>If flag is OR'd with SDL_RLEACCEL then the surface will be draw 
            using RLE acceleration when drawn with <see cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>. The surface 
            will actually be encoded for RLE acceleration the first time 
            <see cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/> or <see cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)"/> is called on the surface.</p>
            <p>If flag is 0, this function clears any current color key.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_SetColorKey(SDL_Surface *surface, Uint32 flag, Uint32 key);
            </code></p>
            </remarks>
            <param name="surface"></param>
            <param name="flag"></param>
            <param name="key"></param>
            <returns>
            This function returns 0, or -1 if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_BlitSurface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)">SDL_DisplayFormat</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)">SDL_MapRGB</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)">SDL_SetAlpha</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)">
            <summary>
            Adjust the alpha properties of a surface.
            </summary>
            <remarks>
            SDL_SetAlpha is used for setting the per-surface alpha value and/or
            enabling and disabling alpha blending.
            <p>The surface parameter specifies which surface whose alpha 
            attributes you wish to adjust. flags is used to specify whether
             alpha blending should be used (SDL_SRCALPHA) and whether the 
             surface should use RLE acceleration for blitting (SDL_RLEACCEL).
              flags can be an OR'd combination of these two options, one of 
              these options or 0. If SDL_SRCALPHA is not passed as a flag then 
              all alpha information is ignored when blitting the surface. The
               alpha parameter is the per-surface alpha value; a surface 
               need not have an alpha channel to use per-surface alpha and 
               blitting can still be accelerated with SDL_RLEACCEL.</p>
            <p>Note: The per-surface alpha value of 128 is considered a 
            special case and is optimised, so it's much faster than other 
            per-surface values.</p>
            Alpha effects surface blitting in the following ways:
            <list type="table">
                        <item>
                            <term>RGBA-&gt;RGB with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with 
                            the destination, using the alpha channel. 
                            SDL_SRCCOLORKEY and the per-surface alpha 
                            are ignored.</description>
                        </item>
                        <item>
                            <term>RGBA-&gt;RGB without SDL_SRCALPHA</term>
                            <description>The RGB data is copied from the source.
                             The source alpha channel and the per-surface
                              alpha value are ignored.</description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGBA with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with the 
                            destination using the per-surface alpha value. 
                            If SDL_SRCCOLORKEY is set, only the pixels not 
                            matching the colorkey value are copied. The alpha 
                            channel of the copied pixels is set to opaque.
                            </description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGBA without SDL_SRCALPHA</term>
                            <description>The RGB data is copied from the 
                            source and the alpha value of the copied pixels
                             is set to opaque. If SDL_SRCCOLORKEY is set, 
                             only the pixels not matching the colorkey value
                              are copied.</description>
                        </item>
                        <item>
                            <term>RGBA-&gt;RGBA with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with
                             the destination using the source alpha channel.
                              The alpha channel in the destination surface 
                              is left untouched. SDL_SRCCOLORKEY is ignored.
                              </description>
                        </item>
                        <item>
                            <term>RGBA-&gt;RGBA without SDL_SRCALPHA</term>
                            <description>The RGBA data is copied to the destination
                             surface. If SDL_SRCCOLORKEY is set, only the pixels 
                             not matching the colorkey value are copied.
                             </description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGB with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with the 
                            destination using the per-surface alpha value. 
                            If SDL_SRCCOLORKEY is set, only the pixels not 
                            matching the colorkey value are copied.
                            </description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGB without SDL_SRCALPHA</term>
                            <description>The RGB data is copied from the source.
                             If SDL_SRCCOLORKEY is set, only the pixels not 
                             matching the colorkey value are copied.
                             </description>
                        </item>
                    </list>
            <p>Note: Note that RGBA-&gt;RGBA blits (with SDL_SRCALPHA set) keep 
            the alpha of the destination surface. This means that you cannot 
            compose two arbitrary RGBA surfaces this way and get the result 
            you would expect from "overlaying" them; the destination alpha 
            will work as a mask.</p>
            <p>Also note that per-pixel and per-surface alpha cannot be
             combined; the per-pixel alpha is always used if available.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);
            </code></p>
            </remarks>
            <param name="surface"></param>
            <param name="flag"></param>
            <param name="alpha"></param>
            <returns>This function returns 0, or -1 if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)">SDL_MapRGBA</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGBA(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGBA</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayFormatAlpha(System.IntPtr)">SDL_DisplayFormatAlpha</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_BlitSurface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.UInt32,System.Byte)">
            <summary>
            Adjust the alpha properties of a surface.
            </summary>
            <remarks>
            SDL_SetAlpha is used for setting the per-surface alpha value and/or
            enabling and disabling alpha blending.
            <p>The surface parameter specifies which surface whose alpha 
            attributes you wish to adjust. flags is used to specify whether
             alpha blending should be used (SDL_SRCALPHA) and whether the 
             surface should use RLE acceleration for blitting (SDL_RLEACCEL).
              flags can be an OR'd combination of these two options, one of 
              these options or 0. If SDL_SRCALPHA is not passed as a flag then 
              all alpha information is ignored when blitting the surface. The
               alpha parameter is the per-surface alpha value; a surface 
               need not have an alpha channel to use per-surface alpha and 
               blitting can still be accelerated with SDL_RLEACCEL.</p>
            <p>Note: The per-surface alpha value of 128 is considered a 
            special case and is optimised, so it's much faster than other 
            per-surface values.</p>
            Alpha effects surface blitting in the following ways:
            <list type="table">
                        <item>
                            <term>RGBA-&gt;RGB with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with 
                            the destination, using the alpha channel. 
                            SDL_SRCCOLORKEY and the per-surface alpha 
                            are ignored.</description>
                        </item>
                        <item>
                            <term>RGBA-&gt;RGB without SDL_SRCALPHA</term>
                            <description>The RGB data is copied from the source.
                             The source alpha channel and the per-surface
                              alpha value are ignored.</description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGBA with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with the 
                            destination using the per-surface alpha value. 
                            If SDL_SRCCOLORKEY is set, only the pixels not 
                            matching the colorkey value are copied. The alpha 
                            channel of the copied pixels is set to opaque.
                            </description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGBA without SDL_SRCALPHA</term>
                            <description>The RGB data is copied from the 
                            source and the alpha value of the copied pixels
                             is set to opaque. If SDL_SRCCOLORKEY is set, 
                             only the pixels not matching the colorkey value
                              are copied.</description>
                        </item>
                        <item>
                            <term>RGBA-&gt;RGBA with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with
                             the destination using the source alpha channel.
                              The alpha channel in the destination surface 
                              is left untouched. SDL_SRCCOLORKEY is ignored.
                              </description>
                        </item>
                        <item>
                            <term>RGBA-&gt;RGBA without SDL_SRCALPHA</term>
                            <description>The RGBA data is copied to the destination
                             surface. If SDL_SRCCOLORKEY is set, only the pixels 
                             not matching the colorkey value are copied.
                             </description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGB with SDL_SRCALPHA</term>
                            <description>The source is alpha-blended with the 
                            destination using the per-surface alpha value. 
                            If SDL_SRCCOLORKEY is set, only the pixels not 
                            matching the colorkey value are copied.
                            </description>
                        </item>
                        <item>
                            <term>RGB-&gt;RGB without SDL_SRCALPHA</term>
                            <description>The RGB data is copied from the source.
                             If SDL_SRCCOLORKEY is set, only the pixels not 
                             matching the colorkey value are copied.
                             </description>
                        </item>
                    </list>
            <p>Note: Note that RGBA-&gt;RGBA blits (with SDL_SRCALPHA set) keep 
            the alpha of the destination surface. This means that you cannot 
            compose two arbitrary RGBA surfaces this way and get the result 
            you would expect from "overlaying" them; the destination alpha 
            will work as a mask.</p>
            <p>Also note that per-pixel and per-surface alpha cannot be
             combined; the per-pixel alpha is always used if available.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);
            </code></p>
            </remarks>
            <param name="surface"></param>
            <param name="flag"></param>
            <param name="alpha"></param>
            <returns>This function returns 0, or -1 if there was an error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)">SDL_MapRGBA</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetRGBA(System.Int32,System.IntPtr,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">SDL_GetRGBA</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayFormatAlpha(System.IntPtr)">SDL_DisplayFormatAlpha</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_BlitSurface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_SetClipRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">
            <summary>
            Sets the clipping rectangle for a surface.
            </summary>
            <remarks>
            Sets the clipping rectangle for a surface. When this surface 
            is the destination of a blit, only the area within the clip 
            rectangle will be drawn into.
            <p>The rectangle pointed to by rect will be clipped to the 
            edges of the surface so that the clip rectangle for a surface 
            can never fall outside the edges of the surface.</p>
            <p>If rect is NULL the clipping rectangle will be set to the 
            full size of the surface.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>
            void SDL_SetClipRect(SDL_Surface *surface, SDL_Rect *rect)
            </code></p>
            </remarks>
            <param name="surface">IntPtr to SDL_Surface</param>
            <param name="rect">SDL_Rect</param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetClipRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_GetClipRect</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_BlitSurface</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GetClipRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">
            <summary>
            Gets the clipping rectangle for a surface.
            </summary>
            <remarks>
            Gets the clipping rectangle for a surface. 
            When this surface is the destination of a blit, 
            only the area within the clip rectangle is drawn into.
            <p>The rectangle pointed to by rect will be filled with the 
            clipping rectangle of the surface.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>
            void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect)
            </code></p>
            </remarks>
            <param name="surface">IntPtr to SDL_Surface</param>
            <param name="rect">SDL_Rect</param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetClipRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_SetClipRect</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">SDL_BlitSurface</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ConvertSurface(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Converts a surface to the same format as another surface.
            </summary>
            <remarks>
            Creates a new surface of the specified format, 
            and then copies and maps the given surface to it. 
            If this function fails, it returns NULL.
            <p>The flags parameter is passed to 
            <see cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and has those semantics.</p>
            <p>This function is used internally by <see cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)"/>.</p>
            <p>This function can only be called after SDL_Init.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>
            SDL_Surface *SDL_ConvertSurface(SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags)
            </code></p>
            </remarks>
            <param name="src">IntPtr to SDL_Surface</param>
            <param name="fmt">IntPTr to SDL_PixelFormat</param>
            <param name="flags"></param>
            <returns>
            Returns either a pointer to the new surface, or NULL on error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_CreateRGBSurface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)">SDL_DisplayFormat</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_ConvertSurface(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            Converts a surface to the same format as another surface.
            </summary>
            <remarks>
            Creates a new surface of the specified format, 
            and then copies and maps the given surface to it. 
            If this function fails, it returns NULL.
            <p>The flags parameter is passed to 
            <see cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and has those semantics.</p>
            <p>This function is used internally by <see cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)"/>.</p>
            <p>This function can only be called after SDL_Init.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>
            SDL_Surface *SDL_ConvertSurface(SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags)
            </code></p>
            </remarks>
            <param name="src">IntPtr to SDL_Surface</param>
            <param name="fmt">IntPTr to SDL_PixelFormat</param>
            <param name="flags"></param>
            <returns>
            Returns either a pointer to the new surface, or NULL on error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateRGBSurface(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">SDL_CreateRGBSurface</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)">SDL_DisplayFormat</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat">SDL_PixelFormat</seealso>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface">SDL_Surface</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">
             <summary>
             This performs a fast blit from the source surface to the 
             destination surface.
             </summary>
             <remarks>
             This performs a fast blit from the source surface 
             to the destination surface.
             <p>The width and height in srcrect determine the 
             size of the copied rectangle. Only the position is used 
             in the dstrect (the width and height are ignored).</p>
             <p>If srcrect is NULL, the entire surface is copied. 
             If dstrect is NULL, then the destination position 
             (upper left corner) is (0, 0).</p>
             <p>The final blit rectangle is saved in dstrect after all 
             clipping is performed (srcrect is not modified).</p>
             <p>The blit function should not be called on a locked surface.</p>
             <p> The results of blitting operations vary greatly depending 
             on whether SDL_SRCAPLHA is set or not. See SDL_SetAlpha for an
              explaination of how this affects your results. Colorkeying and 
              alpha attributes also interact with surface blitting, as the
              following pseudo-code should hopefully explain. </p>
             <code>if (source surface has SDL_SRCALPHA set) 
            	{
            		if (source surface has alpha channel (that is, format-&gt;Amask != 0))
            		blit using per-pixel alpha, ignoring any colour key
            		else {
            		if (source surface has SDL_SRCCOLORKEY set)
            			blit using the colour key AND the per-surface alpha value
            		else
            			blit using the per-surface alpha value
            		}
            } 
            else 
            {
            if (source surface has SDL_SRCCOLORKEY set)
            blit using the colour key
            else
            ordinary opaque rectangular blit
            }</code>
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_BlitSurface(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect);
            </code></p>
             </remarks>
             <param name="src">IntPtr to SDL_Surface</param>
             <param name="srcrect">IntPtr to SDL_Rect</param>
             <param name="dst">IntPtr to SDL_Surface</param>
             <param name="dstrect">IntPtr to SDL_Rect</param>
             <returns>If the blit is successful, it returns 0, otherwise it 
             returns -1.
             <p>If either of the surfaces were in video memory, 
             and the blit returns -2, the video memory was lost, 
             so it should be reloaded with artwork and re-blitted: </p>
            
             <code>while ( SDL_BlitSurface(image, imgrect, screen, dstrect) == -2 ) 
            	{
            		while ( SDL_LockSurface(image)) &lt; 0 )
            		SDL_Delay(10);
            		-- Write image pixels to image-&gt;pixels --
            		SDL_UnlockSurface(image);
            	}
            	</code>
             <p>This happens under DirectX 5.0 when the system switches away from your 
             fullscreen application. Locking the surface will also fail until you 
             have access to the video memory again.</p>	
             </returns>	
             <seealso cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_FillRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.Int32)"/>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface"/>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Rect"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_FillRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.Int32)">
            <summary>
            This function performs a fast fill of the given rectangle with some color.
            </summary>
            <remarks>
            This function performs a fast fill of the given rectangle with color. 
            If dstrect is NULL, the whole surface will be filled with color.
            <p>The color should be a pixel of the format used by the surface,
             and can be generated by the <see cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/> or 
             <see cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)"/> functions.
              If the color value contains an alpha value then the destination
               is simply "filled" with that alpha information, no blending 
               takes place.</p>
            <p>If there is a clip rectangle set on the destination (set via
             <see cref="M:Tao.Sdl.Sdl.SDL_SetClipRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>) then this function will clip based on the 
             intersection of the clip rectangle and the dstrect rectangle 
             and the dstrect rectangle will be modified to represent the 
             area actually filled.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>
            int SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);
            </code>
            </p>
            </remarks>
            <param name="surface">IntPtr to SDL_Surface</param>
            <param name="rect">IntPtr to SDL_Rect</param>
            <param name="color"></param>
            <returns>
            This function returns 0 on success, or -1 on error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Rect"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_FillRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.UInt32)">
            <summary>
            This function performs a fast fill of the given rectangle with some color.
            </summary>
            <remarks>
            This function performs a fast fill of the given rectangle with color. 
            If dstrect is NULL, the whole surface will be filled with color.
            <p>The color should be a pixel of the format used by the surface,
             and can be generated by the <see cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/> or 
             <see cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)"/> functions.
              If the color value contains an alpha value then the destination
               is simply "filled" with that alpha information, no blending 
               takes place.</p>
            <p>If there is a clip rectangle set on the destination (set via
             <see cref="M:Tao.Sdl.Sdl.SDL_SetClipRect(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>) then this function will clip based on the 
             intersection of the clip rectangle and the dstrect rectangle 
             and the dstrect rectangle will be modified to represent the 
             area actually filled.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>
            int SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);
            </code>
            </p>
            </remarks>
            <param name="surface">IntPtr to SDL_Surface</param>
            <param name="rect">IntPtr to SDL_Rect</param>
            <param name="color"></param>
            <returns>
            This function returns 0 on success, or -1 on error.
            </returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_MapRGBA(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Rect"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)">
            <summary>
            Convert a surface to the display format.
            </summary>
            <remarks>
            This function takes a surface and copies it to a new surface of the 
            pixel format and colors of the video framebuffer, suitable for fast
             blitting onto the display surface. It calls 
             <see cref="M:Tao.Sdl.Sdl.SDL_ConvertSurface(System.IntPtr,System.IntPtr,System.Int32)"/>.
            <p>If you want to take advantage of hardware colorkey or alpha blit
             acceleration, you should set the colorkey and alpha value before 
             calling this function.</p>
            <p>If you want an alpha channel, see 
            <see cref="M:Tao.Sdl.Sdl.SDL_DisplayFormatAlpha(System.IntPtr)"/>.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_Surface *SDL_DisplayFormat(SDL_Surface *surface)
            </code>
            </p>
            </remarks>
            <param name="surface">IntPtr to SDL_Surface</param>
            <returns>IntPtr to SDL_Surface. 
            If the conversion fails or runs out of memory, 
            it returns NULL</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_DisplayFormatAlpha(System.IntPtr)">
            <summary>
            Convert a surface to the display format.
            </summary>
            <remarks>
            This function takes a surface and copies it to a new surface of the 
            pixel format and colors of the video framebuffer plus an alpha channel,
             suitable for fast blitting onto the display surface. 
             It calls <see cref="M:Tao.Sdl.Sdl.SDL_ConvertSurface(System.IntPtr,System.IntPtr,System.Int32)"/>.
            <p>If you want to take advantage of hardware colorkey or alpha blit
             acceleration, you should set the colorkey and alpha value before 
             calling this function.</p>
            <p>This function can be used to convert a colourkey to an alpha 
            channel, if the SDL_SRCCOLORKEY flag is set on the surface. The 
            generated surface will then be transparent (alpha=0) where the
             pixels match the colourkey, and opaque (alpha=255) elsewhere.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_Surface *SDL_DisplayFormatAlpha(SDL_Surface *surface)
            </code></p></remarks>
            <param name="surface"></param>
            <returns>IntPtr to SDL_Surface. 
            If the conversion fails or runs out of memory, 
            it returns NULL</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_ConvertSurface(System.IntPtr,System.IntPtr,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetAlpha(System.IntPtr,System.Int32,System.Byte)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetColorKey(System.IntPtr,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayFormat(System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Surface"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create a YUV video overlay.
            </summary>
            <remarks>
            SDL_CreateYUVOverlay creates a YUV overlay of the specified width, 
            height and format (see <see cref="T:Tao.Sdl.Sdl.SDL_Overlay"/> for a list of 
            available formats),
             for the provided display. A <see cref="T:Tao.Sdl.Sdl.SDL_Overlay"/> 
             structure is returned.
            <p>The term 'overlay' is a misnomer since, unless the overlay is 
            created in hardware, the contents for the display surface underneath
             the area where the overlay is shown will be overwritten when the 
             overlay is displayed.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_Overlay *SDL_CreateYUVOverlay(int width, int height, Uint32 format, SDL_Surface *display)
            </code></p></remarks>
            <param name="width"></param>
            <param name="height"></param>
            <param name="format"></param>
            <param name="display">IntPtr to SDL_Surface</param>
            <returns>IntPtr to SDL_Overlay</returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Overlay"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayYUVOverlay(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeYUVOverlay(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.UInt32,System.IntPtr)">
            <summary>
            Create a YUV video overlay.
            </summary>
            <remarks>
            SDL_CreateYUVOverlay creates a YUV overlay of the specified width, 
            height and format (see <see cref="T:Tao.Sdl.Sdl.SDL_Overlay"/> for a list of 
            available formats),
             for the provided display. A <see cref="T:Tao.Sdl.Sdl.SDL_Overlay"/> 
             structure is returned.
            <p>The term 'overlay' is a misnomer since, unless the overlay is 
            created in hardware, the contents for the display surface underneath
             the area where the overlay is shown will be overwritten when the 
             overlay is displayed.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_Overlay *SDL_CreateYUVOverlay(int width, int height, Uint32 format, SDL_Surface *display)
            </code></p></remarks>
            <param name="width"></param>
            <param name="height"></param>
            <param name="format"></param>
            <param name="display">IntPtr to SDL_Surface</param>
            <returns>IntPtr to SDL_Overlay</returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Overlay"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayYUVOverlay(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_FreeYUVOverlay(System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_LockYUVOverlay(System.IntPtr)">
            <summary>
            Lock an overlay
            </summary>
            <remarks>
            Much the same as <see cref="M:Tao.Sdl.Sdl.SDL_LockSurface(System.IntPtr)"/>, 
            SDL_LockYUVOverlay locks the overlay for direct access to pixel data.
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_LockYUVOverlay(SDL_Overlay *overlay)
            </code></p></remarks>
            <param name="overlay"></param>
            <returns>Returns 0 on success, or -1 on an error</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_UnlockYUVOverlay(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Overlay"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_UnlockYUVOverlay(System.IntPtr)">
            <summary>
            Unlock an overlay.
            </summary>
            <remarks>
            The opposite to <see cref="M:Tao.Sdl.Sdl.SDL_LockYUVOverlay(System.IntPtr)"/>. 
            Unlocks a previously locked overlay. 
            An overlay must be unlocked before it can be displayed.
            <p>Binds to C-function call in SDL_video.h:
            <code>void SDLCALL SDL_UnlockYUVOverlay(SDL_Overlay *overlay)
            </code></p></remarks>
            <param name="overlay">IntPtr to SDL_Overlay</param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_UnlockYUVOverlay(System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Overlay"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_DisplayYUVOverlay(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)">
            <summary>
            Blit the overlay to the display.
            </summary>
            <remarks>
            Blit the overlay to the surface specified when it was <see cref="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)">created</see>. 
            The <see cref="T:Tao.Sdl.Sdl.SDL_Rect"/> structure, dstrect, specifies the position and size of the 
            destination. If the dstrect is a larger or smaller than the overlay then
             the overlay will be scaled, this is optimized for 2x scaling.
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect)
            </code></p></remarks>
            <param name="overlay">IntPtr to SDL_Overlay</param>
            <param name="dstrect">SDL_Rect</param>
            <returns>Returns 0 on success.</returns>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Overlay"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_FreeYUVOverlay(System.IntPtr)">
            <summary>
            Free a YUV video overlay.
            </summary>
            <remarks>
            Frees an <see cref="T:Tao.Sdl.Sdl.SDL_Overlay">overlay</see> created by <see cref="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)"/>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_FreeYUVOverlay(SDL_Overlay *overlay)
            </code></p></remarks>
            <param name="overlay"></param>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Overlay"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_DisplayYUVOverlay(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)"/>
            SDL_Overlay, SDL_DisplayYUVOverlay, SDL_FreeYUVOverlay
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GL_LoadLibrary(System.String)">
            <summary>
            Specify an OpenGL library.
            </summary>
            <remarks>
            If you wish, you may load the OpenGL library at runtime, this must 
            be done before <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/> is called. 
            The path of the GL 
            library is passed to SDL_GL_LoadLibrary and it returns 0 on 
            success, or -1 on 
             an error. You must then use <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetProcAddress(System.String)"/>
              to retrieve 
             function pointers to GL functions.
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_GL_LoadLibrary(const char *path);
            </code></p></remarks>
            <param name="path"></param>
            <returns>Returns 0 on success, or -1 on an error.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetProcAddress(System.String)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GL_GetProcAddress(System.String)">
             <summary>
             Get the address of a GL function
             </summary>
             <remarks>
             Returns the address of the GL function proc, or NULL if the 
             function is not found. If the GL library is loaded at runtime,
              with SDL_GL_LoadLibrary, then all GL functions must be retrieved
               this way. Usually this is used to retrieve function pointers 
               to OpenGL extensions.
             <p>Binds to C-function call in SDL_video.h:
             <code>void *SDL_GL_GetProcAddress(const char* proc);
             </code></p></remarks>
             <example>
             <code>
             typedef void (*GL_ActiveTextureARB_Func)(unsigned int);
            		GL_ActiveTextureARB_Func glActiveTextureARB_ptr = 0;
            		int has_multitexture=1;
            		.
            		.
            		.
            		/* Get function pointer */
            		glActiveTextureARB_ptr=(GL_ActiveTextureARB_Func) SDL_GL_GetProcAddress("glActiveTextureARB");
            
            		/* Check for a valid function ptr */
            		if(!glActiveTextureARB_ptr)
            			{
            		fprintf(stderr, "Multitexture Extensions not present.\n");
            		has_multitexture=0;
            	}
            	.
            	.
            	.
            	.
            	if(has_multitexture)
            {
            	glActiveTextureARB_ptr(GL_TEXTURE0_ARB);
            	.
            	.
            }
            	else
            {
            	.
            	.
            }
             </code>
             </example>
             <param name="proc"></param>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_LoadLibrary(System.String)"/>
             <returns>Returns the address of the GL function proc, or NULL if the 
             function is not found.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GL_SwapBuffers">
            <summary>
            Swap OpenGL framebuffers/Update Display
            </summary>
            <remarks>
            Swap the OpenGL buffers, if double-buffering is supported.
            <p>Binds to C-function call in SDL_video.h:
            <code>void SDL_GL_SwapBuffers(void )
            </code></p></remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)">
            <summary>
            Set a special SDL/OpenGL attribute.
            </summary>
            <remarks>
            Sets the OpenGL attribute attr to value. 
            The attributes you set don't 
            take effect until after a call to <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
             You should use 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/> to check the values after a 
            SDL_SetVideoMode call.
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_GL_SetAttribute(SDL_GLattr attr, int value);
            </code></p></remarks>
            <param name="attr">SDL_GLattr enum</param>
            <param name="val"></param>
            <returns>Returns 0 on success, or -1 on error.</returns>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_GL_GetAttribute(System.Int32,System.Int32@)">
            <summary>
            Get the value of a special SDL/OpenGL attribute
            </summary>
            <remarks>
            Places the value of the SDL/OpenGL 
            attribute attr into value. This is 
            useful after a call to <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/> to check 
            whether your attributes have been 
            <see cref="M:Tao.Sdl.Sdl.SDL_GL_SetAttribute(System.Int32,System.Int32)">set</see> as you expected.
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_GL_GetAttribute(SDLGLattr attr, int *value)
            </code></p>
            </remarks>
            <param name="attr">SDL_GLattr enum</param>
            <param name="val"></param>
            <returns>Returns 0 on success, or -1 on an error.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WM_SetCaption(System.String,System.String)">
            <summary>
            Sets the title and icon text of the display window
            </summary>
            <remarks>
            Sets the title-bar and icon name of the display window.
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC void SDLCALL SDL_WM_SetCaption(const char *title, const char *icon)</code>
            </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_WM_GetCaption(System.String@,System.String@)">SDL_WM_GetCaption</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_WM_SetIcon(System.IntPtr,System.Byte[])">SDL_WM_SetIcon</seealso>
            <param name="title"></param>
            <param name="icon"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WM_GetCaption(System.String@,System.String@)">
            <summary>
            Gets the title and icon text of the display window
            </summary>
            <remarks>
            <p>Binds to C-function call in SDL_video.h:
            <code>extern DECLSPEC void SDLCALL SDL_WM_GetCaption(char **title, char **icon)</code>
            </p></remarks>
            <param name="title"></param>
            <param name="icon"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_WM_SetCaption(System.String,System.String)">SDL_WM_SetCaption</seealso>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_WM_SetIcon(System.IntPtr,System.Byte[])">SDL_WM_SetIcon</seealso>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WM_SetIcon(System.IntPtr,System.Byte[])">
            <summary>
            Sets the icon for the display window.
            </summary>
            <remarks>
            Sets the icon for the display window. Win32 icons must be 32x32.
            <p>This function must be called before the first call to 
            <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>.</p>
            <p>The mask is a bitmask that describes the shape of the icon.
             If mask is NULL, then the shape is determined by the colorkey 
             of icon, if any, or makes the icon rectangular (no transparency)
              otherwise.</p>
            <p>If mask is non-NULL, it points to a bitmap with bits set where
             the corresponding pixel should be visible. The format of the bitmap
              is as follows: Scanlines come in the usual top-down order. Each 
              scanline consists of (width / 8) bytes, rounded up. The most 
              significant bit of each byte represents the leftmost pixel.</p>
            <p>Binds to C-function call in SDL_video.h:
            <code>void SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);
            </code></p>
            </remarks>
            <example>
            <code>SDL_WM_SetIcon(SDL_LoadBMP("icon.bmp"), NULL);
            </code></example>
            <param name="icon">Pointer to an SDL_Surface</param>
            <param name="mask"></param>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_WM_SetCaption(System.String,System.String)"/>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WM_IconifyWindow">
            <summary>Iconify/Minimise the window</summary>
            <remarks>
            This function iconifies/minimizes the window, and returns 1 if it succeeded.
            If the function succeeds, it generates an <see cref="F:Tao.Sdl.Sdl.SDL_APPACTIVE"/> loss event.
            <p>Binds to C-function call in SDL_video.h:
            <code>int SDL_WM_IconifyWindow(void)</code></p>
            </remarks>
            <returns>Returns 1 if it succeeded. 
            This function is a noop and returns 0 in non-windowed environments.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WM_ToggleFullScreen(System.IntPtr)">
             <summary>
             Toggle fullscreen mode without changing the contents of the screen.
             </summary>
             <remarks>If the display surface does not require locking before accessing
             the pixel information, then the memory pointers will not change.
            <p>If this function was able to toggle fullscreen mode (change from 
             running in a window to fullscreen, or vice-versa),
              it will return 1.
             If it is not implemented, or fails, it returns 0.</p>
             <p>The next call to SDL_SetVideoMode() will set the mode fullscreen
             attribute based on the flags parameter - if SDL_FULLSCREEN is not
             set, then the display will be windowed by default where supported.</p>
             <p>This is currently only implemented in the X11 video driver.</p>
             <p>Binds to C-function call in SDL_video.h:
             <code>int SDL_WM_ToggleFullScreen(SDL_Surface *surface);</code></p>
             </remarks>
             <param name="surface"></param>
             <returns>Returns 0 on failure or 1 on success.</returns>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_WM_GrabInput(System.Int32)">
            <summary>
            Grabs mouse and keyboard input.
            </summary>
            <remarks>
            Grabbing means that the mouse is confined to the application 
            window,
            and nearly all keyboard input is passed directly to the 
            application,
            and not interpreted by a window manager, if any.
            <p>
            When mode is SDL_GRAB_QUERY the grab mode is not changed, but the current grab mode is returned.
            </p>
            <p>Binds to C-function call in SDL_video.h:
            <code>SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode)</code></p>
            </remarks>
            <param name="mode">SDL_GrabMode</param>
            <returns>The current/new SDL_GrabMode.
            </returns>
        </member>
        <member name="P:Tao.Sdl.Sdl.AUDIO_U16SYS">
            <summary>
            Native audio byte ordering
            </summary>
            <remarks>
            <p>Based on code from SDL_audio.h
            <code>
            #if SDL_BYTEORDER == SDL_LIL_ENDIAN
            #define AUDIO_U16SYS	AUDIO_U16LSB
            #define AUDIO_S16SYS	AUDIO_S16LSB
            #else
            #define AUDIO_U16SYS	AUDIO_U16MSB
            #define AUDIO_S16SYS	AUDIO_S16MSB
            #endif
            </code>
            </p>
            </remarks>
        </member>
        <member name="P:Tao.Sdl.Sdl.AUDIO_S16SYS">
            <summary>
            Native audio byte ordering
            </summary>
            <remarks>
            <p>Based on code from SDL_audio.h
            <code>
            #if SDL_BYTEORDER == SDL_LIL_ENDIAN
            #define AUDIO_U16SYS	AUDIO_U16LSB
            #define AUDIO_S16SYS	AUDIO_S16LSB
            #else
            #define AUDIO_U16SYS	AUDIO_U16MSB
            #define AUDIO_S16SYS	AUDIO_S16MSB
            #endif
            </code>
            </p>
            </remarks>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_BYTEORDER">
            <summary>
            Returns the endianness of the host system. 
            </summary>
            <remarks>
            </remarks>
            <returns>Returns the endianness of the host system.</returns>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_COMPILEDVERSION">
            <summary>
            This returns the current SDL version
            </summary>
            <remarks>
                 <p>
                Binds to C-function call in SDL_version.h:
                <code>#define SDL_COMPILEDVERSION SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL)</code>
                </p>
            </remarks>
            <returns>
            Returns the version number as a numeric value: (1.2.7 -> 1207)
            </returns>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_AudioSpec">
            <summary>
            Audio Specification Structure
            </summary>
            <remarks>The calculated values in this structure are 
            calculated by SDL_OpenAudio()
            The SDL_AudioSpec structure is used to describe the format of some 
            audio data. This structure is used by SDL_OpenAudio and SDL_LoadWAV.
             While all fields are used by <see cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/> only 
             freq, format, samples
              and channels are used by <see cref="M:Tao.Sdl.Sdl.SDL_LoadWAV(System.String,System.IntPtr@,System.IntPtr@,System.Int32@)"/>. 
              We will detail these common members here.
              <p>Marshals C-struct in SDL_audio.h:
              <code>
              typedef struct{
            	int freq;
            	Uint16 format;
            	Uint8 channels;
            	Uint8 silence;
            	Uint16 samples;
            	Uint32 size;
            	void (*callback)(void *userdata, Uint8 *stream, int len);
            	void *userdata;
            } SDL_AudioSpec;
              </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_LoadWAV(System.String,System.IntPtr@,System.IntPtr@,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.freq">
            <summary>
            Audio frequency in samples per second
            </summary>
            <remarks>
            The number of samples sent to the sound device every second.
             Common values are 11025, 22050 and 44100. The higher the better.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.format">
            <summary>
            Audio data format.
            </summary>
            <remarks>
            Specifies the size and type of each sample element.
            <list type="table">
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.AUDIO_U8"/></term>
                            <description>Unsigned 8-bit samples</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.AUDIO_S8"/></term>
                            <description>Signed 8-bit samples</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.AUDIO_U16"/> <see cref="F:Tao.Sdl.Sdl.AUDIO_U16LSB"/></term>
                            <description>Unsigned 16-bit little-endian samples</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.AUDIO_S16"/> <see cref="F:Tao.Sdl.Sdl.AUDIO_S16LSB"/></term>
                            <description>Signed 16-bit little-endian samples</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.AUDIO_U16MSB"/></term>
                            <description>Unsigned 16-bit big-endian samples</description>
                        </item>
                        <item>
                            <term><see cref="F:Tao.Sdl.Sdl.AUDIO_S16MSB"/></term>
                            <description>Signed 16-bit big-endian samples</description>
                        </item>
                        <item>
                            <term><see cref="P:Tao.Sdl.Sdl.AUDIO_U16SYS"/></term>
                            <description>Either AUDIO_U16LSB or 
                            AUDIO_U16MSB depending on you systems endianness
                            </description>
                        </item>
                        <item>
                            <term><see cref="P:Tao.Sdl.Sdl.AUDIO_S16SYS"/></term>
                            <description>Either AUDIO_S16LSB or 
                            AUDIO_S16MSB depending on you systems endianness
            				</description>
                        </item>
                    </list>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.channels">
            <summary>
            Number of channels: 1 mono, 2 stereo.
            </summary>
            <remarks>
            The number of seperate sound channels. 
            1 is mono (single channel), 2 is stereo (dual channel).
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.silence">
            <summary>
            Audio buffer silence value (calculated).
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.samples">
            <summary>
            Audio buffer size in samples.
            </summary>
            <remarks>
            When used with <see cref="M:Tao.Sdl.Sdl.SDL_OpenAudio(System.IntPtr,System.IntPtr)"/> this refers 
            to the size of the 
            audio buffer in samples. A sample a chunk of audio data
             of the size specified in format mulitplied by the number
              of channels. When the SDL_AudioSpec is used with 
              <see cref="M:Tao.Sdl.Sdl.SDL_LoadWAV(System.String,System.IntPtr@,System.IntPtr@,System.Int32@)"/> samples is set to 4096.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.padding">
            <summary>
            Necessary for some compile environments. Should not be used
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.size">
            <summary>
            Audio buffer size in bytes (calculated)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.callback">
            <summary>
            Callback function for filling the audio buffer
            This function is called when the audio device needs more data.
            'stream' is a pointer to the audio data buffer
            'len' is the length of that buffer in bytes.
            Once the callback returns, the buffer will no longer be valid.
            Stereo samples are stored in a LRLRLR ordering.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioSpec.userdata">
            <summary>
            Pointer the user data which is passed to the callback function
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_AudioCVT">
            <summary>
            Audio Conversion Structure
            </summary>
            <remarks>
            The SDL_AudioCVT is used to convert audio data between different 
            formats. A SDL_AudioCVT structure is created with the 
            <see cref="M:Tao.Sdl.Sdl.SDL_BuildAudioCVT(System.IntPtr,System.Int16,System.Byte,System.Int32,System.Int16,System.Byte,System.Int32)"/> function, while the actual
             conversion is done by the SDL_ConvertAudio function.
            <p>Many of the fields in the <see cref="T:Tao.Sdl.Sdl.SDL_AudioCVT"/> 
            structure should be considered private and their function
             will not be discussed here.</p>
             <p>
             <code>
             typedef struct{
            	int needed;
            	Uint16 src_format;
            	Uint16 dest_format;
            	double rate_incr;
            	Uint8 *buf;
            	int len;
            	int len_cvt;
            	int len_mult;
            	double len_ratio;
            	void (*filters[10])(struct SDL_AudioCVT *cvt, Uint16 format);
            							int filter_index;
            						} SDL_AudioCVT;
             </code></p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_BuildAudioCVT(System.IntPtr,System.Int16,System.Byte,System.Int32,System.Int16,System.Byte,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_ConvertAudio(System.IntPtr)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_AudioSpec"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.needed">
            <summary>
            Set to 1 if conversion possible
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.src_format">
            <summary>
            Audio format of the source
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.dst_format">
            <summary>
            Audio format of the destination
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.rate_incr">
            <summary>
            Rate conversion increment
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.buf">
            <summary>
            Buffer to hold entire audio data
            </summary>
            <remarks>
            This points to the audio data that will be used in the 
            conversion. It is both the source and the destination, 
            which means the converted audio data overwrites the original
             data. It also means that the converted data may be larger 
             than the original data (if you were converting from 8-bit
              to 16-bit, for instance), so you must ensure buf is large
               enough. See below.
            <p>IntPtr to byte</p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.len">
            <summary>
            Length of original audio buffer in bytes
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.len_cvt">
            <summary>
            Length of converted audio buffer in bytes (calculated)
            </summary>
            <remarks>
            This is the length of the original audio data in bytes.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.len_mult">
            <summary>
            buf must be len*len_mult bytes in size(calculated)
            </summary>
            <remarks>
            As explained above, the audio buffer needs to be big enough 
            to store the converted data, which may be bigger than the 
            original audio data. The length of buf should be len*len_mult.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.len_ratio">
            <summary>
            Final audio size is len*len_ratio
            </summary>
            <remarks>
            When you have finished converting your audio data, you need 
            to know how much of your audio buffer is valid. len*len_ratio
             is the size of the converted audio data in bytes. This is 
             very similar to len_mult, however when the convert audio 
             data is shorter than the original len_mult would be 1. 
             len_ratio, on the other hand, would be a fractional 
             number between 0 and 1.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_AudioCVT.filter_index">
            <summary>
            Current audio conversion function
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_CDtrack">
            <summary>
            CD Track Information Structure
            </summary>
            <remarks>
            SDL_CDtrack stores data on each track on a CD, 
            its fields should be pretty self explainatory.
            It is a member a the <see cref="T:Tao.Sdl.Sdl.SDL_CD"/> structure.
            <p>Note: Frames can be converted to standard timings.
            There are CD_FPS frames per second, 
            so SDL_CDtrack.length/CD_FPS=length_in_seconds.</p>
            <p>Struct in SDL_cdrom.h
            <code>
            typedef struct{
            Uint8 id;
            Uint8 type;
            Uint32 length;
            Uint32 offset;
            } SDL_CDtrack;
            </code></p>
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_CD"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CDtrack.id">
            <summary>
            Track number(0-99)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CDtrack.type">
            <summary>
            Data or audio track
            </summary>
            <remarks>
            SDL_AUDIO_TRACK or SDL_DATA_TRACK
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CDtrack.unused">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CDtrack.length">
            <summary>
            Length, in frames, of this track
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CDtrack.offset">
            <summary>
            Offset, in frames, from start of disk
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_CD">
             <summary>
             CDROM Drive Information.
             </summary>
             <remarks>
             An SDL_CD structure is returned by <see cref="M:Tao.Sdl.Sdl.SDL_CDOpen(System.Int32)"/>.
              It represents an
              opened CDROM device and stores information on the layout of the
               tracks on the disc.
             <p>A frame is the base data unit of a CD. CD_FPS frames is equal
              to 1 second of music. SDL provides two macros for converting
               between time and frames: FRAMES_TO_MSF(f, M,S,F) and 
               MSF_TO_FRAMES.</p>
             <p>Struct from SDL_cdrom.h
             <code>
             typedef struct{
             int id;
             CDstatus status;
             int numtracks;
             int cur_track;
             int cur_frame;
             SDL_CDtrack track[SDL_MAX_TRACKS+1];
             } SDL_CD;
             </code></p>
             </remarks>
             <example>
             <code>
             int min, sec, frame;
            		int frame_offset;
            
            		FRAMES_TO_MSF(cdrom-&gt;cur_frame, &amp;min, &amp;sec, &amp;frame);
            		printf("Current Position: %d minutes, %d seconds, %d frames\n", min, sec, frame);
            
            		frame_offset=MSF_TO_FRAMES(min, sec, frame);
             </code>
             </example>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_CDOpen(System.Int32)"/>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_CDtrack"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CD.id">
            <summary>
            Private drive identifier
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CD.status">
            <summary>
            Current drive status
            </summary>
            <remarks>
            SDL_CDStatus enum
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CD.numtracks">
            <summary>
            Number of tracks on the CD
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CD.cur_track">
            <summary>
            Current track
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CD.cur_frame">
            <summary>
            Current frame offset within current track
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_CD.track">
            <summary>
            Array of track descriptions. (see <see cref="T:Tao.Sdl.Sdl.SDL_CDtrack"/>)
            </summary>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CD.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_CDTrackData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_CDTrackData.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_CDTrackData.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_ActiveEvent">
            <summary>
            Application visibility event structure.
            </summary>
            <remarks>
            SDL_ActiveEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             union and is used when an event of type SDL_ACTIVEEVENT 
             is reported.
            <p>When the mouse leaves or enters the window area a 
            SDL_APPMOUSEFOCUS type activation event occurs, if the 
            mouse entered the window then gain will be 1, otherwise
             gain will be 0. A SDL_APPINPUTFOCUS type activation event
              occurs when the application loses or gains keyboard focus. 
              This usually occurs when another application is made active.
               Finally, a SDL_APPACTIVE type event occurs when the application
                is either minimised/iconified (gain=0) or restored.</p>
            <p>Note: This event does not occur when an application window is
             first created.</p>
            <p>Struct in SDL_events.h
            <code>
            typedef struct{
            Uint8 type;
            Uint8 gain;
            Uint8 state;
            } SDL_ActiveEvent;
            </code></p>
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetAppState"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ActiveEvent.type">
            <summary>
            SDL_ACTIVEEVENT
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ActiveEvent.gain">
            <summary>
            0 if the event is a loss or 1 if it is a gain.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ActiveEvent.state">
            <summary>
            SDL_APPMOUSEFOCUS if mouse focus was gained or lost, 
            SDL_APPINPUTFOCUS if input focus was gained or lost, 
            or SDL_APPACTIVE if the application was iconified 
            (gain=0) or restored(gain=1).
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_KeyboardEvent">
            <summary>
            Keyboard event structure
            </summary>
            <remarks>
            SDL_KeyboardEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> union 
            and is used when an event of type SDL_KEYDOWN or SDL_KEYUP is 
            reported.
            <p>The type and state actually report the same information, 
            they just use different values to do it! A keyboard event occurs
             when a key is released (type=SDK_KEYUP or state=SDL_RELEASED) 
             and when a key is pressed (type=SDL_KEYDOWN or state=SDL_PRESSED).
              The information on what key was pressed or released is in the 
              <see cref="T:Tao.Sdl.Sdl.SDL_keysym"/> structure.</p>
            <p>Note: Repeating SDL_KEYDOWN events will occur if key repeat 
            is enabled (see <see cref="M:Tao.Sdl.Sdl.SDL_EnableKeyRepeat(System.Int32,System.Int32)"/>).</p>
            <p>Struct in SDL_events.h
            <code>
            typedef struct{
            	Uint8 type;
            	Uint8 state;
            	SDL_keysym keysym;
            } SDL_KeyboardEvent;
            </code></p>
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_keysym"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_EnableKeyRepeat(System.Int32,System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_EnableUNICODE(System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KeyboardEvent.type">
            <summary>
            SDL_KEYDOWN or SDL_KEYUP
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KeyboardEvent.which">
            <summary>
            The keyboard device index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KeyboardEvent.state">
            <summary>
            SDL_PRESSED or SDL_RELEASED
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_KeyboardEvent.keysym">
            <summary>
            Contains key press information
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_MouseMotionEvent">
            <summary>
            Mouse motion event structure
            </summary>
            <remarks>
            SDL_MouseMotionEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             union and is 
            used when an event of type SDL_MOUSEMOTION is reported.
            <p>Simply put, a SDL_MOUSEMOTION type event occurs when a user
            moves the mouse within the application window or when 
            <see cref="M:Tao.Sdl.Sdl.SDL_WarpMouse(System.Int16,System.Int16)"/>
             is called. Both the absolute (x and y) and relative (xrel and yrel
             ) coordinates are reported along with the current button states 
             (state). The button state can be interpreted using the SDL_BUTTON 
             macro (see <see cref="M:Tao.Sdl.Sdl.SDL_GetMouseState(System.Int32@,System.Int32@)"/>).</p>
            <p>If the cursor is hidden (<see cref="M:Tao.Sdl.Sdl.SDL_ShowCursor(System.Int32)"/>(0))
             and the input is 
            grabbed (<see cref="M:Tao.Sdl.Sdl.SDL_WM_GrabInput(System.Int32)"/>(SDL_GRAB_ON)), 
            then the mouse will give
             relative motion events even when the cursor reaches the edge fo 
             the screen. This is currently only implemented on Windows and 
             Linux/Unix-a-likes.</p>
            <p>Struct in SDL_events.h
            <code>
            typedef struct{
            	Uint8 type;
            	Uint8 which;
            	Uint8 state;
            	Uint16 x, y;
            	Sint16 xrel, yrel;
            } SDL_MouseMotionEvent;
            </code></p>
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_MouseButtonEvent"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseMotionEvent.type">
            <summary>
            SDL_MOUSEMOTION
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseMotionEvent.which">
            <summary>
            The mouse device index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseMotionEvent.state">
            <summary>
            The current button state
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseMotionEvent.x">
            <summary>
            The X coordinate of the mouse
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseMotionEvent.y">
            <summary>
            The Y coordinate of the mouse
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseMotionEvent.xrel">
            <summary>
            The relative motion in the X direction
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseMotionEvent.yrel">
            <summary>
            The relative motion in the Y direction
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_MouseButtonEvent">
            <summary>
            Mouse button event structure
            </summary>
            <remarks>
            SDL_MouseButtonEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             union and is used when an event of type SDL_MOUSEBUTTONDOWN or
              SDL_MOUSEBUTTONUP is reported.
            <p>When a mouse button press or release is detected then number
             of the button pressed (from 1 to 255, with 1 usually being the
              left button and 2 the right) is placed into button, the position
               of the mouse when this event occured is stored in the x and the
                y fields. Like <see cref="T:Tao.Sdl.Sdl.SDL_KeyboardEvent"/>, information on
                 whether the event was a press or a release event is stored in
                  both the type and state fields, but this should be obvious.
                  </p>
                  <p>Struct in SDL_events.h
            <code>
            typedef struct{
            	Uint8 type;
            	Uint8 button;
            	Uint8 state;
            	Uint16 x, y;
            } SDL_MouseButtonEvent;
            </code>
            </p>
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_MouseMotionEvent"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseButtonEvent.type">
            <summary>
            SDL_MOUSEBUTTONDOWN or SDL_MOUSEBUTTONUP
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseButtonEvent.which">
            <summary>
            The mouse device index 
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseButtonEvent.button">
            <summary>
            The mouse button index (SDL_BUTTON_LEFT, 
            SDL_BUTTON_MIDDLE, SDL_BUTTON_RIGHT)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseButtonEvent.state">
            <summary>
            SDL_PRESSED or SDL_RELEASED 
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseButtonEvent.x">
            <summary>
            The X coordinate of the mouse at press/release time
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_MouseButtonEvent.y">
            <summary>
            The Y coordinate of the mouse at press/release time
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_JoyAxisEvent">
            <summary>
            Joystick axis motion event structure
            </summary>
            <remarks>
            SDL_JoyAxisEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> union
             and is used when an event of type SDL_JOYAXISMOTION is reported.
            <p>A SDL_JOYAXISMOTION event occurs when ever a user moves an 
            axis on the joystick. The field which is the index of the 
            joystick that reported the event and axis is the index of the 
            axis (for a more detailed explaination see the Joystick section).
             value is the current position of the axis.</p>
            <p>
            <code>Struct in SDL_cdrom.h
            typedef struct{
            	Uint8 type;
            	Uint8 which;
            	Uint8 axis;
            	Sint16 value;
            } SDL_JoyAxisEvent;
            </code></p>
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickEventState(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetAxis(System.IntPtr,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyAxisEvent.type">
            <summary>
            SDL_JOYAXISMOTION
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyAxisEvent.which">
            <summary>
            The joystick device index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyAxisEvent.axis">
            <summary>
            Joystick axis index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyAxisEvent.val">
            <summary>
            Axis value (range: -32768 to 32767)
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_JoyBallEvent">
            <summary>
            Joystick trackball motion event structure
            </summary>
            <remarks>
            SDL_JoyBallEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> union 
            and is used when an event of type SDL_JOYBALLMOTION is reported.
            <p>A SDL_JOYBALLMOTION event occurs when a user moves a trackball
             on the joystick. The field which is the index of the joystick 
             that reported the event and ball is the index of the trackball
              (for a more detailed explaination see the Joystick section). 
              Trackballs only return relative motion, this is the change 
              in position on the ball since it was last polled (last cycle 
              of the event loop) and it is stored in xrel and yrel.</p>
            <p>Struct in SDL_events.h
            <code>
            typedef struct{
            	Uint8 type;
            	Uint8 which;
            	Uint8 ball;
            	Sint16 xrel, yrel;
            } SDL_JoyBallEvent;
            </code></p></remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickEventState(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetBall(System.IntPtr,System.Int32,System.Int32@,System.Int32@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyBallEvent.type">
            <summary>
            SDL_JOYBALLMOTION
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyBallEvent.which">
            <summary>
            The joystick device index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyBallEvent.ball">
            <summary>
            The joystick trackball index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyBallEvent.xrel">
            <summary>
            The relative motion in the X direction
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyBallEvent.yrel">
            <summary>
            The relative motion in the Y direction
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_JoyHatEvent">
            <summary>
            Joystick hat position change event structure
            </summary>
            <remarks>
            SDL_JoyHatEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> union 
            and is used when an event of type SDL_JOYHATMOTION is reported.
            <p>A SDL_JOYHATMOTION event occurs when ever a user moves a hat 
            on the joystick. The field which is the index of the joystick that
             reported the event and hat is the index of the hat (for a more 
             detailed exlaination see the Joystick section). value is the 
             current position of the hat. It is a logically OR'd combination 
             of the following values (whose meanings should be pretty 
             obvious:) :</p>
            <p>SDL_HAT_CENTERED</p> 
            <p>SDL_HAT_UP</p> 
            <p>SDL_HAT_RIGHT</p>
            <p>SDL_HAT_DOWN</p> 
            <p>SDL_HAT_LEFT</p> 
            <p>The following defines are also provided:</p>
            <p>SDL_HAT_RIGHTUP</p>
            <p>SDL_HAT_RIGHTDOWN</p>
            <p>SDL_HAT_LEFTUP</p> 
            <p>SDL_HAT_LEFTDOWN</p>
            <p>Struct from SDL_events.h
            <code>
            typedef struct{
            	Uint8 type;
            	Uint8 which;
            	Uint8 hat;
            	Uint8 value;
            } SDL_JoyHatEvent;
            </code></p></remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickEventState(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetHat(System.IntPtr,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyHatEvent.type">
            <summary>
            SDL_JOYHATMOTION
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyHatEvent.which">
            <summary>
            The joystick device index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyHatEvent.hat">
            <summary>
            The joystick hat index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyHatEvent.val">
            <summary>
            The hat position value:
             <p><code>SDL_HAT_LEFTUP   SDL_HAT_UP       SDL_HAT_RIGHTUP
             SDL_HAT_LEFT     SDL_HAT_CENTERED SDL_HAT_RIGHT
             SDL_HAT_LEFTDOWN SDL_HAT_DOWN     SDL_HAT_RIGHTDOWN</code></p>
            Note that zero means the POV is centered.
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_JoyButtonEvent">
            <summary>
            Joystick button event structure
            </summary>
            <remarks>
            SDL_JoyButtonEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> 
            union and is used when an event of type SDL_JOYBUTTONDOWN or 
            SDL_JOYBUTTONUP is reported.
            <p>A SDL_JOYBUTTONDOWN or SDL_JOYBUTTONUP event occurs when ever 
            a user presses or releases a button on a joystick. The field which
             is the index of the joystick that reported the event and button 
             is the index of the button (for a more detailed explaination see
              the Joystick section). state is the current state or the button
               which is either SDL_PRESSED or SDL_RELEASED.</p>
            <p>Struct from SDL_events.h
            <code>
            typedef struct{
            	Uint8 type;
            	Uint8 which;
            	Uint8 button;
            	Uint8 state;
            } SDL_JoyButtonEvent;
            </code></p></remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickEventState(System.Int32)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_JoystickGetButton(System.IntPtr,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyButtonEvent.type">
            <summary>
            SDL_JOYBUTTONDOWN or SDL_JOYBUTTONUP
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyButtonEvent.which">
            <summary>
            The joystick device index 
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyButtonEvent.button">
            <summary>
            The joystick button index
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_JoyButtonEvent.state">
            <summary>
            SDL_PRESSED or SDL_RELEASED
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_ResizeEvent">
            <summary>
            Window resized event
            </summary>
            <remarks>
            SDL_ResizeEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> union 
            and is used when an event of type SDL_VIDEORESIZE is reported.
            <p>When SDL_RESIZABLE is passed as a flag to 
            <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/> the user is allowed to resize the
             applications window. When the window is resized an 
             SDL_VIDEORESIZE is report, with the new window width and height
              values stored in w and h, respectively. When an SDL_VIDEORESIZE
               is recieved the window should be resized to the new dimensions
                using <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>.</p>
            <p>Struct in SDL_events.h
            <code>
            typedef struct{
            	Uint8 type;
            	int w, h;
            } SDL_ResizeEvent;
            </code></p></remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ResizeEvent.type">
            <summary>
            SDL_VIDEORESIZE
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ResizeEvent.w">
            <summary>
            New width of the window
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ResizeEvent.h">
            <summary>
            New height of the window
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_ExposeEvent">
            <summary>
            Screen redraw event
            </summary>
            <remarks>
            SDL_ExposeEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> union 
            and is used whan an event of type SDL_VIDEOEXPOSE is reported.
            <p>A VIDEOEXPOSE event is triggered when the screen has been 
            modified outside of the application, usually by the window 
            manager and needs to be redrawn.</p>
            <p>Struct in SDL_events.h
            <code>
            typedef struct{
            	Uint8 type
            	} SDL_ExposeEvent;
            </code>
            </p>
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetEventFilter(Tao.Sdl.Sdl.SDL_EventFilter)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_ExposeEvent.type">
            <summary>
            SDL_VIDEOEXPOSE
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_QuitEvent">
            <summary>
            Quit requested event
            </summary>
            <remarks>
            SDL_QuitEvent is a member of the <see cref="T:Tao.Sdl.Sdl.SDL_Event"/> union 
            and is used whan an event of type SDL_QUIT is reported.
            <p>As can be seen, the SDL_QuitEvent structure serves no useful 
            purpose. The event itself, on the other hand, is very important.
             If you filter out or ignore a quit event then it is impossible 
             for the user to close the window. On the other hand, if you do 
             accept a quit event then the application window will be closed,
              and screen updates will still report success event though the 
              application will no longer be visible.</p>
            <p>Note: The macro SDL_QuitRequested will return non-zero if a 
            quit event is pending</p>
            <p>Struct in SDL_events.h
            <code>
            typedef struct{
            	Uint8 type
            	} SDL_QuitEvent;
            </code></p></remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetEventFilter(Tao.Sdl.Sdl.SDL_EventFilter)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_QuitEvent.type">
            <summary>
            SDL_QUIT
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_UserEvent">
             <summary>
             A user-defined event type
             </summary>
             <remarks>
             SDL_UserEvent is in the user member of the structure 
             <see cref="T:Tao.Sdl.Sdl.SDL_Event"/>. This event is unique, it is never created
              by SDL but only by the user. The event can be pushed onto the 
              event queue using <see cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/>. 
              The contents of the structure 
              members or completely up to the programmer, the only requirement
               is that type is a value from SDL_USEREVENT to SDL_NUMEVENTS-1 
               (inclusive).
             <p>Struct in SDL_events.h
             <code>
             typedef struct{
            		Uint8 type;
            		int code;
            		void *data1;
            		void *data2;
            	} SDL_UserEvent;
             </code>
             </p>
             </remarks>
             <example>
             <code>
             SDL_Event event;
            
            		event.type = SDL_USEREVENT;
            		event.user.code = my_event_code;
            		event.user.data1 = significant_data;
            		event.user.data2 = 0;
            		SDL_PushEvent(&amp;event);
             </code>
             
             </example>
             <seealso cref="T:Tao.Sdl.Sdl.SDL_Event"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_UserEvent.type">
            <summary>
            SDL_USEREVENT through SDL_NUMEVENTS-1
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_UserEvent.code">
            <summary>
            User defined event code
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_UserEvent.data1">
            <summary>
            User defined data pointer
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_UserEvent.data2">
            <summary>
            User defined data pointer
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMEvent">
            <summary>
            Platform-dependent window manager event.
            </summary>
            <remarks>
            The system window manager event contains a pointer to 
            system-specific information about unknown window manager events.
             If you enable this event using <see cref="M:Tao.Sdl.Sdl.SDL_EventState(System.Byte,System.Int32)"/>, 
             it will be generated whenever unhandled events are received from
              the window manager. This can be used, for example, to implement
               cut-and-paste in your application.
               <p>
               If you want to obtain system-specific information about the 
               window manager, you can fill the version member of a 
               SDL_SysWMinfo structure (details can be found in SDL_syswm.h,
                which must be included) using the SDL_VERSION() macro found
                 in SDL_version.h, and pass it to the function:
               </p>
               <p><code>int SDL_GetWMInfo(SDL_SysWMinfo *info);</code></p>
            <p>Struct from SDL_events.h
            <code>
            typedef struct {
            	Uint8 type;   /* Always SDL_SYSWMEVENT */
            	SDL_SysWMmsg *msg;
            } SDL_SysWMEvent;
            </code>
            </p></remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_EventState(System.Byte,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMEvent.type">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMEvent.msg">
            <summary>
            IntPtr to SDL_SysWMmsg
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_Event">
             <summary>
             General event structure
             </summary>
             <remarks>
             The SDL_Event union is the core to all event handling is SDL,
              its probably the most important structure after SDL_Surface.
               SDL_Event is a union of all event structures used in SDL, 
               using it is a simple matter of knowing which union member
                relates to which event type.
             <list type="table">
                         <listheader>
                             <term>Event type</term>
                             <description>Event Structure</description>
                         </listheader>
                         <item>
                             <term>SDL_ACTIVEEVENT</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_ActiveEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_KEYDOWN</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_KeyboardEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_KEYUP</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_KeyboardEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_MOUSEMOTION</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_MouseMotionEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_MOUSEBUTTONDOWN</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_MouseButtonEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_MOUSEBUTTONUP</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_MouseButtonEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_JOYAXISMOTION</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_JoyAxisEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_JOYBALLMOTION</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_JoyBallEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_JOYHATMOTION</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_JoyHatEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_JOYBUTTONDOWN</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_JoyButtonEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_JOYBUTTONUP</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_JoyButtonEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_QUIT</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_QuitEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_SYSWMEVENT</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_SysWMEvent"/></description>
                         </item> 
                         <item>
                             <term>SDL_VIDEORESIZE</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_ResizeEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_VIDEOEXPOSE</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_ExposeEvent"/></description>
                         </item>
                         <item>
                             <term>SDL_USEREVENT</term>
                             <description><see cref="T:Tao.Sdl.Sdl.SDL_UserEvent"/></description>
                         </item>
                     </list>	
             <p>
             The SDL_Event structure has two uses
             <p>Reading events on the event queue</p>
             <p>Placing events on the event queue</p>
             <p>Reading events from the event queue is done with either
              <see cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/> or <see cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>.
               We'll use SDL_PollEvent and step through an example.</p>
             <p>First off, we create an empty SDL_Event structure.</p> 
             <p><code>SDL_Event test_event;</code></p>
             <p>SDL_PollEvent removes the next event from the event queue, if 
             there are no events on the queue it returns 0 otherwise it returns 
             1. We use a while loop to process each event in turn.</p>
             <p><code>while(SDL_PollEvent(&amp;test_event)) { </code></p>
             <p>The SDL_PollEvent function take a pointer to an SDL_Event 
             structure that is to be filled with event information. We know
              that if SDL_PollEvent removes an event from the queue then the
               event information will be placed in our test_event structure, 
               but we also know that the type of event will be placed in the 
               type member of test_event. So to handle each event type 
               seperately we use a switch statement.</p>
             <p><code> switch(test_event.type) { </code></p>
             <p>We need to know what kind of events we're looking for and the
              event type's of those events. So lets assume we want to detect 
              where the user is moving the mouse pointer within our application.
               We look through our event types and notice that SDL_MOUSEMOTION 
               is, more than likely, the event we're looking for. A little more
                research tells use that SDL_MOUSEMOTION events are handled 
                within the <see cref="T:Tao.Sdl.Sdl.SDL_MouseMotionEvent"/> 
                structure which is the motion
                 member of SDL_Event. We can check for the SDL_MOUSEMOTION 
                 event type within our switch statement like so: </p>
             <p><code>case SDL_MOUSEMOTION:</code></p>
             <p>All we need do now is read the information out of the 
             motion member of test_event.</p> 
             <code>
            		printf("We got a motion event.\n");
            		printf("Current mouse position is: (%d, %d)\n", test_event.motion.x, test_event.motion.y);
            		break;
            		default:
            		printf("Unhandled Event!\n");
            		break;
            	}
             }
             printf("Event queue empty.\n");</code>
             <p>It is also possible to push events onto the event queue 
             and so use it as a two-way communication path. Both 
             <see cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/> and <see cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>
              allow you to place events onto the event queue. This is 
              usually used to place a SDL_USEREVENT on the event queue,
               however you could use it to post fake input events if you 
               wished. Creating your own events is a simple matter of 
               choosing the event type you want, setting the type member 
               and filling the appropriate member structure with information.
               </p><p>
             <code>
            SDL_Event user_event;
            
            user_event.type=SDL_USEREVENT;
            user_event.user.code=2;
            user_event.user.data1=NULL;
            user_event.user.data2=NULL;
            SDL_PushEvent(&amp;user_event);
            </code>
             </p>	   
             <p>Union from SDL_events.h
             <code>
             typedef union{
            		Uint8 type;
            		SDL_ActiveEvent active;
            		SDL_KeyboardEvent key;
            		SDL_MouseMotionEvent motion;
            		SDL_MouseButtonEvent button;
            		SDL_JoyAxisEvent jaxis;
            		SDL_JoyBallEvent jball;
            		SDL_JoyHatEvent jhat;
            		SDL_JoyButtonEvent jbutton;
            		SDL_ResizeEvent resize;
            		SDL_ExposeEvent expose;
            		SDL_QuitEvent quit;
            		SDL_UserEvent user;
            		SDL_SywWMEvent syswm;
            	} SDL_Event;
             </code></p></p></remarks>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PollEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PushEvent(Tao.Sdl.Sdl.SDL_Event@)"/>
             <seealso cref="M:Tao.Sdl.Sdl.SDL_PeepEvents(Tao.Sdl.Sdl.SDL_Event[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.type">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.active">
            <summary>
            Activation event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.key">
            <summary>
            Keyboard event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.motion">
            <summary>
            Mouse motion event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.button">
            <summary>
            Mouse button event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.jaxis">
            <summary>
            Joystick axis event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.jball">
            <summary>
            Joystick trackbell event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.jhat">
            <summary>
            Joystick hat motion event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.jbutton">
            <summary>
            Joystick button event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.resize">
            <summary>
            Application window resize event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.expose">
            <summary>
            Application window expose event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.quit">
            <summary>
            Quit request event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.user">
            <summary>
            User defined event
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Event.syswm">
            <summary>
            Undefined window manager event
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_keysym">
            <summary>
            The SDL_keysym structure describes a key press or a key release.
            </summary>
            <remarks>
            The SDL_keysym structure describes a key press or a key release. 
            The scancode field is hardware specific and should be ignored 
            unless you know what your doing. The sym field is the SDLKey 
            value of the key being pressed or released. The mod field 
            describes the state of the keyboard modifiers at the time the 
            key press or release occurred. So a value of KMOD_NUM | KMOD_CAPS
             | KMOD_LSHIFT would mean that Numlock, Capslock and the left shift
              key were all press (or enabled in the case of the lock keys). 
              Finally, the unicode field stores the 16-bit unicode value of 
              the key.
              <p>Note: It should be noted and understood that this field is
               only valid when the SDL_keysym is describing a key press, 
               not a key release. Unicode values only make sense on a key 
               press because the unicode value describes an international 
               character and only key presses produce characters. More 
               information on Unicode can be found at www.unicode.org</p>
              <p>Note: Unicode translation must be enabled using the 
              <see cref="M:Tao.Sdl.Sdl.SDL_EnableUNICODE(System.Int32)"/> function.
              </p>
            <p>Struct in SDL_keyboard.h
            <code>
            typedef struct{
            	Uint8 scancode;
            	SDLKey sym;
            	SDLMod mod;
            	Uint16 unicode;
            } SDL_keysym;
            </code></p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_keysym.scancode">
            <summary>
            Hardware specific scancode.
            </summary>
            <remarks>
            The scancode is hardware dependent, 
            and should not be used by general
            applications.  
            If no hardware scancode is available, it will be 0.
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_keysym.sym">
            <summary>
            SDL virtual keysym.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_keysym.mod">
            <summary>
            Current key modifiers.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_keysym.unicode">
            <summary>
            Translated character.
            </summary>
            <remarks>
            The 'unicode' translated character is only available 
            when character
            translation is enabled by the SDL_EnableUNICODE() API.  
            If non-zero,
            this is a UNICODE character corresponding to the keypress.  
            If the
            high 9 bits of the character are 0, 
            then this maps to the equivalent
            ASCII character:
            <p><code>
            	char ch;
            if ( (keysym.unicode and 0xFF80) == 0 ) {
            	ch = keysym.unicode and 0x7F;
            } else {
            	An international character..
            }</code></p>
            </remarks>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_Cursor">
            <summary>
            Structure to hold cursor
            </summary>
            <remarks>
            <p>Struct in SDL_mouse.h
            <code>
            struct {
            	SDL_Rect area;			/* The area of the mouse cursor */
            	Sint16 hot_x, hot_y;		/* The "tip" of the cursor */
            	Uint8 *data;			/* B/W cursor data */
            	Uint8 *mask;			/* B/W cursor mask */
            	Uint8 *save[2];			/* Place to save cursor area */
            	WMcursor *wm_cursor;		/* Window-manager cursor */
            } SDL_Cursor
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Cursor.area">
            <summary>
            The area of the mouse cursor
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Cursor.hot_x">
            <summary>
            The "tip" of the cursor
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Cursor.hot_y">
            <summary>
            The "tip" of the cursor
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Cursor.data">
            <summary>
            B/W cursor data
            </summary>
            <remarks>
            IntPtr to byte
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Cursor.mask">
            <summary>
            B/W cursor mask
            </summary>
            <remarks>
            IntPtr to byte
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Cursor.save">
            <summary>
            Place to save cursor area
            </summary>
            <remarks>
            IntPtr to byte[2]
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Cursor.wm_cursor">
            <summary>
            Window-manager cursor
            </summary>
            <remarks>
            IntPtr to WMcursor
            </remarks>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMmsg_Unix">
            <summary>
            The UNIX custom event structure. TODO
            </summary>
            <remarks>
            <p>Struct in SDL_syswm.h
            <code>
            struct SDL_SysWMmsg {
            	SDL_version version;
            	SDL_SYSWM_TYPE subsystem;
            	union 
            	{
            	XEvent xevent;
            	} event;
            };		
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_Unix.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_Unix.subsystem">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMinfo_Unix">
             <summary>
             The UNIX custom window manager information structure. TODO
             </summary>
             <remarks>
             When this structure is returned, it holds information about which
             low level system it is using, and will be one of SDL_SYSWM_TYPE.
             <p>Struct in SDL_syswm.h
             <code>
             struct SDL_SysWMinfo {
            		SDL_version version;
            		SDL_SYSWM_TYPE subsystem;
            		union 
            		{
            		struct 
            		{
            			Display *display;	/* The X11 display */
            			Window window;		/* The X11 display window */
            			/* These locking functions should be called around
            					   any X11 functions using the display variable.
            					   They lock the event thread, so should not be
            			   called around event functions or from event filters.
            			 */
            			void (*lock_func)(void);
            			void (*unlock_func)(void);
            
            			/* Introduced in SDL 1.0.2 */
            			Window fswindow;	/* The X11 fullscreen window */
            			Window wmwindow;	/* The X11 managed input window */
            		} x11;
            	 } info;
             } SDL_SysWMinfo;		
             </code>
             </p>
             </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_Unix.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_Unix.subsystem">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMmsg_Windows">
            <summary>
            The Windows custom event structure. TODO
            </summary>
            <remarks>
            <p>Struct in SDL_syswm.h
            <code>
            struct SDL_SysWMmsg {
            SDL_version version;
            HWND hwnd;
            UINT msg;
            WPARAM wParam;
            LPARAM lParam;
            };		
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_Windows.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_Windows.hwnd">
            <summary>
            The window for the message
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_Windows.msg">
            <summary>
            The type of message
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_Windows.wParam">
            <summary>
            WORD message parameter
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_Windows.lParam">
            <summary>
            LONG message parameter
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMinfo_Windows">
            <summary>
            The Windows custom window manager information structure. TODO
            </summary>
            <remarks>
            <p>Struct in SDL_syswm.h
            <code>
            struct SDL_SysWMinfo {
            SDL_version version;
            HWND window;
            HGLRC hglrc;
            } SDL_SysWMinfo;		
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_Windows.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_Windows.window">
            <summary>
            The Win32 display window
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_Windows.hglrc">
            <summary>
            The OpenGL context, if any
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMmsg_RiscOS">
            <summary>
            RISC OS custom event structure
            </summary>
            <remarks>
            <p>Struct in SDL_syswm.h
            <code>
            struct SDL_SysWMmsg {
            SDL_version version;
            int eventCode;
            int pollBlock[64];
            };		
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_RiscOS.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_RiscOS.eventCode">
            <summary>
            The window for the message
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg_RiscOS.pollBlock">
            <summary>
            The window for the message
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMinfo_RiscOS">
            <summary>
            The RISCOS custom window manager information structure 
            </summary>
            <remarks>
            <p>Struct in SDL_syswm.h
            <code>
            struct SDL_SysWMinfo {
            SDL_version version;
            int wimpVersion;
            int taskHandle;
            int window;
            };		
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_RiscOS.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_RiscOS.wimpVersion">
            <summary>
            Wimp version running under
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_RiscOS.taskHandle">
            <summary>
            The RISCOS task handle
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo_RiscOS.window">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMmsg">
            <summary>
            The generic custom event structure
            </summary>
            <remarks>
            <p>Struct in SDL_syswm.h
            <code>
            struct SDL_SysWMmsg {
            SDL_version version;
            int data;
            };		
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMmsg.data">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_SysWMinfo">
            <summary>
            The generic custom window manager information structure 
            </summary>
            <remarks>
            <p>Struct in SDL_syswm.h
            <code>
            struct SDL_SysWMinfo {
            SDL_version version;
            int data;
            };		
            </code>
            </p>
            </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo.version">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_SysWMinfo.data">
            <summary>
            
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_TimerID">
            <summary>
                
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_version">
            <summary>
            Structure to hold version number of the SDL library
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_version.major">
            <summary>
            Major version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_version.minor">
            <summary>
            Minor version
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_version.patch">
            <summary>
            Patch version
            </summary>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_version.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_Rect">
            <summary>
            Defines a rectangular area.
            </summary>
            <remarks>
            A SDL_Rect defines a rectangular area of pixels. 
            It is used by <see cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/> to define blitting 
            regions and by several other video functions.
            </remarks>
            <see cref="M:Tao.Sdl.Sdl.SDL_BlitSurface(System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@,System.IntPtr,Tao.Sdl.Sdl.SDL_Rect@)"/>
            <see cref="M:Tao.Sdl.Sdl.SDL_UpdateRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Rect.x">
            <summary>
            x position of the upper-left corner of the rectangle.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Rect.y">
            <summary>
            y position of the upper-left corner of the rectangle. 
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Rect.w">
            <summary>
            The width of the rectangle.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Rect.h">
            <summary>
            The height of the rectangle.
            </summary>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Rect.#ctor(System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
            <param name="h"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Rect.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_Color">
            <summary>
            Format independent color description
            </summary>
            <remarks>
            SDL_Color describes a color in a format independent way. 
            You can convert a SDL_Color to a pixel value for a certain 
            pixel format using <see cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/>.
            </remarks>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_PixelFormat"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/>
            <seealso cref="T:Tao.Sdl.Sdl.SDL_Palette"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Color.r">
            <summary>
            Red Intensity
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Color.g">
            <summary>
            Green Intensity
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Color.b">
            <summary>
            Blue Intensity
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Color.unused">
            <summary>
            Alpha Channel
            Currently unused
            </summary>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Color.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_Color.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_Palette">
            <summary>
            Color palette for 8-bit pixel formats
            </summary>
            <remarks>
            Each pixel in an 8-bit surface is an index into 
            the colors field of the SDL_Palette structure store 
            in <see cref="T:Tao.Sdl.Sdl.SDL_PixelFormat"/>. A SDL_Palette should never need 
            to be created manually. It is automatically created 
            when SDL allocates a <see cref="T:Tao.Sdl.Sdl.SDL_PixelFormat"/> for a surface. 
            The colors values of a <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/> 
            palette can be set with the <see cref="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/>.
            </remarks>
            <see cref="T:Tao.Sdl.Sdl.SDL_Color"/>
            <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/>
            <see cref="M:Tao.Sdl.Sdl.SDL_SetColors(System.IntPtr,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/>
            <see cref="M:Tao.Sdl.Sdl.SDL_SetPalette(System.IntPtr,System.Int32,Tao.Sdl.Sdl.SDL_Color[],System.Int32,System.Int32)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Palette.ncolors">
            <summary>
            Number of colors used in this palette
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Palette.colors">
            <summary>
            Array of <see cref="T:Tao.Sdl.Sdl.SDL_Color"/> 
            structures that make up the palette.
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_PixelFormat">
             <summary>
             Stores surface format information
             </summary>
             <remarks>
             A SDL_PixelFormat describes the format of the pixel data stored at the 
             pixels field of a SDL_Surface. Every surface stores a SDL_PixelFormat 
             in the format field.
             <p>
             If you wish to do pixel level modifications on a surface, then 
            	understanding how SDL stores its color information is essential.
             </p>
             <p>							
             8-bit pixel formats are the easiest to understand. 
             Since its an 8-bit format, we have 8 BitsPerPixel and 1 BytesPerPixel.
             Since BytesPerPixel is 1, all pixels are represented by a Uint8 which
             contains an index into palette.colors. So, to determine the color 
             of a pixel in a 8-bit surface: we read the color index from 
             surface.pixels and we use that index to read the SDL_Color 
             structure from surface.format.palette.colors. Like so: 
             </p>	
             <p>
             <code>
            		SDL_Surface *surface;
            		SDL_PixelFormat *fmt;
            		SDL_Color *color;
            		Uint8 index;
            
            		.
            		.
            
            		/* Create surface */
            		.
            		.
            		fmt=surface.format;
            
            		/* Check the bitdepth of the surface */
            		if(fmt.BitsPerPixel!=8)
            	{
            		fprintf(stderr, "Not an 8-bit surface.\n");
            		return(-1);
            	}
            
            	/* Lock the surface */
            	SDL_LockSurface(surface);
            
            	/* Get the topleft pixel */
            	index=*(Uint8 *)surface.pixels;
            	color=fmt.palette.colors[index];
            
            	/* Unlock the surface */
            	SDL_UnlockSurface(surface);
            	printf("Pixel Color- Red: %d, Green: %d, Blue: %d. Index: %d\n",
            	color.r, color.g, color.b, index);
            	.
            	.
            	</code>
             </p>
             <P>
            	Pixel formats above 8-bit are an entirely different experience. 
            	They are considered to be "TrueColor" formats and the color 
            	information is stored in the pixels themselves, not in a palette. 
            	The mask, shift and loss fields tell us how the color information
            	is encoded. The mask fields allow us to isolate each color 
            	component, the shift fields tell us the number of bits to the 
            	right of each component in the pixel value and the loss fields
            	tell us the number of bits lost from each component when 
            	packing 8-bit color component in a pixel. 
            	</P>
            
            <code>
            	/* Extracting color components from a 32-bit color value */
            	SDL_PixelFormat *fmt;
            	SDL_Surface *surface;
            	Uint32 temp, pixel;
            	Uint8 red, green, blue, alpha;
            	.
            	.
            	.
            	fmt=surface.format;
            	SDL_LockSurface(surface);
            	pixel=*((Uint32*)surface.pixels);
            	SDL_UnlockSurface(surface);
            
            	/* Get Red component */
            	temp=pixel&amp;fmt.Rmask; /* Isolate red component */
            	temp=temp&gt;&gt;fmt.Rshift;/* Shift it down to 8-bit */
            	temp=temp&lt;&lt;fmt.Rloss; /* Expand to a full 8-bit number */
            	red=(Uint8)temp;
            
            	/* Get Green component */
            	temp=pixel&amp;fmt.Gmask; /* Isolate green component */
            	temp=temp&gt;&gt;fmt.Gshift;/* Shift it down to 8-bit */
            	temp=temp&lt;&lt;fmt.Gloss; /* Expand to a full 8-bit number */
            	green=(Uint8)temp;
            
            	/* Get Blue component */
            	temp=pixel&amp;fmt.Bmask; /* Isolate blue component */
            	temp=temp&gt;&gt;fmt.Bshift;/* Shift it down to 8-bit */
            	temp=temp&lt;&lt;fmt.Bloss; /* Expand to a full 8-bit number */
            	blue=(Uint8)temp;
            
            	/* Get Alpha component */
            	temp=pixel&amp;fmt.Amask; /* Isolate alpha component */
            	temp=temp&gt;&gt;fmt.Ashift;/* Shift it down to 8-bit */
            	temp=temp&lt;&lt;fmt.Aloss; /* Expand to a full 8-bit number */
            	alpha=(Uint8)temp;
            
            	printf("Pixel Color - R: %d,  G: %d,  B: %d,  A: %d\n", red, green, blue, alpha);
            	.
            	.
            	.
            	</code>
             </remarks>
             <see cref="T:Tao.Sdl.Sdl.SDL_Surface"/>
             <see cref="M:Tao.Sdl.Sdl.SDL_MapRGB(System.IntPtr,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.palette">
            <summary>
            Pointer to the palette, or NULL if the BitsPerPixel&gt;8
            Pointer to <see cref="T:Tao.Sdl.Sdl.SDL_Palette"/>
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.BitsPerPixel">
            <summary>
            The number of bits used to represent each pixel in a surface. 
            Usually 8, 16, 24 or 32.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.BytesPerPixel">
            <summary>
            The number of bytes used to represent each pixel in a surface. 
            Usually one to four.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Rloss">
            <summary>
            Precision loss of each color component (2[RGBA]loss)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Gloss">
            <summary>
            Precision loss of each color component (2[RGBA]loss)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Bloss">
            <summary>
            Precision loss of each color component (2[RGBA]loss)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Aloss">
            <summary>
            Precision loss of each color component (2[RGBA]loss)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Rshift">
            <summary>
            Binary left shift of each color component in the pixel value
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Gshift">
            <summary>
            Binary left shift of each color component in the pixel value
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Bshift">
            <summary>
            Binary left shift of each color component in the pixel value
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Ashift">
            <summary>
            Binary left shift of each color component in the pixel value
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Rmask">
            <summary>
            Binary mask used to retrieve individual color values
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Gmask">
            <summary>
            Binary mask used to retrieve individual color values
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Bmask">
            <summary>
            Binary mask used to retrieve individual color values
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.Amask">
            <summary>
            Binary mask used to retrieve individual color values
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.colorkey">
            <summary>
            Pixel value of transparent pixels
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_PixelFormat.alpha">
            <summary>
            Overall surface alpha value
            </summary>
        </member>
        <member name="M:Tao.Sdl.Sdl.SDL_PixelFormat.#ctor(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte)">
            <summary>
            
            </summary>
            <param name="palette"></param>
            <param name="BitsPerPixel"></param>
            <param name="BytesPerPixel"></param>
            <param name="Rloss"></param>
            <param name="Gloss"></param>
            <param name="Bloss"></param>
            <param name="Aloss"></param>
            <param name="Rshift"></param>
            <param name="Gshift"></param>
            <param name="Bshift"></param>
            <param name="Ashift"></param>
            <param name="Rmask"></param>
            <param name="Gmask"></param>
            <param name="Bmask"></param>
            <param name="Amask"></param>
            <param name="colorkey"></param>
            <param name="alpha"></param>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_Surface">
             <summary>
             Graphical Surface Structure.
             </summary>
             <remarks>
             This structure should be treated as read-only, except for 'pixels',
             which, if not NULL, contains the raw pixel data for the surface.
             SDL_Surface's represent areas of "graphical" memory, memory 
             that can be drawn to. The video framebuffer is returned as a 
             SDL_Surface by SDL_SetVideoMode and SDL_GetVideoSurface. 
             Most of the fields should be pretty obvious. w and h are the 
             width and height of the surface in pixels. pixels is a pointer 
             to the actual pixel data, the surface should be locked before 
             accessing this field. The clip_rect field is the clipping rectangle
             as set by SDL_SetClipRect.
            
             <p>The following are supported in the flags field.</p>
            <code>
             SDL_SWSURFACE Surface is stored in system memory
             SDL_HWSURFACE Surface is stored in video memory
             SDL_ASYNCBLIT Surface uses asynchronous blits if possible
             SDL_ANYFORMAT Allows any pixel-format (Display surface)
             SDL_HWPALETTE Surface has exclusive palette
             SDL_DOUBLEBUF Surface is double buffered (Display surface)
             SDL_FULLSCREEN Surface is full screen (Display Surface)
             SDL_OPENGL Surface has an OpenGL context (Display Surface)
             SDL_OPENGLBLIT Surface supports OpenGL blitting (Display Surface)
             SDL_RESIZABLE Surface is resizable (Display Surface)
             SDL_HWACCEL Surface blit uses hardware acceleration
             SDL_SRCCOLORKEY Surface use colorkey blitting
             SDL_RLEACCEL Colorkey blitting is accelerated with RLE
             SDL_SRCALPHA Surface blit uses alpha blending
             SDL_PREALLOC Surface uses preallocated memory</code>
             </remarks>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.flags">
            <summary>
            Surface flags
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.format">
            <summary>
            Pixel format
            Pointer to SDL_PixelFormat
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.w">
            <summary>
            Width of the surface
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.h">
            <summary>
            Height of the surface
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.pitch">
            <summary>
            Length of a surface scanline in bytes
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.pixels">
            <summary>
            Pointer to the actual pixel data
            Void pointer.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.hwdata">
            <summary>
            Hardware-specific surface info
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.clip_rect">
            <summary>
            surface clip rectangle
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.unused1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.locked">
            <summary>
            Allow recursive locks
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.map">
            <summary>
            info for fast blit mapping to other surfaces
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.format_version">
            <summary>
            format version, bumped at every change to invalidate blit maps
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Surface.refcount">
            <summary>
            Reference count -- used when freeing surface
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_VideoInfo">
            <summary>
            Video Target information.
            Useful for determining the video hardware capabilities.
            Not finished. The C struct uses a set of bit-fields that need to be marshalled.
            The vfmt IntPtr works and provided useful information.
            </summary>
            <remarks>
            This (read-only) structure is returned by <see cref="M:Tao.Sdl.Sdl.SDL_GetVideoInfo"/>. 
            It contains information on either the 'best' available mode 
            (if called before <see cref="M:Tao.Sdl.Sdl.SDL_SetVideoMode(System.Int32,System.Int32,System.Int32,System.Int32)"/>) or the current video mode.
            </remarks>
            <see cref="M:Tao.Sdl.Sdl.SDL_GetVideoInfo"/>
            <see cref="T:Tao.Sdl.Sdl.SDL_PixelFormat"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VideoInfo.field1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VideoInfo.field2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VideoInfo.unused">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VideoInfo.video_mem">
            <summary>
            Total amount of video memory in Kilobytes.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VideoInfo.vfmt">
            <summary>
            Pixel format of the video device. Pointer to SDL_PixelFormat.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VideoInfo.current_w">
            <summary>
             The current video mode width
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_VideoInfo.current_h">
            <summary>
             The current video mode height
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.hw_available">
            <summary>
            Is it possible to create hardware surfaces?
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.wm_available">
            <summary>
            Is there a window manager available
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.blit_hw">
            <summary>
            Are hardware to hardware blits accelerated?
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.blit_hw_CC">
            <summary>
            Are hardware to hardware colorkey blits accelerated?
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.blit_hw_A">
            <summary>
            Are hardware to hardware alpha blits accelerated?
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.blit_sw">
            <summary>
            Are software to hardware blits accelerated?
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.blit_sw_CC">
            <summary>
            Are software to hardware colorkey blits accelerated?
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.blit_sw_A">
            <summary>
            Are software to hardware alpha blits accelerated?
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_VideoInfo.blit_fill">
            <summary>
            Are color fills accelerated?
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_Overlay">
            <summary>
            The YUV hardware video overlay
            </summary>
            <remarks>
            A SDL_Overlay is similar to a SDL_Surface except 
            it stores a YUV overlay. All the fields are read only, 
            except for pixels which should be locked before use. 
            The format field stores the format of the overlay 
            which is one of the following: 
            <code>
            SDL_YV12_OVERLAY  0x32315659  /* Planar mode: Y + V + U */
            SDL_IYUV_OVERLAY  0x56555949  /* Planar mode: Y + U + V */
            SDL_YUY2_OVERLAY  0x32595559  /* Packed mode: Y0+U0+Y1+V0 */
            SDL_UYVY_OVERLAY  0x59565955  /* Packed mode: U0+Y0+V0+Y1 */
            SDL_YVYU_OVERLAY  0x55595659  /* Packed mode: Y0+V0+Y1+U0 */</code>
            
            More information on YUV formats can be found at 
            http://www.webartz.com/fourcc/indexyuv.htm.
            </remarks>
            <see cref="M:Tao.Sdl.Sdl.SDL_CreateYUVOverlay(System.Int32,System.Int32,System.Int32,System.IntPtr)"/>
            <see cref="M:Tao.Sdl.Sdl.SDL_LockYUVOverlay(System.IntPtr)"/>
            <see cref="M:Tao.Sdl.Sdl.SDL_UnlockYUVOverlay(System.IntPtr)"/>
            <see cref="M:Tao.Sdl.Sdl.SDL_FreeYUVOverlay(System.IntPtr)"/>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.format">
            <summary>
            Overlay format (see below)
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.w">
            <summary>
            Width of overlay
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.h">
            <summary>
            Height of overlay
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.planes">
            <summary>
            Number of planes in the overlay. Usually either 1 or 3.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.pitches">
            <summary>
            An array of pitches, one for each plane. 
            Pitch is the length of a row in bytes.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.pixels">
            <summary>
            An array of pointers to the data of each plane. 
            The overlay should be locked before these pointers are used.
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.hwfuncs">
            <summary>
            Hardware-specific surface info
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.hwdata">
            <summary>
            
            </summary>
        </member>
        <member name="F:Tao.Sdl.Sdl.SDL_Overlay.field1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Tao.Sdl.Sdl.SDL_Overlay.hw_overlay">
            <summary>
            This will be set to 1 if the overlay is hardware accelerated.
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.AudioSpecCallbackDelegate">
            <summary>
            Used in the SDL_AudioSpec struct
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_EventFilter">
            <summary>
            This function sets up a filter to process all events before they
            change internal state and are posted to the internal event queue.
            </summary>
            <param name="evt">
                Event.
            </param>
            <returns>
                If the filter returns 1, then the event will be added 
                to the internal queue. If it returns 0, then the event
                 will be dropped from the queue. This allows selective
                  filtering of dynamically.
            </returns>
            <remarks>
            <p>
                Binds to C callback in SDL_events.h:
                <code>typedef Uint32 (SDLCALL *SDL_EventFilter)(const SDL_Event *event)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetEventFilter(Tao.Sdl.Sdl.SDL_EventFilter)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_GetEventFilter"/>
        </member>
        <member name="T:Tao.Sdl.Sdl.ThreadDelegate">
            <summary>
            int (SDLCALL *fn)(void *)
            </summary>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_TimerCallback">
            <summary>
                Prototype for the timer callback.
            </summary>
            <param name="interval">
                The current timer interval.
            </param>
            <returns>
                The next timer interval.
            </returns>
            <remarks>
            <p>
                Binds to C callback in SDL_timer.h:
                <code>typedef Uint32 (SDLCALL *SDL_TimerCallback)(Uint32 interval, void *param)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_SetTimer(System.Int32,Tao.Sdl.Sdl.SDL_TimerCallback)"/>
        </member>
        <member name="T:Tao.Sdl.Sdl.SDL_NewTimerCallback">
            <summary>
                Prototype for the new timer callback.
            </summary>
            <param name="interval">
                The current timer interval.
            </param>
            <returns>
                The next timer interval.
            </returns>
            <remarks>
            <para>
            The callback function is passed the current timer interval 
            and returns the next timer interval.  If the returned 
            value is the same as the one passed in, the periodic alarm
             continues, otherwise a new alarm is scheduled.  
             If the callback returns 0, the periodic alarm is cancelled.
            </para>
            <p>
                Binds to C callback in SDL_timer.h:
                <code>typedef Uint32 (SDLCALL *SDL_NewTimerCallback)(Uint32 interval, void *param)</code>
                </p>
            </remarks>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_AddTimer(System.Int32,Tao.Sdl.Sdl.SDL_NewTimerCallback)"/>
            <seealso cref="M:Tao.Sdl.Sdl.SDL_RemoveTimer(Tao.Sdl.Sdl.SDL_TimerID)"/>
        </member>
    </members>
</doc>
